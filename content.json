{"pages":[{"title":"about","text":"나는 수빈","link":"/about/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"1. OOP and ADT","text":"Object-oriented DesignObject-oriented design has fundamnental defferences from structured programming design methods. The two methods are similar in that they develop complex systems with divide and conquer, but differ in how to divide a given task. Algorithmic Decomposition vs Object-oriented DecompositionTraditional programming techniques used to algoritmicc decomposition. Algorithmic or functional decomposition treats software as a process and breaks it down into modules that represent the steps of the process. These modules are implemented in language syntax such as procedure of Pascal, subprogram of FORTRAN, function in C. Data Structure to implement the program is of secondary concern and should be considered only after the project has been divided into functional modules. Object-oriented decomposition views software as set of Well-defined objects that model software well for entity in applications. These objects form software sysyem by interaction. Functional decomposition should be considered after system decomposied to objects. The majot positive of object-oriented design is reuse of software. This enables flexible software systems that can change and evolve as the requirements of the system change. Basic concept of Object-oriented ProgrammingDefinition : An object is an entity that performs calculations and has states. So object can be considered compination of data and operations. Definition : OOP has methods such as .. An object is basic building block. Each object is instance of some type(class). Classes are connected each other by inheritance. (Programming not using inheritance does not considered as object-oriented programming) Definition : Called object-oriented language if some language has a function like .. Support object All objects are involved in class Support inheritance A language support 1, 2 not 3 called “object-based language”. (JavaScript) Data Abstraction and EncapsulationThe concept of abstraction and encapsulation is used to human-machine interaction. Definition : Data encapsulation(or Information Hiding) hides the detailed implementation of data objects from the outside world. Definition : Data abstraction is the separation of specification and implementation of data objects. C++ has char, int, float, double as a default data type. These data types are modified if short, long, signed, unsigned keywords are used. All programming languages provide at least a minimum of predefined data types, plus the ability to create new user-defined types. Definition : Data type is set of objects and operations of that objects. Whatever program addresses default data type or user-defined data type, object and operation must be considered. Definition : ADT(Abstraction Data Type) is a data type in which the specifications of objects and the specifications of operations on these objects are separated from the representation of the objects and the implementation of the operations. To emphasize the separation of specification and implementation, the ADT definition of the object will begin first. In this way, people can understand the essential elements of an object without a complex description of the representation of the object and the actual implementation of the operation. ADT NaturalNumber is Object : from 0 to MAXINT Functions : All x, y in NaturalNumber","link":"/2019/04/29/1-OOP-and-ADT/"},{"title":"1. What is Programming?","text":"1. Computational ThinkingProgramming is communication that sends commands to be performed to the computer. In order to define the “command to be performed,” the resolution task (problem/requirements) must be clearly understood, the complexity must be simply desconstructed, the data organized and sorted by modeling, and the actions arranged in sequence. In other words, clear understanding of reguirements and proper definitaion of solution are needed before programming. What is required at this time is the problem-solving skill. Some people tend to equate problem-solving abilities with algorithms, but it does not. Of course studying algorithm is very helpful to get problem-solving skill, but problem-solving skill is more higher level of ability. Programming is just a means of expression to produce the final result of solving a problem. Programming itself doesn’t solve the problem. Considering the solution of the problem, you should look at preoblem from a computer’s point of view. Computational thinking is required this kind of time. You should do computational thinking with solving problems. This requires logical and mathematical thinking, and all concepts that will be used within the programming should be defined as assessable, breaking down and patterning the resolution tasks into smaller units. 2. Programming LanguageAs above, solution defined based on problem-solving skill should be communicated to computer. At this point, computer do perform the commands. So the command should be communicated by machine code, not a natural language. But it is very difficult that human to understand machine code. It is even described in bits. The most useful alternative to delivering commands in direct mechanical language is to use a kind of translator to write a program using “programming language” consisting of promised phrases (Syntax) that humans can understand and then convert it into machine language that computers can understand. This kind of translator is called complier or interpreter. Programming is a kind of communication that sends commands to the computer that you want to perform using the programming language. The programming language is expressed as a combination of Syntax and Semantics. 3. Syntax &amp; SemanticsUnderstanding both syntax and semantics properly is important to use language well. In the end, solutions created through problem-solving ability are expressed through the syntax of programming languages. The code is a specific implementation of the solution. This is only archeive semantics when the requirements are fulfilled(problem solved). Most of programming languages provide syntax such as variables and values, keywords, operators, expressions, flow control by conditional and loop statements, statements, functions(set of statements), and data structures such as objects and arrays. What a programmer needs to do is find a solution for problem and implement it in a code that has correct syntax. Implemented code should act as expected and solve the problem. It should be predictable and explainable how the code work inside the computer and what it will give back. To do this, it is important to have an accurate understanding of the basic concepts and operating principles of programming language. If you just copy &amp; paste code without understand basic concept and principle, that code is not reliable. And problem-solving skills will not grow anymore. Reference 프로그래밍이란?","link":"/2019/04/29/1-What-is-Programming/"},{"title":"12. Scope","text":"The scope determines the extent to which the identifier can be referenced. A scope is a data structure that keeps the binding of identifiers and values, and is managed by the JavaScript engine. What is Scope?The range in which the variable is valid. That is, the extent to which other code can refer to the variable itself. The scope is created by the location where the variable is declared. When there are variables with the same name in different scopes, JavaScript engine must decide which variable to reference at runtime. JavaScript uses the scope to determine which variables to reference. That is, the scope is the rule that the JavaScript engine uses to search for variables to reference. By default, JavaScript supports function-level scopes rather than block-level scopes. Variables declared with var form a function-level scope. However, variables declared with let or const form a block-level scopes. If there is no scope, the name of the variable in the program should be unique. Duplicate declaration of var keyword variableVariables declared with the var keyword allow duplicate declarations within the same scope. 1234567891011&gt; function foo() {&gt; var x = 1; &gt; &gt; // This statement operates like x = 2;&gt; // So reassignment occurs.&gt; var x = 2; //2&gt; &gt; console.log(x); //2&gt; }&gt; foo();&gt; Variables declared as let or const do not allow duplicate declarations, so it is better to use them. Types of scopeCode can be distinguished as global and local. Global Local Explanation Outermost area of code Inside of function body Scope Global scope Local scope Vaiable Global variable Local variable The variable is determined by its declared location (global or local) to the scope in which it is valid. A variable declared in global is a global variable having a global scope A variable declared in local is a local variable having a local scope. Declaring a variable in global is a global variable with a global scope. Global variables can be referenced anywhere. In other words, global variables are valid in the global scope. Local variables can be referenced only in the declared region and sub-region (nested function). In other words, local variables are valid in their local and subregional scopes. Scope ChainScopes are created by functions. Functions can be nested, so the local scope of a function can also be nested. This means that the scope has a hierarchical structure by nesting of functions. The local scope of the outer function is the top scope of the nested function. The scope chain refers to a structure in which the scopes from the deepest local scope to the global scope of the overlap are hierarchically connected. When referring to a variable, the JavaScript engine starts at the scope of the code that references the variable, moves to the top scope, and searches for the declared variable. Function-level Scope Most programming language like C, Java Block-level scope All code blocks (if, for, while, try / catch, etc.), not just the function body, create the local scope. Variables declared with the var keyword Function-level scope Accept only the code block of the function as the local scope. The let and const keywords introduced in ES6 support block level scopes. Lexical Scope Dynamic Scope The function’s top scope is determined by where the function is called. Lexical Scope / Static Scope The function’s top scope is determined by where the function is defined. Most programming languages follow the lexical scope. JavaScript follows a lexical scope. So it determines the top scope depending on where it is defined. Implicit Global VariableIf declare a variable without var keyword, it becomes a global variable. 123456789function foo() { i = 0; //implicit global variable}// var i = 0 is a duplicate declarationfor (var i = 0; i &lt; 5; i++) { foo(); console.log(i);} // infinite loop Global variables are so dangerous!","link":"/2019/05/08/12-Scope/"},{"title":"13. Problems with Global Variables","text":"1. Life Cycle of a Variable변수는 선언에 의해 생성되고 할당을 통해 값을 가진다. 생성된 변수는 언젠가는 소멸한다. 변수가 생성되고 소멸되는 주기를 변수의 생명 주기라고 한다. 변수가 생성된다는 것은 메모리 공간을 차지하는 것이고, 소멸됨은 차지하던 메모리가 해제되는 것이다. 조금 더 정확히 말하면 변수가 소멸된다는 것은 등록된 식별자가 소멸한다는 것이다. 이때 식별자와 값의 바인딩이 해제된다. 어떤 지역 스코프가 사라질 때 그 스코프에 등록된 식별자들이 소멸된다. 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다. 즉, 지역 변수의 생명주기는 함수와 생명 주기와 같다. 그래서 지역 변수의 생명주기는 비교적 짧다. 그러나 전역 변수는 다르다. 함수는 함수 몸체의 문이 끝나거나, return 문이 실행되면 종료한다. 하지만 전역 코드는 마지막 문이 끝나서 더 이상 실행할 문이 없어도 함수처럼 종료하지 않는다. 전역변수는 브라우저를 종료해서 애플리케이션을 종료할 때까지 유효하다. 즉, 전역 변수의 생명주기는 애플리케이션의 생명 주기와 일치한다. 이는 다음과 같은 문제점을 가진다. 2. Problem of Global Variable2.1. Implicit Coupling전역 변수는 코드의 전체 영역에서 사용할 수 있다. 이는 모든 코드에서 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용한다. 문제는 변수의 유효 범위가 크면 클수록 코드의 가독성이 나빠지고 의도치 않은 상태 변경이 일어난다는 것이다. 2.2. Long Life Cycle전역 변수는 생명 주기가 길다. 이는 다음과 같이 몇 가지 문제점을 가진다. 전역 변수의 상태를 변경할 수 있는 시간이 길다. 모든 함수가 참조할 수 있으므로 상태가 변경될 위험이 크다. 메모리 리소스를 오랜기간 차지한다. var 키워드는 변수의 중복 선언을 허용하므로 중간에 변수명이 중복되어 의도치 않은 재할당이 일어날 수 있다. 2.3. Exist at the End of the Scope Chain전역 변수의 또다른 문제점은 스코프 체인 가장 상위에 존재한다는 것이다. 이는 자바스크립트 엔진이 전역 변수를 찾을 때 가장 마지막 스코프까지 검색해야함을 의미한다. 즉, 전역 변수의 검색 속도가 가장 느리다. 2.4. Namespace Pollution자바스크립트의 특성으로, 분리되어있는 파일을 함께 import할 경우 하나의 전역 스코프를 공유한다. 따라서 다른 파일 내에서 동일한 이름으로 명명한 변수나 함수가 겹칠 경우 예상치 못한 결과를 가져올 수 있다. 3. How to Suppress Using Global Variables위에서 살펴본 바와 같이 전역 변수의 사용은 위험하다. 반드시 사용해야할 때가 아니라면 지역 변수를 사용해야 한다. 3.1. Immediately Invoke Function Expression즉시 실행 함수는 함수의 정의와 동시에 한 번만 호출되는 함수로, 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 함수는 스코프를 만들고, 함수 내에 선언된 변수는 지역 변수가 된다는 것을 이용한 방법이다. 123(function(){ var foo = 10; //local variable of IIF}()); 가장 간단하고 일반적인 방식이다. 3.2. Namespace Object전역 네임 스페이스 역할을 담당할 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다. 즉, 전역 변수를 네임 스페이스 객체의 프로퍼티로 등록하고 사용하는 방법이다. 12var GLOBAL = {}; // global namespace objectGLOBAL.name = 'Lee'; 현재는 잘 안 쓰는 방식. 3.3. Module Pattern모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아서 즉시 실행함수로 감싸 하나의 모듈로 만든다. 모듈 패턴은 자바스크립트의 클로저를 기반으로 동작한다. 캡슐화란 보호하고자 하는 내부 구현을 외부로부터 감추는 것을 말한다. 캡슐화의 목적은 상태 유지로, 외부에서 객체 내부의 상태를 변경하는 것을 제한한다. C++이나 Java의 class는 기본적으로 Access modifier를 제공하여 공개 범위를 한정할 수 있게 한다. 자바스크립트는 Access modifier를 제공하지 않는다. 모듈 패턴은 전역 네임 스페이스의 오염을 막는 기능에 더해서, 한정적이기는 하지만 캡슐화를 구현하기 위해 사용한다. 1234567891011121314151617181920var Account = (function () { // private variable var balance = 0; return { deposit(money) { balance += money; return balance; }, withdraw(money) { balance -= money; return balance; } };}());console.log(Account.balance); // undefinedconsole.log(Account.deposit(3000)); //3000console.log(Account.withdraw(1000)); //2000 위 코드의 즉시 실행 함수는 외부에 노출할 메소드를 객체에 담아 반환한다. 이 때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버이다. 반환되는 객체에 추가되지 않은 변수나 함수는 모두 외부에서 접근할 수 없는 프라이빗 멤버가 된다. Closure?그런데 즉시 실행 함수는 선언과 동시에 실행되고 종료되는데 deposit()과 withdraw() 메소드가 어떻게 num을 참조할 수 있을까? deposit()과 withdraw()는 즉시 실행 함수의 중첩 함수로, 중첩 함수가 외부 함수보다 더 오래 살아남아 있을 경우 이를 클로저라고 부른다. 자바스크립트의 함수 객체는 생성될 때, 프로퍼티 어트리뷰트로 [[Environment]]라는 내부 슬롯을 가진다. 이 곳에 자신이 생성될 때의 외부 스코프(Lexical scope)를 담는다. 이는 함수 객체가 소멸하기 전까지 유지된다. 위의 num같은 변수를 자유변수라고 한다. deposit()과 withdraw()는 같은 lexical scope object를 참조하고 있다. 모던 자바스크립트 프로그래밍에서는 클로저의 사용을 적극 권장한다. 3.4 ES6 Module import export ES6가 구체적인 구현 스펙을 제안하지 않아 대부분의 브라우저가 완전히 지원하지는 않는다. 그러나 Webpack 등의 모듈 번들러를 사용해서 ES6 모듈을 사용할 수 있다.","link":"/2019/05/09/13-Problems-with-global-variables/"},{"title":"14. let, const and a Block-level Scope","text":"1. Problems with Variables declared with the var keywordES5까지 변수를 선언할 수 있는 유일한 키워드는 var 하나였다. var 키워드로 선언된 변수는 다른 언어와는 구별되는 특징을 가진다. 1.1. Allow Duplicate Variable Declarationvar 키워드로 선언한 변수는 중복 선언이 가능하다. 1234var x = 1;// No Errorvar x = 10;console.log(x); //10 같은 스코프 내에서 변수를 중복 선언하면 나중에 선언된 변수는 선언문이 아닌 할당문처럼 동작한다. 이 때 에러가 발생하지 않기 때문에 중복 선언을 인지하기 힘들다. 이로 인해 의도치 않게 변수값이 변경될 수 있다. 1.2. Function-level Scopevar 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서, if문이나 for문 등에서 선언한 var 변수는 모두 전역 변수가 된다. 대부분의 프로그래밍 언어는 block-level scope이기 때문에 function-level scope를 이용하는 것은 전역 변수를 남발할 가능성을 높인다. 1.3. Variable Hoistingvar키워드로 선언한 변수는 변수 호이스팅에 의해 변수 선언문이 스코프의 가장 위로 끌어 올려진 것처럼 동작한다. 즉, 선언 이전에 var 변수를 참조해도 에러가 나지 않는다. 이는 프로그램의 흐름을 해치고 가독성을 떨어뜨린다. 2. let keywordvar 키워드의 단점들을 보완하기 위해 ES6에서 var와 const 키워드가 추가되었다. 이들은 var 키워드와 같이 변수를 선언할 때 사용된다. 2.1. Ban Duplicate Variable Declarationlet 키워드로 선언한 변수를 중복 선언하면 var와 달리 SyntaxError가 발생한다. 123let x = 1;let x = 10; // SyntaxError: Identifier 'x' has already been declared 2.2. Block-level Scopevar 키워드로 선언한 변수는 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따른다. 그러나 let 키워드로 선언한 변수는 모든 코드 블록 {}을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다. 12345678910let foo = 1; // global variable{ let foo = 3; // local variable let bar = 4; // local variable console.log(foo); // 3 console.log(bar); // 4}console.log(foo); // 1console.log(bar); // ReferenceError: bar is not defined 2.3. Variable Hoistinglet 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다. 12console.log(foo); // ReferenceError: foo is not definedlet foo; 그렇다면 let 키워드로 선언한 선언문은는 런타임 이전에 실행되지 않는 것일까? 일반적으로 var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 declaration phase와 initialization phase가 한 번에 진행된다. Declaration phase : Execution context의 lexical environment에 있는 스코프에 변수 식별자를 등록하여 변수의 존재를 알린다. Initialization phase : declaration phase가 끝나는 즉시 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined로 변수를 할당해 초기화한다. let 키워드로 선언한 변수는 “Declaration phase”와 “Initialization Phase”가 분리되어 진행된다. 즉, 런타임 이전에 암묵적으로 declaration phase가 먼저 실행되지만 initialization phase는 런타임에 변수 선언문에 도달했을 때 실행된다. initialization phase가 실행되기 이전에 변수에 접근하려고 하면 reference error가 발생한다. 아직 변수를 위한 메모리 공간이 확보되지 않았기 때문이다. 따라서 스코프의 시작 지점부터 변수 선언문을 만나서 initialization phase가 시작되기 전까지는 변수를 참조할 수 없다. TDZ (Temporal Dead Zone)스코프의 시작 지점부터 Initialization phase 시작 지점까지의 구간 let 키워드로 선언한 변수는 hoisting이 되지 않는 게 아니라, 선언문을 만났을 때 initialization phase를 진행하는 것이다. 2.4. Global Object and let전역 객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 브라우저 환경에서는 window 객체, Node.js 환경에서는 global 객체를 말한다. var 키워드로 선언한 전역 변수와, 키워드 없이 선언하고 값을 할당한 암묵적 전역변수, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다. 1234567var x = 1;y = 2;function foo() {}console.log(window.x === x); // trueconsole.log(window.y === y); // trueconsole.log(window.foo === foo); // true 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. 그러나 let 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다. let 전역 변수는 전역 렉시컬 환경의 선언적 환경 레코드 내에 존재하게 된다. 123let x = 1;console.log(window.x); // undefined 3. const Keywordconst 키워드는 상수(변하지 않는 고정된 값)를 선언하기 위해 사용한다. let 과 const 는 동일한 특징이 많다. 차이점을 살펴보자. 3.1. Declaration and Initializationlet 키워드로 선언한 변수와 달리 const 키워드로 선언한 변수는 재할당이 금지된다. 123const PI = 3.14;PI = 3.141492; // TypeError: Assignment to constant variable. const 키워드로 선언한 변수는 반드시 선언과 할당이 동시에 이루어져야 한다. 이후로는 재할당을 할 수 없다. const 키워드로 선언한 변수 또한 block-level scope를 갖는다. 3.2. Constant변수를 만들고 재할당을 하지 않을 거라면 상수를 적극적으로 쓰는 게 좋다. 고정된 값을 상수로 만들어 쓰면 코드의 가독성을 높일 수 있다. 상수는 프로그램 전체에서 사용하므로, 유지보수에 효율적이다. 3.3. const Keyword and Objectconst 키워드로 선언한 변수에 primitive value를 할당한 경우, primitive value는 immutable value이고 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법이 없다. const 키워드로 선언한 변수에 객체를 할당한 경우, 재할당이 금지되는 것은 마찬가지이다. 그러나 객체는 mutable value이므로 const 키워드로 선언된 변수에 할당된 객체는 변경이 가능하다. 즉, const 키워드는 재할당을 금지할 뿐 immutable을 의미하지 않는다. immutable과 mutable은 상수와 변수의 개념이 아닌, 값의 변경에 대한 개념이다. 4. var vs. let vs. const변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 사용하는 것이 좋다. ES6 사용시 var 키워드 사용하지 않는다. 재할당이 필요한 경우에만 let 키워드를 사용하고, 변수의 스코프를 최소화 한다. 객체와 변경을 하지 않을 원시 값에는 const 키워드를 사용한다. var 와 let/const를 함께 쓰지 않는다.","link":"/2019/05/09/14-let-const-and-a-Block-level-Scope/"},{"title":"190313-TIL","text":"Today I Learned 오늘부터 하루하루 내가 배우고 공부한 것들을 정리해놓기로 한다. 오전 - 팀 토의일주일이 조금 넘게 웹 기초를 배우며 과제를 진행한 것에 대해서 팀원들과 토의를 나눴다. 나는 Grab 홈페이지에서 설명을 누르면 이미지가 바꾸도록 jQuery를 써보는 과제가 인상 깊었다. Responsible Web 과 SEO 등 집중해서 공부하고 싶은 것들이 생겼다. 오후 - git1. git으로 블로그 만들기 : HEXOLorem ipsum 등 dummy text를 넣어 html 디자인 전 레이아웃을 잡는 방법을 알았다. github에서 제공하는 github.io Blog를 만들었다. Hexo를 설치하고 포스팅하는 방법을 알았다. : hexo new post, hexo generate, _config.yml을 수정한 후 hexo deploy : deployment - the use of something or someone in an effective way 2. git branch &amp; checkout &amp; merge 협업을 위해 중요한 git의 branch와 commit 개념을 배웠다. 익숙해지면 버전관리와 개발에 많은 도움이 될 것 같다. 난 Markdown Emoji가 좋다 🐷Markdown Emoji","link":"/2019/03/13/190313-TIL/"},{"title":"190314-TIL","text":"Today I Learned JavaScript Methodwindow 객체의 method를 통해 사용자 입력, 화면 제어, 스크롤 제어 등을 하는 방법을 새로 배웠다. 외에도 screen, history, navigator, location 객체의 method를 활용해 사용자 분석을 위한 정보를 parsing하는 걸 프론트엔드에서 할 수 있다는 것을 알았다. Interval &amp; Timer네트워크 프로그래밍 수업 때 잠시 배웠던 Push, Polling 기법과 timeout을 간략하게 들었다. 시간이 날 때 개념을 확실히 하기 위해 노트에 적어두었다. jQueryjQuery의 selector를 이용, 요소의 이벤트를 처리하고 속성값을 이용해 기능을 구현했다. TO DO LIST과제로 TO DO LIST를 만들었다. 느낀 점:할 일을 추가, 수정, 삭제, field를 나눠서 보여주는 것만 하면 되는데도 생각해야할 것들이 많았다. 사용자가 작은 기능이라도 편하게 이용할 수 있도록 프로그래밍하는 것이 하나도 쉬운 게 없다. 💘 My To do list git 주소 To Do List","link":"/2019/03/14/190314-TIL/"},{"title":"190315-TIL","text":"Today I Learned 오늘 한 일 LeetCode Medium 문제를 풀었다. C나 C++이 아니고 익숙하지 않은 JavaScript로 알고리즘 문제를 풀려니 메소드를 하나하나 찾아야해서 시간이 오래 걸렸다. 🐸 2. Add Two Numbers : if문을 잔뜩 사용한 내 코드와 달리 carry를 이용한 솔루션을 보고 알고리즘 공부를 꾸준히 해서 효율성을 높여야겠다는 목표가 생겼다. 적어도 하루에 하나씩은 LeetCode 문제를 풀려고 한다. 오후엔 JavaScript를 이용해 Lotto 추첨기를 만들었다. 느낀 점:사용자의 입력을 받아서 화면에 적절히 출력하는 게 아직 어렵다. 3명이 팀별로 진행하다보니 알고리즘을 짜는 데에도 토의를 하느라 시간이 길어졌다. 협엽과 HTML, CSS, JS를 다루는 법에 조금 더 익숙해져야겠다. 🐸 Lottery Machine git address LOTTERY Machine","link":"/2019/03/15/190315-TIL/"},{"title":"190317-TIL","text":"Today I Learned어제는 처음으로 토익을 보러 갔다. 피곤해서 컴퓨터를 켜지도 못했지만 앞으로 알고리즘 문제를 하나라도 풀어야겠다. 오전 LeetCode Easy 문제: 7. Reverse Integer 와 관련문제 190. Reverse Bits를 풀었다. 오후 Hexo blog의 이름을 바꾸고 전부터 적용하고 싶었던 Hexo Clexy 테마를 적용했다. 처음에는 어떻게 해야할 지 몰랐지만 Clexy github description을 보며 따라하니 어떻게 적용이 됐다.내 마음대로 디자인을 바꾸려면 공부를 더 해야겠다. 카테고리를 나눠서 알고리즘 풀이, HTML/CSS와 javaScript 등 공부한 내용을 정리해서 올리고 싶어서 카테고리를 추가하는 방법을 찾아봤는데 잘 알 수 없었다. 강사님께 물어봐야겠다.","link":"/2019/03/17/190317-TIL/"},{"title":"190318-TIL","text":"Today I Learned 오전 LeetCode Easy 문제 : 🌈 9. Palindrome Number 이번 문제는 비교적 쉽게 풀렸다. 주말에 Reverse Integer와 Reverse Bit 문제를 풀었을 때 썼던 알고리즘을 응용하니 문제가 풀렸다. CSS로 3가지 형태의 메뉴 만들기 BootStrap을 이용하지 않고 CSS와 jQuery를 이용해서 다운드롭, 햄버거 메뉴를 만들었다. jQueryUI의 slide()를 이용해서 왼 쪽에서 나오는 햄버거 메뉴를, CSS의 hover를 이용해 전체 드롭다운 메뉴와 특정 메뉴의 하단메뉴만 드롭다운으로 보여주는 메뉴를 만들었다. 오후 다음 우편번호 서비스를 이용해 회원가입 홈페이지 만들기 다음 우편번호 API를 이용해 우편번호를 찾고, 사용자 입력을 받아 정규표현식으로 Validation 하는 것까지 진행했다. 느낀 점 JavaScript로 처음 알고리즘 문제를 풀 때는 한 줄 치기도 어려웠는데 며칠 문제를 풀다보니까 조금씩 익숙해지는 것 같다. HTML 레이아웃을 짤 때 &lt;div&gt;에 의존하지 않고 &lt;ul&gt;과 &lt;li&gt; 태그를 자주 이용해야겠다는 생각을 했다. 매번 잊어버리므로 유념하자. 🌈 Simple Sign Up Page git address ▶ [Simple Sign Up Page] ◀","link":"/2019/03/18/190318-TIL/"},{"title":"190320-TIL","text":"Today I Learned 오늘 한 일 HTML, CSS, JS의 전체적인 개념을 복습했다. git 으로 협업하기를 배웠다. git flow를 이용해 branch를 만들고 작업, merge를 쉽게 하는 방법에 대해서도 공부했다. Fork &amp; Merge를 이용해서 여러명과 협업하고 repo에 contribute하는 방법을 새로 알았다. 느낀 점 몸이 안 좋아 알고리즘 문제 하나를 다 풀지 못했다. 하루종일 집중력 저하로 충전의 필요성을 느꼈다. git은 여러명과 프로젝트를 진행하며 불편했던 점들을 한 번에 해소해주는 느낌이었다. 더이상 카카오톡이나 텍스트파일로 코드를 주고받고 일일히 합치지 않아도 된다는 점이 굉장히 매력적으로 다가왔다. 자주 이용해 손에 익도록 만들어야겠다.","link":"/2019/03/20/190320-TIL/"},{"title":"190319-TIL","text":"Today I Learned 오늘 한 일 LeetCode Easy 문제 : 🌟 13. Roman to Integer if로 I, X, C일 때 경우를 나누어 풀었다. 시간이 짧게 걸린 알고리즘들은 let, const를 썼는데 나는 아직 var로 선언하는 방법밖에 공부하지 않아 더 공부를 해야겠다. webStorage 공부 localStorage, sessionStorage의 차이와 활용방법에 대해서 배웠다. localStorage.setItem(storage_key, storage_value), localStorage.getItem(storage_key) 를 사용하여 localHost에서 사용자가 입력한 정보를 유지하는 기능을 다수 추가했다. To do List, Signup Page 보완 locaStorage를 이용해 기존에 만들었던 html에 유지기능을 추가했다. Select, Input: radio 등 다양한 input type 학습 단순히 text type의 input뿐만이 아니라 select.val, option.text 등을 다루는 방법을 공부했다. 느낀 점 localStorage를 이용하는 것 뿐인데 해야할 일이 대폭 많아졌다. 꼼꼼하게 정리해놓고 해당 기능을 사용할 때마다 참고해야겠다. Upgrade ver. To do List ▶ 🌟 Upgrade ver. Sign Up Page ▶ 🌟","link":"/2019/03/19/190319-TIL/"},{"title":"190322~24 TIL","text":"Today I Learned 배운 것 LeetCode 14. Longest Common Prefix를 풀었다. : 쉬운 문제를 이틀에 걸쳐 풀었는데, javaScript에 String method 중 유용한 indexOf()라는 method가 있다는 것을 알았다. C++에서부터 나는 문자열을 다루는 데에 익숙하지 않다. var의 scope와 javaScript의 Hoisting에 대해 배웠다. var, let, const: var는 function-scoped고, let이나 const는 block-scoped이다. : let은 재할당이 가능, 선언한 이후에 할당할 수 있는 반면 const는 선언과 동시에 값을 할당하여야 하고 그 값을 변경시킬 수 없다. (C처럼) Hoisting: hoisting은 끌어올린다는 뜻이다. 자바스크립트에서는 변수가 끌어올려진다. 이 때, 변수의 선언은 hoist되지만 할당부(값)는 hoist되지 않는다. 즉 함수의 선언은 hoist되지만 변수의 값으로 선언한 함수는 hoist되지 않는다. 그래서 for문에서 var i =0으로 선언한 후 함수 종료 후에 i를 부르면 정의되지 않았다고 뜬다. 그러나 var i가 아니라 그냥 i=0 로 선언하면 i가 hoisting되어 global variable이 된다. 느낀 점scope와 hoisting 등 javaScript를 공부하니 그동안 아무 것도 모르는 상태에서 이것저것 만들어 보면서, 이해되지 않던 오류들이 조금씩 이해되기 시작했다. 어쩌다보니 LeetCode 알고리즘을 스터디로 함께 풀게 됐다. 어려명과 함께 공부하는 건 처음이지만 배울 점이 많을 거라고 생각한다. indexOf() 등 여러 javaScript String 관련 method를 접할 때마다 정리하고 활용할 수 있도록 해야겠다.","link":"/2019/03/24/190322-24-TIL/"},{"title":"190321-TIL","text":"Today I Learned 오늘 한 일 Naver Maps API를 이용한 맛집 리뷰 어플리케이션 : Naver가 제공하는 Naver Maps API를 이용해 웹에 지도를 띄우고, 다음 우편번호 서비스로 주소를 입력받아 해당 주소의 좌표에 마커를 찍는다. : 마커를 클릭했을 때 리뷰가 없다면 리뷰를 등록하고, 이미 리뷰가 등록됐다면 등록된 리뷰를 infoWindow로 보여준다. : 어려웠던 점! for문 내에서 marker객체와 infoWindow 객체를 각각 만들어 addEvent를 해주면 scope 문제로 마지막 이벤트 리스너만 살아남게 된다. 정확한 내용은 공부를 더 해야 알겠지만 우선 forEach문으로 해결했다. 참고한 페이지에서는 let으로 선언(block-scoping)해도 된다고 한다. 어제 배운 git fork &amp; merge를 이용해 팀원들과 협업을 했다. 패스트캠퍼스 수료생 선배들과 티타임을 가지며 개발자가 되기 위한 과정에 대해서 들었다. 꾸준히 열심히 하고 모르는 것을 넘어가지 않는 게 중요한 것 같다. 맛집 리뷰페이지 ▶ 🍩 Yummy 🍩","link":"/2019/03/21/190321-TIL/"},{"title":"190325-TIL","text":"Today I Learned 웹 애플리케이션 프로젝트오늘부터 5일간 팀원들과 함께 프로젝트를 진행한다. 간단한 프론트 기초 지식만 배운 상태에서 완벽한 애플리케이션을 만들기에는 부족함이 있지만 오늘 기획단계를 끝냈다.백엔드가 없어 데이터를 localStorage에 저장하고 불러올 예정이다. 회원가입과 로그인 기능도 뺐다. 디자인을 위해 전공 소프트웨어 공학 수업시간에 배운 Use Case Diagram, step-by-step Description, Communication Diagram을 작성해 기능들을 나눴다. 우리는 식단, 운동을 제공하고 사용자가 날짜별로 건강관리를 기록할 수 있는 프로그램을 만들 예정이다. 나는 운동 부위(상체, 복근, 하체, 전신)와 운동 종류(근력, 유산소, 스트레칭)에 따른 Youtube 운동 영상을 미리 수집해 분류한 후 사용자의 Option 선택에 따라 운동 영상을 제시하는 기능을 맡았다. 사용자는 또한 운동 기록을 저장하고 관리할 수 있다. 오늘은 전체적인 프로그램 디자인과 html 레이아웃을 마쳤다. Youtube API를 잠깐 써봤는데 생각보다 어렵지 않을 것 같다.","link":"/2019/03/25/190325-TIL/"},{"title":"190327-TIL","text":"Today I Learned 오늘 한 일프로젝트 clickSaveButton() -&gt; saveHealth() : 운동 영상의 상세 페이지에서 운동 기록 저장 버튼을 클릭시 해당 운동의 이름이 localStorage에 저장된다. showDiary() : 운동 기록을 저장한 후 반영된 페이지로 이동한다. clickMyHealthButton() -&gt; showMyHealthPop() : 나의 운동 버튼 클릭시 사용자 정의 운동을 입력하고 저장할 수 있는 페이지를 팝업으로 띄운다. clickSaveButton() -&gt; showSavedPage() : 팝업 창에서 운동 이름, youtube 주소, 운동 부위와 종류를 입력하면 기록이 localStorage에 저장된다. 외에도 알고리즘 스터디를 했다. 나는 5개 정도 문제를 미리 풀어놔서 복습하는 개념으로, 다른 사람들의 풀이에서 많은 걸 배우고 있다. 배운 것 ! 어떤 element를 클릭하고 새로 뜬 창에서 어떤 버튼을 눌렀을 때 맨 처음 element 값 전달하고 싶을 때는 button의 attr에 data-key 같은 식으로 정보를 전달해준다. 1234567891011121314151617181920212223242526 $('div.workout').click(function(){ //showWorkoutDetail var key = this.id; var workout = workouts[key]; var id = workout['YT_id']; $('#saveHealthButton').attr('data-key',key); $('#popModal').modal('show'); $('#popTitle').text(workout['name']); console.log(id); player = new YT.Player('player', { height: '300', width: '450', videoId: id, events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange } }); }); $('#saveHealthButton').click(function(){ console.log($(this).attr('data-key'));//잘 뜸!! saveWorkout(); }); ! 외부 API를 사용하는 것은 어렵다. 조금만 수정하려고 해도 내 마음처럼 되지 않는다. 경험을 늘려야겠다. 운동 영상 썸네일 클릭시 Modal을 띄워 해당 운동 영상을 보여주려고 했는데, iframe을 사용하지 않고 new YT_player로 player를 만드는 API를 사용했더니 맨 처음 생성된 player만 뜨는 문제가 있었다. 구글 검색으로 해결했다! Modal show event마다 내가 원하는 youtube 보여주기!! How to embed YouTube video in Bootstrap modalAnswer: Insert YouTube Code inside Modal Bodyhttps://www.tutorialrepublic.com/faq/how-to-embed-youtube-video-inside-bootstrap-modal.php ! javaScript에서는 Array.length, String.length로 둘 다 뒤에 ()를 붙이지 않는다. java와 헷갈리지 말자. 느낀 점 프로젝트 기획 때 Use Case와 Communication을 잘 정리하고 나니 그 때 명세한 기능을 구현하기만 돼서 편하다. 순서대로 구현을 하니 딱히 커다란 문제가 생기지 않았다. 소프트웨어 공학 시간에도 그렇지만 다시 한 번 디자인이 중요하다고 느꼈다.","link":"/2019/03/27/190327-TIL/"},{"title":"190326-TIL","text":"Today I Learned 프로젝트 진행 중! 무식하면 몸이 고생한다를 뼈저리게 느끼고 있다. 백엔드가 없고 DB를 관리할 수가 없어서 리소스와 데이터를 수동으로 정리해 폴더에 넣는 작업을 했다. Dictionary가 익숙해질수록 편하게 쓰고 있다. 오늘 한 일 운동 부위, 종류에 따른 youtube 동영상 주소(고유주소ID, 썸네일, 이름) 모으고 각 selector로 사용할 id 부여 (upper_weight_1 등)Load할 때마다 workouts 먼저 그려놓고 숨겨놓음 selectBodyPart() -&gt; showHealthList() : Health Option select 조건에 따라 분류해놓은 운동 영상을 보이게 한다. selectHealthType() -&gt; showHealthList() : Health Option select 조건에 따라 분류해놓은 운동 영상을 보이게 한다. clickHealth() -&gt; showHealthDetail(id) : div에 배치된 운동 영상 클릭시 해당 영상의 상세 페이지를 팝업으로 띄운다. 배운 것 Dictionary key값이 string일 때는 Dict[‘key’] 잊지 말기!!!! 계속 ‘’ 를 잊어버린다. var today = new Date().toISOString().slice(2, 10); 날짜를 19-03-26 형식으로 만들어준다!!!!","link":"/2019/03/26/190326-TIL/"},{"title":"190328-TIL","text":"Today I Learned 오늘 배운 것 프로젝트의 모든 정보를 localStorage에 load하고 save하는 기능을 끝냈다. 점점 객체와 배열을 다루는 방법이 익숙해진다. 어렵던 select의 option value와 option:selected).text도 잘 알았다. 디자인을 수정하고 메인 페이지를 full video background로 설정했다. 알고리즘 스터디에서 Array.reduce와 eval method를 새로 알았다. 주말에 더 공부 해야겠다. LeetCode 중 Medium 3. Longest Substring Without Repeating Characters 문제를 풀었다. 오랜만에 새로운 알고리즘 문제를 푸니 재미있었다. LeetCode에 console.log를 찍어 stdout을 확인할 수 있다는 것을 처음 알았다. 앞으로 자주 사용해야겠다. 프로젝트가 마무리되며 볼만해진다. 공공 데이터 포탈에서 제공하는 미세먼지 API를 사용해 메인 페이지에 마스크 사용여부를 알려주고 싶었는데 낮에 신청한 직후에는 잘 안 됐다. 그런데 밤에 해보니까 결과가 나와서 내일 다시 시도해볼 예정이다.","link":"/2019/03/28/190328-TIL/"},{"title":"190329-TIL","text":"Today I Learned 오늘 한 일 jQeury 플러그인을 통해 Diary 화면의 배경에 ripples 효과를 줬다. 50px정도 여백에 효과가 적용되지 않는 문제가 있어 body background에 효과를 주는 것으로 해결했다. 알고리즘 스터디에서 Longest Common Prefix 문제를 다시 한 번 훑어보았다. 프로젝트 페이지의 폰트와 버튼 hover event 등을 추가하고 마무리했다. 느낀 점 프로젝트를 하며 겪었던 자잘한 문제들과 해결방법을 정리해두어야겠다. 첫 팀 프로젝트는 생각보다 재미있었다. 해결하지 못할 문제는 없다는 것을 다시 한 번 알았다. ✨ My Health Diary ✨","link":"/2019/03/29/190329-TIL/"},{"title":"190330~31 TIL","text":"Today I Learned 토요일에 특강을 들었다. 실제로 현업에서 개발을 어떻게 하는지, 개발 방법에는 Waterfall보다 Agile를 많이 쓰는 추세라는 것을 알았다.","link":"/2019/04/01/190330-31-TIL/"},{"title":"190402-TIL","text":"Today I Learned 오늘 한 일 CSS의 기초 문법, 상속과 겹침 그리고 우선순위에 대해 배웠다. 상속(Inheritance): 부모에게 적용한 style이 자식에게 적용되는 것영역에 관한 속성이 아닌 꾸미기 속성 등이 상속된다. 겹침(Cascading): 하나의 element에 여러 style이 겹쳐질 수 있다.우선순위가 같을 경우 가장 밑의 style이 적용된다. 우선순위각각 selector마다 가진 우선순위가 다름 정적블로그 특강 : jekyll을 이용해 블로그 만들기나는 지금 hexo를 이용해서 블로깅을 하고 있는데 jekyll에 대해서도 배웠다. 느낀 점 의미있는 태그. Semantic Markup이 중요함을 점점 더 느낀다. Web Accessibility를 고려하면 간단한 화면 배치도 간단하지 않다. Markup은 공부할수록 깊이있는 언어같다. 객체지향언어에서 class를 의미있고 효율적으로 짜는 데에도 관심이 많았기 때문에 이 부분을 잘 살려서 코딩을 하고 싶다. hexo를 계속 이용하기로 했다. 익숙하기도 하고, 나중에 내가 테마를 조금씩 수정하거나 만들고 싶다.","link":"/2019/04/02/190402-TIL/"},{"title":"190401 TIL","text":"Today I Learned 오늘 배운 것 오늘부터 4주간 HTML/CSS를 새로 배운다. 첫 수업이었는데 많은 것을 새롭게 알았다. 웹 접근성과 웹 표준이 무엇이며 얼마나 중요한지, 개발자에 자세에 대해서 배웠다. HTML5의 역사와 특징에 대해 다시 한 번 배웠다. Web page 제작을 위한 단계를 배웠다. 선형화(layout) 단계 : design이 아닌 논리적 구조를 linearize Semantic Element : &lt;div&gt;만 사용하는 것이 아니라 &lt;header&gt;, &lt;footer&gt;, &lt;article&gt; 등 사용 Naming : element naming and grouping 편리한 Emmet Cheatsheet를 알았다. 진짜 편하다! CSS Box Model : content-box(defualt)와 border-box의 차이점을 알았다. flex를 이용해서 layout을 잡는 것과, 호환되지 않을 때를 대비하여 float를 이용하는 방법을 여러 case를 통해서 배웠다. Margin collapsing, clear: both 등 float CSS trick들을 배웠다. 느낀 점 지난 한달 간 나에게 가장 어려운 건 javascript보다는 HTML/CSS로 layout을 잡는 것이었는데, 내 생각대로 요소들이 배치되지 않았기 때문이다. 수업에서 CSS의 여러 속성들과 기능을 배우면서 왜 그렇게 되지 않았는지 알게 되었다. flex와 float는 확실히 공부하고 넘어가야겠다.","link":"/2019/04/01/190401-TIL/"},{"title":"190403-TIL","text":"Today I Learned 오늘 한 일 &amp; 느낀 점 🍀 LINEplus 홈페이지를 Markup해보는 시간을 가졌다. 홈페이지를 선형화하고, semantic하게 요소를 정하고 class 이름을 짓는 것만 해도 머리가 아팠다. data를 다루는 function들은 그 관계를 정의하고 흐름을 파악하기가 쉬운데, Markup은 당장 이런 요소를 쓰면 되겠다고 생각을 해도 아직은 머릿속에 바로 그려지지가 않는다. 🍀 3월에 일주일간 진행했던 프로젝트 발표 시간을 가졌다. 다들 열심이 만들어서 동기부여가 됐다. 🍀 오전에 flex에 대해서 공부했다. 과제를 하느라 배운 걸 다 정리하지 못해서 내일 아침에 마저 정리할 예정이다. 🐾 My linepluscorp markup page 🐾","link":"/2019/04/03/190403-TIL/"},{"title":"190404-TIL","text":"Today I Learned 오늘 한 일 주요 메뉴인 &lt;nav&gt;요소의 main menu를 마크업하고 CSS 디자인을 했다. 웹 접근성을 고려해서 submenu를 따로 ul로 분리하지 않고 menu-item인 li 안에 넣는 게 어려웠는데, 해결을 했다. HTML5의 flex model을 공부했다. container와 item에 따로 주던 flex 속성 값들이 이해되지 않았는데 flex-direction과 justify-content, align-item과 align-content가 어떻게 다른지 정리했다. 어제 만들었던 LINEplus 홈페이지를 조금 수정했다. 접근성을 높이기 위해서 몇 몇 요소의 위치를 바꾸고, CSS로 배치를 했다. ▶ &lt;option&gt; 안에는 &lt;a&gt;가 올 수 없다! Interactive요소 안에는 interactive 요소가 올 수 없다. a 안에 button 등 ▶ W3 문서를 확인해보니 &lt;h&gt;안에 &lt;a&gt;가 오는 게 아니고 그 반대가 맞는 것 같다. CSS Animation에 대해서 배웠다. timing-function을 이용한 animation이 흥미로웠다. 이번 주말에 나도 한 번 만들어보고 싶다. ▶ 참고 링크 : steps를 이용한 애니메이션 느낀 점 HTML/CSS 수업을 3일 들었는데 지난 한 달간 궁금하던 점이 많이 해결되었다. 웹 표준을 준수하고 접근성을 높이기 위해서 고려해야할 게 한두가지가 아니다. 처음 배우는 HTML을 기초부터 제대로 하는 것 같아 좋다. 시간이 빠르게 가는 것 같아 아깝다. 요즘은 하루하루가 바쁜만큼 더 많이 알고 싶다는 욕심이 생긴다. 🐸 Modified Lineplus site 🐸","link":"/2019/04/04/190404-TIL/"},{"title":"190406~07-TIL","text":"Today I Learned 오늘 한 일 음수마진에 대해서 배웠다. CSS grid framework에 대해서 배웠다.","link":"/2019/04/08/190406-07-TIL/"},{"title":"190405-TIL","text":"Today I Learned 오늘 한 일 로그인 메뉴를 구성하는 form tag와 input의 여러 속성에 대해서 배웠다. fieldset에 대해 처음 알았다. 접근성을 위해 label 과 input 을 bind 해야한다는 것을 알았다. box-shadow, section에 heading하는 법을 알았다. 느낀 점 오늘은 실습 위주의 수업이라 재미있었다. 하루종일 너무 많은 정보를 들어서 어지러운데 다 내 걸로 만들어야겠다!","link":"/2019/04/05/190405-TIL/"},{"title":"190409-TIL","text":"Today I Learned 오늘 배운 것 tab menu 마크업 했다. float, absolute, flex를 이용해서 여러가지로 마크업할 수 있다는 것을 알았다. jQuery로 메뉴의 mouseover, focusin 등 event를 입혔다.","link":"/2019/04/09/190409-TIL/"},{"title":"190408-TIL","text":"Today I Learned 오늘 한 일 ⭐️ &lt;dl&gt; tag에 대해서 배웠다. &lt;dl&gt; : Defines a definition list. &lt;dt&gt; : Defines a term/name in a description list. &lt;dd&gt; : Is used to describe a term/name in a description list. Ø 원래 &lt;dt&gt;와&lt;dd&gt; 를 &lt;div&gt;로 묶으면 안 됐었는데 허용됨 : 다만 맞는 &lt;dt&gt;를 설명하는 모든 &lt;dd&gt; 함께 묶어야 함. ⭐️ Web Cafe 예제 중 배너와 검색영역을 Markup, 디자인 설계 했다. &gt; 웹 관련 용어 배너 디자인 : float 사용 &gt; Logical order and Markup design ⭐️ LINEcorp 페이지 Markup을 처음부터 다시 했다. 디자인 관점이 아닌 컨텐츠 관점으로 논리적인 Markup 순서를 정하고 html과 CSS를 작성했다. 느낀 점 경험이 부족해서인지 아직 content에 맞게 semantic한 tag를 생각해내는 게 어렵다. 👼 More Semantic LINEpluscorp","link":"/2019/04/08/190408-TIL/"},{"title":"10. Comparing primitive and objects","text":"Difference between primitive type and object type Primitive Type Object Type immutable value mutable value stored as value itself stored as reference value (memory address of an object) Pass by value Pass by reference Primitive ValueImmutable Value The value of primitive type is an immutable value. (Read only, can not change) Can not change value doesn’t mean can not reassign value. Variable can be reassigned a new value, but the value can not be changed. When reassigning a new value to a variable, instead of changing the value stored in the memory space pointed to by the variable, assign a value to the new memory space and make the variable refer to the new memory space. This is because the primitive value is immutable. If the primitive value is a mutable value, the memory address referenced by the variable will not change when reassigning the variable. immutability : Since the primitive value is an immutable value, when the value of the variable is changed, the new value is stored in the new memory space, and the memory space is referred to. This property is called the immutability of the primitive value. Immutable? constant?In programming language, variable is a mechanism that store and refer data values. So, constant is also variable but can not assign more than once. Variables, and constants are memory spaces that can hold values, and the concept of mutable, immutable is about whether the value can change. 123456&gt; //Constants declared with the const keyword are not reassigned.&gt; const obj = {};&gt; &gt; obj.a = 1;&gt; console.log(obj); // {a: 1}&gt; Objects declared as const can be changed. This is because you are not reassigning a new object to const. That is, the constant is only a variable for which reassignment is prohibited. String and Immutability String is immutable because it’s also primitive type of JavaScript. String is an array-like object. Array-like ObjectAn array-like object is an object that is not an array, but can be treated like an array. A string can access each character through an index like an array, or it can be traversed by a for statement. This means that the string can be an object with a length property. You can not change str[0], but error doesn’t occur. Just ignore it. But, it is of course possible to reassign the new string. Because it is not a change to the existing string but a new assignment of the new string. The string gives the confidence that the value does not change without reassignment. Pass by valueWhat happens when a variable is assigned to a variable? If assigned variable is primitive type, the assigned variable value is copied and passed. It’s pass by value. 12var score = 80;var mine = score; Variable score and mine have a value 80, but it’s a separate value in memory. The value 80 in mine is not same as 80 in score. This is because the memory space of the variables mine and score is different and each contains a value. Thus, reassigning another value to the variable score does not affect the value of the variable mine. Object An object is a collection of properties consisting of key and value. A property whose value is a function is called a method. Since the number of properties is not fixed and the object can be added and deleted dynamically, the size of the memory space can not be preset in advance like the primitive value. How JavaScript manages objectsUnlike with an class-based object-oriented language, JavaScript can create an object without class and dynamically add a property and method even after an object have been created. For this reason, almost modern JavaScript engine uses a function-based dictionary-like structure to score a location of object property in memory. This is theoretically more costly and inefficient than object management in class-based object-oriented programming languages such as Java. So V8 JavaScript engine uses hidden class method. A hidden class operates like class in Java. Mutable ValueThe value of an object (reference) type, that is, an object is a mutable value. A variable that has been assigned a primitive value has its primitive value as its value. But, the variable that the object is assigned has a reference value as a value. The reference value is the address of the memory space in which the created object is stored, itself. 123var student = { name: 'Park'}; student variable has a address of the memory space where a created object is stored. This is a reference value. A variable can access the object by this reference value. When evaluating a variable that assigns an object, it returns the object by accessing the actual object through the reference value rather than returning the reference value stored in memory. An object pointed by a variable can be added dynamically after it has been created, updated, or deleted. In other words, an object is a mutable value. Objects can be very large and change fluidly, so instead of reallocating each time as a primitive value and changing the memory address, it changes the object itself to be referenced directly. In other words, copying an object as a primitive value (a deep copy) is expensive and inefficient, so it copies the reference value. Shallow copy and Deep copy Shallow copy : copying reference values Deep copy : copying and recreating the object itself as a primitive value. The larger the object, the higher the cost. A side effect of storing an object’s reference value is that an object can be referenced by multiple identifiers. 123456789var student = { name: 'Park'};var teacher = student;teacher.age = 35;console.log(teacher);console.log(student); The property is added only to the object of the teacher variable, but the changes are shared because the objects referenced by the student and teacher are the same. Pass by ReferenceIf you assign a variable that points to an object to another variable, the original reference value is copied and passed. This is called pass by reference. As shown in the figure above, since the memory address of the same object is referenced, student and teacher refer to the same object and change it.","link":"/2019/05/07/10-Comparing-primitive-and-objects/"},{"title":"190413~14-TIL","text":"Today I Learned오늘 한 일 4월 1일부터 2주간 김데레사 강사님의 HTML/CSS 수업을 들은 내용을 Github Repository에 Markdown file로 정리해 올렸다. 꼬박 네 시간은 더 걸렸다. Markdown 작성법은 익숙해진 것 같다. Google Analytics를 블로그에 연결했다. 참고하려고 주소만 첨부해놓고 정리하지 않은 Referance 페이지가 정말 많다! 틈틈히 공부하고 정리해야겠다. 😅 💞 GO to my Markup Summary Repo 💞","link":"/2019/04/14/190413-14-TIL/"},{"title":"190412-TIL","text":"Today I Learned오늘 한 일 계속 헷갈렸던 (그리고 어려웠던) CSS의 Transition(전이)과 Transform(변형)을 배웠다. CSS Animation은 정말 재밌다! mouseover와 mouseenter의 차이를 다시 한 번 복습했다. HEXO 테마를 바꿨다. 이제 정말 마지막이다!","link":"/2019/04/12/190412-TIL/"},{"title":"190415-TIL","text":"Today I Learned 오늘은 드디어 Web Cafe 예제를 끝마치고, 반응형 웹에 대해서 배웠다. 매번 아리송하던 Grid에 대해서 알고나니 속이 시원했다. 강력한 Layout 기능인데 우리나라에선 IE 점유율이 높아 잘 사용되지 않는다고 한다. 제대로 써보고 싶은데 아쉽다. Image, Video, iframe 등을 flexible하게 처리하는 방법을 배웠다. LeetCode Easy 26번 문제를 풀었다. 영어로 된 문제다보니까 문제를 제대로 파악을 하지 못해 매번 헛수고를 한다.","link":"/2019/04/15/190415-TIL/"},{"title":"190416-TIL","text":"Today I Learned오늘 한 일 LeetCode 27번 Remove Element 문제를 풀었다. 혼자 생각하며 알고리즘을 푸는 것은 어렵지 않은데, 다른 사람에게 논리적으로 설명하려고 하면 말문이 막힌다. 내가 알고 있는 것을 논리적으로 잘 전달하는 연습을 해야겠다. HTML/CSS 마지막 수업으로 반응형 이미지, 배경 이미지 처리, Grid를 이용한 Mobile, DeskTop layout 등을 실습했다. 4월 15일부터 16일까지 이틀간 진행한 내용 또한 Markup Summary에 올릴 예정이다. 느낀 점 김데레사 강사님과 2주 간의 수업을 마쳤다. 짧은 시간 동안 정말 많은 것을 배웠다. 도저히 무슨 의미와 성질을 가지는지 몰랐던 HTML과 CSS에 대해 이해할 수 있게 되었다. 무엇보다 접근성을 고려한 웹 개발을 지향하게 되었다는 점이 가장 뜻깊다. 🌟 FDS12th HTML/CSS Summary 🌟","link":"/2019/04/16/190416-TIL/"},{"title":"190417-TIL","text":"Today I Learned오늘 한 일오전 알고리즘 스터디에서 LeetCode 말고 다른 알고리즘 풀이 사이트를 이용하자는 의견이 나와 오늘부터 CodeWars에서 문제를 풀어보기로 했다. 6급 문제를 풀었는데 생각보다 쉬워서 LeetCode 문제를 하나 더 풀었다. 오후 컴퓨터공학 기초 수업을 8일간 듣는다. 자료구조, 알고리즘과 Python을 배운다고 한다. 오늘은 Memory와 Number type, Binary 연산을 공부했다. 학교 전공 수업을 다시 복습해야겠다. position: sticky는 top, left, right 중 값 한가지를 넣어야 동작한다!!!","link":"/2019/04/17/190417-TIL/"},{"title":"190418-TIL","text":"Today I Learned오늘 한 일 Epsilon, Number Digit 등 컴퓨터에서 실수를 표현하는 방식과 상대오차에 대해서 깊게 배웠다. 실수형의 논리비교를 위한 is_equal 함수를 만들었다. 123456789101112131415function is_equal(x, y, allowed=0){ // 둘 중 큰 수의 다음 숫자와의 오차의 allowed 배 정도 되는 범위 안에 있으면 같다고 판단한다. return (Math.abs(x-y) &lt;= Math.max(Math.abs(x), Math.abs(y))*Number.EPSILON*Math.pow(2, allowed));}function main(){ var sum = 0; for(var i =0; i&lt; 100; i++){ sum += 0.01; } if(is_equal(sum, 1.0, 2)){ console.log(\"THE SAME\"); } else{ console.log(\"NOT THE SAME\"); }} Python을 배우는데 너무 재미있다. 익숙하지 않아 찾아보는 것이 번거롭지만 문법이나 기능이 흥미롭다.","link":"/2019/04/18/190418-TIL/"},{"title":"190419-TIL","text":"Today I Learned오늘 한 일새로운 언어를 배우는 방법 자료형 연산자 제어문, 반복문 함수 call by reference, call by value, call by object reference First class function인지 Class 지원하는지 ( Encapsulation Inheritance Virtual function 지원 여부) Python Data Type과 기본 Data Structure 실습Text 가위바위보 게임123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import randomdef get_player_choice(): \"\"\" get_player_choice() -&gt; string Return \"바위\" or \"가위 or \"보\" \"\"\" choice = input(\"가위바위보! : \") while choice != \"가위\" and choice != \"바위\" and choice != \"보\": choice = input(\"가위바위보! : \") return choicedef get_computer_choice(): \"\"\" get_computer_choice -&gt; string Return \"바위\" or \"가위 or \"보\" \"\"\" tup = (\"가위\", \"바위\", \"보\") return tup[random.randint(0,2)]def who_wins(player, computer): \"\"\" who_wins(player, com) -&gt; string Return if player wins 'player' elif computer wins 'computer' else None \"\"\" if player == computer: return None if (player == \"바위\" and computer == \"가위\") or\\ (player == \"가위\" and computer == \"보\") or\\ (player == \"보\" and computer == \"바위\"): return 'player' else: return 'computer'def play_one(): \"\"\" play_one -&gt; string Return if player wins 'player' elif computer wins 'computer' \"\"\" player_win = 0 computer_win = 0 while player_win == computer_win: player = get_player_choice() computer = get_computer_choice() result = who_wins(player, computer) print(f'Player {player} vs Computer {computer}') if result == 'player': player_win += 1 elif result == 'computer': computer_win += 1 if player_win &gt; computer_win: return 'player' else: return 'computer'def check_final_winner(result): \"\"\" check_final_winner(result) -&gt; string result : ex) ['player', 'player'] Return if 'player' &gt;= 2 in result, 'Player' elif 'computer' &gt;=2 in result, 'Computer' else None \"\"\" print(f\"Player {result.count('player')}승 | Computer {result.count('computer')} 승\") if result.count('player') &gt;= 2: return 'Player' else: return 'Computer'def play(): \"\"\" play() -&gt; None 3판 2선승가위바위보 \"\"\" result_list = [] for i in range(3): result_list.insert(i, play_one()) print(check_final_winner(result_list)+\" Wins!!\")if __name__==\"__main__\": play() ASCII와 UNICODEASCII와 UNOCODE의 역사, UNICODE의 Encoding, Decoding 방법도 배웠다. Python Bubble Sort1234567891011def bubble_sort(li): n = len(li) for i in range(n-1): for j in range(n-1-i): if li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j]if __name__ == \"__main__\": li=[6, 2, 1, 4] bubble_sort(li) print(li) 간단한 Bubble Sort function을 만들었다. 알고리즘CodeWars 6kyu. Persistent Bugger 그리고 LeetCode의 Medium Level 문제를 풀려고 했는데 Dynamic Programming 개념이 들어가 쉽지 않다. 주말 내내 풀어야겠다.","link":"/2019/04/19/190419-TIL/"},{"title":"190421-TIL","text":"Today I LearnedLeetCode 5. Longest Palindromic Substring금요일부터 오늘까지 내내 나를 괴롭히던 문제를 해결(?) 했다. 시간을 많이 들여도 도저히 답이 나오지 않으면 포기하기보다 다른 사람들의 Solution을 보고 분석하는 것 또한 공부라고 생각한다. Python에 익숙해질겸, Dynamic Programming을 재정리할겸 여러 시도를 해보았지만 내가 생각하지 못한 기발한 방법으로 문제를 해결한 사람들이 많았다.","link":"/2019/04/21/190421-TIL/"},{"title":"190420-TIL","text":"Today I LearnedSass 특강 임기완 강사님의 Sass 특강을 들었다. Sass는 CSS의 preprocessor이다. Preprocessor란, 컴파일러와 같이 자신의 input data로 만들어낸 ouput data가 다른 프로그램의 input data가 되게끔 하는 프로그램을 말한다. scss 를 css로 변환하는 방법과, variable, partial, import, mixin, @extend를 이용한 inheritance, data type 등 전체적인 부분을 훑어봤다. HEXO로 블로그를 하기 위해서 살펴보았던 .ejs 나 .jade 파일에서 보았던 이상한 문법들이 이해가 되는 순간이었다! mixin이 많은 도움이 될 것 같다. 🐊 구닥다리 공룡을 위한 오늘날의 CSS 알고리즘 CodeWars Directions Reduction 문제를 풀었다. 😈 알고리즘 풀이 보러가기","link":"/2019/04/20/190420-TIL/"},{"title":"190422-TIL","text":"Today I Learned오늘 한 일 Python Functions(호출 방식, stack, map filter 등)을 배우고 posting으로 정리했다. LeetCode 알고리즘을 풀고, 알고리즘 스터디를 했다.","link":"/2019/04/22/190422-TIL/"},{"title":"190423-TIL","text":"Today I Learned오늘 한 일 Big-O notation을 다시 한 번 정리하며 성능순으로 정리했다. O(1) : 상수 시간 엄청 빠름 array의 indexing, linked list의 insert, delete O(logn) : 로그 시간 Binary Search Tree의 insert, search, delete O(n) : 선형 시간 linked list의 search, 특정 array의 insert, delete O(nlogn) : 선형 로그 시간 quicksort, merge sort comparision sorting의 경우 quick sort보다 성능 좋을 수 없다. O(n2) : 지수시간(?) bubble sort, select sort, insert sort 등 Memory | Performance of fbstring Memory에 관련된 영상 하나를 보고 Memory 공부를 했다. Performance of fbstring 나는 전공 수업에서 OS를 들으며 배웠던 내용이라, 그 때 배웠던 것들을 처음부터 정리하며 복습 했다. Process and Thread 어렵고 다룰 게 많은 주제인데 한 번에 후다닥 나가는 느낌이라 아쉬웠다. OS를 복습할 겸 Chapter 별로 정리해 포스팅할 계획을 세웠다. Process와 Memory 개념 정리 Codewars 5kyu Sum of Pairs 문제를 풀었다. 자꾸 Timeout이 나서 성능을 좋게 만들려고 최대한 노력했다.","link":"/2019/04/23/190423-TIL/"},{"title":"190424-TIL","text":"Today I Learned오늘 한 일 Python Class 선언과 instance를 만드는 방법에 대해서 배웠다. Object-Oriented Programming에 대해서 정리한 내용을 포스팅했다. ✨4 Fundamentals of OOP Python Access Modifier에 대해서 알고 정리했다. Network 계층 및 Eathernet과 IP Protocol에 대해서 배웠다. Quick sort | Divide and Conquer - Python으로 Code를 짰다","link":"/2019/04/24/190424-TIL/"},{"title":"190425-TIL","text":"Today I Learned Fastcampus에서 진행한 졸업생과의 티타임 시간에 졸업한 개발자분을 만나뵙고 경험들을 들었다. 많은 도움이 됐다. Network를 대략적으로 살펴봤다. 나는 학교에서 배웠지만 오래되어 다시 한 번 정리하는 게 필요할 것 같다. TCP/IP 네트워크 스택 이해하기 Quick Sort의 성능 분석 및 정리해서 posting 했다.","link":"/2019/04/25/190425-TIL/"},{"title":"190426-TIL","text":"Today I Learned Simulated and implemented Merge sort. Studied python Stack and queue. Also implemented stack using 2 queues, queue using 2 stacks. Review linked list in python. Solve CodeWars 6kyu Take a Number And Sum Its Digits Raised To The Consecutive Powers And ….¡Eureka!!","link":"/2019/04/26/190426-TIL/"},{"title":"190501-TIL","text":"Today I LearnedI learned about the operation principle and process of web browser. HTML parser creates DOM tree, CSS parser creates CSSOM tree and JavaScript parser creates AST(Abstract Syntax Tree). Now I can explain JavaScript and ECMAScript.","link":"/2019/05/01/190501-TIL/"},{"title":"190429-TIL","text":"Today I LearnedSolved Morse code decoding problem my Algorithm Post Wrote posting about JavaScript 1. What is Programming? Studied Data Structure and posted 1. OOP and ADT","link":"/2019/04/29/190429-TIL/"},{"title":"190430-TIL","text":"Today I LearnedAlgorithm study Studied history, variable, data type and operation of JavaScript","link":"/2019/04/30/190430-TIL/"},{"title":"190502-TIL","text":"Today I LearnedAlgorithm study Solved Double cola problem! Studied about Control flow statement of JavaScript","link":"/2019/05/02/190502-TIL/"},{"title":"190507-TIL","text":"Today I LearnedStudied JavaScript operator, contitional statement, type coercion and short-circuit evaluation, object literal. Algorithm study - CodeWars [6kyu] Consecutive strings. We will start to implement underscore library functions like map, reduce.","link":"/2019/05/07/190503-TIL/"},{"title":"190508-TIL","text":"Today I LearendStudied JavaScript function and scope of JavaScript. ✨ Function posting ✨ ✨ Scope posting ✨","link":"/2019/05/08/190508-TIL/"},{"title":"190509-TIL","text":"Today I Learned Implemented underscore libray’s last function 12345// Like first, but for the last elements. If n is undefined, return just the// last element._.last = function(array, n) { return n === undefined ? array[array.length-1] : n &gt; array.length ? array : array.slice(array.length-n, array.length);}; Studied about JavaScript global variable and let, const keyword variables.","link":"/2019/05/09/190509-TIL/"},{"title":"190516-TIL","text":"Today I Learned Prototype 포스팅을 하면서 다시 한 번 정리 했다. String, Number, Math, Date 객체의 프로퍼티와 메소드를 공부했다. String, Number, Math, Date 연습문제를 풀었다.","link":"/2019/05/16/190516-TIL/"},{"title":"190517-TIL","text":"Today I Learned this가 바인딩되는 방식에 대해서 팀원들과 토론했다. 💛190517 Brain Stretching Math, String, Number 객체의 메소드를 응용한 알고리즘 연습 문제를 풀었다. 💛 풀이 보러가기 자바스크립트 Array에 대해서 배웠다. 주말에 할 일 자바스크립트 String 자주 쓰이는 method 정리하기 자바스크립트 Array 정리하기","link":"/2019/05/17/190517-TIL/"},{"title":"190515-TIL","text":"Today I Learned 자바스크립트의 Strict Mode, 전역 객체 window, this 바인딩에 대해서 배웠다. Underscore의 each 메소드를 구현했다. 자바스크립트 알고리즘 문제 3개를 풀었다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// if문 사용function evenOrOdd(num) {if (num % 2) { return 'Odd';}return 'Even';}// 3항 연산자 사용function evenOrOdd2(num) {return num % 2 ? 'Odd' : 'Even';}console.log(evenOrOdd(42));console.log(evenOrOdd(55));console.log(evenOrOdd2(288));console.log(evenOrOdd2(25));// #2. 1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기 (Google)// 1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라.// 단, 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. 예를 들어 8808은 3, 8888은 4로 카운팅 해야 한다.// (hint) 문자열 중 n번째에 있는 문자 : str.charAt(n) or str[n]function getCount8() {let concatString = '';let count = 0;for (let i = 1; i &lt; 10001; i++) { concatString += i;}for (let j = 0; j &lt; concatString.length; j++) { if (concatString[j] === '8') { count += 1; }}return count;}console.log(getCount8()); // 4000// 3. 문자열 다루기// alphaString46 함수는 문자열 s를 매개변수로 입력받는다. s의 길이가 4 ~ 6이고, 숫자로만 구성되어 있는지 확인하는 alphaString46 함수를 완성하라.// 예를 들어 s가 'a234'이면 false를 리턴하고 '1234'라면 true를 리턴한다.function alphaString46(s) {if (s === undefined || s.length &lt; 4 || s.length &gt; 6) return false;for (let i = 0; i &lt; s.length; i++) { // eslint-disable-next-line no-restricted-globals if (isNaN(s[i])) return false;}return true;}console.log(alphaString46('1234'));console.log(alphaString46('9014'));console.log(alphaString46('723'));console.log(alphaString46('a234'));console.log(alphaString46(''));console.log(alphaString46());","link":"/2019/05/15/190515-TIL/"},{"title":"190522-TIL","text":"Today I Learned JavaScript의 Class, super 키워드에 대해서 공부했다. 해커톤 자료구조를 설계하고 사용할 카카오맵 API를 테스트했다. JavaScript Event에 대해서 읽어보았다.","link":"/2019/05/22/190522-TIL/"},{"title":"190521-TIL","text":"Today I Learned 해커톤 웹 애플리케이션에 사용할 자료를 조사하고 분류하는 작업을 했다. 자바스크립트의 클래스, 디스트럭처링, 객체 프로퍼티 등을 공부했다.","link":"/2019/05/21/190521-TIL/"},{"title":"190520-TIL","text":"Today I Learned 고차 함수, 배열 메소드를 공부했다. 알고리즘 문제를 풀었다.","link":"/2019/05/20/190520-TIL/"},{"title":"190524-TIL","text":"FDS12 Pair Hackaton오늘 약 5일간 기획하고 준비한 페어 해커톤을 마쳤다. 오전 10시부터 오후 5시까지 약 7시간동안 하나의 결과물을 내는 것이다. 내 생애 첫 해커톤에서 1등을 했다. 오늘은 이론을 공부하지는 않았으나 그것보다 훨씬 더 많은 것을 배웠다. 우선 나는 프로젝트 경험이 적어 개발 능력에 자신감이 없는 편이었는데 이번 해커톤으로 자신감을 많이 얻었다. 그리고 무엇보다 내가 생각한대로 기능을 구현하는 것이 너무나 재미있었다.삐그덕거리던 프로그램을 차근차근 고쳐서 모든 게 맞아 돌아가게끔 할 때의 쾌감이란! 확실히 개발은 재미있다. 고통 속에서 느끼는 희열이 있다. 그리고 기획이 얼마나 중요한 것인지도 알았다. 비지니스적인 시야가 넓은 팀원의 주제 제안과 꼼꼼한 기획 덕에 완성도 있고 의미 있는 프로젝트를 할 수 있었다. 또한 디자인적인 감각을 키우는 것도 내가 해야할 공부 중 하나라는 것을 깨달았다. 두번째로 아직 내가 가야할 길이 멀다는 것을 배웠다. 무언가 엄청나게 멋있(어 보이는)는 것을 만들기에 시간은 한없이 모자랐다. 마음이 조급해지니 중간에 혼잣말로 징징거리기도 많이 했다. 결국 프로젝트는 원하던 것의 80%정도밖에 구현하지 못했다. 아쉽지만 분명히 미래의 나에게 좋은 밑거름이 될거라 믿는다. 마지막으로, 나는 발표를 할 때 긴장을 참 많이 한다. 막상 앞에 나가서 무슨 정신인지 여유로운 척 농담을 하고 발표를 했지만 끝나고 돌아와 앉는 순간까지 손과 다리가 떨리는 게 느껴졌다. 오늘도 발표를 하고 들어왔는데 어떻게 한 건지 정신이 하나 없었다. 그런데 같은 스쿨 분들이 안 떤 것처럼 느껴졌다고, 잘 했다고 말해줘서 많이 안심했다. 내가 막연하게 무서워하는 것들. 막연하게 내가 못 할 거라고 단정지었던 것들은 사실 내가 충분히 해낼 수 있는 거였다. 오늘의 경험을 잊지 않고 앞으로 나아가기 위해 기록한다. ✨Team Doctor on Devpost ✨Team Doctor Github","link":"/2019/05/24/190524-TIL/"},{"title":"190527-TIL","text":"Today I Learned JavaScript Event를 연습하기위해서 TodoList를 여러가지로 구현했다. Class를 이용해서 구현하는 방법도 알았다. Event Listener를 Class의 method로 만들었을 때 해당 메소드의 this는 class의 instance가 아니라 event를 바인딩한 DOM객체가 되는 문제 bind로 event listener method에 this를 binding this가 없는 Arrow function을 사용해서 상위 lexical scope, 즉 class의 this를 바인딩하게 하는 방법 Todos 1.0","link":"/2019/05/27/190527-TIL/"},{"title":"190529-TIL","text":"Today I Learned JavaScript Ajax, RESPful API, Promise에 대해서 배웠다. 알고리즘 문제 해결 전략 책을 샀다. 틈틈히 알고리즘 공부를 해야겠다.","link":"/2019/05/29/190529-TIL/"},{"title":"190531-TIL","text":"Today I Learned Ajax, Promise로 CRUD 구현 fetch, async 와 await도 사용해봤다","link":"/2019/05/31/190531-TIL/"},{"title":"190603-TIL","text":"Today I Learned 오후에 3분간 나가서 자바스크립트 키워드에 대해서 설명하는 시험을 봤다. 자바스크립트 원시타입과 객체타입의 차이에 대해서 발표했다. 💛 키워드 정리 Todo List Server가 있는 환경에서 실습하기 위해서 작업환경을 세팅했다. Webpack과 Babel, Sass를 위한 작업 환경을 구성했다. 호스팅 서비스를 이용해서 MongoDB를 설치했다.","link":"/2019/06/03/190603-TIL/"},{"title":"190605-TIL","text":"Today I Learned 오늘은 실행 컨텍스트를 배웠다. 엄청 어렵다.. 변수 선언문을 배울 때부터 의문점이었던 실행 컨텍스트의 렉시컬 환경의 정체에 대해서 알게 되어서 속이 시원한 것 같다.","link":"/2019/06/05/190605-TIL/"},{"title":"190604-TIL","text":"Today I LearnedMongoDBMongoDB는 Document-Oriented NoSQL Database이다. RDBMS의 Table을 Collection, Tuple를 Document라고 부른다.RDBMS처럼 고정된 Schema가 존재하지 않고 하나의 Collection 내의 DOcument가 각각 다른 Schema를 가질 수 있다. SASSSass(Syntactically Awesome StyleSheets)는 CSS pre-processor로 CSS의 단점을 보완하고 코드 재사용에 유리한 CSS를 생성하기 위한 CSS의 extension이다. 변수의 사용 조건문과 반복문 Import Nesting Mixin Extend/Inheritance 등의 도구들을 제공한다. 한 일 Todos version 3을 만들었다. MongoDB 서버를 연동 복습하는 겸 네트워크 공부를 조금 했다.","link":"/2019/06/04/190604-TIL/"},{"title":"190610-TIL","text":"Today I Learned Tab UI를 만들었다. Accordian UI를 만들었다. Range Slider UI를 만들었다. 셋을 합쳤다. jQuery로 구현된 코드를 Vanilla JavaScript로 고쳤다. ✨UI Exercise","link":"/2019/06/10/190610-TIL/"},{"title":"190612-TIL","text":"Today I Learned TypeScript에 대해서 배우고 실습해봤다. Angular로 간단한 TodoList 기능을 구현해봤다. 맛보기만 해봤지만 재밌다! 그리고 엄청 편하다. TypeScript는 기존에 알고 있던 객체지향개념(Class, Interface 등)이 있어 사용하기 편리할 것 같다.","link":"/2019/06/12/190612-TIL/"},{"title":"190611-TIL","text":"Today I Learned SPA (Sigle Page Application)에 대해서 배웠다. JavaScript Class를 복습했다.","link":"/2019/06/11/190611-TIL/"},{"title":"190617-TIL","text":"Today I Learned Angular Component의 Data Binding에 대해서 배웠다. Angular의 ngFor와 ngIf Directive를 적용해서 TabsUI를 구현해봤다. Angular 문법이 아직 익숙하지는 않은데 재미있다. 생각을 전환하기가 쉽지 않다.","link":"/2019/06/17/190617-TIL/"},{"title":"190618-TIL","text":"Today I Learned Angular로 AnalogClock과 StopWatch를 구현했다. Angular Built-in Directive에 대해서 배웠다. 부모-자식 Component간 통신을 이용해서 simpleTodo를 구현했다. 자식 &gt; 부모 Component로 Data를 보낼 때는 @Output() 에 EventEmmitter의 instance로 event를 발생시킨다. emit()을 호출해야 event가 발생한다. 부모 &gt; 자식 Compinent로 Data를 보낼 때는 부모 Component에서 자식 Component로 Property binding을 하는 방식으로 Data를 보낸다. 자식 Compinent는 해당 프로퍼티를 @Input()으로 정의하고 값을 받는다.","link":"/2019/06/18/190618-TIL/"},{"title":"190619-TIL","text":"Today I Learned Angular 계층적 구조를 가진 Component 간의 Data 통신을 Service로 한다는 것을 알았다. Angular의 Service는 전체 프로그램에서 하나의 Instance만을 가지는 Singleton이기 때문에 상태 관리가 가능하다.","link":"/2019/06/19/190619-TIL/"},{"title":"190624-TIL","text":"Today I Learned ToastUI를 JavaScript와 Angular로 구현했다. window.pageYOffset은 wiondow.scrollY보다 cross browsing에 적합(IE 9 지원)하므로 pageYOffset을 사용하는 게 좋다.","link":"/2019/06/25/190624-TIL/"},{"title":"190622-TIL","text":"Today I Learned Front Endgame 컨퍼런스에 갔다왔다. Angular와 React에 대한 정보를 많이 얻었다. 현직 프론트엔드 개발자들이 어떤 식으로 일 하는지 들을 수 있어 좋았다. 앵귤러 공부 위해서 디렉티브 등 템플릿 문법 숙지해야함 RxJS 공부해야함 RxJS 는 비동기적 데이터 흐름을 한 곳에서 조작할 수 있음 Dependency Injection으로 다형성 UX 예상 가능한 동작 뒤로가기시 스크롤 복원 모바일 Thumbs zone SEO/SMO Observable 공부하기 도서 하스켈로 배우는 함수형 프로그래밍 클린 코드 실용주의 프로그래머 프로그래밍 심리학 함수형 프로그래밍이 왜 CPU보다 메모리를 많이 쓰는지 알기","link":"/2019/06/22/190622-TIL/"},{"title":"190628-TIL","text":"FDS12 School Hackaton패스트캠퍼스에 들어오고 두 번째 해커톤을 마쳤다. 총 10개 팀 중 3개 팀을 수상했는데 우리 팀이 인생을 바꾸는 작은 유용함 상을 수상했다. 각 스쿨의 매니저분들이 엑셀 파일로 학생 관리를 하는 불편함을 해소하고자 학생 관리 툴을 웹으로 옮겼다. 페어 해커톤이 아닌, 전체 스쿨 해커톤으로 백엔드와의 협업을 하고 싶었으나 전날 백엔드 팀이 빠지게 되어 프론트엔드 세명으로만 프로젝트를 진행했다. Angular Form을 사용해서 login 기능을 구현하고 싶었는데 아쉬웠다. 기대가 별로 없었는데 입상을 해서 기분이 좋았다. 앞으로 Final 프로젝트가 하나 남았다. ✨IWAM on Devpost ✨IWAM Github","link":"/2019/06/28/190628-TIL/"},{"title":"190701-TIL","text":"Today Test[오답] 식별자를 검색했을 때 없으면 ReferenceError지만 Property를 검색했을 때 없으면 error가 아니고 undefined를 리턴 함수가 아닌 것에 () 붙여 실행하면 TypeError (SyntaxError 아님!!!!!!) undefined 값에 method 실행해도 TypeError typeof 배열은 object 1234function getAge(...args) { console.log(typeof args);}getAge(20); Spread operator …가 argument에서 사용되면 Object나 Array를 풀어서 함수의 argument로 전달 Rest parameter … 를 사용하면 풀어진 argument를 하나의 배열로 받음 ‘use strict’ 12345function getAge() { 'use strict'; age = 20; console.log(age);} ‘use strict’ mode가 아닐 때는 키워드 없이 선언한 변수를 암묵적 전역 변수로 등록하지만, ‘use strict’ mode에서는 식별자를 찾고 없으면 ReferenceError 발생 Angular HttpClient 어떤 element의 값으로 일을 하고 그 값을 수정해야할 때 ngModel 양방향 바인딩 사용","link":"/2019/07/01/190701-TIL/"},{"title":"190708-TIL","text":"Today I LearnedTEST Wrapper Object 1234'string'.length; // 6const s = 'super'String.prototype.sayHi() = () =&gt; { console.log('Hi') };s.sayHi(); // 'Hi 문자열을 객체처럼 사용할 경우 JavaScript 엔진이 순간 String 생성자 함수로 wrapping 한다. Property Key Property Key 동적 생성 123456789var obj = {};var key = 'hello';// ES5: 프로퍼티 키 동적 생성obj[key] = 'world';// ES6: 프로퍼티 키 동적 생성// var obj = { [key]: 'world' };console.log(obj); // {hello: \"world\"} Property Key는 문자열이나 symbol 값 이외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다. 예를 들어, 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로는 문자열로 변환된다. Property Key로 객체를 사용해도 error가 나지 않고 들어감. 배열도 마찬가지 객체는 [object Object]라는 String으로 변환된다. obj[string]이 되어야하기 때문에 [] 내부는 문자열로 강제 형변환된다. 123456789const a = {};const b = { key: 'b' };const c = { key: 'c' };// 두 객체 모두 Property key로 쓰일 때 문자열 [object Object]로 변환되어 같은 key가 된다.a[b] = 123;a[c] = 456;console.log(a[b]); Property Key를 중복 선언하면 나중에 선언한 Property가 이전 것을 덮어씀 call, apply method는 함수에 this를 전달하고 호출하지만 bind는 this를 전달한 함수를 return한다. Function literal과 Function declaration statement의 차이 함수 이름이 있는 함수 선언문은 자바스크립트 엔진이 함수명과 동일한 식별자를 생성하고 생성한 함수 객체를 할당한다. 함수 이름이 필수가 아닌 함수 리터럴은 그저 평가되어 함수 객체를 생성한다. 이를 괄호로 감싸면 에러 없이 함수 객체가 된다.1234// 즉시 실행 함수로 함수 리터럴을 사용하는 경우(function () { ...})()","link":"/2019/07/08/190708-TIL/"},{"title":"190709-TIL","text":"Today I Learned 오전에 프로젝트 기능 분석, 컴포넌트 분리에 대해 회의를 진행했다. 오후에 이력서 특강을 들었다. ✨이력서 특강 요약✨ 이력서 특강이력서에 담을 내용 개인 정보 (이름, Contact) 업무적 강점 Technology Set 경력사항 프로젝트경험 주제를 명확히 작성 (프로젝트 목적 명시) 완벽한 대규모 프로젝트가 아니라도 괜찮음 자격증, 수상 경력 학력 및 교육 (온오프라인 단기 교육 포함) 교육 수료증 첨부 !! 기타활동 (컨퍼런스, 해커톤 등) 컨퍼런스나 해커톤 인상적이었던 거 적어놓기 취미 영화, 책읽기, 운동 등으로 자기 관리 어필 기본 맞춤법 전공이나 개발교육 과정 최근순 작성 일관성 있는 문장 꼭 적어야 하는 개인 정보 연락에 필요한 이메일 주소와 전화번호 GitHub 계정 기술 블로그 쓰지 않는 개인 정보 사진 필수 아님 생년월일 주민번호 요구할 때만 주소는 동까지 사생활 노출되는 개인 SNS 가족사항 등 업무와 관련되어 있는 정보 요약 채용 공고의 키워드 === 내 이력서의 키워드 지원서에 해당 회사의 에 대한 관심을 표현하고 있는지 내 강점 내가 기여할 수 있는 것 강점 JD에 맞는 인재인가? 기여할 수 있는 부분 강조하기 업무적 강점을 충분히 설명하고 있나? 간략하고 알기 쉽게 표현했나? 자신의 개발 성향을 언급했나? 러닝커브가 짧은 개발자 테스트코드를 꼼꼼하게 작성하는 개발자 문서화를 잘하는 개발자 커뮤니케이션을 잘 하는 개발자 일정관리를 잘 하는 개발자 해당 도메인 지식이 많은 개발자 개발경력 외의 경력이 있다면 어떻게 활용하면 좋을지? 버전 관리의 중요성 이해, GitHub 꼮쓰기 Ex SKILL SET 실력이 부족한 것도 다뤄봤다는 것을 알리면 좋음 영문 이력서 작성 front-end junior resume 등으로 검색 취업 플랫폼 잡플래닛 원티드 잡코리아 크레딧잡 - 연봉 ✨이력서 특강 자료✨","link":"/2019/07/09/190709-TIL/"},{"title":"190706-TIL","text":"Today I Learned Anguler Reactive Form을 이용해서 Netflix 회원가입과 로그인 Form을 Validation까지 구현했다. FastCampus Final Project로 Netflix를 클론하기로 했다. CSS 작업은 늘 어렵다. 그래도 transition과 box size를 잘 이용하면 뭐가 되긴 된다.. 🎆 Subin Angular Netflix Form","link":"/2019/07/06/190706-TIL/"},{"title":"190715-TIL","text":"Today I Learned오전 프로젝트 구현을 시작하기 위해서 팀원들과 개발 환경을 세팅했다. 오후 모일 시간 등 회의 Header Component의 Secondary Navigation과 Directive를 이용한 window scroll Fixed header를 구현 오늘 회의1. 출퇴근 시간 정하기 업무 시간 : 6 ~ 7 시간 (평일: 월 ~ 금 / 주말: 토요일) 오전 : 오전 10시 출근 오후 6시 퇴근 오후 : 오후 1시 출근 오후 10시 퇴근 (저녁 시간 1 시간 30분) 2. 오늘부터 구현할 내용 발표하기 매일 오후 5시 반","link":"/2019/07/15/190715-TIL/"},{"title":"190720-TIL","text":"Today I Learned 백엔드에서 API가 하나씩 완성이 되어 협업을 하다보니까 생각지 못한 변수가 생겼다. 하나를 고치면 새로운 수정 사항이 생기기를 반복하는 식이다. step이 4개가 되는 회원가입, 로그인과 관련된 Http 통신을 구현했다. 현재 로그인을 한 후 프로필을 등록하는 단계를 진행 중이다. 토요일 오늘은 React 특강을 들었다. Angular와는 다른 느낌으로 더 배워보면 재미있을 것 같다.","link":"/2019/07/20/190720-TIL/"},{"title":"190716-TIL","text":"Today I Learned Home과 Movie, My List 뷰의 Header와 Footer를 통일하고 Header의 sub menu와 hover transition 등을 마무리 했다. bootstrap 모듈을 하나 가져다 썼다고 내가 적용했던 CSS가 먹통이 되는 일이 있었다.. 개고생 했다. Server에서 받아온 Data를 어떻게 다룰 것인지 고민해봐야한다.","link":"/2019/07/16/190716-TIL/"},{"title":"19. Global Object","text":"전역 객체는 어떤 객체보다도 먼저 생성하고 어느 객체에도 속하지 않는 최상위 객체. client side 환경(브라우저)에서는 window server side 환경에서는 global 객체 전역 객체는 개발자가 의도적으로 생성할 수 없다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. 전역 객체는 Object, String, Number,Boolean, Function, Array RegExp, Date, Math, Promise 등 모든 built-in 객체를 프로퍼티로 가지고 있다. 브라우저의 window 객체는 DOM, BOM, Canvas, XMLHttpRequest, Fetch, SVG, Web Storage 등 Client side Web API를 프로퍼티로 소유한다. var 키워드로 선언한 전역 변수와 암묵적 전역 변수, 전역 함수는 전역 객체의 프로퍼티가 된다. (단, let이나 const 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다.) 전역 객체의 프로퍼티와 메소드는 window를 생략하고 참조/호출 할 수 있으므로 전역 함수처럼 사용할 수 있다. 1. Global Property전역 프로퍼티는 전역 객체의 프로퍼티이다. 1.1. InfinityInfinity 프로퍼티는 양/음의 무한대를 나타내는 Number Infinity를 갖는다. 숫자를 0으로 나누면 NaN이 될 것 같지만 무한대를 나타낸다. 123console.log(4/0); // Infinityconsole.log(4/-0); // -Infinityconsole.log(typeof Infinity); // number 1.2. NaNNaN(Not-a-Number) 프로퍼티는 숫자가 아님을 나타내는 Number NaN을 갖는다. 123console.log(Number('string')); // NaNconsole.log(1 * 'string'); // NaNconsole.log(typeof NaN); // number 1.3. undefinedundefined 프로퍼티는 primitive type undefined를 값으로 갖는다. 2. Global Function전역 함수는 전역 객체의 메소드이다. 애플리케이션 전역에서 호출할 수 있다. 2.1. eval문자열로 코드를 주면 그 코드를 실행하는데, 평가시 자신의 스코프를 만들고 상위 스코프로 변형시켜 비용이 많이 든다. 2.2. isFiniteparameter에 전달된 값이 정상적인 유한수인지 검사해서 Boolean을 리턴한다. 숫자가 아닌 값 전달받으면 숫자 타입으로 변환 후 검사를 수행한다. 2.3. isNaNparameter에 전달된 값이 NaN인지 검사해서 Boolean을 리턴한다. 숫자가 아닌 값 전달받으면 숫자 타입으로 변환 후 검사를 수행한다. 2.4. parseFloatparameter에 전달된 String을 부동소숫점 숫자(floating point number)로 변환하여 반환한다. 2.5. parseIntparameter에 전달된 String을 정수형 숫자(Integer)로 parsing하여 리턴한다. 리턴값은 10진수이다. 10진수 숫자를 10진수가 아닌 수의 문자열로 변환하고 싶을 때는 Number.prototype.toString 메소드를 사용한다. 123456const x = 10;console.log(x.toString(2)); // '1010'console.log(x.toString(8)); // '12'console.log(x.toString(16)); // 'a'console.log(x.toString()); // '10' 2.6. encodeURI / decodeURIencodeURI 함수는 paremeter로 전달된 URI(Uniform Resource Identifier)를 인코딩한다. URI (Uniform Resource Identifier)인터넷에 있는 자원을 나타내는 유일한 주소. URI의 하위 개념으로 URL, URN이 있다. Scheme(protocol) : 통신 방식 Host : 찾아갈 server의 주소 localhost : 컴퓨터 한 대에서 client와 server를 동시에 돌릴 때 server를 의미. Port 번호로 server에 고유 번호를 매김 Port : port 번호 Path : file 경로 REST API : 서버와 통신시 메소드 호출방식처럼 사용 Query Parameter : ?key=value&amp;key=value&amp;key=value Fragment : # page 내 이동에서 씀 인코딩이랑 URI의 문자들을 Escape 처리 하는 것을 의미한다. Escape 처리는 네트워크를 통해 정보를 공유할 때 ASCII Character-set으로 변환하는 것이다. 한글은 %EC%9E%90 등과 같이 인코딩 된다. decodeURI 함수는 paremeter로 전달된 encoded URI을 전달받아 escape 처리 되기 전으로 디코딩한다.","link":"/2019/05/15/19-Global-Object/"},{"title":"190722-TIL","text":"Today I Learned오전 학교에서 유니티를 활용한 VR 콘텐츠 교육을 7월 22일부터 7월 25일까지 수강한다. AR/VR Virtual Reality (VR) 현실 세계가 전혀 없는 완전 가상 환경 현실을 차단할 수 있는 장치 필요 (HMD : Head Mounted Display) + Controller Augmented Reality (AR) 증강현실 현실 + 가상 환경 (현실 &gt; 가상) 포켓몬고나 스냅챕 필터 등 Mixed Reality (MR) 현실과 가상이 합쳐져 둘을 구분하기 어려움 HMD(Head Mouted Display) FOV (Field of View): 시야각, 보통 인간은 120도 봄 Refresh Rate : frame 수 같은.. 필요 Skill Set Unity C# Android Vuforia","link":"/2019/07/22/190722-TIL/"},{"title":"190411-TIL","text":"Today I Learned오늘 한 일 Web Cafe의 새소식 영역을 &lt;section&gt;과 &lt;article&gt;을 이용해 Markup 했다. [Web Cafe 새소식 영역] [Markup Design] 123456789101112131415161718&lt;!-- news section HTML Code --&gt;&lt;section class=\"news\"&gt; &lt;h2 class=\"news-heading\"&gt;새소식&lt;/h2&gt; &lt;article class=\"news-item\"&gt; &lt;a href=\"#\"&gt; &lt;h3 class=\"news-item-subject\"&gt;W3C 사이트가 리뉴얼 되었습니다.&lt;/h3&gt; &lt;time class=\"news-item-date\" datetime=\"2019-04-11T11:19:37\"&gt;2019.04.11&lt;/time&gt; &lt;p class=\"news-item-brief\"&gt; 디자인 및 다양한 view 환경을 고려하여 구성되어 있으며, 기존보다 최신 정보 및 개발자를 위한 기술 가이드도 찾기 쉽도록 구성되어 있습니다. &lt;/p&gt; &lt;figure class=\"news-item-thumbnail\"&gt; &lt;img src=\"images/news.gif\" alt=\"\"&gt; &lt;figcaption&gt;W3C 리뉴얼&lt;/figcaption&gt; &lt;/figure&gt; &lt;/a&gt; &lt;/article&gt; &lt;a href=\"#\" class=\"news-more icon-plus\" target=\"_blank\"&gt;더보기&lt;/a&gt;&lt;/section&gt; : 처음으로 &lt;article&gt;과 &lt;figure&gt; tag를 써봤다. &lt;section&gt; 내에 &lt;article&gt;을 nesting하는 것은 신문의 스포츠 섹션에 단일 기사를 싣는 것과 같다는 글을 읽어 이해가 쉬웠다. Semantic HTML을 접하고 처음 &lt;div&gt; 범벅이던 코드를 만났을 때보다 훨씬 이해가 쉽고 직관적으로 구조를 짤 수 있게 된 기분이 든다. HTML5부터 inline인 &lt;a&gt; 안에 block 요소등을 넣을 수 있게 됐다. 그러나 focus를 받을 때 다음과 같은 문제가 생길 수 있다. '2019.04.11'이 inline인 time tag라서 그 부분이 들어간 모습 이는 &lt;a&gt;의 display를 block으로 바꿔주면 해결할 수 있다. Image Replacing and Sprite 웹 기초 수업 때 instagram 등 Social Media의 로고로 실습을 했던 Image Sprite 기법을 다시 한 번 적용해 Web Cafe 예제를 진행했다. [신규 이벤트 & 관련 사이트 영역] [신규 이벤트 & 관련 사이트 Design] Image Replacement: image가 들어갈 영역의 크기를 지정해놓고, 해당 높이나 너비만큼 padding을 주고 overflow: hidden 처리를 한 후 image를 sprite로 처리한다. Image Sprite: server가 제공하는 image 최소화하기위해 한 image만 준비하고 background 위치 조정해서 보여주는 것 : 단점으로 &lt;button&gt;에 focus시 outline이 안 보이는 문제가 있었는데, ARIA를 사용해 role을 주고 button의 textnode를 삭제해 해결했다. 123456789101112131415161718.btn-event{ position: absolute; top: 0; right: 0; height: 18px; padding: 2px;}.btn-event-prev, .btn-event-next { width: 19px; height: 18px; padding: 0; border: none; background-image: url(images/back_forward.png); background-position: 0 0;}.btn-event-next{ background-position: 100% 0;} 하루를 마무리 하며오늘 Semantic HTML과 tag의 효율성 등을 알아보다가 좋은 사이트를 알게 되었다. 많은 도움이 될 것으로 보여 기분이 좋다. 밑에 첨부한다. HEXO 테마를 바꾸고 싶은데 마땅히 마음에 드는 게 없어 만들어볼까 생각중이다. 이번 주말을 활용해 알아봐야겠다. 😊 INTERNETING IS HARD 😊","link":"/2019/04/11/190411-TIL/"},{"title":"25. Enhanced Object property","text":"ES6에서 객체 리터럴 프로퍼티 기능이 확장되었다. 1. Object Property Value ShorthandES5에서는 프로퍼티 값으로 변수를 할당하더라도 프로퍼티 키와 값을 써주어야 한다. 12345678910var x = 1;var y = 2;var obj = { x: x, y: y};console.log(obj); // {x: 1, y: 2}obj.x === obj['x']; // true ES6에서는 프로퍼티 값으로 변수를 사용하는 경우에는 프로퍼티 키를 생략할 수 있다. (Property Shorthand) 프로퍼티 키는 변수의 이름으로 자동 생성된다. 1234567let x = 1;let y = 2;const obj = { x, y };console.log(obj); // {x: 1, y: 2}obj.x === obj['x'] // true 2. Dynamic Property KeysES5에서는 변수를 사용해서 프로퍼티 키를 생성하기 위해서는 두 단계를 거쳐야했지만 ES6에서는 프로퍼티 키를 동적으로 생성할 수 있다. 123456// ES5var pass = 'pw'var obj = { id: 1};obj[pass] = '1234'; 123456// ES6const pass = 'pw'const obj = { id: 1, [pass]: '1234'}; 3. Object Method ShorthandES5와 다르게 ES6에서는 메소드를 선언할 때 function 키워드를 생략하고 메소드 축약 표현을 사용할 수 있다. 123456789// ES6const obj = { name: 'Park', getName() { console.log(this.name); }};obj.getName(); // Park ES6의 화살표 함수(Arrow Function)와 메소드 축약 표현으로 생성된 함수는 constructor를 가지지 않는 non-constructor이다. 4. Inheritance by _proto_ PropertyES5에서 어떤 객체를 상속받기 위해서는 Object.create() 함수를 사용한다. Object.create의 argument로 전달하는 객체를 생성되는 객체의 프로토타입으로 지정하는 것이다. 이를 프로토타입 패턴 상속이라고 한다. ES6에서는 객체 리터럴 내부에서 _proto_ 프로퍼티를 직접 바인딩해서 상속을 표현할 수 있다. 1234567891011121314const parent = { name: 'parent', getName() { console.log(this.name); }}const child = { __proto__: parent, name: 'child'};parent.getName(); // parentchild.getName(); // child","link":"/2019/05/21/25-Enhanced-Object-property/"},{"title":"22. Regular Expression","text":"Regular Expression정규 표현식은 문자열에서 특정 내용을 찾거나 바꾸거나 뽑아내는 데에 사용된다. 아이디나 이메일, 비밀번호 등의 유효성 검사에 정규 표현식을 사용할 수 있다. 자주 사용하는 정규 표현식은 간단한 구글 검색으로 찾을 수 있지만, 표현식 구성법에 대해서 우선 정리해볼 것이다. How to make Regular Expression?정규 표현식을 생성하는 가장 간단한 방법은 리터럴 표기법이다. RegExp.prototype.exec, RegExp.prototype.test, String.prototype.match, String.prototype.replace, String.prototype.search, String.prototype.split 등의 메소드에서 정규 표현식을 사용할 수 있다. 1234567891011121314// '/(pattern)/(flag: i, g, m)'const targetStr = 'I like koala.'const regExp = /k/ig; // 정규 표현식// RegExp.prototype methodsconsole.log(regExp.exec(targetStr)); // [\"k\", index: 4, input: \"I like koala.\", groups: undefined]console.log(regExp.test(targetStr)); // true// String.prototype methodsconsole.log(targetStr.match(regExp)); // (2) [\"k\", \"k\"]console.log(targetStr.replace(regExp, 'K')); // I liKe Koala.console.log(targetStr.search(regExp)); // 4console.log(targetStr.splitgExp)); // (3) [\"I li\", \"e \", \"oala.\"] 1.1. Flag정규 표현식의 플래그에는 다음과 같은 종류가 있다. i Ignore Case 대소문자를 구별하지 않고 검색 g Globl 문자열 내의 모든 패턴을 검색 m Multi Line 문자열의 행이 바뀌더라도 계속 검색 플래그는 옵션으로, 플래그를 사용하지 않으면 첫번째 매칭된 대상만 검색하고 끝낸다. 1.2. Pattern정규 표현식의 패턴으로 검색할 문자열을 지정한다. 패턴은 특별한 의미를 가진 Meta Character 또는 기호로 표현할 수 있다. . : 임의의 문자 한 개 [A-Z] : A ~ Z가 한 번 이상 반복되는 문자열. [] 안에 - 쓰면 범위 지정 * / + * : 0개 이상 반복되는 패턴 + : 1개 이상 반복되는 패턴 [] : [] 내의 문자는 or로 동작 {2, 3} : 2 ~ 3 자리 \\d, \\D \\d : 숫자 \\D : 숫자가 아닌 문자 \\w, \\W \\w : 알파벳과 숫자 \\W : 알파벳과 숫자가 아닌 문자 \\s 여러가지 공백 문자 (space, tab 등) [\\t\\r\\n\\v\\f] ^ [^]는 not [] 밖의 ^는 문자열의 처음을 의미 $ 문자열의 끝을 의미 1.3. Well Used Reguler Expression특정 단어로 시작하는지 검사 12// 문자열이 'http'로 시작하는지 검사const regexr = /^http/; 특정 단어로 끝나는지 검사 12// 문자열이 'html'로 끝나는지 검사const regexr = /html$/; 아이디 유효성 검사 123// 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~10자리인지 검사// {4,10}: 4 ~ 10자리const regexr = /^[A-Za-z0-9]{4,10}$/; 메일 주소 유효성 검사 1const regexr = /^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]{2,3}$/; 핸드폰 번호 유효성 검사 1const regexr = /^\\d{3}-\\d{3,4}-\\d{4}$/; 특수 문자 포함 여부 검사 12345// A-Za-z0-9 이외의 문자가 있는지 검사let regexr = /[^A-Za-z0-9]/gi;// 아래 방식도 동작한다. 이 방식의 장점은 특수 문자를 선택적으로 검사할 수 있다.regexr = /[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\'\\\"]/gi;","link":"/2019/05/19/22-Regular-Expression/"},{"title":"190410-TIL","text":"Today I Learned오늘 한 일 🌷 LINEpluscorp 마크업을 다시 한 html에 header CSS 를 입혔다. 언어선택창에 Tab, Click event를 적용했다. 1234567891011&lt;div class=\"language\"&gt; &lt;button class=\"btn-language\"&gt;한국어&lt;/button&gt; &lt;ul class=\"language-list\"&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;English&lt;/a&gt;&lt;/li&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;日本語&lt;/a&gt;&lt;/li&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;한국어&lt;/a&gt;&lt;/li&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;中文(繁體)&lt;/a&gt;&lt;/li&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;中文(简体)&lt;/a&gt;&lt;/li&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;ภาษาไทย&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031var buttonLang = $('.btn-language');var listLang = $('.language-list'); // language button click eventbuttonLang.on('click keyup', function(e){ if(e.keyCode === 9){ listLang.parent().addClass('language-act'); } else{ // tab 아니고 click 됐을 떄 listLang.parent().toggleClass('language-act'); }});// event capturing &amp; bubbling// div.language 외의 영역 click시 닫기document.addEventListener(\"click\", function(e) { console.log(e); if (!e.path.includes(document.querySelector(\".language\"))) { listLang.parent().removeClass('language-act'); }});// div.language 외의 영역에 tab key 눌리면 닫기document.addEventListener(\"keyup\", function(e){ if(e.keyCode === 9){ if (!e.path.includes(document.querySelector(\".language\"))) { listLang.parent().removeClass('language-act'); } }}); Header에 mouseenter, mouseleave event를 적용했다.flex를 쓰지 않고 해보고 싶었는데 결국 flex를 적용한 채 오늘은 마무리했다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;nav class=\"navigation\"&gt; &lt;ul class=\"menu\"&gt; &lt;li class=\"menu-item menu-item1 menu-act\"&gt; &lt;a href=\"#\"&gt;회사소개&lt;/a&gt; &lt;ul class=\"sub-menu submenu1\"&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;회사소개&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt; &lt;a href=\"#\"&gt;LINE's Mission&lt;/a&gt; &lt;ul class=\"mission-menu\"&gt; &lt;li class=\"mission-menu-item\"&gt;&lt;a href=\"#\"&gt;MISSION&lt;/a&gt;&lt;/li&gt; &lt;li class=\"mission-menu-item\"&gt;&lt;a href=\"#\"&gt;LINE STYLE&lt;/a&gt;&lt;/li&gt; &lt;li class=\"mission-menu-item\"&gt;&lt;a href=\"#\"&gt;LINE CODE&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;LINE그룹 행동 규범&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;LINE 로고 사용 가이드&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;a href=\"#\"&gt;사업&lt;/a&gt; &lt;ul class=\"sub-menu submenu2\"&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;서비스&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;서비스사업&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;a href=\"#\"&gt;홍보&lt;/a&gt; &lt;ul class=\"sub-menu submenu3\"&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;Global News&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;기사 및 보도자료&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;Blog &amp; SNS&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;a href=\"#\"&gt;채용&lt;/a&gt; &lt;ul class=\"sub-menu submenu4\"&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;일과 사람&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;채용공고&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"sitemap\"&gt; &lt;a href=\"#\"&gt;SITEMAP&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 12345678910var menuItem = $('.menu-item');menuItem.on('mouseenter', function(){ menuItem.removeClass('menu-act'); $(this).addClass('menu-act');});menuItem.on('mouseleave', function(){ $(this).removeClass('menu-act');}); 새로 배운 것 Event Capturing과 Bubbling으로 문제를 해결했다. 원리는 꼭 정리해놔야겠다! 한 기능을 구현하면 다른 기능이 문제가 생긴다. 아직 HTML과 CSS에 대한 이해가 부족한 것 같다. 🌷 More semantic LINE git","link":"/2019/04/10/190410-TIL/"},{"title":"23. Array","text":"자바스크립트에서는 배열(Array)도 객체이다. 배열은 Array 생성자로 생성된 Array type의 객체이며 프로토타입 객체로 Array.prototype을 가진다. 1. Creation of Array1.1. Array LiteralArray literal은 0개 이상의 값을 쉼표(,)로 구분하여 대괄호([])로 묶는다. 배열은 index를 가지며, 첫번째 값은 index 0으로 읽을 수 있다. 존재하지 않는 index로 접근하면 undefined를 리턴한다. 배열은 순회할 수 있으므로 길이를 나타내는 length 프로퍼티를 가진다. 1234const arr = [];console.log(arr[1]); // undefinedconsole.log(arr.length); // 0 객체가 프로퍼티의 키와 값을 가지고 프로퍼티 키로 값에 접근하는 반면 배열은 요소의 index로 요소의 값에 접근할 수 있다. Index는 0부터 시작한다. 다른 프로그래밍 언어와 다르게 자바스크립트의 배열은 서로 다른 데이터 타입의 원소들을 함께 포함할 수 있다. 1.2. Array() Constructor Function배열은 보통 배열 리터럴 방식으로 생성하지만 Array 생성자 함수를 사용해서 생성할 수도 있다.","link":"/2019/05/19/23-Array/"},{"title":"2. What is JavaScript?","text":"1. Creation of JavaScriptIn 1995, the Netscape Communications decided to introduce a lightweight programming language to dynamically express static HTML. So JavaScript developed by Brendan Eich. JavaScript was mounted on Netscape Navigator 2 which is web browser of Netscape Communications, named “Mocha” in March, 1996. In September, renamed to “LiveScript” and finally named as “JavaScript” in December. So JavaScript is now the standard programming language for all browsers. But JavaScript has not grown smoothly 2. Fragmentation and Standardization of JavaScriptIn August 1996, Microsoft added a derived version of JavaScript, “JScript”, to Internet Explorer 3.0. But the problem is that JScript and JavaScript are not standardized and are moderately compatible. In other words, they have competitively begun adding features that only work with their browsers to gain market share in their browsers. This has led to cross-browsing issues where webpages are not working properly, and it has become extremely difficult to develop webpages that work across all browsers. Thus, the need for stadard of JavaScript which works same in all browser has begun to be raised. For this, Netscape Communications requested standardization of JavaScript to ECMA International in November 1996. Version Release Specification ES1 1997 First version ES2 1998 Application of the same standards as ISO/IEC 16262 international standards ES3 1999 Regular Expression, try … catch Exception ES5 2009 Standard released with HTML5. JSON, strict mode, accessor property(getter, setter), improved array manipulation (forEach, map, filter, reduce, some, every) ES6 (ECMAScript 2015) 2015 let, const, class, arrow function expression(=&gt;), template literal, destructuring assignment, spread operator, rest parameter, Symbol, Promise, Map/Set, iterator/generator, module import/export ES7 (ECMAScript 2016) 2016 Exponential operator(**), Array.prototype.includes, String.prototype.includes ES8 (ECMAScript 2017) 2017 async/await, Object static method(Object.values, Object.getOwnPropertyDescriptors) ES9 (ECMAScript 2018) 2018 Object Rest/Spread Property 3. History of JavaScriptEarly JavaScript was used for limited purposes to perform the supplementary functions of webpages. During this time, most logics were run primarily on Web servers and browsers were simply rendering HTML and CSS delivered from the server. Rendering?Rendering refers to interpreting data expressed in HTML and CSS and expressing it visually on a browser. In 1999, Ajax(Asynchronous JavaScript and XML), a communication function that allows server and browser to exchange data asynchronously using JavaScript, has emerger under the name of XMLHttpRequest. Previous webpages worked by receiving complete HTML from the server and rendering the entire web page. So when screen switches, it received a new HTML file from server and started rendering a whole web page again from beginning. This is a disadvantageous way because unnecessary data communication occurs when receive HTML including unchanged parts from a server and browser should be rendering that whole HTML again including unchanged parts. This causes the screen to flash momentarily when a screen transition occurs, which has been accepted as the limit for web applications. The advent of Ajax changed the previous paradigm. In other words, it make possible to do not rendering again the parts unnecessary to change and rendering only the part need to change by receiving only a necessary data from server. This enables fast performance and smooth screen transitions similar to desktop applications in web browsers. In 2005, Google Maps, which operates on JavaScript and Ajax in a web browser, has shown performance and smooth screen transitions that are comparable to desktop applications. In 2006, the advent of jQuery made it easier to control the rather cumbersome DOM(Document Object Model) and resolved cross-browsing issues to some extent. jQuery quickly secured a large user base. This resulted in the mass production of developers who preferred jQuery, which was easier to learn and more intuitive than JavaScript. In 2008, V8 JavaScript Engine from google made more fast performance in web browser. With the advent of the V8 JavaScript engine, JavaScript has become a web application development programming language that can provide a user experience(UX) similar to that of desktop applications. In 2009, the Node.js that enable operate JavaScript in an environment other than a browser emerged. JavaScript is now a standard for web programming languages that cover not only front-end but also back-end areas. 4. JavaScript and ECMAScriptECMAScriptECMAScript refers ECMA-262, which standard specification of JavaScript and defines core syntax such as the type, value, objace and property, function, built-in object, etc. Each JavaScriptJavaScript is typically a programming language that encompasses ECMAScript as a core and client side Web API, which is supported separately by the browser. Web APIDOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker, etc. Apart from ECMAScript, the client side Web API is managed as a separate specification by the World Wide Web Consortium (W3C). 5. Characteristics of JavaScriptJavaScript is one of the components that compose the web with HTML and CSS, and is the only programming language that works with a web browser. It use basic syntax from C, prototype-based inheritance from Self, first-class function from Scheme. JavaScript is interpreter language that developer not have to do compile work. Almost modern JavaScript engines(V8 by Chrome, Spidermonkey by FireFox, JavaScriptCore by Safari, Chakra by Microsoft Edge) combined advantage of interpreter and compiler to resole disadvantage of slow interpreter. Actually JavaScript complie but not make executable file. So JavaScript is interpreter lanuage. JavaScript is a multi-paradigm programming language that supports imprerative, functional, and prototype-based object-oriented programming. Reference 자바스크립트란?","link":"/2019/04/29/2-What-is-JavaScript/"},{"title":"28. Module","text":"원래 모듈화를 하거나 파일을 분리하면 각 모듈, 파일 별로 개별적인 스코프를 가져야하는데 자바스크립트는 파일을 분리해서 함께 사용할 때 하나의 전역 스코프만을 가진다. 즉, 여러 개의 js 파일에서 식별자 명이 겹칠 경우 의도한 바와 다르게 동작할 수 있다. 이전에는 각 파일을 IIFE(Imediately Invoked Function Expression)로 감쌌으나 근본적인 해결책은 아니다. 특정 클래스나 함수를 외부에 노출시키고 싶지 않을 때는 클로저를 사용해서 선택적으로 노출했다. ES6에서 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능이 추가되었다. script tag에 type=&quot;module&quot; 어트리뷰트 추가시 해당 자바스크립트 파일은 모듈로 동작하며 파일 스코프를 가진다. 모듈화된 자바스크립트 파일을 사용할 때는 확장자 명을 .mjs라고 한다. 그러나 아직까지 문법이 엄격하고 구형 브라우저(IE 등)에서는 ES6 모듈을 지원하지 않는 문제가 있다. 그러니까 아직은 바벨 / 웹팩 등을 사용해서 개발해야한다. 바벨: ES6 이상의 문법을 사용해서 코딩하더라도 ES5의 문법으로 다운그레이드해서 구형 브라우저에서 돌아갈 수 있게 함 웹팩: 여러 파일을 import하면 하나의 파일로 압축해줌 1. File Scope12// lib.jsvar x = 10; 12// app.jsconsole.log(x); 모듈을 사용하지 않을 경우 정상적으로 코드가 돌아가지만 type=&quot;module&quot; 사용시 각 파일마다 스코프가 분리되어 app.js에서 lib.js의 x에 접근할 수 없다. 1234567891011121314&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"module\" src=\"./lib.js\"&gt;&lt;/script&gt; &lt;script type=\"module\" src=\"./app.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. export KeywordES6의 모듈을 쓰면 각각 파일이 파일 스코프를 가지기 때문에 다른 파일에 공개할 변수나 함수, 클래스 앞에 export 키워드를 붙여서 선택적으로 노출할 수 있다. 12// lib.jsexport let x = 10; 3. import Keyword다른 파일에서 export 키워드로 노출한 변수, 함수, 클래스 등을 import 키워드를 사용함으로써 사용할 수 있다. 123// app.jsimport { x } from './lib.js';console.log(x); 모듈에서 하나만 export할 때는 default 키워드를 사용할 수 있음 12345// lib.jsfunction (x) { return x;}export default; default 키워드로 export한 모듈은 import할 때 {} 없이 받아올 수 있다. 12// app.jsimport y from './lib.js';","link":"/2019/05/22/28-Module/"},{"title":"26. Destructuring","text":"Destructuring구조화된 배열 / 객체를 풀어서(destructure) 개별적인 변수에 할당하는 것. 배열 / 객체 리터럴에서 필요한 값을 추출해서 변수에 할당하거나 리턴할 때 유용 1. Array DestructuringES6의 배열 디스트럭처링은 배열의 각 요소를 배열에서 추출해 변수 리스트에 할당한다. 배열 인덱스를 기준으로 추출, 할당한다. 이 때 할당 연산자(=)의 왼 쪽에 배열 형태의 변수 리스트가 와야한다. 12345678// ES6const arr = [1, 2, 3];const [one, two, three] = arr;// const [one, two, three] = [1, 2, 3];console.log(one, two, three); // 1 2 3 배열의 인덱스를 기준으로 오른쪽의 배열에서 왼쪽의 변수 리스트로 할당된다. 그러므로 변수의 순서가 중요하다. 1234567891011121314let x, y, z;[x, y] = [1, 2]; console.log([x, y]); // [1, 2][x, y] = [1, 2, 3]; console.log([x, y]); // [1, 2][x, y] = [1]; console.log([x, y]); // [1, undefined]// default 설정[x, y = 3, z = 4] = [1];console.log([x, y, z]); // [1, 3, 4] 2. Object DestructuringES6의 객체 디스트럭처링은 객체의 각 프로퍼티를 객체로부터 추출해서 변수 리스트에 할당한다. 할당 기준은 프로퍼티 키이다. 할당 연산자 왼쪽에는 객체 형태의 변수 리스트가 필요하다. 123456// ES6 Destructuringconst obj = { firstName: 'Subin', lastName: 'Park' };const {firstName, lastName } = obj;console.log(firstName, lastName); // Subin Park 객체 destructing의 경우 할당 기준이 프로퍼티 키이므로 프로퍼티 키를 명시해주지 않으려면 변수명과 프로퍼티 키가 같아야 한다. 순서는 상관 없다. 12345678const { prop1: p1, prop2: p2 } = { prop1: 'a', prop2: 'b' };// 변수명을 prop1, prop2가 아닌 p1, p2로 하기 위해서 pro1: p1 등으로 구분해줌console.log(p1, p2); // a, bconsole.log({ prop1: p1, prop2: p2 }); // { prop1: 'a', prop2: 'b' }// Shorthand(변수명을 프로퍼티 명과 같게 함) &amp; default 설정const { prop1, prop2, prop3 = 'c' } = { prop1: 'a', prop2: 'b' };console.log({ prop1, prop2, prop3 }); // {prop1: \"a\", prop2: \"b\", prop3: \"c\"} 객체 디스트럭처링으로 객체에서 필요한 프로퍼티 키의 값만을 추출해낼 수 있다. 12345678const parts = [ { id: 1, department: 'Human Resource', checked: false }, { id: 2, department: 'Development', checked: true }, { id: 3, department: 'Management', checked: false } ];// parts 배열의 객체 element 중에서 checked 프로퍼티의 값만을 checked라는 이름의 변수(parameter)로 받는다.const checkedParts = parts.filter(({checked}) =&gt; checked);console.log(checkedParts); // { id: 2, department: 'Development', checked: true } 위의 예제에서 filter 함수의 callback은 argument 로 parts의 객체 element를 하나씩 받는다. parameter에 {checked} 를 정의했다는 것은 내부적으로 1{ checked } = { id: 1, department: 'Human Resource', checked: false }; 가 실행되는 것과 같다. callback 함수 내에서는 checked라는 parameter 변수에 객체 element의 checked 프로퍼티의 값이 할당되어있다. 따라서 filter 실행시배열의 element 중 checked 프로퍼티의 값을 할당한 변수 checked 가 true인 객체 element만 필터링된다. 1234567891011const student = { name: 'Park', address: { zipCode: '12345', city: 'NewYork' }};const { address: { city } } = student;// 왼 쪽의 city 변수에 student 객체의 address 프로퍼티의 값 객체의 city 프로퍼티의 값 'NeyWork'이 할당됨 (프로퍼티 추출)console.log(city); // 'NewYork'","link":"/2019/05/21/26-Destructuring/"},{"title":"32. REST API","text":"REST(Representational State Transfer) APIopen API를 이용하기 위해서 문서를 찾아다닐 때 가장 많이 본 단어가 RESTful API이다. REST는 웹의 장점을 최대한 활용할 수 있는 architecture로 처음 소개되었으며 HTTP 프로토콜을 의도에 맞게 디자인하도록 유도하는 방법론이다. REST의 기본 원칙에 충실한 서비스 디자인을 RESTful이라고 한다. 1. REST API 중심 규칙1) URI는 정보의 자원을 표현해야 한다.리소스명으로 동사보다는 명사를 사용 URI는 자원을 표현하는 데 중점 두어야 함 2) 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)로 표현한다.12345# badGET /books/delete/1# goodDELETE /books/1 2. HTTP Method주로 5자리 Method를 사용해서 CRUD (Create, Read, Update, Delete) 구현 Method Action 역할 GET index/retireve 모든/특정 리소스 조회 POST create 리소스 생성 PUT update all 모든 리소스 갱신 PATCH update 리소스 갱신 DELETE delete 리소스 삭제 3. Configuring the REST APIREST의 3요소 구성 요소 내용 표현 방법 Resource Resource HTTP URI Verb Actions on Resources HTTP Method Representations Details of actions on resources HTTP Message Pay Load REST는 Self-descriptiveness(자체 표현 구조)로 구성되어 REST API만으로 Request를 이해할 수 있다.","link":"/2019/05/27/32-REST-API/"},{"title":"4 Fundamental of Object Oriented Programming","text":"추상화 | Abstraction ? 추상화란, 복잡한 로직을 가지고 있는 기능에서 그것을 다루기 위해 필요한 최소한의 핵심만을 추출해내는 것을 말한다. 정의만 들으면 어렵다. TV 전원을 예로 들어 생각해보자. 새로 산 TV의 설명서를 보면 TV를 켜려면 전원 버튼을 누르라고 되어있다. 사용자는 전원 버튼을 누르면 쉽게 TV를 켤 수 있다. 그러나 실제로 TV의 전원 버튼을 누르는 순간 내부 전기회로에서는 복잡한 기능이 실행될 것이다. 사용자는 그것을 알 수 없고, 알 필요도 없다. TV 제작 회사에서 TV에 대한 추상화를 시켜 사용자가 쉽게 TV를 동작시킬 수 있도록 한 것이다. 함수를 보통 function, routine, procedure 라고 부른다. 이 때, procedure 단위로 추상화를 하고 procdural하게 진행하는 프로그램을 절차 지향 프로그램이라고 한다. 그러나 프로그램이 거대해지고, 코드가 길어지자 프로그램을 객체(object)로 추상화하는 방법론이 나왔고 그걸 적용한 게 객체 지향 프로그램이다. 절차 지향 Procedural Programming : procedure 단위 추상화객체 지향 Object Oriented Programming : Object 단위 추상화Function Abstraction Function Signature (Interface) : function name, parameter, return calue Implementation : operations 함수의 명세(Function Signature)와 내부구현(Implementation)을 분리하는 것 4 Fundamental of Object Oriented ProgrammingEncapsulationEncapsulation은 모든 object가 그 state(private variables)를 class내부에 private으로 보유하고 있을 때 지켜진다. 다른 object들은 그 state에 직접 접근할 필요 없이, 해당 object의 public object(method)를 호출한다. 결과적으로 object는 자신의 state를 method를 통해 관리한다. Abstraction추상화는 encapsulation을 자연스럽게 확장한 것으로 볼 수 있다.추상화를 적용한다는 것은, 각 object를 사용할 때 오직 high-level machanism만을 공개해야한다는 것이다. 이 mechanism은 내부 implementation을 숨기고, 오직 관련된 객체의 operation으로만 접근할 수 있다. 즉, 사용자는 class의 method가 어떻게 작동하는지 알 필요 없이 제공된 interface(method name, parameter, return value)만 알고 사용할 수 있다. Inheritance대부분의 object는 비슷하고 공통된 logic을 공유한다. 상속을 통해 중복되는 코드를 최대한 방지하는 것이 inheritance의 핵심이다. Parent class로부터 child class를 만들 수 있으며, child class는 parent class의 모든 영역을 재사용할 수 있는 특권을 가진다. Parent class의 기능에 자신만의 method를 추가하거나 재정의(override)할 수 있다. Polymorphism | One Interface and Multiple Implementations.다형성. 우리가 parent class와 그로부터 상속받은 여러 child class를 가지고 있을 때, 이 모든 class를 collection처럼 한번에 쓰고 싶을 때가 있을 것이다. Polymorphism은 class를 이렇게 사용할 수 있게 하는 방법 제공한다. Parent class에 interface method를 선언하고(implementation은 하지 않는다!) child class에서 그 method의 implementation을 담당하는 것이다. 상속은 많은 형태의 변화를 가능케 한다. Parent class를 상속하는 child class는 parent class로 정의될 수 있다. (ex. Child C = new Parent(); ) Function OverLoading : 이름은 같지만 signature(parameter 수, data type)는 다른 method를 중복으로 선언하는 것method 이름은 같아야 한다. Parameter 수는 달라야 하며, 같다면 data type이 달라야 한다. Method OverRiding : 부모 클래스의 method 동작 방법을 재정의하여 우선적으로 사용하는 것.override 하고자 하는 method가 상위 클래스에 존재해야 한다. Method 이름이 같아야 하며, parameter 개수, data type, return type 등 모든 signature를 동일하게 사용한다. 달라지는 것은 내부 구현 뿐이다. 부르는 object만 달라질뿐 method 이름을 동일하게 하면 하나의 method로 여러 기능을 실행할 수 있다. 참고 자료 How to explain object-oriented programming concepts to a 6-year-old","link":"/2019/04/24/4-Fundamental-of-Object-Oriented-Programming/"},{"title":"4. Variable","text":"What is variable?Application uses data. And the variable is core concept for managing data. Computer is computing machine. To do simple operation like sum of 1 and 2, computer should memorize these operand 1 and 2 in register. Computer uses memory to memorze the data. MemoryMemory is a collection of memory cells that can store data. Size of one cell is 1byte(8bit) and computer read or wirte data by one cell, 1 byte size. Each memory cell has its own address. That address means location of memory space and can be represented from 0 to memory size. Computer can simply compute 1 + 2, but how to use this result of sum? What you need at this point is the variable. To store data in memory and read to use data from memory, programming language provide variable. Variable refers name of memory space or memory space itself. Simply, variable is mechanism that store and refer data values. Through variable, developer can store, refer and change value wihout access to memory directly. Just, like it. 1var result = 1 + 2; In JavaScript, var means variable. In that code, ‘result’ is a name of the variable and 3 is a value of the variable. Storing value in variable is called assignment and reading data from variable is called reference. The variable name is the name given to the memory space where the value is stored for the person. Declaration of variableVariable name is the name given to memory space. To use a variable, variable must be declared. Use var, let, const keywords to declare variable. Before ES6 introduced let and const keywords, var was the only method to declare variable. KeywordKeyword is kind of command that defines the actions performed by JavaScript engines that execute JavaScript code. When JavaScript engine meets 1var soup; After declaring a variable, the variable never been assigned. Therefore, the memory space allocated by the variable declaration may be considered to be empty, but the allocated memory space is implicitly allocated with the value undefined by the JavaScript engine. This is a unique feature of JavaScript. undefinedundefined is primitive value of JavaScript. JavaScript engine operates declaration of variable by 2 phases. Declaration phase : Register the variable name to tell the JavaScript engine the existence of the variable. Initialization phase : Allocates memory space to store the value and implicitly assigns undefined. Variable declaration using the var keyword proceeds both in the declaration phase and in the initialization phase. var soup; registers the variable name soup through the declaration phase, and initializes it by assigning undefined to the variable score through the initialization step. In general, initialization refers to assigning a value first after a variable is declared. JavaScript automatically do implicit initialization to undefined. Therefore, even if you declare a variable and do not assign any value, the variable has a value of undefined. If you do not go through the initialization phase, the reserved memory space may still contain values that were previously used by other applications. These values are called garbage values. Therefore, garbage value can be obtained by referring to a variable value immediately after allocating memory space and not allocating a value. Declarations are required to use variables. Not just variables, but all identifiers (functions, classes, etc.). If you access the identifier without declaration, a ReferenceError is raised. ReferenceError is a error that occurs when the JavaScript engine tries to reference a value through an identifier but can not find the registered identifier. Variable Declaration run time and Hoisting123console.log(soup);var soup; In C, the avobe code will occur compile error because it access to the variable before its declaration. But in JavaScript print undefined instead of ReferenceError. Variable declaration is processed before the run-time that source code execute in line step. In other words, JavaScript engine estimate entire source code in advance. At this time, it finds all of declaration(variable declaration, function declaration), declare and initialize identifiers. After that run source codes sequentially except declarations. What is Hoisting?Hoist means to lift something. It is a variable that is hoisted in JavaScript. Hoist means that the definition of a variable is separated into declarations and allocations according to its scope.Declarations execute before other codes so it seems like declarations are hoisted to top of the source code. In JavaScript, all of variable declarations are hoisted. Warning Function hoisting hoists function declarations too, but not hoist the value of variables. So think separate declarations and assignment is important. It’s relevant with run-time and parsing-time. 1234567891011foo();function foo(){ console.log('ok');};// Okfoo();var foo = function foo(){ console.log('ok');};// Syntax error! Assignment of Values1234var soup; // Variable Declarationsoup = 3; // Assignment valuevar soup = 3; // Variable declaration and assigment Variable declaration is executed at parsing-time and assignment is executed in run-time, affter the parsing-time. Of course when declare variable, it is initialized to undefined. 12345console.log(soup); // undefinedvar soup = 3; // Variable declaration and assigmentconsole.log(soup); // 3 So soup is re-initialized to 3. Reassignment of Value12var soup = 3; // Declaration and Assignmentsoup = 5; // Reassignment Variable that declared by var keyword can be reassigned. Reassignment is that variable discards the current value and store new value. Reassignment changes old value to new value. If the reassignment is not possible, it is called a constant not a variable. A constant is a value that does not change once set. In other words, constants are variables that can be assigned only once. const keywordIntroduced from ES6, variable that declared by const is prohibited reassignment. But const keyword does not only used for constant. Identifier Naming ConventionAn identifier is a unique name that can identify any data. The identifier shall conform to the following naming conventions. Identifiers can include letters, numbers, underscore ( _ ), and dollar sign ($), except for special characters. However, identifiers must begin with a letter, underscore ( _ ), or dollar sign ($), except for special characters. It is not allowed to start with a number. Reserved words can not be used as identifiers. Since the variable name is an identifier, the above naming rules must be followed. There are 4 naming conventions that are often used to distinguish words at a time when naming identifiers composed of one or more English words. 123456789101112// camelCasevar firstName;// snake_casevar first_name;// PascalCasevar FirstName;// typeHungarianCasevar strFirstName; // type + identifiervar $elem = $('.myClass'); // jQuery Any naming convention may be used if it is consistent. The most common is to use a camel case for the name of a variable or function and a Pascal case for the name of a constructor function or class. In order to improve the readability of the entire code, it is advantageous to follow the above naming convention. Reference Data type &amp; Variable","link":"/2019/04/30/4-Variable/"},{"title":"3. JavaScript Develop Environment and Execute","text":"Before this chapter, What is Web API?While the most common scripting language ECMAscript (more widely known as JavaScript) is developed by Ecma, a great many of the APIs made available in browsers have been defined at W3C. What is scripting?A script is program code that doesn’t need pre-processing(e.g. compiling) before being run. In the context of Web browser, scripting usually refers to program code written in JavaScript that is executed by browser when a page is downloaded, or in response to an event triggered by the user. Scripting can make Web pages more dynamic.For Example, without reloading a new version of a page it may allow modifications to the content of that page : DHTML(Dynamic HTML) allow content to be added to or sent from that page : AJAX(Asyncronous JavaScript and XML) What scripting interfaces are available ?The most basic scripting interface developed by W3C is the DOM, the Document Object Model which allows programs and scripts to dynamically access and update the content, structure and stype of documents. DOM specifications form the core of DHTML. Modifications of the content using the DOM by the user and by scripts trigger events that developers can make use of to build rich user interface. A number of more advanced interfaces are being standardized, for instance: XMLHttpRequest makes it possible to load additional content from the Web without loading a new document, a core component of AJAX, the Geolocation API makes the user’s current location available to browser-based applications, several APIs make the integration of Web applications with the local file system and storage seamless. Execution Environment of JavaScriptAll browsers have JavaScript engine that can inpterpreter and execute JavaScript. Not only browser but also Node.js has JavaScript engine. So JavaScript can operate in both browser and Node.js environment. Basically code that operate in browser also operate in Node.js environment too. But the browser and Node.js have different purpose. The main purpose of browser is execute HTML, CSS, JavaScript to rendering web page on screen, but the other one is provide server development envorinment. So both of browser and Node.js can operate ECMAScript(core of JavaScript) but additional features provided by Node.js and browser and ECMAScript are incompatible. Node.js environment ES + Node.js API (file control) Browser Rendering HTML, CSS JavaScript : ES + Web API (created by browser vendors and managed by W3C) (DOM API, event) only browser can execute As such, the browser supports ECMAScript and client side Web APIs such as DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, and Web worker. Node.js does not support client side Web APIs and supports ECMAScript and Node.js-specific APIs. Web BrowserHow does a Web Browser work?Most programming languages run on Operating System, but JavaScript in Web application runs with HTML and CSS in a browser. So efficient JavaScript programming is available when considering Web browser environment. Core function of Web browser is that request the Web page user want and represent the response from server in browser. Web browser receives HTML, CSS, JavaScript, and image files from the server. HTML and CSS files are parsed by the rendering enginde’s HTML parser and CSS parser, converted into DOM tree and CSSOM tree, and combined into a Render Tree. Browser represent Web pages by this Render tree. JavaScript is processed by JavaScript engine, not the Rendering engine. HTML parser stops DOM construction process when meet the script tag, and passes control to the JavaScript engine to execute JavaScript code. Control passed JavaScript engine loads, parses and executes the JavaScript code in script tag or JavaScript file defined in script tag’s src attribute. Interpreter that used in most modern Web browser doesn’t compile like typical compiler language but compiles and executes a part of source code in complex way. Interperter Translates program one statement at a time. It takes less amount of time to analyze the source code but the overall execution time is slower. No intermediate object code is generated, hence are memory efficient. Continues translating the program until the first error is met, in which case it stops. Hence debugging is easy. Programming language like Python, Ruby use interpreters. Compiler Scans the entire program and translates it as a whole into machine code. It takes large amount of time to analyze the source code but the overall execution time is comparatively faster. It takes large amount of time to analyze the source code but the overall execution time is comparatively faster. It generates the error message only after scanning the whole program. Hence debugging is comparatively hard. Programming language like C, C++ use compilers. Source code is composed of simple strings. So interpret string codes to make the AST(Abstrack Syntax Tree) that has syntax and semantics. TokenizingSeparate the source code into tokens, the smallest unit of meaning, by lexical analysis. ParsingSyntactically analysis the set of tokens to create AST. Execute codeCreated AST is converted to byte code or optimized machine code and run by interpreter. If execution of JavaScript is finished, pass control to HTML parser and resume DOM creation from the time when browser stopped. As such, browsers process HTML, CSS, and JavaScript synchronously. This means creation of DOM can be delayed by blocking from script tag. So the position of script tag has important meaning. You should put script code at bottom of HTML file. It prevent error that can be occured when JavaScript touch DOM before DOM creation completed. Node.jsA client side, or simple web application that works on a web browser, can be developed with just a browser. However, as the project grows in size, it is necessary to introduce external libraries such as React and jQuery, or to use several tools such as Babel, Webpack, ESLint, etc. Node.js and npm are required. Node.js and npmNode.js, announced by Ryan Dahl in 2009 is a JavaScript runtime environment built with Chrome V8 JavaScript engine. Simply, Node.js is JavaScript execution environment that enable JavaScript to run in addition to browser. npm(node package manager) is JavaScript package manager. Itself a repository include packaged modules available in Node.js and provide CLI to install and management. Reference JavaScript Web API Hello world","link":"/2019/04/30/3-JavaScript-Develop-Environment-and-Execute/"},{"title":"8. Type Coercion and Short-Circuit Evaluation","text":"What is Type coercion? Explicit coercion / Type casting: developer intentionally converting value types 123var x = 10;var str = x.toString(); Implicit coercion / Type coercion: Type automatically converted by the JavaScript engine regardless of developer intent. 12345var x = 10;var str = x + '';// x = Number 10, str = Sring 10 Does reassignment occur when type coercion occur?No. It only takes a moment to type when evaluating expressions. The developer can use implicit type conversion intentionally. Implicit type coercionThe JavaScript engine performs implicit type coercion when evaluating expressions, taking into account the context of the code. 1234'10' + 2 // '102'5 * '10' // 50!0 // trueif(1) {} // if(true) When an implicit type coercion occurs, it automatically converts the type to one of the primitive types such as string, number, or boolean. Coercion to String type1234567891011121314151617181920212223242526272829// Number type0 + '' // \"0\"-0 + '' // \"0\"1 + '' // \"1\"-1 + '' // \"-1\"NaN + '' // \"NaN\"Infinity + '' // \"Infinity\"-Infinity + '' // \"-Infinity\"// Boolean typetrue + '' // \"true\"false + '' // \"false\"// null typenull + '' // \"null\"// undefined typeundefined + '' // \"undefined\"// Symbol type(Symbol()) + '' // TypeError: Cannot convert a Symbol value to a string// onject type({}) + '' // \"[object Object]\"Math + '' // \"[object Math]\"[] + '' // \"\"[10, 20] + '' // \"10,20\"(function(){}) + '' // \"function(){}\"Array + '' // \"function Array() { [native code] }\" Coercion to Number type123456789101112131415161718192021222324// String type+'' // 0+'0' // 0+'1' // 1+'string' // NaN// Boolean type+true // 1+false // 0// null type+null // 0// undefined type+undefined // NaN// Symbol type+Symbol() // TypeError: Cannot convert a Symbol value to a number// object type+{} // NaN+[] // 0+[10, 20] // NaN+(function(){}) // NaN Coercion to Boolean typeWhen evaluating a non-boolean value with a boolean, there are only 6 values that evaluate to false. Falsy value false undefined null 0, -0 NaN ‘’ (empty string) Truthy value non-falsy values 1234567// The following conditional statements all execute code blocks.if (!false) console.log(false + ' is falsy value');if (!undefined) console.log(undefined + ' is falsy value');if (!null) console.log(null + ' is falsy value');if (!0) console.log(0 + ' is falsy value');if (!NaN) console.log(NaN + ' is falsy value');if (!'') console.log('' + ' is falsy value'); Explicit type coercion Call the wrapper object constructor used to create the Wrapper object without new 12String(1); // '1'Number('1'); // 1 Using the built-in method provided by JavaScript 12(1).toString(); // '1'parseInt('-1'); // -1 Using implicit type coercion 1231 + ''; // '1'+ '-1'; // -1'-1' * 1; // -1 Short-Circuit EvaluationThe logical AND operator &amp;&amp; and the logical OR operator || return the operand that determined the logical evaluation. This is called short-circuit evaluation. Logical OR operator || 1'Cat' || 'Dog' // 'Cat' The logical OR operator || returns true even if only one of the two operands evaluates to true. The OR operator || returns the first operand that determines the result of the logical operation, that is, the string ‘Cat’. Logical AND operator &amp;&amp; 1'Cat' &amp;&amp; 'Dog' // 'Dog' The AND operator &amp;&amp; returns true when both operands evaluate to true. The logical AND operator &amp;&amp; returns the second operand that determined the result of the logical operation, the string ‘Dog’. Short evaluation means that &amp;&amp; and || return the operand that determined the logical evaluation. Used to reduce TypeErrors 123456var elem = null;console.log(elem.value); // TypeError: Cannot read property 'value' of nullconsole.log(elem &amp;&amp; elem.value); // nullif (elem) console.log(elem.value);","link":"/2019/05/04/8-Type-Coercion-and-Short-Circuit-Evaluation/"},{"title":"7. Control Flow Statement","text":"Controls the flow of code that runs sequentially from top to bottom. Control statements make the flow of code difficult to understand, which detracts from readability. Should suppress the use of control statements with using high order functions (map, filter, reduce, forEach) Block Statement / Compound Statement 0 or more statements enclosed in curly braces {} In other languages, a block creates a scope, but JavaScript creates a function-level scope. Therefore, variables created in block are global variables. Block statements (code blocks) are treated as one execution unit. A semicolon (;) is usually appended to the end of the statement, but no semicolon at the end of the block statement. Conditional Statement Determine whether to execute a code block based on the evaluation result of a given conditional expression. Conditional expressionExpression that can be evaluated as boolean value JavaScript provides 2 conditional statements as if..else statements and switch statement if … else Statement12345if (Conditional expression) { // This code block is executed if the conditional expression is true.} else { // This code block is executed if the conditional expression is false.} Most if … else statement can be replaced with the ternary conditional operator discussed in 6. Operators. switch Statement12345678910switch (Expression) { case Expression1: // The statement to be executed if the expression in the switch statement matches expression 1; break; case Expression2: // The statement to be executed if the expression in the switch statement matches expression 2; break; default: // The statement to be executed when there is no case statement with an expression that matches the expression in the switch statement;} If the code can be represented by if…else, the use of the switch should be avoided whenever possible. Evaluates a given conditional expression and moves the execution order to a case statement with an expression that matches the value. Used when there are more cases than if…else statements. If do not use a break statement in a case, all the cases are checked sequentially to the default due to the fall through property of the switch. Loop StatementLoop statement executes the code block repeatedly until the conditional expression is false. for StatementThe for statement executes the code block repeatedly until the conditional expression is determined to be false. 123for (declaration statement or assignment statement; conditional expression; Increase / decrease expression){ // Statements that will be executed when conditional expression return true;} 123for (var i = 0; i &lt; 2; i++) { console.log(i);} while StatementThe while statement repeatedly executes the code block repeatedly if the evaluation result of the given conditional expression is true. 123while (conditional expression){ // Escape condition is needed} do while StatementIt’s the same as while, but once it runs and checks the conditional break StatementThe break statement exits the code block. Actually it escapes the label statement, the for loop (for, for … in, for … of, while, do … while) or the code block of the switch statement. If a break statement is used in addition to the label statement, the loop statement, or the code block of the switch statement, SyntaxError occurs. continue Statement If continue is encountered, the code will stop running and move to the increment or decrement statement of the loop The statements under continue are not executed.","link":"/2019/05/03/7-Control-Flow-Statement/"},{"title":"Angular Basics","text":"AngularAngular는 SPA(Single Page Application) 개발을 위한 Google의 Open source JavaScript Framework. Framework and LibraryLibrary는 관련있는 함수를 모아놓아 개발자가 사용할 수 있는 도구이다. 즉, Library는 개발자에 의해 사용된다. Framework는 클래스와 인터페이스의 집합으로 Application의 Flow를 쥐고 있다. 개발자가 Framework 틀 내부에서 작업하는 것이다. 전통적인 웹 개발에서 JavaScript는 HTML/CSS에 의존한다. 의존한다는 것은 HTML/CSS에 접근해서 조작하는 방식으로 JavaScript 코드가 작성되었다는 것을 뜻한다. 이는 HTML/CSS가 변경되면 JavaScript 코드도 영향을 받음을 의미한다. Angular는 HTML/CSS가 JavaScript에 의존하도록, 즉 JavaScript 코드의 상태 데이터 (State)에 바인딩해서 상태가 변경될 때마다 Rendering되도록 한다. HTML/CSS를 JavaScript의 Rendering 함수 내부의 문자열로 관리하면 앞서 말한 동작이 가능하다. Advantages of Angular 컴포넌트 기반 개발(CBD: Component Based Development) 로 생산성이 좋다. Web에서 컴포넌트 기반 개발이 어려운 이유는 CSS가 서로에게 영향을 주기 때문인데, Component 별로 CSS를 분리해내는 게 중요하다. TypeScript 사용으로 정적 타이핑, ES6과 ESNext의 기능을 지원한다. Angular는 대부분의 모던 브라우저를 지원한다. IE는 9 이상을 지원한다. Angular Projectapp.componentApplication의 root Component로, 실행 기본 page. (index.html처럼) app.component.spec.tstest specification ng build 후 map file디버깅용 app.module전체 모듈을 관리하므로 component 추가시 module에 추가됨 Component 생성 후 module file의 declarations에 추가해줘야함 Generate Component Shortcut1ng g c service -s -t --skip-tests (-S) ng generate component UI를 만들기 위해서 존재 sercive component와 직접적인 연관이 없는 state 관리 component가 활성화된다 =&gt; component가 메모리에 올라가면 view가 보임 12345System.out.print('이거슨 java');console.log('이거슨 JavaScript');printf('이거슨 C');cout&lt;&lt;'이거슨 c++';print('이거슨 python');","link":"/2019/06/14/Angular-Basics/"},{"title":"Angular Built-in Directive","text":"What is Directive?지시, 명령. View에 관련한 명령을 내리는 모든 것을 directive라고 한다. Component의 공통된 기능을 외부로 내보낸다. Dependency Injectivetype 지정하면 Angular가 class Instance를 생성한다. Component DirectiveComponent의 템플릿 표시를 위한 Directive. @Component Attribute DirectivengClass, ngStyle 등 ngClass여러 개의 Class를 추가하고 제거할 때 간편하다. String, Array, Object 형태로 바인딩할 수 있다. 123&lt;div [ngClass] = \"'active red'\"&gt;&lt;/div&gt; &lt;!-- string --&gt;&lt;div [ngClass] = \"\"['active', 'red']\"&gt;&lt;/div&gt; &lt;!-- array --&gt;&lt;div [ngClass] = \"{'active': true, 'red': false}\"&gt;&lt;/div&gt; &lt;!-- object --&gt; ngStyle여러 개의 Inline Style을 추가하고 제거한다. 1&lt;div [ngStyle]=\"{ color: 'red', 'width.px': 100 }\"&gt;&lt;/div&gt; Host ElementAttribute가 사용된 Element Structural Directives구조 디렉티브는 DOM 요소를 조건에 따라서 추가/삭제(ngIf, ngSwitch)하거나 반복 생성(ngFor)할 때 사용한다.","link":"/2019/06/18/Angular-Built-in-Directive/"},{"title":"Angular Component","text":"Angular Application은 component를 중심으로 구성되는만큼 component는 Angular의 핵심 개념이다. Component는 application의 화면을 구성하는 View를 생성하고 관리한다. Component는 template의 중첩 관계에 의해서 tree 구조를 갖는다. 여러 component 사이의 통신과 상태 관리를 위해서 Service가 있다. @Compnonent : decoratorComponent Metadata export class Add Component to app.module.ts Parent에서 Child로 data 보내는 법 : Property Bindingparent Component는 자신의 template에 Child Component를 담고 있으므로 Child Component를 알 수 있다. 따라서 data를 쉽게 전송할 수 있다. Parent Component에서 Child의 Property로 값을 전달한다. 1234567891011121314// app.component.tsimport { Component } from '@angular/core';@Component({ selector: 'app-root', template: ` &lt;!--The content below is only a placeholder and can be replaced.--&gt; &lt;app-hello [hi]=\"greeting\"&gt;&lt;/app-hello&gt; `, styles: []})export class AppComponent { greeting = 'hello'; } Child에서 @Input decorator로 Proterty value를 전달받는다. 12345678910111213// hello.component.tsimport { Component, Input } from \"@angular/core\";@Component({ // metadata selector: 'app-hello', template: `&lt;h1&gt;{{hi}}&lt;/h1&gt;`, styles: [``]})export class HelloComponent { // class Field @Input() hi: string;} Child Component에서 Parent Component로 data 보내는 법 : Event 발생Child Component는 Parent Component를 모르므로 Event를 발생시켜 Parent Component에서 Event를 Handling하는 방식으로 data를 전송한다. @Output, EventEmitter를 이용해서 Child Component에서 Event를 발생시킨다. 12345678910111213141516import { Component, Input, Output, EventEmitter } from \"@angular/core\";@Component({ // metadata selector: 'app-hello', template: ` &lt;h1&gt;{{hi}}&lt;/h1&gt; &lt;button (click)=\"greeting.emit('Hello')\"&gt;greeting&lt;/button&gt; `, styles: [``]})export class HelloComponent { // class Field @Input() hi: string; @Output() greeting = new EventEmitter&lt;string&gt;();} @Output으로 선언한 method는 emit으로 argument를 전달할 수 있다. Parent Component에서는 Event Handler를 이용해서 Event를 처리한다. 12345678910111213141516171819import { Component } from '@angular/core';@Component({ selector: 'app-root', template: ` &lt;!--The content below is only a placeholder and can be replaced.--&gt; &lt;app-hello [hi]=\"greeting\" (greeting)=\"changeGreet($event)\" &gt;&lt;/app-hello&gt; `, styles: []})export class AppComponent { greeting = 'Hi~~!!!!'; changeGreet(greet: string) { this.greeting = greet; }} &lt;app-hello&gt; 내부에서 event greeting의 event handler를 등록하고 class 내부에서 정의한다. $event로 parameter에 argument 값을 받아온다. Content ProjectionChild Component의 selector tag 사이에 HTML content를 넣을 수 있다. 123456&lt;!-- parent --&gt;&lt;app-child&gt; &lt;h1&gt; Content from parent &lt;/h1&gt;&lt;/app-child&gt; 1234&lt;!-- child --&gt;&lt;div&gt; &lt;ng-content&gt;&lt;/ng-content&gt;&lt;/div&gt; Child component의 template에 &lt;ng-content&gt;&lt;/ng-content&gt;가 Parent component에서 전달한 template으로 치환된다.","link":"/2019/06/14/Angular-Component/"},{"title":"Angular Data Binding","text":"Interpolation Property Binding[propertyName] = &quot;expression&quot; &quot; &quot; 내부에는 string이 아니라 expression(표현식)이 오는 곳이므로 주의하자. Attribute and PropertyAttribute는 HTML Element의 attribute이고 Property는 DOM node object인 HTML Element 객체의 property이다. 초기에 HTML Attribute가 초기값으로 그려지고 Property는 실시간으로 변경되는 DOM 최신값을 반영한다. 12&gt; &lt;input value=\"Initial Value\" [value]=\"Property Value\"&gt;&gt; 앞의 value는 attribute이고 [value]는 property이다. Property는 최신값이므로 실행시 “Property Value”가 view에 보여지게 된다. Attribute Binding[attr.attName] = &quot;expression&quot; Property와 달리 attr.를 붙여줘야 한다. HTML Element의 Property와 Attribute는 항상 1 대 1로 대응하지 않는다. HTML Element 별로 어떤 Attribute와 Property가 있는지 알고 있어야 한다. Class BindingClass binding은 2가지 방법으로 사용할 수 있다. [class.className] = &quot;expression&quot;expression의 평가 결과가 true일 때는 class를 적용하고, false일 때는 class를 적용하지 않는다. classList.add와 remove를 간단하게 할 수 있다. [class]=&quot;className List&quot;class에 className List를 적용한다. 1classNames = 'active red block'; 여러 Class를 조건 별로 다룰 때에는 Angular의 built-in ngClass Directive를 사용하는 것이 좋다. Style Binding[style.styleProp]=&quot;expression&quot; 123// style property 이름은 camelExpression과 kebab-expression 모두 사용&lt;div [style.fontSize.px] = \"'64'\"&gt;..&lt;/div&gt;&lt;div [style.font-size.px]=\"'64'\"&gt;..&lt;/div&gt; Event Binding(event)=&quot;event handler()&quot; 함수 호출문을 써야 한다. 1&lt;button (click)=\"onClick()\"&gt;..&lt;/button&gt; Two-way Data BindingProperty와 event binding을 한 번에 123&lt;input type=\"text\" (input)=\"changeVal($event.target.value)\" [value]=\"value\"&gt;&lt;/input&gt;&lt;button (click)=\"remove()\"&gt;X&lt;/button&gt; 1234567891011export class AppComponent { value= ''; changeVal(value: string) { this.value = value; } remove() { this.value = ''; }} input event로 인해서 AppComponent class의 value가 바뀌면 그 바뀐 value에 의해서 또 HTMLInputElement의 value도 영향을 받는다. 이런 상황을 양방향 데이터 바인딩으로 작성할 수 있다. 1&lt;input type=\"text\" [(ngModel)]=\"value\"&gt; 위 와 같이 고치면 input tag에 대해서 input event 발생시 AppCoㅊㅌ mponent의 value도 변경되고, AppComponent의 value가 변경되면 view에;ㅀ 반영된다. ngModel을 사용하기 위해서는 FormsModule을 모듈에 등록해야 한다.","link":"/2019/06/17/Angular-Data-Binding/"},{"title":"9. Object Literal","text":"What is Object?JavaScript is an object-based programming language and almost “everything” that makes up JavaScript is an object. The rest of the values (functions, arrays, regular expressions, etc.) are all objects except primitive types. Object / reference type is a complex data structure that consists of several types of values (primitive type values or other objects) in a single unit. Primitive value Object immutable value mutable value pass by value pass by reference Object is a set of properties that consist of keys and values. Any value that is available in JavaScript can be used as the value of the property. Functions in JavaScript are first-class objects, so they can be treated as values. JavaScript functions are first-class objects, so they can be used as property values. If the property value is a function, it is called a method to distinguish it from a normal function. Attributes are refer to additional information of an object. Properties are describing the characteristics of an object. An object is a set of methods, which means properties that refer to data and behavior that can refer to and manipulate data. Create Object by Object LiteralClass-based object-oriented languages such as C ++ and Java pre-define classes and create objects by calling the constructor with the new operator at the point in time. However, JavaScript is a prototype-based object-oriented language that creates objects differently. Then how JavaScript creates object? Object literal Object constructor function Constructor function Object.create method Class (ES6) The most basic and general method is using object literal. 12345678910// empty objectvar empty = {};// At the time of assignment, the object literal is interpreted and the resulting object is created.var student = { name: 'Park', hello: function () { Console.log('Hello. I'm ${this.name}.'); }}; The {} used to create the object is not a block of code. It is an object literal because it ends with a ;. You can create a property as soon as you create the object by including the property in an object literal, or you can dynamically add a property after you create the object. PropertyAn object is a set of properties. A property consists of a key and a value. The values that can be used for property key and property values are as follows. Property key : all strings include empty string or symbol value Property value : all values in JavaScript Quotes can be omitted if the property key is a name that conforms to the identifier naming convention, that is, a valid name that can be used in JavaScript. 12345678var student = { name: 'Park'};// Dynamically add property keystudent['age'] = 25;console.log(student); // {name: \"Park\", age: 25} Property keys are allowed to be duplicated, and in the event of duplication, the last declared key is valid. MethodIf the property value is a function, it is called a method to distinguish it from a normal function. In other words, a method means a function restricted to an object. 12345678var circle = { radius: 5, // ← property getDiameter: function () { // ← method return 2 * this.radius; // this pointing circle }};console.log(circle.getDiameter()); // 10 this is a reference variable that points to the object that called it. Access of PropertyYou can access the properties in such a way, Dot notation Bracket notation 123456var student = { name: 'Park'};console.log(student.name); // Access by dot notaionconsole.log(student['name']; // Access by bracket notation If the property key follows the identifier naming convention, 2 notations are both available. If not, only bracket notation is available. If the property key is not a name that does conform to the identifier naming convention, that is, not a valid name that can be used in JavaScript, must use square bracket notation. However, the quotation marks '' can be omitted if the property key is a string of numbers. Update Property ValueIf assign a value to an existing property, the property value is updated. 1234567var student = { name: 'Park'};student.name = 'Kim';console.log(student); // {name: \"Kim\"} Dynamic property creation1234567var student = { name: 'Park'};student.age = '22';console.log(student); // {name: \"Park\", age: \"22\"} Can add, modify, and delete properties after object creation is complete. New ES6 Object Literal FunctionsProperty shorthand123let x = 1, y = 2;const obj = { x, y }; // { x:1, y: 2 } Property key dynamic creation123456789101112// ES6const prefix = 'prop';let i = 0;// 객체 리터럴 내부에서 프로퍼티 키 동적 생성var obj = { [`${prefix}-${++i}`]: i, [`${prefix}-${++i}`]: i, [`${prefix}-${++i}`]: i};console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3} Method shorthand12345678910// ES6const obj = { name: 'Park', // 메소드 축약 표현 sayHi(other) { console.log(`Hi, ${other}! I'm ${this.name}`); }};obj.sayHi('Sam'); // Hi, Sam! I'm Park","link":"/2019/05/05/9-Object-Literal/"},{"title":"Angular Directive","text":"DirectiveDirective는 DOM의 모양이나 동작 등을 관리하기 위한 명령이다. HTML Element 또는 Attribute 형태로 사용한다. Directive를 사용하는 HTML Element를 Directive 내에서 Host element라고 부르며, Directive 내부에서 host element의 event를 처리하거나 style 등을 변경할 수 있다. 123456789101112131415161718@Directive({ selector: '[textBlue]' })export class TextBlueDirective { constructor(public el: ElementRef, public renderer: Renderer2) {} @HostListener('mouseenter') onMouse() { this.setColor('blue'); } @HostListener('mouseleave') offMouse() { this.setColor(null); } setColor(color: string | null) { this.renderer.setStyle(this.el.nativeElement, 'color', color); }} Directive class의 constructor에서 주입된 parameter는 class의 class field가 되어 class 전역에서 사용할 수 있다. 이를 constructor에 ElementRef instance가 Dependency Intect(의존성 주입)되었다고 한다. @Directive : meta data 객체에 Directive에 필요한 정보(selector등)를 입력한다. selector property 설명 selector: ‘foo’ foo element에 Directive가 적용된다. selector: ‘.foo’ .foo class가 선언된 element에 Directive가 적용된다. selector: [foo] foo attribute가 선언된 element에 Directive가 적용된다. selector: [foo=bar] foo attribute의 값이 bar로 선언된 element에 Directive가 적용된다. selector: :not(foo) foo element를 제외한 모든 element에 Directive가 적용된다. selector: ‘foo, bar’ foo 또는 bar element에 Directive가 적용된다. Directive의 selector는 attribute로 이용하는 것이 일반적이다. Component는 Directive를 상속받은 것으로 selector 규칙이 동일하게 적용된다. ElementRef: host element를 감싼 wrapper object el.nativeElement: host element Renderer2: Angular에서는 el.nativeElement의 style 프로퍼티를 직접 변경하는 것이 아니라 Renderer2를 이용하는 것이 권장된다. @HostListener : host element에서 발생한 event에 대한 event listener를 정의할 때 사용하는 데코레이터. Directive로 data 보내기 | property binding12345678910111213// app.component.ts@Component({ selector: 'app-root', template: ` &lt;!--The content below is only a placeholder and can be replaced.--&gt; &lt;p [color]=\"color\" textColor&gt;Hello&lt;/p&gt; `, styles: [] })export class AppComponent { color = 'red';} 12345678910111213141516171819202122// text-color.directive.ts@Directive({ selector: '[textColor]' })export class TextColorDirective { @Input() color: string; constructor(public el: ElementRef, public renderer: Renderer2) {} @HostListener('mouseenter') onMouse() { this.setColor(this.color); } @HostListener('mouseleave') offMouse() { this.setColor(null); } setColor(color: string | null) { this.renderer.setStyle(this.el.nativeElement, 'color', color); }}","link":"/2019/06/24/Angular-Directive/"},{"title":"Angular Pipe","text":"AngularJS에는 60여개의 built-in Pipe가 있었으나 Angular는 9개의 built-in pipe를 지원한다. 나머지 기능은 pipe를 직접 구현하여 사용할 수 있다. pipe meaning date 날짜 형식 변환 json JSON 형식 변환 uppercase 대문자 변환 lowercase 소문자 변환 currency 통화 형식 변환 percent 퍼센트 형식 변환 decimal 자리수 형식 변환 slice 문자열 추출 async 비동기 객체 출력 new Date() 등으로 생성한 객체에 pipe를 사용하면 깔끔한 형식으로 출력할 수 있다. 객체 배열 형식으로 된 data를 확인하며 코딩할 때 &lt;pre&gt;{ data | json }&lt;/pre&gt;로 data를 확인할 수 있다. Category가 있는 경우 category 별로 filtering해서 데이터를 보여줄 수도 있다. 12345678910111213// filter.pipe.ts@Pipe({ name: 'filter',})export class FilterPipe implements PipeTransform { transform(todos: Todo[], active: NavItem): any { if (active === 'All') return todos; return active === 'Active' ? todos.filter(todo =&gt; !todo.completed) : todos.filter(todo =&gt; todo.completed); }} 1234&lt;!-- todos.component.html --&gt;&lt;li *ngFor=\"let todo of (todos | filter: navState)\"&gt; ....&lt;/li&gt; Angular는 template을 렌더링할 때 사용하는 data의 Reference value가 바뀌어야 상태 감지를 해서 재렌더링을 하며 pipe를 실행한다. 따라서 상태가 변경될 때는 명시적으로 재할당을 해주는 게 좋다. 재할당을 하지 않고 일부분만을 변경할 경우 pipe에 option을 주어야 한다. 1234@ Pipe({ name: 'filter', pure: false}) pure: false option을 주면 Reference value가 바뀌지 않더라도 상태를 감지하지만 퍼포먼스가 안 좋아진다. 재할당을 하자.","link":"/2019/06/21/Angular-Pipe/"},{"title":"Angular JWT","text":"Angular Guard로그인에 성공한 사용자만 접속할 수 있는 페이지를 구현해야할 때가 있다. 이런 때에는 Angular Guard를 이용한 Authentication을 한다. Guard는 Service의 일종이다. Generate Guard1ng g g Auth CanActivate AuthGuard12345678910111213141516171819202122// auth.guard.tsimport { Injectable } from '@angular/core';import { ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, CanActivate} from '@angular/router';import { Observable } from 'rxjs';@Injectable({ providedIn: 'root' })export class AuthGuard implements CanActivate { // canActivate: boolean을 implements 해야함 canActivate() { // 일단 token 있으면 진입 가능하게 함 if (localStorage.getItem('my-token')) return true; // 없으면 login으로 이동하고 return false this.router.navigate(['login']); return false; }} Guard 적용할 Component1234567891011121314151617181920// community-routing.module.tsimport { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';import { CommunityComponent } from './components/community.component';import { PhotoComponent } from './components/photo.component';import { KnowhowComponent } from './components/knowhow.component';import { AuthGuard } from '../auth.guard';const routes: Routes = [ { path: 'community', component: CommunityComponent, canActivate: [AuthGuard] }, { path: 'community/photo', component: PhotoComponent }, { path: 'community/knowhow', component: KnowhowComponent }];@NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule] })export class CommunityRoutingModule {} Angular JWT (JSON Web Authentication)http Protocol은 stateless로, Server는 Client의 상태(state)를 기억하지 않는다. 로그인 유지를 위해서 Client 측에서 Session과 Cookie를 이용했다. 요즘은 보안을 위해 JWT(JSON Web Token)을 이용한다. Browser가 id와 pw로 Server에 login 함 Server가 Browser로 JWT 전송 Browser가 Server로 JWT을 Authorization Header에 담아 전송 Server가 JWT의 signature 확인하고 JWT를 Decoding해서 User Information을 얻는다. JWON Web Token은 header.payload.signature로 이루어진다. SIgnature는 Header의 encoding 값과 Palyload의 encoding 값을 합쳐 주어진 Private Key로 Hash 해서 생성한다. 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) SHA256은 네트워크 보안 수업 시간에 공부했던 건데 이렇게 실제로 사용되고 있는 것을 보니 감회가 새롭다.","link":"/2019/07/12/Angular-JWT/"},{"title":"Angular NgModule","text":"ModuleAngular의 모듈은 관련이 있는 구성 요소(Component, Directive, Pipe, Service)를 하나의 단위로 묶는 메커니즘 모듈은 관련이 있는 구성 요소들로 구성된 integrated functional block으로 Application을 구성하는 하나의 단위를 말함 모듈은 다른 모듈과 결합할 수 있으며 Angular는 여러 모듈을 조합해서 Application을 구성한다. 초기 속도가 느린 SPA의 단점을 해결하기 위해서 모듈을 분리하고 Lazy Loading하는 방법이 있다. Angular는 최소한 하나의 모듈, root Module인 app.module.ts를 갖는다. NgModule은 @NgModule Decorator로 장식된 class이다. Feature Module 하나의 View 가 하나의 Feature Module Shared Module 여러 Feature Module에서 import되어 사용되는 Shared Module Core Module Application 전체에서 사용하거나 하나의 Feature Module에서 사용하는 Service Component 하나로만 이루어진 단순한 view여도 view 단위로 모듈을 나누기로 했으면 나눠야함 @NgModule DecoratorMetadataDecorator에 전달하는 Metadata는 Angular에 Module code를 어떻게 compile하고 실행할지를 설명한다. declarationsComponent, Direcive, Pipe를 선언하면 선언된 구성요소는 Module에서 사용할 수 있다. importsModule에서 사용하는 다른 Module을 선언한다. Module은 다른 Module를 사용할 수 있다. providersInjectable object, 즉 Service를 선언한다. Root Module에 선언된 Service는 Application 전역에서 사용할 수 있다. 최신 버전 Angular에서는 ng generate service로 생성한 service는 @Injectable Decorator의 Metadata에 proviededIn: ‘root’로 들어감 bootstrapCSS Bootstrap 아님 Root Module에서 사용하는 Property로 Application의 entry point인 Root Component(AppComponent) 선언 Shared Module12ng generate module shared// ng g m shared Shared Module은 Application 전역에서 사용되는 Component, Directive, Pipe 등으로 구성된다. Core Module1ng generate module core Core Module은 Application 전역에서 사용되는 Data Service, Authentication Service, Authentication Guard 등으로 구성된다. 12345import { CoreModule} from '../core.module.ts';@Injectable({ providedIn: CoreModule})","link":"/2019/07/08/Angular-NgModule/"},{"title":"Angular Service & Dependency Injection","text":"ServiceComponent는 View를 구성하고 관리하는 역할을 해야한다. 그러나 View를 구성하다보면 필요한 데이터를 가져오기 위해서 서버와 통신을 하는 등의 부가 기능이 필요하게 된다. 이런 기능을 Component에서 하지 않고 Service로 분리한다. Component의 관심사와 Application 전역의 관심사를 분리하는 것이다. 이렇게 기능을 분리하면 Application의 복잡도가 낮아지고 서비스를 재사용할 수 있다. 또한 의존도가 낮아져 유지보수성이 좋아진다. Dependency InjectionService는 Dependency Injection이 가능한 class이다. @Injectable 데코레이터로 정의한다. Dependency Injection이란 말 그대로 의존성(dependency)을 주입(inject)한다는 것이다. 어떤 Component에서 Service의 method를 사용하는 경우 둘은 의존 관계(Dependency relationship)에 있다고 한다. Component 내부에서 Service class의 instance를 생성하는 경우 둘은 강한 결합(Tight Coupling)을 하고 있는 것이다. 반면 Component에서 직접 Service를 생성하는 것이 아니라 constructor의 parameter로 선언하여 Angular가 생성한 Service instance를 주입받는 것은 느슨한 결합(Loose Coupling)이다. Tight Coupling은 많은 문제를 일으킨다. 하나의 Service의 생성 방법 등에 변동이 있을 경우 해당 Service와 의존 관계에 있는 모든 Component가 영향을 받는다. 재사용과 유지보수가 효율적인 프로그램을 만들기 위해서는 객체 사이의 의존 관계를 최소화해야 한다. 필요에 의해 의존 관계가 있을 경우 Tight Coupling은 지양해야 한다. Dependency Injection은 Design pattern 중 하나로, tight coupling에서 loose coupling으로 전환하는 방법이다. 1234567891011class A { // dependency의 instance를 직접 생성하지 않고 외부 환경에 요구 constructor(private dependency: B) { } foo() { this.dependency.bar(); }}class B { bar() { console.log('bar'); }} A class처럼 constructor에서 instance를 parameter로 받는 경우, A class에서는 해당 instance의 생성 방법을 알 필요가 없다. 123456789// greeting.service.tsimport { Injectable } from '@angular/core';@Injectable({ providedIn: 'root' /* @Injectable 프로바이더 */})export class GreetingService { sayHi() { return 'Hi!'; }} Angular에서 Dependency Injection을 받기 위해서는 @Injectable 데코레이터에 meta data로 providedIn: 'root'를 설정해야 한다. 해당 선언이 된 Service는 전역에서 Injectable하다. 또는 해당 Service를 주입받을 Component에서 @Compinent 데코레이터에 meta data로 providers: [GreetingService]를 설정해주면 된다. 이 Component를 포함한 Child component 들에서만 Injectable하다.","link":"/2019/06/25/Angular-Service-Dependency-Injection/"},{"title":"C# Basic","text":"CObject-oriented Language다른 객체 지향 언어와 마찬가지로 Class와 Instance Attribute, Method 등의 개념이 존재한다. C# Script 생성시 초기 화면123456789101112131415161718using System.Collections;using System.Collections.Generic;using UnityEngine;public class HelloWorld : MonoBehaviour{ // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { }} MonoBehaviour : Unity의 기본 Class 😪 docs.unity Update method : frame마다 매번 실행됨 Data Type1234567891011121314151617181920212223242526272829303132using System.Collections;using System.Collections.Generic;using UnityEngine;public class HelloWorld : MonoBehaviour{ int iValue; double dValue; float fValue; bool bValue; string sValue; // Start is called before the first frame update void Start() { iValue = 50; dValue = 100.123; fValue = 100.23f; bValue = true; sValue = &quot;Hello World&quot;; } // Update is called once per frame void Update() { print(&quot;Integer Value: &quot; + iValue); print(&quot;Double Value: &quot; + dValue); print(&quot;Float Value: &quot; + fValue); print(&quot;Boolean Value: &quot; + bValue); print(&quot;String Value: &quot; + sValue); }} float type은 number + f로 써야함","link":"/2019/07/22/C-Basic/"},{"title":"CodeWars 5kyu. Directions Reduction","text":"CodeWars 6kyu. Dubstep뒤죽박죽 방향 지시를 효율적으로 만들기 Instruction이 길어 생략하도록 하겠다. 위의 링크를 참조하도록 하자. 요구조건 북쪽으로 갔다가 남쪽으로, 동쪽으로 갔다가 서쪽으로. 움직이지 않는 것만 못한 비효율적인 지시를 제거하는 문제다. [NORTH + SOUTH], [EAST + WEST] 와 같이 두 방향이 인접해야지만 제거할 수 있다. [SOUTH, EAST, WEST, NORTH]와 같은 경우, 첫번째로 EAST + WEST가 사라지고 나면 SOUTH + NORTH가 인접하게 되므로 이것 또한 제거해 효율적인 지시를 내려야 한다. 해결책이전에 LeetCode에서 두어번 풀어보았던 in-place 알고리즘이 떠올랐다. input을 담을 자료구조를 따로 만들지 않고 input 자체에 연산을 하는 작업이다. Call by reference로 parameter를 넘겨줄 때만 유효한 알고리즘이다. input arr의 item이 한개 이하라면 그냥 arr를 return한다. 각 대응되는 direction들을 dictionary의 key와 value로 mapping한다. for문을 돌며 만약 서로 대응되는 방향이 인접해있다면 그 둘을 arr에서 잘라내고, i를 초기화해서 처음부터 다시 arr를 순회한다. javaScript Solution123456789101112131415function dirReduc(arr){ if(arr.length &lt;= 1) return arr; var direction = {\"NORTH\": \"SOUTH\", \"EAST\": \"WEST\", \"SOUTH\": \"NORTH\", \"WEST\": \"EAST\"}; for(var i = 0; i &lt; arr.length; i++){ if(direction[arr[i]] == arr[i+1]){ arr.splice(i, 2); i = -1; } }","link":"/2019/04/20/CodeWars-5kyu-Directions-Reduction/"},{"title":"CodeWars 5kyu Maximum subarray sum","text":"CodeWars 5kyu. Maximum subarray sumReturn maximum sum of subarrays The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers: maxSequence([-2, 1, -3, 4, -1, 2, 1, -5, 4]) // should be 6: [4, -1, 2, 1] Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead. Empty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist/subarray. Requirement Should return maximum sum of any subarrays including empty list. Return 0 when all of list’s element is negative numbers. SolutionI used Dynamic Programming - Bottom up approach to solve this problem. Because I learned on some online lectures about Dynamic Programming recently. First I catched that all the start and end element in subarray is positive numbers. So I decided to put all positive numbers’ index in positive_index list. Make a 2 dementional array, sum[][] to keep the sum of subarrays. Drew the recurrance Induction of this problem. Basis sum[i][i] = arr[positive_index[i]] sum[i][i+1] = arr[positive_index[i]] to arr[positive_index[j]] (i &lt; positive_index.length - 1) Inductive Step sum[i][j] = sum[i][j-1] + sum[j-1][j] - arr[positive_index[j-1]] javaScript Solution 12345678910111213141516171819202122232425262728293031323334353637var maxSequence = function(arr){ var positive_index = [] arr.filter(function positive_check(element, index){ if(element&gt;0){ positive_index.push(index); } }) if (positive_index.length == 0) return 0; var sum = Array(positive_index.length).fill(null).map(() =&gt; Array(positive_index.length)); var max = Number.MIN_SAFE_INTEGER; for(var i=0; i&lt;positive_index.length; i++){ sum[i][i] = arr[positive_index[i]]; if(max &lt; sum[i][i]){ max = sum[i][i]; } if(i+1&lt;positive_index.length){ sum[i][i+1] = arr.slice(positive_index[i], positive_index[i+1]+1).reduce((a,b)=&gt;a+b); if(max &lt; sum[i][i+1]){ max = sum[i][i+1]; } } } for(var i=0; i&lt; positive_index.length; i++){ for(var j=i+2; j&lt; positive_index.length; j++){ sum[i][j] = sum[i][j-1] + sum[j-1][j] - arr[positive_index[j-1]]; if(max &lt; sum[i][j]){ max = sum[i][j]; } } } return max;} PPT slidesMade presentations for my algorithm study group","link":"/2019/04/25/CodeWars-5kyu-Maximum-subarray-sum/"},{"title":"Call by Value, Call by Reference and Call by Object Reference","text":"우선 Parameter와 Argument의 차이를 짚고 가도록 한다. ParameterThe names given in the function definition are called Parameters. ArgumentThe values supplied in the function call are called Arguments. Call by Value 함수를 호출할 때, 변수의 값을 복사하여 argument로 넘기는 것 123456789101112#include &lt;stdio.h&gt;void change_value(int x, int val) { x = val; printf(\"x : %d in change_value \\n\", *x);}int main(void) { int x = 10; change_value(x, 20); printf(\"x : %d in main \\n\", x);} 위 코드에서는 단순히 x에 10이라는 값이 복사되어 들어가기 때문에, change_value(x, 20)에서 x를 변경하더라도 main 함수에서의 x에 영향을 미치지 못한다. Call by Reference 함수를 호출할 때 변수의 값을 넘기는 것이 아니라, 변수의 주소(변수의 위치)를 복사하여 함수에 넘긴다. 넘겨받은 주소로 실제 변수에 접근하고 값을 변경할 수 있다. 123456789101112#include &lt;stdio.h&gt;void change_value(int * x, int val) { *x = val; printf(\"x : %d in change_value \\n\", *x);}int main(void) { int x = 10; change_value(&amp;x, 20); printf(\"x : %d in main \\n\", x);} 주소값을 전달 (참조값을 전달) : 주소값을 알고 있으면 해당 memory 주소에 저장되어있는 값을 참조할 수 있다. *x가 x를 참조하고 있다 : 가리키고 있다. 이를 이해하기 위해서는 pointer에 대한 이해가 필요하다. Pointer 123int *pnum;int num = 12345;pnum = &amp;num //num의 주소값을 return하여 pnum에 저장 변수를 만들 때 변수 이름 앞에 *를 붙이면 pointer 변수 됨 &amp;연산자: &amp;오른쪽에 오는 피연산자의 주소값을 반환 *연산자: 포인터가 가리키는 메모리 공간에 접근할 때 사용되는 연산자. 포인터 변수를 이용해 포인터 변수가 가리키는 변수의 값을 바꿀 수도 있다. Call by Assignment (Call by Object Reference) The actual parameters (arguments) to a function call are introduced in the local symbol table of the called function when it is called; thus, arguments are passed using call by value (where the value is always an object reference, not the value of the object). [1] When a function calls another function, a new local symbol table is created for that call. 이 문장이 나를 얼마나 헷갈리게 했는지 모른다. 그러니까 Python에서는 function의 argument가 call by value로 넘어오는데, 그 value는 언제나 object의 값이 아닌 object의 reference라는 것이다. Actually, call by object reference would be a better description, since if a mutable object is passed, the caller will see any changes the callee makes to it (items inserted into a list). 정확하게는 call by object reference라는 설명이 더 맞다. 왜냐면 mutable 객체가 넘어올 때에는 call by reference처럼 원본 값을 변경할 수 있기 때문이다. 파이썬은 모든 것이 object이고, Object에는 두 종류가 있다. Immutable object int, float, str, tuple Immtable 객체가 함수의 인자로 전달되면, 처음에는 call by reference로 받지만 값이 변경되면 call by value로 동작한다. 즉, 함수 내에서 formal parameter 값이 바뀌어도 actual parameter에는 영향이 없다. 함수 내부에서 값을 변경할 수 없다! 그래서 tuple은 변경하려면 함수에서 element와 tuple 인자로 넘겨 아예 새로 할당해줘야 함 Mutable object list, dict, set Mutable 객체가 함수의 인자로 넘어가면 call by reference도 동작한다. 즉, object referene가 전달되어 actual parameter의 값에 영향을 미칠 수도 있다. 새로운 객체를 할당하는 게 아니라면, 함수 내부에서 값을 변경할 수 있다! 정리 Python은 함수를 실행할때 Call by reference같은 느낌으로 reference를 넘겨준다. 하지만 이때 넘겨주는 것은 변수(Variable)의 reference가 아니라 변수가 담고 있는 자료(Data)의 reference이다. 자료가 mutable하다면 변경해도 reference가 보존되므로 결과적으로 Call by reference처럼 보일 것이고, 자료가 immutable하다면 결과적으로 Call by value처럼 보일 것이다.","link":"/2019/04/22/Call-by-Value-Call-by-Reference-and-Call-by-Object-Reference/"},{"title":"CodeWars 6kyu. Decode the Morse code","text":"CodeWars 6kyu. Decode the Morse codeDecode Morse code to plain text The Morse code encodes every character as a sequence of “dots” and “dashes”. For example, the letter A is coded as ·−, letter Q is coded as −−·−, and digit 1 is coded as ·−−−−. The Morse code is case-insensitive, traditionally capital letters are used. When the message is written in Morse code, a single space is used to separate the character codes and 3 spaces are used to separate words. For example, the message HEY JUDE in Morse code is ···· · −·−− ·−−− ··− −·· ·. NOTE: Extra spaces before or after the code have no meaning and should be ignored. In addition to letters, digits and some punctuation, there are some special service codes, the most notorious of those is the international distress signal SOS (that was first issued by Titanic), that is coded as ···−−−···. These special codes are treated as single special characters, and usually are transmitted as separate words. Your task is to implement a function that would take the morse code as input and return a decoded human-readable string. 12decodeMorse('.... . -.-- .--- ..- -.. .')//should return \"HEY JUDE\" Each word distinguished by &quot; &quot; (3 spaces) Free to use the preloaded Morse code table as a dictionary. By MORSE_CODE['.--'] javaScript Solution 1234567891011121314151617decodeMorse = function(morseCode){ var words = morseCode.split(\" \"); var string = \"\" for (var i in words){ if(words[i] != ''){ var word = words[i].split(\" \"); for(var j in word){ if(word[j] != ''){ string += MORSE_CODE[word[j]]; } } if(i &lt; words.length-1){ string += \" \" } } }","link":"/2019/04/29/CodeWars-6kyu-Decode-the-Morse-code/"},{"title":"CodeWars 6kyu. Build a pile of Cubes","text":"CodeWars 6kyu. Build a pile of CubesFind the largest number of cubes can be piled. Your task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume of n^3, the cube above will have volume of (n-1)^3 and so on until the top which will have a volume of 1^3. You are given the total volume m of the building. Being given m can you find the number n of cubes you will have to build? The parameter of the function findNb (find_nb, find-nb, findNb) will be an integer m and you have to return the integer n such as n^3 + (n-1)^3 + … + 1^3 = m if such a n exists or -1 if there is no such n. Examples: findNb(1071225) –&gt; 45findNb(91716553919377) –&gt; -1mov rdi, 1071225call find_nb ; rax &lt;– 45 mov rdi, 91716553919377call find_nb ; rax &lt;– -1 접근법Σ k3 (k = 1~n) == ((n * (n+1))/2))**2 가 m보다 작아야 한다. 따라서 n == Math.sqrt(2 * Math.sqrt(m)) 에 근사한 값으로 설정한 후 m보다 커질 때까지 반복한다. JavaScript Solution 1234567function findNb(m) { let n = parseInt(Math.sqrt(2 * (Math.sqrt(m)))) - 1; while ( ((n * (n+1))/2) ** 2 &lt; m ) { n++; } return ((n * (n+1))/2) ** 2 &gt; m ? -1 : n;}","link":"/2019/05/09/CodeWars-6kyu-Build-a-pile-of-Cubes/"},{"title":"CodeWars 6kyu. Consecutive strings","text":"CodeWars 6kyu. Consecutive stringsFind longest k consecutive strings You are given an array strarr of strings and an integer k. Your task is to return the first longest string consisting of k consecutive strings taken in the array. Example: longest_consec([“zone”, “abigail”, “theta”, “form”, “libe”, “zas”, “theta”, “abigail”], 2) –&gt; “abigailtheta” n being the length of the string array, if n = 0 or k &gt; n or k &lt;= 0 return “”. Note consecutive strings : follow one after another without an interruption JavaScript Solution12345678910111213141516function longestConsec(strarr, k) { if (strarr.length == 0 || k &gt; strarr.length || k &lt;= 0) return ''; let longStr = ''; let newStr = ''; for (let i = 0; i &lt; strarr.length; i++){ newStr = strarr.slice(i, i+k); if (newStr.join('').length &gt; longStr.length ){ longStr = newStr.join(''); } } return longStr;}","link":"/2019/05/07/CodeWars-6kyu-Consecutive-strings/"},{"title":"CodeWars 6kyu. Dubstep","text":"CodeWars 6kyu. Dubstep덥스텝 제목을 Decoding 하기 Polycarpus works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them. Let’s assume that a song consists of some number of words (that don’t contain WUB). To make the dubstep remix of this song, Polycarpus inserts a certain number of words “WUB” before the first word of the song (the number may be zero), after the last word (the number may be zero), and between words (at least one between any pair of neighbouring words), and then the boy glues together all the words, including “WUB”, in one string and plays the song at the club. For example, a song with words “I AM X” can transform into a dubstep remix as “WUBWUBIWUBAMWUBWUBX” and cannot transform into “WUBWUBIAMWUBX”. Recently, Jonny has heard Polycarpus’s new dubstep track, but since he isn’t into modern music, he decided to find out what was the initial song that Polycarpus remixed. Help Jonny restore the original song. Input The input consists of a single non-empty string, consisting only of uppercase English letters, the string’s length doesn’t exceed 200 characters Output Return the words of the initial song that Polycarpus used to make a dubsteb remix. Separate the words with a space. Examples 12songDecoder(\"WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\") // =&gt; WE ARE THE CHAMPIONS MY FRIEND 요구조건 input으로 200자를 넘지 않고 비어있지 않은 string 하나가 들어오면 WUB가 끼어들어가있지 않은 원래의 song 제목으로 decoding해 return 한다. 각 단어는 space로 나눠져야 한다. 해결책여러가지 방법으로 해결했다. Regular Expression을 활용해 string을 처리했다. replace method와 RegEx를 사용해 song에 존재하는 모든 “WUB”를 “ “(space)로 대체한다. 단어 사이에 space가 여러개 있을 수 있으니 하나 이상의 space(\\s+)로 string을 배열로 조각낸 후, 각 단어를 다시 space를 사이에 넣어 join한다. 1-1. 이렇게 되면 string의 시작과 끝에 존재하는 공백이 처리되지 않는다. 처음 Solution 1을 작성할 때는 trim() method를 몰랐으므로 직접 if문으로 처리했다. filter() method와 새로운 function 문법 =&gt; 를 써보고 싶어 작성한 Suolution 정규 표현식과 trim method를 활용해 코드의 길이를 줄였다. javaScript Solution 1123456789101112function songDecoder(song){ let result = song.replace(/WUB/gi, ' ').split(/\\s+/).join(' '); if(result[0] === ' '){ result = result.slice(1); } if(result[result.length-1] === ' '){ result = result.slice(0, -1); } return result;} javaScript Solution 21234function songDecoder(song){ return song.replace(/WUB/g, ' ').split(' ').filter(word=&gt;word!='').join(' ');;} javaScript Solution 3 123function songDecoder(song){ return song.replace(/(WUB)+/g,\" \").trim();} Regular Expression ^x : 문자열의 시작이 x x$ : 문자열의 끝이 x .x : x로 끝나는 임의의 문자 x+ : x가 1번 이상 반복 x* : x가 0번 이상 반복 x? : x가 존재하거나 존재하지 않음 x{n} : x를 n번 반복한 문자를 찾음 x{n,} : x를 n번 이상 반복한 문자를 찾음 x{n, m} : x를 n번 이상, m번 이하 반복하는 문자를 찾음 Flags g (Global) : 문자열 내에 존재하는 모든 패턴을 찾음 i (Ignore Case) : 대소문자 구분 없이 찾음 m (Multi Line) : 문자열의 행이 바뀌어도 찾음 12// 객체초기화(Object initializer) 방법var regExp = /정규표현식/[Flag];","link":"/2019/04/18/CodeWars-6kyu-Dubstep/"},{"title":"CodeWars 6kyu. Take a Number And Sum Its Digits Raised To The Consecutive Powers And ...","text":"CodeWars 6kyu. Take a Number And Sum Its Digits Raised To The Consecutive Powers And ….¡Eurekal!!Return a number that sum of each digit powered of its own number of digit. The number 89 is the first integer with more than one digit that fulfills the property partially introduced in the title of this kata. What’s the use of saying “Eureka”? Because this sum gives the same number. In effect: 89 = 8^1 + 9^2 The next number in having this property is 135. See this property again: 135 = 1^1 + 3^2 + 5^3 We need a function to collect these numbers, that may receive two integers a, b that defines the range [a, b] (inclusive) and outputs a list of the sorted numbers in the range that fulfills the property described above. Let’s see some cases: sumDigPow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] sumDigPow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] If there are no numbers of this kind in the range [a, b] the function should output an empty list. sumDigPow(90, 100) == [] 해결책 Put the numbers that fulfill the property to eureka[]. Used String type casting to use split and reduce method to each number. javaScript Solution 123456789101112function sumDigPow(a, b) { eureka = []; for(i=a; i &lt;=b; i++){ digits = String(i).split(''); if(i == digits.reduce(function(accumulator, currentValue, currentIndex){ return accumulator + currentValue**(currentIndex+1); }, 0)){ eureka.push(i); } } return eureka;}","link":"/2019/04/26/CodeWars-6kyu-Take-a-Number-And-Sum-Its-Digits-Raised-To-The-Consecutive-Powers-And-¡Eurekals/"},{"title":"CodeWars 6kyu. Persistent Bugger","text":"CodeWars 6kyu. Persistent Bugger각 자릿수의 곱이 한자릿수가 되는 횟수를 구하기 Write a function, persistence, that takes in a positive parameter num and returns its multiplicative persistence, which is the number of times you must multiply the digits in num until you reach a single digit. For example: 1234567persistence(39) === 3 // because 3*9 = 27, 2*7 = 14, 1*4=4 // and 4 has only one digitpersistence(999) === 4 // because 9*9*9 = 729, 7*2*9 = 126, // 1*2*6 = 12, and finally 1*2 = 2persistence(4) === 0 // because 4 is already a one-digit number 해결책split()을 사용해서 숫자를 각각 문자열 배열의 원소로 떼어내면 쉬울 것 같았는데 나는 고전적인 방법으로 숫자 그대로를 parsing하고 싶었다. 그래서 이전 LeetCode의 Palindrome 문제를 풀 때 사용한 숫자의 pop 기법을 이용해 한자리씩 숫자를 분리했다. javaScript Solution 1 123456789101112131415161718192021222324let pop = 0; let count;let mult, nums; function mul(num){ mult = 1; while(num &gt; 0){ pop = num%10; num = (num-pop)/10; mult *= pop; } nums = mult;}function persistence(num) { if(num &lt; 10) return 0; count = 0; nums = num; do{ count++; mul(nums); }while(mult &gt;= 10) return count;}","link":"/2019/04/19/CodeWars-6kyu-Persistent-Bugger/"},{"title":"CodeWars 6kyu. Find The Parity Outlier","text":"CodeWars 6kyu. Find The Parity OutlierFind one odd / even number in last all even / odd numbers. You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. Write a method that takes the array as an argument and returns this “outlier” N. Examples 12345[2, 4, 0, 100, 4, 11, 2602, 36]Should return: 11 (the only odd number)[160, 3, 1719, 19, 11, 13, -21]Should return: 160 (the only even number) First Solution 1234567891011121314151617181920212223242526272829303132333435363738394041function findOutlier(integers){ var isOdd = true; if (integers[0]%2 == 0){ // even if (integers[1]%2 == 0){ // even even isOdd = false; } else{ // even odd if(integers[2]%2 ==0){ // if even odd even, return odd return integers[1]; } else{ // else if even odd odd, return even return integers[0]; } } } else{ // odd if (integers[1]%2 == 0){ // odd even if (integers[2]%2 == 0){ // if odd even even, return odd return integers[0]; } else{ // if odd even odd, return even return integers[1]; } } } if(isOdd == true){ for(var i=2; i&lt;integers.length; i++){ if(integers[i]%2 == 0) return integers[i]; } } else{ for(var i=2; i&lt;integers.length; i++){ if(integers[i]%2 != 0) return integers[i]; } }} Second Solution 123456function findOutlier(integers){ var even = integers.filter(a=&gt;a%2==0); var odd = integers.filter(a=&gt;a%2!=0); return even.length == 1 ? Number(even) : Number(odd);}","link":"/2019/05/01/CodeWars-6kyu-Find-The-Parity-Outlier/"},{"title":"CodeWars 6kyu. Playing with digits","text":"CodeWars 6kyu. Playing with digitsPlay with digits 😊 I changed the type of input n to cycle through each digit. 123456789function digPow(n, p){ let digitSum = 0; let strNum = String(n); for(let i in strNum){ digitSum += strNum[i]**p; p++; } return Number.isInteger(digitSum/n) ? digitSum/n : -1;}","link":"/2019/05/02/CodeWars-6kyu-Playing-with-digits/"},{"title":"CodeWars 6kyu. Multiples of 3 or 5","text":"CodeWars 6kyu. Multiples of 3 or 53 또는 5의 배수의 합 구하기 If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in. Note: If the number is a multiple of both 3 and 5, only count it once. Courtesy of ProjectEuler.net 요구조건어떤 자연수 number 미만의 3 또는 5의 배수를 찾는 문제 해결책 input number가 3 또는 5로 나누어 떨어지면 sum에 더하는 방식이다. 문제가 너무 간단하게 풀려서 새로운 방법으로 생각 해보기로 했다. number를 3, 5로 나누면 그 몫의 개수만큼만 for loop을 돌며 추가한다. 5로 나눈 몫이 항상 3으로 나눈 몫보다 작기 때문에 한 번 더 검사를 해주었다. javaScript Solution 1123456789function solution(number){ var sum = 0; for (var i = 0; i &lt; number; i++) { if (i % 3 === 0 || i % 5 === 0) { sum += i; } } return sum;} javaScript Solution 212345678910function solution(number){ var sum = 0; var threeMultiples = number/3; var fiveMultiples = number/5; for(var i=1; i&lt; threeMultiples; i++){ if(i%5 != 0) sum += i*3; if(i &lt; fiveMultiples) sum += i*5; } return sum;}","link":"/2019/04/17/CodeWars-6kyu-Multiples-of-3-or-5/"},{"title":"First-class Function","text":"First-class Function 프로그래밍 언어 중 함수를 다른 변수와 동일하게 다루는 언어를 함수우선순위(First-class Functions) 가졌다고 표현한다. 함수를 다른 함수의 argument로 사용하고, 함수에서 함수를 return하거나 변수의 값으로 함수를 할당할 수 있다. 변수에 함수를 할당 12345const foo = function() { console.log(\"foobar\");}// 변수를 사용하여 호출foo(); 함수를 인자로 전달 12345678function sayHello() { return \"Hello, \";}function greeting(helloMessage, name) { console.log(helloMessage() + name);}// `sayHello`를 `greeting` 함수에 인자로 전달greeting(sayHello, \"JavaScript!\"); 다른 함수에 인자로 전달된 함수를 Call Back 함수라고 한다. 다른 언어들과 같이 sayHello()를 호출하면 바로 실행되지만, 위와 같이 greeting(satHello, “)의 인자로 전달된 sayHello의 경우 greeting 함수의 helloMessage parameter로 전달된 후에, 필요한 경우 helloMessage()에서 호출된다. 전달된 이후 나중에 호출되기 때문에 CallBack 함수라고 불린다. 함수를 return 값으로 전달 (함수 return) 12345function sayHello() { return function() { console.log(\"Hello!\"); }} 함수가 함수를 반환하는 예시문. JavaScript에서는 함수를 변수처럼 취급하므로 함수를 return할 수 있다. Higher-Order Function : 함수를 반환하는 함수","link":"/2019/04/22/First-class-Function/"},{"title":"Difference between Subsequence and Substring","text":"SubsequenceIn mathmatics, a subsequence is a sequence that can be derived from another sequence by deleting some or no elememts without changing the order of the remaining elememts. What is Sequence?In mathematics, a sequence is an enumerated collection of objects in which repetitions are allowed. Serial arrangement in which things follow in logical order or a recurrent pattern. SubstringSubstring can be derived from the string by deleting anoter substring. The substring is a refinement of the subsequence.","link":"/2019/04/29/Difference-between-Subsequence-and-Substring/"},{"title":"LeetCode 26. Remove Duplicates from Sorted Array","text":"LeetCode 26. Remove Duplicates from Sorted Array정렬된 배열에서 중복되는 값 제거 : in-place Algorithm Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1:Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the returned length. Example 2:Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn’t matter what values are set beyond the returned length. 요구조건 배열 nums에서 중복되지 않는 원소의 수를 return한다. 배열 nums는 중복되지 않는 수로 앞부분이 정렬되어야한다. 문제는 위의 설명과 같이 nums라는 number형 array를 입력받아 중복되는 element 대신 다음 element를 그 자리에 오게 하는 것이다. 나는 처음에 중복된 element를 제거한 새로운 배열을 return해 여러 번 오류가 났었다. 이 문제의 핵심은 nums 배열이 referance로 넘어온다는 것이다. 즉, 새로운 배열을 만들지 않고 원본 nums의 값을 바꿔야한다. 솔루션을 도출하기까지 나를 헷갈리게 한 것은 한 element를 제거하고 나면 nums의 index부터 길이가 매번 변화한다는 것이다. 처음에 그 부분을 캐치하지 못해 여러 번 오류가 났다. 해결책 처음에 문제를 완벽하게 이해하지 못해서, nums 배열의 중복을 완전히 제거하는 것인줄로만 알았다. 그래서 array.splice method를 이용해서 중복되는 부분을 제거했다. 첫번째 Solution을 제출한 후 다른 사람들의 풀이를 보고 문제를 다시 제대로 이해했다. javaScript Solution 1: Runtime 92 ms | Memory Usage 37.3 MB 1234567891011121314151617/** * @param {number[]} nums * @return {number} */var removeDuplicates = function(nums) { var prev= nums[0]; for(var i = 1; i &lt; nums.length; i++){ if(nums[i] == prev){ prev = nums[i]; nums.splice(i, 1); i -= 1; } else{ prev = nums[i]; continue; } }}; javaScript Solution 2: Runtime 72 ms | Memory Usage 37.3 MB 123456789101112131415/** * @param {number[]} nums * @return {number} */var removeDuplicates = function(nums) { if(nums.length == 0) return 0; let prev = 0; for(let i = 1; i &lt; nums.length; i++){ if(nums[i] != nums[prev]){ prev++; nums[prev] = nums[i]; } } return prev+1;} 배운 점영어라고 해서 대충 Example만 보고 바로 문제를 풀려고 하는 습관을 고쳐야겠다. 문제를 제대로 해석하고, 알고리즘을 짜는 것이 훨씬 효율적인 것 같다.","link":"/2019/04/15/LeetCode-26-Remove-Duplicates-from-Sorted-Array/"},{"title":"LeetCode 35. Search Insert Position","text":"LeetCode 35. Search Insert PositionInsert할 Position을 찾는 문제 : C++, Binary Search 사용 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 Example 3: Input: [1,3,5,6], 7 Output: 4 Example 4: Input: [1,3,5,6], 0 Output: 0 요구조건input으로 들어오는 정렬된 배열 nums와 target으로, target이 nums에 있다면 그 index를 return하고 없다면 순서상 target이 있어야할 자리의 index를 return한다. 해결책처음 문제를 접하고 바로 Binary Search를 사용해야겠다고 생각했다. 원래는 값을 찾으면 return하고 없으면 -1을 return하지만, 이 문제에서는 target이 있어야 할 자리를 return하므로 end + 1을 return했다. C++ Solution : Runtime 8 ms | Memory Usage 8.7 MB 1234567891011121314151617181920class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { if(target &lt;= nums[0]) return 0; int start = 0; int end = nums.size() - 1; int mid; while(start &lt;= end){ mid = (start + end) / 2; if(target == nums[mid]) return mid; else if(target &lt; nums[mid]){ end = mid -1; }else { start = mid+1; } } if(start &gt; end) return end+1; return -1; }};","link":"/2019/04/18/LeetCode-35-Search-Insert-Position/"},{"title":"LeetCode 27. Remove Element","text":"LeetCode 27. Remove ElementInput 배열의 요소를 제거하기 : in-place Algorithm Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn’t matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn’t matter what values are set beyond the returned length. 요구조건 배열 nums에서 val의 값을 가진 element를 제거한다. in-place algorithm으로 연산해야 한다. 이번 문제는 LeetCode 26. Remove Duplicates from Sorted Array를 오해해서 풀었을 때와 거의 흡사해서 푸는 데에 시간이 오래 걸리지 않았다. 해결책 혼자 풀었을 때는 for문에서 nums.length를 검사할 때, nums.length가 splice로 인해서 줄어든 길이를 인식하지 못한다고 생각하여 if문의 마지막에 length = nums.length로 재정의를 했다.스터디원들과 대화를 하며 nums를 직접 접근하고 변형하는 것이므로 그럴 필요가 없다는 것을 알았다. 배열 nums의 길이만큼 for문을 돌며 val과 같은 element를 만나면 배열에서 제거한다.i번 째 loop에서 index = i 자리의 원소가 사라져, i+1번째 원소가 앞으로 당겨지므로, splice 연산 뒤에 i에서 1을 빼준다. javaScript Solution : Runtime 60 ms | Memory Usage 34.6 MB 1234567891011121314/** * @param {number[]} nums * @param {number} val * @return {number} */var removeElement = function(nums, val) { for(let i = 0; i &lt; nums.length; i++){ if(val == nums[i]){ nums.splice(i, 1); i =- 1; } } return nums.length;}; 배운 점 array.splice method에 대해서 제대로 알게 되었다. 원소를 제거하는 것 뿐만 아니라 그 자리에 여러 element를 넣을 수도 있는 유용한 method다. 여러 명과 알고리즘에 대해 이야기하면 생각지 못한 풀이가 나오는 것이 재밌다.","link":"/2019/04/16/LeetCode-27-Remove-Element/"},{"title":"LeetCode 28. Implement strStr()","text":"LeetCode 28. Implement strStr()strStr()을 구현하기 : javaScript, C Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 &gt; if needle is not part of haystack. Example 1: Input: haystack = “hello”, needle = “ll”Output: 2Example 2: Input: haystack = “aaaaa”, needle = “bba”Output: -1 요구조건 string haystack에서 needle이 처음으로 등장하는 index를 반환한다. 존재하지 않으면 -1을 반환한다. 해결책 javaScript의 indexOf() method를 이용해 해결했다. method를 쓰지 않고 C로 해결해보려고 했는데 한 1년 C를 쓰지 않았다고 기능이 기억이 나지 않아 여러 번 찾아봐야 했다. 포인터 개념도 다시 한 번 훑어봐야겠다. javaScript Solution : Runtime 56 ms | Memory Usage 33.8 MB 123456789/** * @param {string} haystack * @param {string} needle * @return {number} */var strStr = function(haystack, needle) { if (needle === \"\") return 0; return haystack.indexOf(needle);}; C Solution : Runtime 1300 ms | Memory Usage 7 MB 1234567891011121314151617181920int strStr(char* haystack, char* needle) { if(needle[0] == '\\0') return 0; int index = -1; int hayLen = strlen(haystack); int neeLen = strlen(needle); for(int i=0; i&lt; hayLen; i++){ if(haystack[i] == needle[0]){ index = i; for(int j=1; j &lt; neeLen ; j++){ if(i+j &gt;= hayLen || haystack[i+j] != needle[j]){ index = -1; break; } } } if(index &gt; -1) return index; } return -1;}","link":"/2019/04/17/LeetCode-28-Implement-strStr/"},{"title":"LeetCode 5. Longest Palindromic Substring","text":"LeetCode 5. Longest Palindromic Substring가장 긴, 거꾸로 해도 똑같은 Substring을 찾는 문제 Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad” Output: “bab” Note: “aba” is also a valid answer. Example 2: Input: “cbbd” Output: “bb” 요구 조건요구 조건은 간단하다. 한 가지 용어만 정리하고 가면 된다. Palindrome : “aba” “dccd”와 같이 reverse한 결과와 원본이 같은 단어를 말한다. 주어지는 input의 substring 중 가장 긴 palindromic substring을 return하는 문제다. 해결책그러나 Solution은 간단하지 않았다. Palindromic Substring은 길이도 주어지지 않았고, 앞 뒤가 똑같은지 확인하기 위해서 비교해야할 변수가 많았다. 가장 중요한 건 효율성이다. 어떻게 하면 최소한의 비교로 가장 긴 Palindrome을 찾아낼 수 있을 지 오랫동안 고민했다. 이미 확인한 string은 다시 확인하지 않기 위해 Dynamic Programming을 이용하려고 했으나 실패했다. P[i][j] = P[i+1][j-1] and S[i] == S[j] 이 완벽해보이는 알고리즘을 이용해 해답을 찾으려고 했지만 내가 부족한지 자꾸 i+1, j-1이 이전에 계산이 되지 않아 원하는 답이 나오지 않았다. 아래 두 해답은 다른 사람들의 Solution을 참고한 것이다. Python Solution 1Runtime 5496 ms | Memory Usage 13.3 MB 1234567891011121314class Solution: def longestPalindrome(self, s: str) -&gt; str: long = \"\" if len(s) &lt;= 1: return s for i in range(len(s)): for j in range(len(s), i, -1): if len(long) &gt;= j-i: continue elif s[i:j] == s[i:j][::-1]: long = s[i:j] return long 정말 단순히, s의 모든 substring이 palindromic한지 검사하는 알고리즘이다. Python Solution 2Runtime 68 ms | Memory Usage 13.3 MB 12345678910111213class Solution: def longestPalindrome(self, s: str) -&gt; str: if len(s) &lt;= 1: return s i,l=0,0 for j in range(len(s)): if s[j-l: j+1] == s[j-l: j+1][::-1]: i, l = j-l, l+1 # print(s[i: i+l]) elif j-l &gt; 0 and s[j-l-1: j+1] == s[j-l-1: j+1][::-1]: i, l = j-l-1, l+2 # print(s[i: i+l]) return s[i: i+l] 이 Solution은 놀라웠다. 가장 긴 substring의 시작 index를 i에, 길이는 l에 저장한다. j로 s를 순회하면서 s[j-l-1:j+1], 즉 j를 기준으로 l+1만큼의 길이를 가진 (저장된 l의 길이보다 2 더 큰) substring이 palindrome인지 검사한다. 맞으면 i와 l을 update한다. 된다! 그리고 이해도 쉽게 된다. 느낀 점문제를 보는 능력을 기르려면 한참 멀었다는 생각이 들었다. 더 좋은 Solution을 많이 접하고 공부해야겠다.","link":"/2019/04/22/LeetCode-5-Longest-Palindromic-Substring/"},{"title":"Local Variable and Global Variable","text":"전역변수 (global variable) / 지역변수 (local variable) 변수의 scope와 lifetime 변수는 선언하는 순간부터 속한 scope 내에서 lifetime을 가진다. 즉, 특정 범위의 코드가 실행되고 있을 때는 메모리에 존재하지만, 실행이 끝나면 이 변수는 메모리에서 사라진다. 변수의 선언 위치 a. Block 외부 : block({})으로 감싸진 main 함수와 여러 함수들의 외부 공간에 변수를 선언할 수 있다. b. Block 내부 : block 내부에 변수를 선언할 수 있다. C는 block의 최상단에 모든 지역변수를 선언해야한다. c. 함수의 parameter : 함수의 매개변수는 그 함수의 block 내에서 선언된 변수와 동일한 효과를 갖는다. 전역변수 (a case) Block 외부에 선언되는 변수. 전역 변수는 프로그램이 시작되는 순간부터 종료되는 순간까지 메모리를 차지하고 있으며 사라지지 않는다. C라면 main() 위, #include &lt;stdio.h&gt;와 함수 원형 밑 그 사이에 선언 전역변수는 어느 block에서도 언제든지 접근이 가능하다 &gt; sycncrinize 고려 지역변수 (b case, c case) 지역변수는 block 내부에서 선언되는 변수이다. { } 안에 선언되어있다면 무조건 지역변수 지역변수는 선언된 block 내부로 scope가 한정되며 그 block의 실행이 끝나면 lifetime 또한 소멸된다. 함수의 parameter로서 선언되는 local variable도 이와 같다. 함수 body 내에서 선언되는 것과 똑같다.","link":"/2019/04/22/Local-Variable-and-Global-Variable/"},{"title":"Python 3.7.3 | Jupyter 설치","text":"Window Python 3.7.3 및 Jupyter 설치파이썬을 공부하기 위해 작업환경을 우선 구축하기로 한다. Python 3.7.3 설치 Python 최신 릴리즈인 3.7.3 다운로드 페이지로 이동한다. Download for Windows의 Python 3.7.3 버튼을 누르면 자동으로 설치 실행 파일이 다운로드 된다. 다운받은 python-3.7.3.exe 파일을 관리자 권한으로 실행 후, 설치를 진행한다. PATH를 자동으로 생성하는 것이 좋다! 다운로드가 완료되면 cmd 창을 열어 python --version 명령어로 설치가 제대로 되었는지 확인한다. Jupyter 설치위의 Python 설치 4단계에서, cmd 명령으로 확인을 정상적으로 마쳤다면 추가적인 명령 한 줄로 Jupyter를 설치할 수 있다. cmd 창에 pip install jupyter를 입력한다. 여기까지 하면 Python 사용을 위한 간단한 작업 환경 구성이 완료된다.","link":"/2019/04/18/Python-3-7-3-Jupyter-설치/"},{"title":"Python Data Type and Data Structure | Jupyter 사용방법","text":"Jupyter 사용법 | Python Data TypeJupyter notebook window 사용을 기준으로 Window PowerShell을 실행한다. pwd로 현재 폴더를, ls로 현재 폴더에 존재하는 file들을 확인 후 mkdir 폴더이름 command로 python file을 만들고 실습할 폴더 하나를 생성한다. 나는 python-basic이라는 폴더를 만들고 cd python-basic 명령으로 해당 폴더로 이동했다. 만든 폴더로 이동한 후 cmd에 jupyter notebook command를 입력한다. 조금 기다리다보면 (10초 이상 소요) 브라우저 새 창으로 jupyter notebook이 실행된다. 그림과 같이 우측의 new button을 눌러 새로운 python file을 생성한다. 그럼 새로운 탭에 생성된 file이 보여진다. 제목을 수정하고 실습을 시작하면 된다! method 이름을 치고 Shift + Tab을 하면 function의 signature를 확인할 수 있다. object (variable)을 입력한 상태에서 Tab 키를 누르면 사용 가능한 method들을 확인할 수 있다. instruction을 작성한 후 Shift + Enter를 누르면 해당 line이 실행된다. 어떤 line에 focus가 있는 상태에서, ESC + m을 누르고 Enter를 치면 markdown으로 작성할 수 있다. Python Data Type Number Type : Int, Float javaScript와 다르게 C처럼 int, float등 정수형과 실수형을 구분한다. String character와 string의 구분 없이 str type을 가진다. Python Data StructureMutable and Immutable ObjectMutable object (변경 가능 객체) list dictionary set Immutable object (변경 불가능 객체) int, float 등 숫자는 immutable : 값을 덮어쓰는 것이 아니라 새로운 memory 공간에 할당하고 그 값을 가리킨다. 이름 객체가 값 객체를 가리키는 것을 binding이라고 한다. string Tuple Dynamic Typing Python은 Dynamic typing 언어로, C / C++ 같은 정적 타이핑 언어처럼 자료형을 미리 선언하지 않아도 알아서 동적으로 자료형을 할당할 수 있다. Data Assignment C : char a = 10; A라는 이름을 가진 공간에 10의 값이 저장된다. 20으로 변경시 같은 메모리 공간의 값을 변경한다. Python : a = 10; 10이라는 값을 가진 객체가 생기고, a라는 이름을 가진 객체가 10을 가리키게 된다. 만약 a=20으로 재할당할 경우 20이라는 값을 가진 객체가 생기고 a는 20을 가리켜, 10은 자신을 가리키는 객체가 없으므로 제거된다. 20으로 변경시 10의 메모리공간을 건드리지 않고 새로운 공간을 만든다. Integer, float등 number type은 immutable 객체 Python 성질 모든 것이 객체: integer가 그냥 4 byte가 아니라 객체로 필요한 것들이 붙어있어 크기를 더 차지함 Overflow: overflow 되는 대신 4 byte를 8 byte로 늘림. 대신 경계검사 하므로 속도 저하 Language Abstraction Hardware 의존적인 Assembly 언어에서 벗어나 하드웨어 독립적인 C언어로 Coding하고 각 하드웨어 별 어셈블러로 해석하게끔 함 ▶ 하드웨어 추상화 (각 어셈블러가 어떻게 동작하는지 몰라도 C로 코딩하면 됨) Assembly : low level language C / C++ : hardware abstraction 됐으나 memory abstraction X ▶ 메모리를 직접 할당, 해제 Java / C# : 언어 자체에서 메모리 할당, 해제 ▶ garbage collection. Memory abstraction O 그러나 Data Type은 선언해줘야함 Python / javaScript : Data type abstraction. Interpreter Language Level은 abstraction level을 말하는 것이지 급을 나누는 것이 아님 성능은 C/C++ 생산성은 Python","link":"/2019/04/18/Python-Data-Type-and-Data-Structure-Jupyter-사용방법/"},{"title":"Python Class and Access Modifier","text":"Python Class1234567891011121314151617181920212223242526272829303132333435363738class Account: # constructor # 객체를 생성할 때 \"반드시\" 한 번 호출한다. def __init__(self, cus_name, init_balance): # instance member self.name = cus_name self.balance = init_balance # descructor # 객체가 소멸될 때 \"반드시\" 한 번 호출 def __del__(self): pass # instance method(operator) def deposit(self, money): if money &lt; 0: print('0보다 작은 값을 저금할 수 없습니다.') return False self.balance += money print(f'잔고 {self.balance}') return True def withdraw(self, money): if money &gt; self.balance: print('잔고보다 출금하려는 돈이 더 많습니다.') return False self.balance -= money print(f'잔고 {self.balance}') return money def transfer(self, other, money): self.balance -= money # 다른 object의 member에 바로 접근하지 않는다!! (private없어서 접근 할 수는 있음(뭐임?)) # 다른 object의 member는 \"반드시\" 상대 object의 method를 호출해서 접근해야 한다. - Message Passing other.deposit(money) print(f'잔고 {self.balance}') Object : abstraction method (추상화 도구) 관련 있는 변수(member)와 기능(operator, method)를 묶어서 하나의 object로 만든다. Operator를 통해서만 member에 접근할 수 있다. Class와 Instance, object의 차이 클래스(class)란 똑같은 무엇인가를 계속해서 만들어낼 수 있는 설계 도면 같은 것이고(과자 틀), 객체(object)란 클래스에 의해서 만들어진 피조물(과자틀에 의해서 만들어진 과자)을 뜻한다. class에 의해서 만들어진 Object를 instance라고도 한다. 그렇다면 Object와 Instance의 차이는 무엇일까?이렇게 생각해 보자. a = Cookie() 이렇게 만들어진 a는 Object이다. 그리고 a라는 Object는 Cookie의 Instance이다. 즉, Instance라는 말은 특정 Object(a)가 어떤 Class(Cookie)의 객체인지를 관계 위주로 설명할 때 사용된다. 즉, “a는 instance” 보다는 “a는 object”라는 표현이 어울리며, “a는 Cookie의 object” 보다는 “a는 Cookie의 instance”라는 표현이 훨씬 잘 어울린다. Public, Private and Protected | Python Access ModifierC++, Java와 같이 클래식한 object-oriented 언어에서는 public, private, protected와 같은 키워드로 class의 member에 대한 접근을 제어한다. Class의 Private member는 class 외부에서 접근이 불가능하며 class 내부에서만 접근될 수 있다. Class 내의 Public member는 class 외부에서도 접근할 수 있다. 같은 class의 object는 public method를 호출하도록 요구된다. Private instance variable과 public method를 함께 써야지만 데이터 encapsulation의 원칙에 따르는 것이다. Class의 protected member는 오직 해당 class와 그 class를 상속받은 child class만이 접근할 수 있다. 이는 parent class가 child class에게 특정한 리소스를 상속할 수 있게 한다. 그런데 Python은 instance variable과 method에 대해서 접근 제한을 하는 방식이 따로 없다. Python vaiable이나 method의 이름 앞에 한개 또는 2개의 _(underscore)를 붙여서 protected와 private으로 구분하기로 약속한다. Public Attributes12345class Account: def __init__(self, cus_name, init_balance): # instance member self.name = cus_name self.balance = init_balance Protected Attribute12345class Account: def __init__(self, cus_name, init_balance): # instance member self._name = cus_name self._balance = init_balance Private Attribute12345class Account: def __init__(self, cus_name, init_balance): # instance member self.__name = cus_name self.__balance = init_balance 그런데 웃긴 건, underscore로 name mangling한 private variable을 class 외부에서 접근이 가능하다는 것이다. 다음의 방법을 사용하면 된다. 12myAccount = Account('subin', 10000)myAccount._Account__balance 정말 필요하다면 접근할 수 있지만, Python에서는 접근하지 말 것을 권고하고 있다. 참고 자료 점프 투 파이썬 TutorialsTeacher","link":"/2019/04/24/Python-Class-and-Access-Modifier/"},{"title":"Recursion","text":"Recursion (재귀) 함수 호출 도중에 자기 자신을 다시 호출하는 것 Base case가 필수 (기초, 종료, 탈출 조건) Base case가 없으면 무한으로 자기 자신을 호출해서 stack overflow가 된다. 재귀함수를 만드는 방법 패턴을 찾는다. 즉, 점화식(Induction)을 만든다. Base case를 만든다. 예제1: Factorial ! Basis 0! = 1! = 1 Induction Step n! = (n-1) * (n-2) * (n-3) * … 3 * 2 * 1 12345def factorial(n): if n &lt;= 1: return 1 else: return n*factorial(n-1) 예제2: Fibonacci Basis fib(0) = fib(1) = 1 Induction Step fib(n) = fib(n-1) + fib(n-2) 12345def fib(n): if n &lt;= 1: return 1 else: return fib(n-1) + fib(n-2) Fibonacci Dynamic Programming Memorization (Top Down) 123456789f = [-1 for _ in range(100)]def fib_memorize(n): if f[n] &gt; -1: return f[n] elif n &lt;= 1: f[n] = 1 else: f[n] = fib_memorize(n-1) + fib_memorize(n-2) return f[n] Bottom Up 123456f2 = [-1 for _ in range(100)]def fib_bottup(n): f2[0] = f[1] = 1 for i in range(2, n+1): f[n] = f[n-1] + f[n-2] return f[n] 예제3: Hanoi TowerPlay Tower of Hanoi 12345678def hanoi(n, _from, _by, _to): # base case if n==1: print(f'{n}번째 쟁반을 {_from}에서 {_to}로 옮긴다.') return hanoi(n-1, _from, _to, _by) print(f'{n}번째 쟁반을 {_from}에서 {_to}로 옮긴다.') hanoi(n-1, _by, _from, _to)","link":"/2019/04/23/Recursion/"},{"title":"Quick Sort","text":"Quick Sort Divide and Conquer Algorithm Use Recursion 정렬해야할 list, 시작점 start와 끝점 end를 넘겨 받는다. left = start, right = end로 정한다. 양방향의 left와 right를 pivot 방향으로 움직이며 pivot 값과 left, right index의 element 값을 비교한다. left의 element 값이 pivot 보다 크고, right의 element 값이 pivot보다 작을 때 둘을 교환하고 각 index를 하나씩 이동한다.(left면 +1, right면 -1) left와 right가 교차되기 전까지 반복하면서 sorting한다. 한 번 교차되면 while문을 빠져나오는데, 이 때 pivot을 기준으로 왼쪽은 pivot보다 작은 값들로, 오른쪽은 pivot보다 큰 값들로만 이루어져있다. Recursion으로 pivot을 포함하지 않고 왼쪽과 오른쪽을 각각 다시 돌려준다. 이 때 base case는 start가 end와 같아지거나 교차하면 return하는 것이다. 코드를 보는 게 더 이해가 쉬울 것 같다. 그림으로 그려보며 진행하는 게 가장 도움이 된다. 12345678910111213141516171819def quickSort(li, start, end): if start &gt;= end: return left = start right = end pivot = li[(left+right)//2] while left &lt;= right: while li[left] &lt; pivot: left += 1 while li[right] &gt; pivot: right -= 1 if left &lt;= right: li[left], li[right] = li[right], li[left] left += 1 right -= 1 quickSort(li, start, right-1) quickSort(li, left, end) 12345678910import randomwhile True: num_data=int(input('데이터 개수(0이면 종료):')) if not num_data: break data=[random.randint(1, 100) for _ in range(num_data)] print(data) quickSort(data, 0, len(data)-1) print(data) [Quick sort에 관련된 TED edu 영상] What’s the fastest way to alphabetize your bookshelf? 문제는 pivot을 어떻게 결정할 것이냐이다. Pivot이 정렬해야할 list의 모든 값들의 평균치일 때는 n/2번을 비교하는 것으로 가장 좋지만, 예를 들어 최솟값이나 최댓값을 기준으로 pivot이 선택될 경우 n번을 계산해야한다. pivot을 정렬된 list의 가운데 값으로 결정하는 것이 Best case지만, 정렬을 하기 위해서 pivot을 사용하는 것이므로 실현될 수 없는 이야기이다. Quick Sort의 Time Complexity는 O(nlogn)으로, average case일 때를 기준으로 한다. Pivot을 random pivot으로 둘 경우 확률적으로 avarage case를 만족한다. li의 start와 end와 mid를 정렬한 결과의 중간 값을 return한다. Random Pivot을 이용하기 위해 코드를 수정했다. 1234567891011121314def getMiddleIndex(li, start, mid, end): \"\"\" list의 맨 처음 값, 끝 값, 중간 값 정렬시 가운데 값의 index 반환 \"\"\" indices = [start, mid, end] if li[indices[0]] &gt; li[indices[1]]: indices[0], indices[1] = indices[1], indices[0] if li[indices[1] &gt; li[indices[2]]]: indices[1], indices[2] = indices[2], indices[1] if li[indices[0]] &gt; li[indices[1]]: indices[0], indices[1] = indices[1], indices[0] return indices[1] 전체 반영한 결과123456789101112131415161718192021222324252627282930313233343536373839404142def getMiddleIndex(li, start, mid, end): \"\"\" list의 맨 처음 값, 끝 값, 중간 값 정렬시 가운데 값의 index 반환 \"\"\" indices = [start, mid, end] if li[indices[0]] &gt; li[indices[1]]: indices[0], indices[1] = indices[1], indices[0] if li[indices[1] &gt; li[indices[2]]]: indices[1], indices[2] = indices[2], indices[1] if li[indices[0]] &gt; li[indices[1]]: indices[0], indices[1] = indices[1], indices[0] return indices[1]def quickSort(li, start, end): if start &gt;= end: return left = start right = end mid = (left+right)//2 #추가된 코드 mid_index = getMiddleIndex(li, start, mid, end) li[mid_index], li[mid] = li[mid], li[mid_index] pivot = li[mid] while left &lt;= right: while li[left] &lt; pivot: left += 1 while li[right] &gt; pivot: right -= 1 if left &lt;= right: li[left], li[right] = li[right], li[left] left += 1 right -= 1 quickSort(li, start, right-1) quickSort(li, left, end)","link":"/2019/04/24/Quick-Sort/"},{"title":"React Basic","text":"React &amp; Angular 비교React Facebook이 만든 Frontend Framework 오로지 View만 관리 Facebook, Netflix, Airbnb 등 Angular 구글이 만든 Frontend Framework Framework로서 많은 기능 내장 (Router, Auth, animation 등) 필요 Skill React Angular TypeScript 선택 필수 RxJS 선택 필수 상태관리 Redux / Mobx Angular Service Framework 쓰는 이유생산성과 효율성 ↑Start React1npx create-react-app my-app serviceWorker.js와 menifest.js로 Progressive Web App public index.html menifest.js src App.js index.js serviceWorker.js 1yarn start JSX &amp; 가상 DOMJSX(JavaScript Like XML) React의 Element를 생성하는 방법 { }로 감싸고 JavaScript Code 작성 CSS class 적용 위해서 class =” “ 대신 className=” “ 사용 function 은 render 내장되어 return하면 되지만 class에서는 JSX를 return하는 render함수를 사용해야함 Functional ComponentLife Cycle이 없음 Parent Component로부터 Props를 받기만 함 Class Component자체 Life Cycle이 있음 가상 돔 (Virtual DOM)Real DOM의 상태를 Memory에 저장해서 ReactDOM 등의 Library를 이용해 Real DOM과 동기화 하는 방법 props &amp; stateParent Component에서 Child로 data 전송시 1234567891011121314151617181920// parent.jsconstructor() { this.state = { text: '' }}setText = (content = '') =&gt; { // Child가 전달한 content를 state에 반영 this.setState({ test: content });}render() { return ( &lt;Child title=\"Hi\" text={this.setText}&gt; )} 123456789101112131415161718// child.jsexport defualt class Child extends React.Component { constructor(props) { super(props); this.state = { } } render() { return ( &lt;div&gt; { props.title } &lt;button onClick={() =&gt; this.props.text('test')}&gt; &lt;/div&gt; ) }} React는 화살표 함수 써야 this 전달 용이","link":"/2019/07/13/React-Basic/"},{"title":"Responsive Web (2)","text":"Responsive Web &lt;picture&gt; element Can I Use &lt;picture&gt;? CanIUse.com &lt;picture&gt; 문법 &lt;img&gt;를 fallback으로 첨부해야한다. &lt;picture&gt; 는 &lt;img&gt; tag가 없으면 인식되지 않는다! 1img {display: block; margin: 0 auto;} 12345&lt;picture&gt; &lt;source media=\"(min-width: 650px)\" srcset=\"images/kitten-stretching.png\"&gt; &lt;source media=\"(min-width: 465px)\" srcset=\"images/kitten-sitting.png\"&gt; &lt;img src=\"images/kitten-curled.png\" alt=\"a cute kitten\"&gt;&lt;/picture&gt;Pixel density descriptor 1x, 1.5x, 2x 그리고 3x와 같은 픽셀 밀도 서술자(Pixel density descriptor)들을 사용하여 고해상도 디스플레이 지원을 추가합니다. 새로 추가된 srcset 속성은 &lt;img&gt;와 &lt;source&gt; 엘리먼트 모두에 적용됩니다. letina부터는 2x 나오고 Android는 1.5x 등 정수가 아니고 소숫점으로 증가 Image 반응형으로 만들기 wrapper를 만들고, 그 안에 &lt;img&gt; max-width: 100%; height: auto; 12345678910111213141516 &lt;style&gt; .rwd-wrapper{ width: 30%; border: 5px solid blueviolet; } .rwd-wrapper img{ max-width: 100%; height: auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"rwd-wrapper\"&gt; &lt;img src=\"images/image-src.png\" alt=\"\"&gt; &lt;/div&gt;&lt;/body&gt; srcset 속성을 사용해서 Pixel density 설정 1234567&lt;div class=\"rwd-wrapper\"&gt;&lt;img src=\"images/image-src.png\" alt=\"\" srcset=\"images/image-1x.png 1x, images/image-2x.png 2x, images/image-3x.png 3x, images/image-4x.png 4x\"&gt;&lt;/div&gt; Viewport 별로 Art Direction 설정하기 &lt;picture&gt;의 &lt;source media=&quot;&quot;&gt;로 조건 줌 123456&lt;picture&gt; &lt;source media=\"(max-width: 650px)\" srcset=\"images/small.jpg\"&gt; &lt;source media=\"(min-width: 651px) and (max-width: 999px)\" srcset=\"images/media.jpg\"&gt; &lt;source media=\"(min-width: 1000px)\" srcset=\"images/large.jpg\"&gt; &lt;img class=\"rwd-img\" src=\"images/normal.jpg\" alt=\"\"&gt;&lt;/picture&gt; Background image를 반응형으로 만들기 image 원본 size를 알아내야한다. &gt; 가로, 세로 비율을 계산해야함 height를 0으로 하고, padding을 세로로 원본 image의 비율에 맞게 준다. 12345678.rwd-bg{ width: 100%; height: 0 !important; padding-top: calc(3280 / 4928 * 100%); background: url(\"images/light.jpg\") no-repeat; background-size: 100% 100%;} width 크기를 변경할 때는 새로운 wrapper를 만들어 그 wrapper의 width를 줄인다. 12345678910.wrapper{ width: 50%;}.rwd-bg{ width: 100%; height: 0 !important; padding-top: calc(3280 / 4928 * 100%); background: url(\"images/light.jpg\") no-repeat; background-size: 100% 100%;} 123&lt;div class=\"wrapper\"&gt; &lt;div class=\"rwd-bg\"&gt;&lt;/div&gt;&lt;/div&gt; .rwd-bg는 parent인 wrapper의 width 100%만큼 차지하므로 wrapper의 크기가 줄어들면 같이 줄어든다. Background-size: cover, contain CSS Trick Background-size 참고 사이트 cover : 이미지가 일부 잘리더라도 화면을 꽉 채우게 가장 작은 축을 기준으로 cover함 contain : 가로든, 세로든 가장 긴 축을 기준으로 화면에 잘리지 않게 하는 기법 Media query로 해상도 별 배경 image 다르게 하기 dpi : dot per inch - 1inch 당 들어가는 pixel 수 CSS는 1inch 당 96px이니까 192dpi는 2x임 12345@media all and (min-resolution: 192dpi){ .rwd-bg{ background-image: url(\"images/unsplash.jpg\"); }}","link":"/2019/04/16/Responsive Web (2)/"},{"title":"Development Environment Setting","text":"npm (node package manager) and Modularization자바스크립트는 웹페이지의 보조적인 기능을 수행하기 위해 만들어진 언어로, 다른 범용 프로그래밍 언어와는 달리 모듈 기능이 없다. 모듈이란 애플리케이션을 구성하는 개별적인 요소를 말한다. 일반적으로 파일 단위로 분리된다. 모듈을 기능별로 분리해서 개발의 효율성과 유지보수성이 좋아진다. 그러나 자바스크립트는 파일을 나누었다고 해도 모듈을 로드했을 때 하나의 전역 스코프로 합쳐진다. 즉, 파일 스코프를 지원하지 않는다. 모듈은 그리고 모듈 내부에서 외부로 선택적으로 노출할 수 있는 기능이 있어야 하는데 자바스크립트는 그런 기능이 없었다. ES6에서 자바스크립트에서도 &lt;script type=&quot;module&quot;&gt;&lt;/script&gt;와 같이 모듈을 지원하지만, 2019년 6월 현재까지는 최신브라우저에서만 지원을 하므로 사용할 수 없다. 또한 대형 애플리케이션을 만들 때 모듈의 개수가 백 단위를 넘어갈 때 하나하나를 순서에 맞춰서 import하기 어렵다. 이런 문제를 Webpack과 같은 module bundler를 사용해서 하나의 파일로 만들어(module bundling) 해결할 수 있다. Babel은 크로스브라우징을 위한 다운그레이드 작업 등의 전처리를 해준다. Node.js에서는 CommonJS spec을 받아들여 RequireJS 로 모듈화를 구현하고 있다. npmnpm은 자바스크립트 패키지 매니저로, Node.js에서 사용할 수 있는 모듈을 패키지화 해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공한다. 여기서 패키지란 여러 모듈의 구조를 가지고 모여있는 것을 의미한다. 누구나 자신의 패키지를 공개할 수 있으므로 install할 때는 신뢰성 있는 패키지인지 확인해야 한다. node-emoji 설치 package.json이 없어서 안 깔림 깔림 Babel Webpack 개발 환경 구축 1 Babel Webpack 개발 환경 구축 2","link":"/2019/06/03/npm/"},{"title":"Angular Routing","text":"SEO(Search Engine Optimization)SPA(Single Page Application)의 단점으로 부각되는 SEO 문제를 해결하기 위해서 각 page마다 고유한 URL을 부여하는 Routing 기능이 Angular Framework에도 제공한다. Angular UniversalSSR(Server Side Rendering)을 할 수 있도록 하는 Angular Module Angular RoutingRouting은 Source에서 Destination까지의 경로를 결정하는 기능이다. Application에서 Routing이란 어떤 View에서 다른 View로 View를 전환하는 Navigation을 관리하는 기능을 의미한다. a Element의 href attribute를 이용하면 브라우저의 주소창 URL이 바뀌며 새로운 html 페이지를 렌더링한다. 이 과정에서 화면 깜빡임이 발생한다. 이를 보완하기 위한 AJAX는 브라우저 주소창의 주소가 변경되지 않아 브라우저의 뒤로가기, 앞으로가기 등의 history 관리가 되지 않는다. 하나의 주소로 동작하는 AJAX 방식은 SEO도 되지 않는다. Angular는 위의 문제점을 보완한 2가지의 Location strategy를 제공한다. PathLocationStrategy : HTML5 History pushState 기반 Navigation Strategy HashLocationStrategy : Hasy 기반 Navigation Strategy Angular의 Default Location Strategy는 Path Location Strategy이다. Type Alias12&gt; export declare type Routes = Route[];&gt; Route type 배열을 Routes type으로 선언하는 것처럼 type 이름 짓는 방식 Routing Module1234567891011121314151617181920212223242526// app-routing.module.tsimport { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';import { IndexComponent, HomeComponent, ServiceComponent, AboutComponent, NotFoundComponent} from './pages';const routes: Routes = [ { path: '', redirectTo: 'home', pathMatch: 'full' }, { path: 'home', component: IndexComponent } { path: 'service', component: ServiceComponent }, { path: 'about', component: AboutComponent }, { path: '**', component: NotFoundComponent },];@NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] })export class AppRoutingModule {} Routes type의 routes에 path와 component 프로퍼티를 가진 객체를 배열의 원소로 넣어주면 path가 바뀔 때마다 해당 path에 맞는 component를 보여준다. path에 / 는 생략한다. path **는 wild card로, 위에 설정된 경로가 아닌 모든 경로로 접근할 경우 이동하는 페이지다. 꼭 맨 마지막에 작성해야한다. redirectTo와 pathMatch: 'full'은 path가 정확히 일치할 때 해당 경로로 redirect한다. pathMatch를 설정해주지 않으면 일부만 일치해도 이동하므로 둘을 같이 써주는 것이 좋다. Navigation123456&lt;nav&gt; &lt;a routerLink = \"/\"&gt;Logo&lt;/a&gt; &lt;a routerLink = \"/home\"&gt;Home&lt;/a&gt; &lt;a routerLink = \"/service\"&gt;Service&lt;/a&gt; &lt;a routerLink = \"/about\"&gt;About&lt;/a&gt;&lt;/nav&gt; a tag의 href attribute 대신 Angular에서 제공하는 Directive routerLink를 사용해서 path를 지정한다. routerLinkActive123456&lt;nav&gt; &lt;a routerLink = \"/\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{ exact: true }\"&gt;Logo&lt;/a&gt; &lt;a routerLink = \"/home\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{ exact: true }\"&gt;Home&lt;/a&gt; &lt;a routerLink = \"/service\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{ exact: true }\"&gt;Service&lt;/a&gt; &lt;a routerLink = \"/about\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{ exact: true }\"&gt;About&lt;/a&gt;&lt;/nav&gt; 정확히 일치하는 routerLink가 Active일 때 설정된 active class가 적용된다. [routerLinkActiveOptions]=”{ exact: true }” path가 정확히 일치할 때만 Active 적용 routerLinkActive=”className” routerLink가 active되면 설정한 class 활성화 Module 만들기 Tip1ng g m module-name --routing Routing module을 포함한 module을 만들어준다. 모듈 분리시 app.module.ts에서 import에 AppModule이 가장 밑으로 가게 Module import","link":"/2019/07/10/Angular-Routing/"},{"title":"TypeScript (1)","text":"TypeScriptJavaScript는 모듈 기능을 지원하지 않고, 동적 타입 언어라는 단점 때문에 대형 프로젝트를 진행하기에 불편한 점이 많았다. 따라서 JavaScript의 단점을 보완하고자 하는 AltJS(Alternative) 언어들이 출시되었다. 브라우저는 JavaScript만을 인식하므로 AltJS 를 사용하더라도 JavaScript로 Compile해야한다. TypeScript도 AltJS 중 하나로, JavaScript의 Superset(상위 호환)이라는 특징을 가진다. TypeScript는 ES5의 Superset이므로 기존 JavaScript 문법을 그대로 사용할 수 있다. 또한 Babel 등의 Transpiler를 사용하지 않아도 ES6의 새로운 기능을 기존 브라우저에서 실행할 수 있다. TypeScript의 가장 주된 장점은 Static Type을 지원한다는 것이다. Angular가 TypeScript를 정식 채용하고 ECMAScript의 업그레이드되는 기능을 지속적으로 추가할 예정으로 많은 주목을 받고 있다. TypeScript 장점1. 정적 타입TypeScript의 가장 큰 장점은 정적 타입을 지원하는 것이다. 변수의 타입이 없고 할당되는 값에 따라 타입이 정해지는 동적 타입 언어인 JavaScript는 type check를 해야하는 불편함이 있다. 123function sum(a: number, b: number) { return a + b;} TypeScript는 명시적으로 정적 타입을 지정해 개발자의 의도대로 코드를 작성할 수 있다. 이는 코드의 가독성을 높여 효율적인 디버깅이 가능하다. 2. 도구의 지원IDE 기능을 사용할 수 있다. 3. 강력한 객체지향 프로그래밍 지원4. ES6 / ES Next 지원Babel 없이도 ES6과 그 이상 버전을 지원하고 Babel보다 신기술에 빠르게 대응한다는 장점이 있다. 5. AngularAngular에서 TypeScript를 강력하게 지원한다. HTML code 내부에서 JavaScript를 보는 것과, JavaScript code 내부에서 HTML을 보는 것의 차이JavaScript 내부에서 HTML element를 보면, 즉 querySelector를 사용해서 HTML Element에 접근하고 무언가 수행하면 Angular의 기본 원칙에 어긋난다. Angular는 기본적으로 HTML이 JavaScript에 영향을 받는 방식으로 HTML이 수정되어도 JavaScript code가 영항받지 않는다.","link":"/2019/06/12/TypeScript-1/"},{"title":"Underscore: each","text":"123456789101112_.each = function(collection, iterator) { if (Array.isArray(collection)) { for (let index = 0; index &lt; collection.length; index++) { iterator(collection[index], Number(index), collection); } } else { for (let key in collection) { if (key !== 'someProperty') iterator(collection[key], key, collection); } } };","link":"/2019/05/15/Underscore-each/"},{"title":"Angular RxJS","text":"Reactive Programming Reactive Programming is programming with asynchronous data streams. You can listen to that stream and react accordingly. Reactive Programming은 비동기적 데이터 스트림을 처리하는 프로그래밍 패러다임이다. Data stream이란 연속적인 데이터의 흐름을 말한다. Reactive Programming은 모든 것을 stream으로 본다. Event, AJAX 요청 등 모든 data stream을 시간 순서에 의해 전달되는 stream으로 처리한다. 최근 참여한 FrontEndgame 컨퍼런스에서 Functional Programming과 Reactive Programming을 융합한 FRP에 대한 발표가 있었는데 이제 Reactive Programming을 공부해본다. 여태까지는 입력받는 Data가 synchronous한지 asynchronous한지에 따라서 처리하는 방법이 달라진다. 입력이 string일 때와 Promise/event 등일 때는 코딩하는 방법이 달라진다. Reactive Programming은 data를 async, sync로 구분하지 않고 data를 stream으로 보는 것이다. Data consumer는 Data producer가 연속적으로 생성하고 방출하는 data stream의 상태 변화에 반응하는 방식으로 동작한다. Observable &amp; Observer An observer subscribes to an Observable. An Observable emits items or sends notifications to its observers by calling the observers’ methods. Data producer와 Data consumer 사이에 data stream을 전송하는 방법에는 두가지가 있다. Pull-scenario: Data consumer가 producer에게 data를 연속적으로 요청해서 획득한다. 이는 애플리케이션이 외부 환경에서 데이터를 끌어오는 방식이다. Push-scenario: Data producer가 일정 시간 단위로 계속해서 data를 내보내면(emit) Data consumer가 producer를 관찰하고 있다가 data를 획득한다. 이는 외부 환경에서 애플리케이션으로 데이터를 밀어넣는 방식이다. Observable: 외부 환경에서 애플리케이션 내부로 data stream을 생성하고 emit(방출)하는 객체 Observer: Observable이 emit한 Notification(Observable이 emit할 수 있는 push 기반 event 값)을 획득해서 사용하는 객체 즉 Observer는 Data consumer이고 Observable은 Data producer이다. Observer는 Observable을 구독(subscribe)한다. 보통 Observable과 Observer는 일대다 관계를 가진다. Observable은 ES7에 제안되어있는 비동기 데이터 처리를 위한 표준으로, Reactive Programming은 Observer pattern을 더 심화한 패턴이다. Observer Pattern Subject는 data member로 자신을 관찰하고 있는 Observer의 모음인 ObserverCollection을 유지한다. register/unregister로 Observer를 관리한다. 상태가 변화하면 자신의 ObserverCollection에 등록된 Observer들에게 noftify(status)로 상태 변화를 알린다. 상태 변화를 알리는 notify 메소드 내부에서 Observer의 Update(status)로 상태를 갱신한다. 1234567891011121314151617181920212223242526272829303132333435363738&gt; class Subject {&gt; ObserverCollection = [];&gt; &gt; register(Observer) {&gt; this.ObserverCollection = [Observer, ...this.ObserverCollection];&gt; }&gt; &gt; unregister(Observer) {&gt; this.ObserverCollection = this.ObserverCollection.filter(o =&gt; o !== Observer);&gt; }&gt; &gt; notify(status) {&gt; this.ObserverCollection.forEach(o =&gt; o.update(status));&gt; }&gt; }&gt; &gt; class MySubject extends Subject {&gt; constructor() {&gt; super();&gt; this._state;&gt; }&gt; &gt; set state(status) {&gt; this._state = status;&gt; this.notify(this.state);&gt; }&gt; }&gt; &gt; class Observer {&gt; constructor() {&gt; this.state = ''&gt; }&gt; update(status) {&gt; this.state = status;&gt; console.log(this.state);&gt; }&gt; }&gt; HttpClientHttpClient의 method를 호출하고 subscribe하지 않으면, 즉 Observable에 대한 Observer가 없으면 아무 일도 일어나지 않는다. subscribe method를 통해서 Observer가 Observable을 바라보게 해야 get Request 등이 동작하기 시작한다. json server query123456// ?_sort=id&amp;_order=descconst params = new HttpParams() .set('_sort', 'id') .set('_order', 'desc');this.http.get&lt;Todo[]&gt;(apiUrl, { params }) .subscribe(todos =&gt; this.todos = todos); Cold Observable &amp; Hot Observablesubscribe하기 전에는 동작하지 않는 Observable을 Cold Observable이라고 하며 Observer와 일 대 일 unicast 관계를 가진다. Hot Observable은 생성과 동시에 subscribe 여부와 상관 없이 바로 data stream을 emit한다. 구독하는 모든 Observer에게 data를 emit하는 multicast이다. RxJS의 Observable은 기본적으로 Cold Observable이다. 요청이 중복 발생되는 것을 방지하기 위해서 shareReplay()를 사용해 Cold Observable을 Hot Observable로 만들 수 있다. HttpIntercepterLogin이 성공하면 main page로 이동하고, 성공하지 않으면 login page에 머무르는 Application을 생각해보자. 이 때 사용자가 /main으로 main page에 바로 접근할 경우 해당 사용자가 login 완료된 상태인지는 Token으로 검사해야 한다. JWT (JSON Wen Token)Authentication에 Token의 유효 기간을 이용하는 방식. Server가 JSON Token을 보내주면 Client 측에서 localStorage 또는 cookie에 담는다. Login 완료 후 main page로 이동할 때, Routing이 발생할 때마다 Token을 header에 담아서 보내는 처리가 필요하다. 그러나 매번 header를 setting하기가 번거로우므로 HttpIntercepter를 사용하면 HTTP Request 전후에 특정 기능을 실행할 수 있다.","link":"/2019/06/25/Angular-RxJS/"},{"title":"11. Function","text":"What is a Function?수학에서 함수는 input을 받아 output을 내보내는 일련의 과정(series of processes)을 정의한 것이다. 프로그래밍 언어에서 함수는 input을 받아 output을 내보내는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다. 함수의 구성 요소로는, parameter(매개변수) : input을 함수 내부로 전달받는 변수 argument(인수) : input return value(반환값) : output 함수는 식별자로 함수명을 사용한다. 함수는 함수를 정의함으로써 생성된다. 생성된 함수를 실행시키기 위해서는 함수를 호출해야한다. Why use a function?함수를 사용해야 하는 이유는 다음과 같다. 동일한 작업을 반복적으로 수행할 때 함수를 호출해 코드를 재사용하기 위해서 사용 중복되는 코드를 제가해서 유지보수의 효율성을 높이기 위해서 사용 함수의 이름으로 기능을 명시해 코드의 가독성을 높일 수 있다. Function LiteralJust as objects are created as object literals, functions can also be created as function literals. Function literal consists of function keyword, function name, list of parameters and function body. A function literal is evaluated to create a function object. Function name Since the function name is an identifier, it must conform to the identifier naming rules. A function name is an identifier that can be referenced only within a function body. The function name can be omitted. A function with a function name is called a named function, and a function without a function name is called an anonymous function. List of parameters Wrap 0 or more parameters in parentheses and separate them with commas. Parameters are assigned arguments. Parameters are treated the same as variables in the function body. Function body It is a block of code that defines the statements to be executed in batches as a unit of execution when the function is called. The function body is executed by a function call. A function literal is evaluated to produce a value, which is an object. In other words, the function of JavaScript is an object. Unlike regular objects, functions can be called and have unique properties. All function objects have [[Call]]. Definition of FunctionThere are 4 ways to define a function. Function Declaration / Function Statement 123function add(x, y) { return x + y;} Function Expression 123var add = function (x, y) { return x + y;} Function Constructor 1var add = new Function('x', 'y', 'return x + y'); Arrow Function (ES6) 1var add = (x, y) =&gt; x + y; Each method defines a function, but there is an important difference. Function DeclarationThe function declaration has the same format as the function literal, but the function name can not be omitted. This is because the JavaScript engine needs to create variables with function names. 1234567// Function Declarationfunction add(x, y) { return x + y;}//Function Calladd(2, 3); //5 The function name is an identifier that can be referenced only within the function body. However, when you call a function outside a function, you use the function name. When a function declaration is executed to create a function object, a variable is needed to assign the function object. This is because the function object can not be stored in memory unless it is allocated anywhere. Therefore, the JavaScript engine Implicitly declares an identifier of the same name as the function name Assigns the created function object to the identifier. 123456789// This is the pseudo code when the above function add statement is executed.// variable add is an identifier created by the JavaScript engine with the same name as the function name implicitly. var add = function add(x, y) { return x + y;};add(2, 3); Function name can only be referenced within a function, and implicitly created variable name can be referenced in the scope where the function is defined. This pseudo code is the following function expression. That is, the JavaScript engine converts function declarations into function expressions to create function objects. Function ExpressionFirst-class objectAn object that can be assigned to a variable, such as a value, which can be the value of a property or an element of an array. Function in JavaScript is a first-class object. It means that a function can be freely used as a value. A function object created with a function literal can be assigned to a variable. This way of defining a function is called a function expression. 123456// Function Expressionvar add = function (x, y) { return x + y;};add(2, 3); Unlike function declarations, function literals can omit function names. It is common to use anonymous functions in function expressions. Since a function name is an identifier that can be referenced only by a function body, even if a named function is used, the function must be called with the variable name to which the function object is assigned. Function Creation time and Function HoistingFunction declarations and function expressions seem to behave similarly, because the JavaScript engine implicitly declares the variable as a function name in the function declaration statement and allocates the created object.However, function declaration is non-expression statement, and function expression is an expression statement. Therefore, there is an important difference. The point at which the function is created is when the JavaScript engine evaluates the function declaration to create the function object. Function declaration statements are executed before runtime because they are declarations themselves. However, function expressions are executed at run-time because they are assignment statements that assign function literals to variables. That is, the function created by the function declaration statement and the function generated by the function expression are created at different times. Functions created with function declarations are executed and hoisted before runtime, but functions created with function expressions are not hoisted. Unlike variable hoisting, in the case of function hoisting, a function object is referenced instead of undefined. Function Constructor Constructor FunctionA constructor function is a function that creates an object. The function constructor function, which is a built-in function provided by JavaScript, receives a parameter list and a function body as a string. It is called with the new operator and returns the created function object. 1234// Function Constructorvar add = new Function('x', 'y', 'return x + y');add(2, 3); However, creating a function as a function constructor is not common. These functions behave differently from function declarations or function expressions. Do not use it! Arrow FunctionAn arrow function introduced in ES6 can make a function simply without a function keyword. 1234// Arrow Functionconst add = (x, y) =&gt; x + y;add(2, 3); The arrow function is not available in all situations. Function Call12// Function Calladd(2, 3); add : Variable name referring to function object, not function name ( ) : Function call operator 2, 3 : Arguments to be assigned to the parameter Calling a function stops the current execution flow and passes control to the called function. At this point, arguments are assigned to the parameters and the statements in the function body begin to execute. Parameter and Argument Parameter Declare when defining a function Treated as variables in the function body When a function is called, the parameter is implicitly created in the function body, initialized to undefined, and then an argument is assigned. The scope of the parameter is inside the function. Argument If the argument is passed less than the parameter, the missing parameter has the value undefined. (No error) If the argument is passed in more than the parameter, the excess argument is ignored and kept in the arguments object. Argument Check123456789function add(x, y) { if (typeof x !== 'number' || typeof y !== 'number') throw new TypeError('Non-number type value has assigned to parameter.'); return x + y;}add(2); // TypeError: Non-number type value has assigned to parameter.add('a', 'b'); // TypeError: Non-number type value has assigned to parameter. It is necessary to check whether the argument is passed properly in the JavaScript function. Because.. JavaScript functions do not check that the number of parameters and arguments match. Because JavaScript is a dynamic type language, functions do not specify the type of parameters in advance. Number of parametersThe smaller the number of parameters, the better. A function with 0 parameters is ideal. The more parameters, the more things to consider when using the function, which leads to errors. Also, if the number or sequence of parameters changes, all the code that calls the function must be modified. The ideal function should only do one thing and make it as small as possible. In addition to functions, classes and other functional units must be as clear and small as possible too. External State Changes and Functional ProgrammingSince functions are objects, they follow pass by reference. Passing a value to a function’s parameters is called as Call by value and Call by reference, but the behavior is the same as Pass by value and Pass by reference. As we saw in 10. Comparing primitive and objects, there is a side effect in which the original object is changed by reference values passed from inside the function body to outside of the function. This is called change of external state. Pure function : functions that do not change any external state (No side effect) Impure function : functions that change the external state inside a function (Side effect) Functional programming is a programming paradigm that avoids state changes by suppressing the use of variables and solves complexity by eliminating conditional statements and loops in the logic through the combination of pure and auxiliary functions. Variable values can be changed by someone at any time, and conditional statements or loop statements can make the flow of logic difficult to understand, which can impair readability and become a root cause of errors. Functional programming is a way to avoid errors and increase the stability of programs by minimizing side effects through pure functions. Return StatementThe function returns the execution result through a return statement consisting of the return keyword and the return value. When the return statement is executed, execution of the function is aborted and the function body is exited. If do not write anything after the return keyword or write a return statement, undefined is returned implicitly. Types of various FunctionsIIFE ( Immediately Invoke Function Expression)A function that executes concurrently with the definition of a function. It is common to use anonymous functions and can not be called again once. 123456// Anonymous immediately invoke function(function(){ var a = 2; var b = 3; return a + b;}()); Even if a named function is used, the function name can not be referenced outside of the function and can not be called again. An immediate function must be enclosed in the group operator (). Otherwise, it will not be identified and an error will occur. If put the code in the immediate function, collision of the variable name or the function name can be prevented. An immediate execution function is used for this purpose. Recursive FunctionA recursive call is to call itself. A function that calls itself is called a recursive function. When creating a recursive function, a base case with an escape condition must be included. Stack overflow occurs when a function is called without escaping. Most of what can be implemented as recursive functions can be implemented as loops. Nested Function / Inner FunctionA function defined inside a function is called a nested function (or inner function). A nested function acts as a helper function of an outer function that contains itself. A nested function can access variables of an outer function, but an outer function can not access variables of a nested function. The nesting of functions means the nesting of the scope. Callback FunctionBecause JavaScript functions are first-class objects, can pass functions as arguments to functions. 123456789101112131415161718// Function that recieves calback functionfunction print(f) { var string = 'Good'; // Determine when to call the callback function passed in parameter and call the function return f(string);}// It calls the print function and passes the callback functionvar upper = print(function (str) { return str.toUpperCase();});// It calls the print function and passes the callback functionvar lower = print(function (str) { return str.toLowerCase();});console.log(upper, lower); //GOOD good The function passed to the print function as an argument is called a callback function. The callback function calls the function that receives the callback function as an argument by determining the point of call. Using a callback function is like pushing a nested function depending on your needs and circumstances. Just as a nested function acts as a helper function to help an outer function, the callback function is passed to the function to serve as a helper function. However, since the nested function is fixed and can not be replaced, the callback function can be freely replaced because it is injected as an argument outside the function. When you pass a callback function from the outside, you can create a function that performs various actions depending on the callback function. That is, it is useful to use the callback function in situations where it is changed instead of being fixed like a nested function. Callback functions are mainly used for event handling, Ajax communication, and higher-order functions.","link":"/2019/05/08/11-Function/"},{"title":"16. Creating an Object with a Constructor Function","text":"객체 리터럴 표기법은 가장 일반적이고 간단한 객체 생성 방법이다. 객체는 객체 리터럴 표기법 외에도 다양한 방법으로 생성할 수 있다. 객체를 생성하기 위한 용도로 사용되는 함수를 생성자 함수라고 한다. 1. Object Constructor Function객체 리터럴 표기법은 분명 간단한 방법이지만, 같은 구조를 가진 객체를 여러 개 만들어야할 경우가 있다. new 연선자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 생성한 빈 객체에 프로퍼티와 메소드를 추가한다. 123456const student = new Object();student.name = 'Park';student.sayHello = function () { console.log('Hi! I am ' + this.name);} Object 생성자 함수는 함수 객체이므로 프로퍼티와 메소드를 갖는다. 앞서 살펴본 Object.getOwnPropertyDescriptor() 또한 Object 생성자 함수의 메소드이다. Constructor 함수는 new 연산자와 함께 호출해서 Object(instance)를 생성하는 함수이다. 생성자 함수에 의해 생성된 객체는 instance라고 한다. Instance생성자 함수도 객체이므로 생성자 함수나 클래스가 생성한 객체를 다른 객체와 구분하기 위해 실체라는 의미로 인스턴스라고 한다. 1.1. Built-in Constructor Function (Wrapper Object)자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의 built-in(intrinsic) 생성자 함수를 제공한다. 이들은 전역객체(window)의 메소드이다. 자바스크립트에서 함수는 객체이므로 Built-in 생성자 함수는 객체로서 메소드도 가진다. 123const obj = new Object('str'); //가능하지만 잘 안 씀const strObj = new String('str');const numObj = new Number(123); String, Number 생성자 함수로 형변환도 가능하지만 잘 안 쓴다. Wrapper Object원시 값을 객체처럼 쓰면 자바스크립트 엔진이 원시값 타입의 객체로 순간 바꾸고 평가한 후 다시 원시 값으로 되돌린다. 이 때 원시값 타입의 객체를 wrapper object라고 부른다. 2. Constructor Function객체 리터럴로 객체를 생성하는 경우 프로퍼티 구조가 동일해도 매번 같은 프로퍼티와 메소드를 작성해야하는 문제가 있다. 객체 리터럴은 한 번 평가되어 값을 만드므로 재사용할 수 없으며 동일한 코드의 중복 또한 문제가 된다. 2.1 Advantages of object creation by constructor function생성자 함수로 객체를 생성하면 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 생성자 함수는 일반 함수와 동일한 방법으로 미리 정의한 후에, new 연산자와 함께 호출했을 때만 생성자 함수로 동작한다. 생성자 함수는 보통 Pascal case로 naming 한다. (ex. Object, Circle, String 등) 123456789101112// Constructor Functionfunction Circle(radius) { // this indicates the instance that the constructor function will create. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}// instance creationconst circle1 = new Circle(5);const circle2 = new Circle(10); new 연산자 없이 함수를 호출하면, 일반 함수로 호출되는 것이므로 this는 전역 객체(window)가 된다. thisthis는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 Self-regerencing variable이다. this가 가리키는 객체는 함수 호출 방식에 따라 동적으로 결정된다. Function call Object this points to As a normal function Global object (window) As a method Object that called a method As a constructor function Instance that a constructor function will create in the future. 12345678910111213function foo () { console.log(this);}// Called as a general functionfoo (); // window// Called as a methodconst obj = { foo }; // ES6 property shorthandobj.foo(); // obj// Called as a constructor functionconst inst = new foo(); // inst 2.3. Internal method [[Call]] and [[Constructor]]함수 객체는 일반 객체와 달리 내부 메소드로 [[Call]]과 [[Constructor]]를 가진다. 내부 메소드 [[Call]]은 함수가 일반 함수로 호출되었을 때 실행되고, 내부 메소드 [[Constructor]]는 함수가 생성자 함수로 호출되었을 때 실행된다. 내부 메소드 [[Call]]이 구현되어 있는 객체를 callable, [[Constuctor]]가 구현되어 있는 객체는 constructor, [[Constructor]]가 구현되어 있지 않은 객체는 non-constructor라고 부른다. 단, arrow function은 constructor function으로 생성할 수 없다. ES6의 메소드 축약 표현으로 선언한 메소드 또한 non-constructor이다. 따라서 모든 함수는 callable이지만 모두 constructor인 것은 아니다. 2.4. constructors and non-constructors자바스크립트 엔진은 함수 생성시 FunctionCreate라는 abstract operation을 사용한다. Abstract operation FunctionCreate는 함수 정의가 평가될 때 호출된다. 함수 정의 방식에 따라서 FunctionCreate의 kind parameter에 함수의 종류를 나타내는 문자열이 전달된다. Kinds Strings 일반 함수 정의(함수 선언문, 함수 표현식) 평가 Normal 화살표 함수 정의 평가 Arrow 메소드 정의 평가 Method 일반 함수로 정의된 함수만 constructor, Arrow나 Method는 con-constructor이다. 이 때 주의해야할 점은 ES6의 메소드 축약 표현만을 메소드 정의로 인정한다는 것이다. 2.5. How the Constructor Function Works생성자 함수의 역할은 인스턴스를 생성하는 것과 생성된 인스턴스의 프로퍼티 값을 초기화하는 것이다. 생성자 함수가 호출되면, 자바스크립트 내부에서 빈 객체를 만들고 this에 할당한다. (this binding) 내부 코드를 실행한 후 this를 return한다. 즉, this는 생성자 함수로 생성하는 instance가 된다. 12345678910function Person(name) { // 1. create empty object and bind it to this. this = {} // 2. run internal codes (create property) this.name = name; // 3. return this}console.log(new Person('Park')); // Person {name: 'Park'} 2.6. new Operatornew 연산자와 함께 constructor인 함수를 호출하면 함수는 생성자 함수로 동작한다. 이 때 함수 객체의 내부 메소드 [[Constructor]]가 호출된다. 함수 내부의 this는 생성자 함수가 생성할 instance를 가리킨다. new 연산자 없이 함수를 호출하면 함수 객체의 내부 메소드 [[Call]]이 호출된다. 이 때 함수 내부의 this는 전역 객체 window를 가리킨다. 2.7. new.targetnew 연산자 없이 생성자 함수를 호출하는 것을 방지하기 위해서 ES6에서 new.target을 지원한다. new.target은 함수 내부에서 지역 변수와 같이 사용되는 meta property이다. (IE는 new.target을 지원하지 않음!) 함수가 new 연산자와 함께 호출되면 new.target은 함수 자신을 가리키고, new 연산자 없이 호출된 함수 내부의 new.target은 undefined이다. new 연산자와 함께 호출된 생성자 함수로부터 생성된 instance는 프로토타입에 의해 생성자 함수와 연결된다.","link":"/2019/05/10/16-Creating-an-Object-with-a-Constructor-Function/"},{"title":"17. Function and First-class Object","text":"1. First-class Object자바스크립트에서 함수는 객체이며 값처럼 사용할 수 있다. 값처럼 사용할 수 있는 객체를 일급 객체라고 한다. 자바스크립트의 함수는 일급 객체(first-class object)이다. First-class Object 런타임에 무명의 리터럴로 생성할 수 있다. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다. 함수의 매개변수로 전달될 수 있다. 함수의 반환값으로 사용될 수 있다. 123456789101112131415161718192021222324252627282930313233343536// 1. 무명의 리터럴로 생성할 수 있다.// 2. 변수나 자료 구조에 저장할 수 있다.// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.const increase = function (num) { return ++num;};const decrease = function (num) { return --num;};// 함수 객체를 객체에 저장할 수 있다.const predicates = { increase, decrease };function makeCounter(predicate) { let num = 0; // 4. 함수의 반환값으로 사용할 수 있다. return function () { num = predicate(num); return num; };}// 3. 함수의 매개변수에게 전달할 수 있다.// makeCounter의 매개변수에게 함수 객체를 전달const increaser = makeCounter(predicates.increase);console.log(increaser()); // 1console.log(increaser()); // 2// makeCounter의 매개변수에게 함수 객체를 전달const decreaser = makeCounter(predicates.decrease);console.log(decreaser()); // -1console.log(decreaser()); // -2 자바스크립트의 함수는 일급객체의 조건을 모두 만족하는 일급 객체이다. 따라서 함수는, 무명의 리터럴로 생성할 수 있으므로 어디에서나 정의할 수 있다. 함수를 변수나 자료구조의 값으로 할당할 수 있다. 함수를 값처럼 매개변수로 전달할 수 있다. 함수에서 함수를 반환할 수 있다. 자바스크립트의 함수가 일급 객체이므로 함수형 프로그래밍을 할 수 있다. Functional Programming함수형 프로그래밍이랑 Pure function과 보조 함수의 조합을 통해 외부 상태를 변경하는 side-effect를 최소화하여 immutability를 지향하는 프로그래밍 패러다임이다. 함수형 프로그래밍 패러다임에서 함수를 매개변수에 전달하거나 반환하는 함수를 Hign Order Function이라고 한다. 함수는 객체이지만 일반 객체와 달리 호출할 수 있다. 함수 객체는 일반 객체에는 없는 함수 고유의 프로퍼티를 소유한다. 2. Property of Function Object 함수 객체와 일반 객체를 각각 콘솔에 찍어보면 함수 객체에는 일반 객체에 없는 프로퍼티들이 있다. 함수 객체 내에는 arguments, caller, length, name, prototype 프로퍼티가 존재한다. __ proto __ 프로퍼티는 함수 객체, 일반 객체에 모두 존재한다. 123456789101112131415161718192021222324function add() {};// function object의 Data property들Object.getOwnPropertyDescriptor(add, 'arguments');// {value: null, writable: false, enumerable: false, configurable: false}Object.getOwnPropertyDescriptor(add, 'caller');// {value: null, writable: false, enumerable: false, configurable: false}Object.getOwnPropertyDescriptor(add, 'length');// {value: 0, writable: false, enumerable: false, configurable: true}Object.getOwnPropertyDescriptor(add, 'name');// {value: \"add\", writable: false, enumerable: false, configurable: true}Object.getOwnPropertyDescriptor(add, 'prototype');// {value: {…}, writable: true, enumerable: false, configurable: false}// __proto__는 function object가 아닌, Object.prototype으로부터 상속받은 Accessor property이다.Object.getOwnPropertyDescriptor(add, '__proto__');// undefinedObject.getOwnPropertyDescriptor(Object.prototype, '__proto__');// {get: ƒ, set: ƒ, enumerable: false, configurable: true} 함수 객체의 데이터 프로퍼티 : argunemts, caller, length, name, prototype __ proto __는 접근자 프로퍼티로, Object.prototype객체의 프로퍼티를 상속받은 것. 2.1 arguments Propertyarguments 프로퍼티의 value는 arguments 객체이다. arguments 객체는 함수 호출 시 전달된 argument들의 정보를 담고 있는 iterable array-like object이며, 함수 내부에서만 참조 가능하다. arguments Property함수 객체의 arguments property는 일부 브라우저에서 지원하고 있으나 ES3부터 표준에서 페지되었다. arguments 프로퍼티를 통해서가 아니라 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체를 직접 참조하는 것이 좋다. arguments Object argument들을 value로 가진다. 0, 1, 2 등 key는 argumet의 전달 순서를 나타낸다. callee: 호출된 함수, 즉 arguments 객체를 생성한 함수를 가리킨다. length: argument의 개수 Symbol(Symbol.iteraor): arguments object를 순회 가능한 iterable 자료 구조로 만들기 위한 프로퍼티. arguments object는 parameter의 개수를 확정할 수 없는 가변 인자 함수 (Variable Argument Function)를 구현할 때 유용하게 사용한다. 123456789function sum() { let result = 0; // arguments 객체는 length property를 가진 array-like object이므로 iterable하다. for (let i = 0; i &lt; arguments.length; i++) result += arguments[i]; return result;} Array-like Object란 length property를 가진 객체로, 실제 배열이 아니지만 for 문 등으로 순회할 수 있는 객체를 말한다. 배열이 아니므로 배열 메소드를 사용하면 에러가 발생한다. arguments object에 reduce, for…each 등 고차 함수를 사용하기 위해 배열로 변환한 후 사용하기도 한다. ES6에서는 argument를 배열로 사용하기 위해 Rest parameter를 도입했다. 2.2. caller Propertycaller property는 ECMAScript spec에 포함되지 않은 비표준 프로퍼티이다. 함수 객체의 caller property는 함수 자신을 호출한 함수를 가리킨다. 123456789101112131415function foo(func) { return func();}function bar() { return 'caller : ' + bar.caller;}// 브라우저에서의 실행 결과console.log(foo(bar)); // caller : function foo(func) {...}console.log(bar()); // caller : null// Node.js에서의 실행 결과console.log(foo(bar)); // caller : function foo(func) {...}console.log(bar()); // caller : function (exports, require, module, __filename, __dirname) {전역 코드 전체} 2.3 length Property함수 객체의 length property는 함수 정의 시 선언한 매개변수의 개수를 가리킨다. 12345function add(a, b, c) { return a + b +c;}console.log(add.length) //3 arguments Object의 length property와 Function Object의 length property의 값은 다름을 알고 넘어가자. arguments Object’s length property : 넘겨받은 argument의 개수 Function Object’s length property : 함수에 정의된 parameter의 개수 2.4. name Property함수 객체의 name property는 함수명을 나타낸다. ES6에서 정식 표준이 되었다. 익명 함수의 경우 ES5에서 name property는 빈 문자열이지만 ES6에서는 함수 객체를 가리키는 변수명을 값으로 갖는다. (함수 선언문일 경우 함수명과 동일한 변수명, 익명 함수 표현식일 경우 함수 표현식을 할당한 변수명) 2.5. _proto_ Accessor Property모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. [[Prototype]] 내부 슬롯은 프로토타입 객체를 가리킨다. _proto_ property는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티. 123456const obj = { key: 'value' };console.log(obj.__proto__ === Object.prototype); // trueconsole.log(obj.hasOwnProperty('key')); // trueconsole.log(obj.hasOwnProperty('__proto__')); // false 2.6. prototype Propertyprototype Property는 함수 객체만이 소유하는 프로퍼티이다. prototype Property는 함수가 객체를 생성하는 생성자 함수로 사용될 때 생성자 함수가 생성할 객체의 프로토타입 객체를 가리킨다. 즉, prototype Data Property는 함수가 생성자로 동작하여 생성할 instatnce의 prototype 객체를 가리키고 _proto_ Accessor Property는 자신을 생성한 생성자 함수의 prototype 객체, 즉 자신이 상속받은 prototype 객체를 가리킨다. 12345678910111213function Circle(radius) { this.radius = radius;}const circle2 = new Circle(2);console.log(Circle.prototype === circle2.__proto__); // truefunction Person(name) { this.name = name;}console.log(Person.__proto__ === Circle.__proto__); // true","link":"/2019/05/12/17-Function-and-First-class-Object/"},{"title":"15. Property Definition","text":"1. What is Property Definition?프로퍼티 정의란 프로퍼티 어트리뷰트의 값을 정의하여 프로퍼티의 상태를 관리하는 것이다. 예를 들면 프로퍼티 값을 갱신 가능하도록 할 것인지(writable), 프로퍼티를 열거 가능하도록 할 것인지(enumarable), 재정의 가능하도록 할 것인지(configurable)를 정의할 수 있다. 객체 리터럴이 평가되거나 프로퍼티가 동적 생성될 때 프로퍼티가 생성된다. 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다. 12345678const obj = {};//Dynamic creation of properties. The JavaScript engine creates the property and defines the property's attributes as the default.obj.prop = 10;var descriptor = Object.getOwnPropertyDescriptor(obj, 'prop');console.log(descriptor);// {value: 10, writable: true, enumerable: true, configurable: true} 프로퍼티 동적 생성은 프로퍼티가 존재하지 않을 때 프로퍼티를 생성하여 추가하는 것이다. 프로퍼티 정의는 프로퍼티 어트리뷰트를 정의하는 것을 말한다. 프로퍼티 어트리뷰트는 프로퍼티의 상태를 나타낸다. 프로퍼티의 상태란 프로퍼티의, value writable enumerable configurable 프로퍼티 어트리뷰트는 Object.getOwnPropertyDescriptor 메소드를 사용해 참조할 수 있다. 이 메소드는 프로퍼티 어트리뷰트를 객체로 표현한 PropertyDescriptor 객체를 반환한다. 존재하지 않는 프로퍼티나, 상속받은 프로퍼티에 대한 PropertyDescriptor를 요구하면 undefined가 반환된다. 프로퍼티가 동적 생성될 때 자바스크립트 엔진은 프로퍼티 어트리뷰트를 기본값으로 정의한다. 이미 정의된 프로퍼티 어트리뷰트를 재정의할 수도 있다. 2. Internal Slot / MethodInternal slot and internal method는 ECMAScript 스펙에서 요구하는 객체 관련 내부 상태와 내부 동작을 정의한 것이다. ECMAScript 스펙에서 [[...]]로 감싼 이름들이 내부 슬롯과 내부 메소드이다. Internal slot과 method는 자바스크립트 엔진의 내부 구현 사양을 정의한 것이므로 외부에 노출되지 않는다. 객체의 프로퍼티 키로 프로퍼티 값에 접근할 때 [[Get]] 내부 메소드가 내부적으로 호출된다. [[Get]] 내부 메소드는 다음과 같이 동작한다. 프로퍼티 키가 유효한지 확인한다. (문자열 또는 심볼) 프로토타입 체인에서 프로퍼티를 검색한다. Prototype and Prototype Chain프로토타입은 어떤 객체의 parent 객체 역할을 하는 객체이다. 프로토타입은 Child 객체에게 자신의 프로퍼티와 메소드를 상속한다. Prototype객체의 프로퍼티나 메소드를 상속받은 child 객체는 parent 객체의 프로퍼티나 메소드를 자유롭게 사용한다. 프로토타입 체인은 프로토타입 객체가 연결되어있는 상속 구조이다. 어떤 객체의 프로퍼티나 메소드에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티나 메소드가 없다면 프로토타입 체인을 따라 상위(부모) 객체의 프로퍼티나 메소드를 차례대로 검색한다. 검색된 프로퍼티가 Data property라면 프로퍼티 값(데이터 프로퍼티의 프로퍼티 어트리뷰트 [[Value]])의 값을 그대로 반환한다. 만약 검색된 프로퍼티가 Accessor property라면 접근자 프로퍼티의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하고 그 결과를 반환한다. 함수 객체에는 [[Call]]이라는 고유한 internal method가 있다. [[Call]]은 함수를 호출하면 내부적으로 호출된다. 이는 일반 객체에는 없는 함수 객체만의 고유한 internal method이다. Abstract OperationECMAScript 스펙에서 Abstract operation으로 구현 방향을 제시한다. ECMAScript의 내부 동작을 이해하기 위해서 읽으면 좋음.. 3. Accessor Property프로퍼티는 Data property와 Accessor property로 구분할 수 있다. Data property 키와 값으로 구성된 일반 프로퍼티. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티이다. Accessor property 자체적으로는 값을 갖지 않고 다른 data property의 값을 읽거나 저장할 때 사용되는 Accessor function으로 구성된 프로퍼티 Accessor function은 getter / setter 함수라고도 부른다. 1234567891011121314151617181920212223const student = { // Data property name: 'Park', // Accessor property get infoName() { return this.name; }, set infoName(newName) { this.name = newName; }};// A reference to a property value through a data property.console.log(student); // {name: \"Park\", age: 25}// Setting Property Values with Accessor Properties// If store the value in the accessor property infoName, the setter function is called.student.infoName = 'Kim';console.log(student); // {name: \"Kim\", age: 25}// Getting Property Values with Accessor Propertiesconsole.log(student.infoName); // Kim student 객체의 name은 일반적인 데이터 프로퍼티이다. get infoName은 getter 함수, set infoName은 setter 함수이고 함수의 이름인 infoName이 바로 접근자 프로퍼티이다. 접근자 프로터티는 값([[Value]] attribute)을 가지지 않고 데이터 프로퍼티의 값을 읽거나(get) 저장(set)할 때 동작한다. Accessor property infoName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] internal method가 호출되어 다음과 같이 동작한다. 프로퍼티 키가 유효한지 확인한다. (문자열 또는 숫자인지) 프로토타입 체인에서 프로퍼티를 검색한다. 검색된 infoName 프로퍼티가 data property인지 accessor property인지 확인한다. infoName은 Accessor property이다. Accessor property infoName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출해 결과를 반환한다. 프로퍼티 infoName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDescriptor 메소드가 반환하는 프로퍼티 디스크립터(PropertyDescriptor) 객체의 get 프로퍼티 값과 같다. Accessor property와 data property의 구별 방법 1234567// The __proto__ of a generic object is an accessor property.Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');// {get: ƒ, set: ƒ, enumerable: false, configurable: true}// The prototype of a function object is a data property.Object.getOwnPropertyDescriptor(function() {}, 'prototype');// {value: {…}, writable: true, enumerable: false, configurable: false} Accessor property와 data property의 property descriptor object의 프로퍼티가 다르다. 4. Property Attribute모든 프로퍼티는 자신의 상태와 동작을 정의한 내부 슬롯 / 메소드를 가진다. 이것들을 property attribute라고 한다. Property attribute는 자바스크립트 엔진이 프로퍼티를 생성할 때 default로 자동 정의된다. Data Property Attributes Property Attribute Description Property of Property Descriptor Object [[Value]] - 프로퍼티 키로 프로퍼티 값에 접근하면 내부 메소드 [[Get]]에 의해 반환되는 값- 프로퍼티 키로 프로퍼티 값을 저장하면 [[Value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다. value [[Writable]] - 프로퍼티 값의 변경 가능 여부. Boolean- [[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다. writable [[Enumarable]] - 프로퍼티의 열거 가능 여부. Boolean- [[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다. enumerable [[Configurable]] - 프로퍼티의 재정의 가능 여부. Boolean- [[Configurable]]의 값이 false인 경우, 해당 프로퍼티의 삭제와 프로퍼티 어트리뷰트 값의 변경이 금지된다. - 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. configurable Accessor Property Attributes Property Attribute Description Property of Property Descriptor Object [[Get]] - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수 - 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값인 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환 get [[Set]] - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수 - 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값인 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환 set [[Enumerable]] Same as Data Property’s [[Enumerable]] enumerable [[Configurable]] Same as Data Property’s [[Configurable]] configurable","link":"/2019/05/09/15-Property-Definition/"},{"title":"20. this","text":"1. this Keywordthis는 객체가 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다. 함수 호출시 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. arguments 객체와 this는 함수 내부에서 지역 변수처럼 사용할 수 있다. this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정된다. C++, Java와 같은 클래스 기반 언어에서 this는 항상 클래스로부터 생성되는 인스턴스를 가리킨다. 그러나 자바스크립트의 this는 함수가 호출되는 방식에 따라서 this에 바인딩될 객체가 동적으로 결정된다. Binding바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 객체 리터럴은 할당 단계에 평가되므로 객체의 식별자를 this 대신 사용할 수 있지만, 일반적이지 않다. 생성자를 이용해서 객체를 생성할 때는 인스턴트를 가리킬 식별자를 미리 알 수 없기 때문이다. this는 객체의 프로퍼티나 메소드를 참조하기 위한 변수이므로 객체의 메소드 또는 생성자 함수에서만 의미가 있다. strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩 된다. 적용되지 않을 경우 일반 함수 내부에서 this는 전역 객체 window를 가리킨다. strict mode‘use strict’; strict mode는 자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다. 2. Function call types and this Binding스코프의 경우 렉시컬 스코프(Lexical Scope)는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프가 결정된다. this에 바인딩될 객체는 함수 호출 시점에 결정된다. 함수 호출 방식은 다음과 같다. 일반 함수 호출 : this는 window 메소드 호출 : this는 메소드를 호출한 객체 생성자 함수 호출 : this는 생성할 instance Function.prototype.apply/call/bind 메소드에 의한 간접 호출 2.1. General Function Call일반 함수로 호출된 함수 내부의 this에는 전역 객체(Global Object)가 바인딩된다. 전역 함수는 물론 중첩 함수를 일반 함수로 호출했을 때에도 함수 내부의 this에는 전역 객체가 바인딩된다. 일반 함수에서는 this로 객체의 프로퍼티나 메소드를 참조할 일이 없으므로 this에 의미가 없다. 12345678function foo() { console.log('foo this: ', this); // window function bar() { console.log('bar this: ', this); // window } bar();}foo(); 메소드 내에서 정의한 중첩 함수일지라도 일반 함수로 호출되면 중첩 함수의 this는 전역 객체이다. 123456789101112const obj = { foo() { console.log('foo this: ', this); // {foo: f} function bar() { console.log('bar this: ', this); // window } // 메소드 내부에서 정의한 중첩 함수라도 일반 함수로 호출하면 this에 전역 객체가 바인딩된다. bar(); }};obj.foo(); 마찬가지로 콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 정리하면 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다. 메소드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메소드의 this 바인딩과 일치시키기 위한 방법은 다음과 같다. this를 변수에 저장하고 콜백 함수의 this를 변수로 대체 123456789const obj = { value: 100, foo() { cosnt that = this; setTimeout(function () { console.log(that.value); // 100 }, 100) }}; Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메소드 이용 123456789const obj = { value: 100, foo() { // bind method의 argument를 콜백 함수의 this로 바인딩한다. setTimeout(function () { console.log(this.value); // 100 }.bind(this), 100) }}; 2.2. Method Call메소드 내부의 this는 메소드를 호출한 객체, 즉 메소드 호출시 (.) 연산자 앞에 오는 객체에 바인딩된다. 메소드를 소유한 객체가 아닌, 메소드를 호출한 객체에 바인딩된다는 것을 주의해야 한다. 123456789101112131415161718function Person(name) { this.name = name;}Person.prototype.getName = function () { return this.name;};const me = new Person('Park');const you = { name: 'Kim'};you.getName = me.getName;console.log(me.getName()); // \"Park\"console.log(you.getName()); // \"Kim\" 2.3. Constructor Function Call생성자 함수 내부의 this에는 생성자 함수가 생성할 instance가 바인딩된다. 생성자 함수는 객체(instance)를 생성하는 함수로, new 연산자와 함께 호출되면 빈 객체를 만들고 this에 바인딩한다. 연산을 하며 this 객체를 완성시킨 후 this를 리턴한다. 함수가 new 연산자와 함께 호출되지 않아 일반 함수로 동작할 경우 this는 전역 객체를 가리킨다. 2.4. Indirect Call by Function.prototype.apply / call / bind methodapply, callFunction.prototype의 메소드 apply와 call은 argument로 this와 arguments list를 전달받아 함수를 호출한다. Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 Function.prototype.apply와 call을 상속받아 사용할 수 있다. 1234567/** * 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출한다. * @param thisArg - this로 사용될 객체 * @param argsArray - 함수에게 전달할 인수 리스트 배열 * @returns 호출된 함수의 반환값 */Function.prototype.apply(thisArg, [argsArray])) 1234567/** * 주어진 this 바인딩과 인수 리스트를 사용하여 함수를 호출한다. * @param thisArg - this로 사용될 객체 * @param arg1, arg2, ... - 함수에게 전달할 인수 리스트 * @returns 호출된 함수의 반환값 */Function.prototype.call(thisArg, arg1, arg2, ...)) 두 메소드의 차이는, apply 메소드는 호출할 함수의 arguments를 배열로 묶어 전달한다. call 메소드는 호출할 함수의 arguments를 쉼표로 구분한 리스트 형식으로 전달한다. apply와 call은 호출할 함수에 argument를 전달하는 방식만 다를 뿐, this로 사용할 객체와 argument를 전달하며 함수를 호출한다. bindbind 메소드는 메소드의 this와, 메소드 내부의 중첩함수 또는 콜백 함수의 this가 불일치하는 문제를 해결할 때 사용된다. 콜백 함수 foo는 외부 함수 callName을 돕는 헬퍼 함수(보조 함수)의 역할을 해야하기 때문에 외부 함수 내부의 this와 콜백함수 내부의 this가 다르면 문제가 발생한다. 이 때 bind 메소드를 사용해서 this를 일치시킨다. apply와 call 메소드 또한 사용할 수 있다. 12345678910111213function Person(name) { this.name = name;}Person.prototype.callName = function (callback) { callback.bind(this)(); // callback.apply(this); // callback.apply(this);}function foo() { console.log(this.name);} bind로 this를 전달한 callback을 실행할 수도 있고, apply나 call로 this를 전달하며 동시에 호출할 수도 있다. 정리하면 this 바인딩은 다음과 같이 실행된다. 함수 호출 방식 this 바인딩 일반 함수 호출 전역 객체 메소드 호출 메소드를 호출한 객체 생성자 함수 호출 생성자 함수가 생성할 instance Function.prototype.apply/call/bind 메소드에 의한 간접 호출 Function.prototype.apply/call/bind 메소드에 argument로 전달한 객체 3. this in Arrow Function일반 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다. 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다. 동적으로 결정되는 일반 함수와는 달리 화살표 함수의 this 언제나 상위 스코프의 this를 가리킨다. 이를 Lexical this라 한다. 123456789$completedAll.addEventListener('click', (e) =&gt; { console.log(this); // window completeAllTodos(e.target);});$completedAll.addEventListener('click', function (e) { console.log(this); // $completedAll completeAllTodos(e.target); });","link":"/2019/05/15/20-this/"},{"title":"24. Higher Order Function","text":"고차 함수(Higher order function)함수를 인자(paremeter)로 전달받거나 함수를 결과로 반환하는 함수. 고차 함수는 parameter로 받은 함수를 필요한 시점에 호출하거나 클로저를 생성해서 리턴한다. 자바스크립트에서 함수는 FIrst-class object이므로 값처럼 parameter 로 전달하고 리턴할 수 있다. 고차 함수는 외부에서 전달되는 보조 함수(Helper function)에 따라서 다른 동작을 수행할 수 있다. 함수는 선언된 위치의 스코프를 기억하므로 고차 함수가 클로저를 리턴하고 끝나도 클로저에 의해 참조되고 있는 고차 함수 내부의 변수는 소멸하지 않는다. 이렇게 클로저가 참조하고 있어 스코프가 유지되는 변수를 자유 변수(Free variable)라고 한다. 12345678910function makeAdder(x) { var y = 1; return function(z) { y = 100; return x + y + z; };}const add5 = makeAdder(5);const add10 = makeAdder(10); 함수형 프로그래밍 불변성(Immutability) 지향 : 외부 상태 변경이나 가변(mutable) 데이터를 피함 순수 함수(Pure function) 사용 : 외부 상태를 변경하지 않는 순수 함수를 통해서 side effect를 최대한 억제 고차 함수는 순수 함수와 보조 함수의 조합을 통해 프로그램의 안정성을 높이는 함수형 프로그래밍에 기반을 두고 있다. 1. Array.prototype.sort()숫자 배열 정렬 123456789101112131415161718192021const points = [40, 100, 1, 5, 2, 25, 10];// 숫자 배열 오름차순 정렬// 비교 함수의 반환값이 0보다 작은 경우, a를 우선하여 정렬한다.points.sort(function (a, b) { return a - b; });// ES6 화살표 함수// points.sort((a, b) =&gt; a - b);console.log(points); // [ 1, 2, 5, 10, 25, 40, 100 ]// 숫자 배열에서 최소값 취득console.log(points[0]); // 1// 숫자 배열 내림차순 정렬// 비교 함수의 반환값이 0보다 큰 경우, b를 우선하여 정렬한다.points.sort(function (a, b) { return b - a; });// ES6 화살표 함수// points.sort((a, b) =&gt; b - a);console.log(points); // [ 100, 40, 25, 10, 5, 2, 1 ]// 숫자 배열에서 최대값 취득console.log(points[0]); // 100 객체 배열 정렬 123456789101112131415161718192021const todos = [ { id: 4, content: 'JavaScript' }, { id: 1, content: 'HTML' }, { id: 2, content: 'CSS' }];// 비교 함수function compare(key) { return function (a, b) { // 프로퍼티 값이 문자열인 경우, - 산술 연산으로 비교하면 NaN이 나오므로 비교 연산을 사용한다. return a[key] &gt; b[key] ? 1 : (a[key] &lt; b[key] ? -1 : 0); };}// id를 기준으로 정렬todos.sort(compare('id'));console.log(todos);// content를 기준으로 정렬todos.sort(compare('content'));console.log(todos); 2. Array.prototype.forEach(callback(currentValue[, index[, array]])[, thisArg]) Parametercallback(currentValue[, index, array]) currentValue : 현재 처리할 요소 값 index(option) : 현재 처리할 요소의 인덱스 array(option) : forEach()를 호출한 배열 thisArg (option) ​ callback이 실행될 때 this로 사용할 값 Return Valueundefined forEach 메소드는 for 문 대신 사용 가능 for 문보다 성능이 좋지는 않지만 가독성이 좋으므로 사용이 권장된다. break 문을 사용할 수 없어 중단 없이 배열의 모든 요소를 순회한다. IE 9 이상에서 정상 동작 123456const numbers = [1, 2, 3, 4, 5];let pows = [];numbers.forEach((item) =&gt; pows.push(item ** 2));console.log(pows); forEach 메소드는 this를 수정할 수 없지만 callback 함수는 세 번째 인자로 넘겨받은 원본 배열과 forEach 메소드의 두번째 인자로 넘겨받은 this를 수정할 수 있다. 12345678910111213141516function Square() { this.array = [];}Square.prototype.multiply = function (arr) { console.log(this); // multiply가 메소드로 호출되었으므로 this는 square 객체 : Square { array: [] } arr.forEach(function (item, index, array2) { console.log(this); // Square { array: [] } (1.에서 바인딩된 this) console.log(array2); // [1, 2, 3] this.array.push(item * item); }, this); // 1. this를 callback의 this로 바인딩};const square = new Square(); // Square { array: [] }square.multiply([1, 2, 3]);console.log(square.array); // [ 1, 4, 9 ] 3. Array.prototype.map(callback(currentValue[, index[, array]])[, thisArg]) Parametercallback(currentValue[, index, array]) currentValue : 현재 처리할 요소 값 index(option) : 현재 처리할 요소의 인덱스 array(option) : forEach()를 호출한 배열 thisArg (option) ​ callback이 실행될 때 this로 사용할 값 Return Value배열의 각 요소에 대해 실행한 callback의 리턴 값(리턴 필수)으로 이루어진 새로운 배열 4. Array.prototype.filter(callback(currentValue[, index[, array]])[, thisArg]) Parametercallback(currentValue[, index, array]) currentValue : 현재 처리할 요소 값 index(option) : 현재 처리할 요소의 인덱스 array(option) : forEach()를 호출한 배열 thisArg (option) ​ callback이 실행될 때 this로 사용할 값 Return Valuecallback 테스트를 통과한 요소로 이루어진 새로운 배열. 조건에 부합하지 않아 리턴된 요소가 없으면 빈 배열을 리턴 123456const result = [1, 2, 3, 4, 5].filter(function (item, index, self) { console.log(`[${index}] = ${item}`); return item % 2; // return true인 item만 새로운 배열에 추가한다.});console.log(result); // [ 1, 3, 5 ] 5. Array.prototype.reduce(callback[, initialValue]) Parametercallback accumulator : accumulator(누산기)는 callback의 리턴값을 누적한다. imitialValue가 제공된 경우에는 initialValue로 초기화되어 시작하고, 아닌 경우 callback의 이전 리턴값이다. currentValue : 현재 처리할 요소 값 currentIndex(option) : 현재 처리할 요소의 인덱스. initialValue가 제공된 경우 0. 아니면 1부터 시작 array(option) : reduce()를 호출한 배열 initialValue(option) ​ callback의 최초 호출에서 첫번째 argument에 제공하는 초기값. 초기값을 제공하지 않을 경우 배열의 첫번쨰 요소를 사용. (빈 배열에서 초기값 없이 reduce() 호출시 에러) Return Value누적 계산 결과 값 123456789101112131415161718192021222324252627const arr = [1, 2, 3, 4, 5];/*previousValue: 이전 콜백의 반환값currentValue : 현재 처리할 배열 요소의 값currentIndex : 현재 처리할 배열 요소의 인덱스array : 메소드를 호출한 배열*/const sum = arr.reduce(function (previousValue, currentValue, currentIndex, array) { console.log(previousValue + '+' + currentValue + '=' + (previousValue + currentValue)); return previousValue + currentValue; // 결과는 다음 콜백의 첫번째 인자로 전달된다});/*1+2=33+3=66+4=1010+5=15*/console.log(sum); // 15: 1~5까지의 합const max = arr.reduce(function (prev, cur) { return prev &gt; cur ? prev : cur;});console.log(max); // 5: 최대값 6. Array.prototype.some(callback [, thisArg]): boolean배열 내 일부 요소가 콜백 함수의 테스트를 통과하는지 확인해서 결과를 boolean으로 반환한다. 7. Array.prototype. every(callback [, thisArg]): boolean배열 내 모든 요소가 콜백 함수의 테스트를 통과하는지 확인해서 결과를 boolean으로 반환한다. 8. Array.prototype.find(callback[, thisArg]) Parametercallback element : 현재 처리할 요소 index(option) : 현재 처리할 요소의 인덱스 array(option) : find()를 호출한 배열 thisArg (option) ​ callback이 실행될 때 this로 사용할 객체 Return Valuecallback 테스트를 통과한 첫번째 요소의 값. 못 찾으면 undefined Object.assign(target, …sources) Parametertarget : 대상 객체 sources : 하나 이상의 source 객체 Return Value target(대상 객체) 동일한 키가 존재할 경우 target 객체의 프로퍼티는 source 객체의 프로퍼티로 덮어쓰여진다. Object.assign() 메소드는 enumarable한 source 객체의 프로퍼티만 target 객체의 프로퍼티로 덮어쓴다. source 객체의 프로퍼티가 null이나 undefined이어도 에러를 내지 않는다. Parametercallback(currentValue[, index, array]) currentValue : 현재 처리할 요소 값 index : 현재 처리할 요소의 인덱스 array : forEach()를 호출한 배열 thisArg (option) callback이 실행될 때 this로 사용할 값 Return Valueundefined","link":"/2019/05/20/24-Higher-Order-Function/"},{"title":"33. Promise","text":"What is Promise?자바스크립트는 비동기 처리를 위해서 callback 함수 패턴을 사용한다. 그러나 callback 패턴은 가독성이 나쁘고 에러의 예외 처리가 곤란하다. ES6에서 Asynchronous processing을 위한 패턴으로 Promise를 도입했다. Promise는 비동기 처리를 하고 Response가 오면 해야할 일을 약속하는 것이다. 1. Disadvantages of Callback Pattern1.1. Callback Hell자바스크립트의 Asynchronous Processing Model(non-blocking)은 task를 parallel 처리해서 다른 task가 blocking되지 않는다는 장점이 있다. 그러나 callback 패턴을 사용하면 processing 순서를 위해서 여러 개의 callback 함수가 nesting되어 프로그래밍의 복잡도가 높아진다. 그래서 Callback Hell이 발생한다. 비동기 함수(asynchronous function)의 경우 언제 Request에 대한 Response가 올지 알 수 없으므로 비동기 함수의 처리 결과를 가지고 무언가를 해야할 경우 해당 함수의 callback 함수 내에서 처리해야한다. 이로 인해서 중첩이 계속되어 callback hell이 발생한다. 1.2. Error Handling Limits123456try { setTimeout(() =&gt; { throw 'Error!'; }, 1000);} catch (e) { console.log('에러를 캐치하지 못한다..'); console.log(e);} setTimeout의 argument로 넘겨주는 callback 함수는 setTimeout이 아닌 다른 곳에서 실행된다. setTimeout은 비동기 함수이므로 호출되는 즉시 종료되어 Call Stack에서 제거된다. Exception(예외)는 Caller 방향으로 전파되는데, setTimeout의 callback 함수의 Caller는 setTimeout 함수가 아니므로 catch block에서 exception이 캐치되지 않는다. 이러한 문제를 보완하기 위해서 ES6에서 Promise를 도입했다. IE를 제외한 대부분의 브라우저가 Promise를 지원한다. 2. Creation of PromisePromise constructor function은 비동기 작업을 수행할 callback 함수를 argument로 전달받는다. 이 callback 함수는 resolve, reject 함수를 argument로 전달받는다. 123456789const promise = new Promise((resolve, reject) =&gt; { // Asynchronous process if (/* Asynchronous process Fulilled */) { resolve('result'); } else { /* Asynchronous process Rejected */ reject('failure reason'); }}); Promise는 비동기 처리의 state 정보를 가진다. State Meaning Implementation pending 비동기 처리 수행 전 resolve / reject 함수 호출 전 fulfilled 비동기 처리 수행됨 (성공) resolve 함수 호출된 상태 rejected 비동기 처리 수행됨 (실패) reject 함수 호출된 상태 settled literally 비동기처리 수행됨 (성공 또는 실패) resolve 또는 reject 함수 호출된 상태 4. Post-processing Method of the PromisePromise로 구현된 비동기 함수는 Promise object를 리턴해야한다. Promise로 구현된 비동기 함수를 호출하는 promise consumer는 Promise object의 후속 처리 메소드(then, catch)를 통해서 해당 비동기 함수의 결과 또는 에러메시지를 받아서 처리한다. Promise object의 state에 따라서 후속 처리 메소드를 chaining 방식으로 호출한다. thenthen 메소드는 두 개의 콜백 함수를 argument로 전달받는다. 첫 번째 callback 함수는 성공(fulfilled, resolve 함수가 호출된 상태) 시 호출되고 두 번째 callback은 실패(rejected, reject 함수가 호출된 상태) 시 호출된다. 1234567&gt; p.then(onFulfilled, onRejected);&gt; p.then(function(value) {&gt; // fulfilled&gt; }, function(reason) {&gt; // rejected&gt; });&gt; onFulfilled ​ Promise가 성공했을 때 호출되는 function. Fulfillment value (수행 결과) (Promise의 resolve argument에 넘겨준 response) 하나를 argument로 받는다. Promise를 리턴한다. onRejected ​ Promise가 거부되었을 때 호출되는 function. Rejected reason (에러 이유) (Promise의 regect argument에 넘겨준 error mesagge) 하나를 argument로 받는다. Promise를 리턴한다. catch예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출된다. 123456&gt; p.catch(onRejected);&gt; &gt; p.catch(function(reason) {&gt; // rejected&gt; });&gt; onRejected ​ Promise가 거부되었을 때 호출되는 function. Rejected reason을 argument로 받는다. 5. Error Handling of Promise123456789101112131415161718192021222324const $result = document.querySelector('.result');const render = content =&gt; { $result.innerHTML = JSON.stringify(content, null, 2) };const promiseAjax = (method, url, callback, payload) =&gt; { return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.setRequestHeader('Content-type', 'application/json'); xhr.send(JSON.stringify(payload)); // undefined를 strungify하면 undefined (string 아님) xhr.onreadystatechange = () =&gt; { if (xhr.readyState !== XMLHttpRequest.DONE) return; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) { // 200: GET ok, 201: POST ok // 성공 =&gt; resolve resolve(JSON.parse(xhr.response)); } else { // 실패 =&gt; reject reject(`${xhr.status} ${xhr.statusText}`); } }; });};promiseAjax('GET', 'http://localhost:3000/todos') .then(render) .catch(error =&gt; console.log(`ERROR!: ${error}`)); 비동기 함수 promiseAjax 내부의 비동기 처리시 발생한 에러 메시지는 promiseAjax이 리턴하는 Promise object의 then 메소드의 두번째 argument callback 함수나 catch 메소드로 처리한다. catch 메소드는 then의 두번째 argument callback 함수와 똑같이 에러를 처리하지만, then 뒤에 호출되어 then 내부에서 발생한 에러도 캐치할 수 있다. 따라서 에러 처리는 catch 메소드를 사용하는 게 효율적이다. Async &amp; Await 이용123456789&gt; (async function() {&gt; try {&gt; const res = await promiseAjax('GET', 'http://localhost:3000/todos');&gt; render(res);&gt; } catch(e) {&gt; console.log(`ERROR!: ${e}`);&gt; }&gt; }());&gt; Promise에 async와 await를 이용하면 try, catch로 에러처리를 할 수 있다. 6. Promise ChainingPromise는 후속 처리 메소드를 Chainning해서 여러 개의 Promise를 연결하여 사용할 수 있다. Callback Hell을 해결한다. 여러 개의 Promise를 연결한다는 것은, Promise object의 후속 처리 메소드인 then이나 catch가 또 다른 Promise object를 리턴하도록 하는 것이다. 12345// promiseAjax 함수가 리턴하는 Promise callback에서 JSON.parse 안 하고 리턴할 경우promiseAjax('GET', 'http://localhost:3000/todos') .then(JSON.parse) .then(render) .catch(error =&gt; console.error(`ERROR!: ${error}`)); 7. Static Methods of PromisePromise는 주로 생성자로 사용되지만 4가지 Static method를 갖는다. 7.1. Promise.resolve / Promise.rejectPromise.resolve와 Promise.reject 메소드는 존재하는 값을 Promise로 wrapping하기 위해 사용 Static method resolve는 argument로 전달된 값을 resolve하는 Promise를 생성 12const resolvedPromise = Promise.resolve([1, 2, 3]);resolvedPromise.then(console.log); // [1, 2, 3] Static method reject는 argument로 전달된 값을 reject하는 Promise를 생성 12const rejectedPromise = Promise.reject(new Error('Error!'));rejectedPromise.catch(console.log); // Error: Error! 7.2. Promise.allPromise.all 메소드는 argument로 Promise가 담겨 있는 Iterable을 받는다. 그리고 전달 받은 Promise들을 parallel로 처리하고 결과를 전달받은 순서대로 resolve하는 새로운 Promise를 리턴한다. Promise.all은 Promise가 순서대로 처리되지 않아도 모든 Promise 처리가 완료될 때가지 기다려 순서대로 resolve한다. 즉, 처리 순서를 보장한다. Promise 처리가 하나라도 실패하면 가장 먼저 실패한 Promise가 reject한 에러를 reject하는 Promise를 즉시 리턴한다. 7.3. Promise.racePromise.race 메소드는 Promise.all 메소드와 비슷게 argument로 Promise가 담겨있는 Iterable을 전달받지만, Promise.all과 다르게 가장 먼저 처리된 Promise가 resolve한 결과를 resolve하는 새로운 Promise를 리턴한다.","link":"/2019/05/27/33-Promise/"},{"title":"21. Number, Math and String Object","text":"1. Number wrapper objectNumber 객체 : primitive type number를 다룰 때 유용한 프로퍼티와 메소드를 제공하는 wrapper 객체. 변수 또는 객체의 프로퍼티의 값이 숫자라면 Number 객체를 별도로 생성하지 않고 Number 객체의 프로퍼티와 메소드를 사용할 수 있다. Primitive type이 wrapper 객체의 메소드를 사용할 수 있는 이유: primitive type으로 wrapper 객체의 프로퍼티나 메소드를 호출할 때 일시적으로 해당 타입과 연관된 wrapper 객체로 변환해 프로토타입 객체를 공유하기 때문. 1.1 Number ConstructorNumber 객체는 Number() 생성자 함수를 통해 생성한다. 1234567const x = new Number(123);const y = new Number('123');const z = new Number('string');console.log(x); // 123console.log(y); // 123console.log(z); // NaN new 연산자 없이 Number() 함수를 사용하면 Number 객체가 아니라 primitive type number를 반환한다. 1234567const x = Number(123);const y = Number('123');const z = Number('string');console.log(x); // 123console.log(y); // 123console.log(z); // NaN 이를 이용해 형변환을 할 수 있다. 1.2. Number PropertyNumber 객체의 프로퍼티는 static property로, Number 객체를 생성할 필요 없이 Number.propertyName의 형태로 사용한다. Static PropertyStatic method는 생성자 함수로 인스턴트 객체를 만들지 않아도 생성자 함수의 메소드로 직접 호출 가능하며, 생성자 함수가 생성한 인스턴스 객체에서는 사용할 수 없다. 1.2.1. Number.EPSILONES6Number.EPSILON은 JavaScript에서 표현할 수 있는 가장 작은 수를 나타낸다. EPSILON은 컴퓨터에서 부동소숫점을 표현하는 데에 한계가 있기 때문에 발생하는 오차이다. 컴퓨터가 표현할 수있는 어떤 임의의 수와, 그 바로 다음으로 표현할 수 있는 수와의 차이를 EPSILON이라고 한다. 컴퓨터에서 부동소숫점 수를 비교할 때는 Number.EPSILON을 사용하여 두 수의 차이가 최소 오차인 Number.EPSILON보다 작으면 같은 수로 인정한다. 12345678console.log(0.1 + 0.2 === 0.3); // false// 0.1 + 0.2 = 0.30000000000000004function isEqual(a, b) { return Math.abs(a - b) &lt; Number.EPSILON;}console.log(isEqual(0.1 + 0.2, 0.3)); // true 1.2.2. Number.MAX_VALUEES1Number.MAX_VALUE는 JavaScript에서 사용 가능한 가장 큰 숫자를 반환한다. MAX_VALUE보다 큰 숫자는 Infinity이다. 123Number.MAX_VALUE; // 1.7976931348623157e+308const num = Number.MAX_VALUE + 1; // num = Number.MAX_VALUEconsole.log(Infinity &gt; Number.MAX_VALUE); // true 1.2.3. Number.MIN_VALUEES1Number.MIN_VALUE는 JavaScript에서 사용 가능한 가장 작은 숫자를 반환한다. MIN_VALUE는 0에 가장 가까운 양수 값이다. MIN_VALUE보다 작은 숫자는 0으로 변환된다. 1234567891011Number.MIN_VALUE; // 5e-324function MinEpsilon() { if (Number.MIN_VALUE &gt; Number.EPSILON) { console.log('MIN_VALUE &gt; EPSILON'); } else if (Number.MIN_VALUE &lt; Number.EPSILON) { console.log('MIN_VALUE &lt; EPSILON'); } else console.log('MIN_VALUE = EPSILON');}MinEpsilon(); // MIN_VALUE &lt; EPSILON 1.2.4. Number.POSITIVE_INFINITYES1Number.POSITIVE_INFINITY는 양의 무한대 Infinity를 반환한다. 1Number.POSITIVE_INFINITY // Infinity 1.2.5. Number.NEGATIVE_INFINITYES1Number.NEGTIVE_INFINITY는 음의 무한대 -Infinity를 반환한다 1Number.NEGATIVE_INFINITY // -Infinity 1.2.6. Number.NaNES1Number.NaN은 Not-a-Number를 나타내는 숫자값이다. Number.NaN 프로퍼티는 window.NaN 프로퍼티와 같다. NaN의 type은 number임을 명심하자. 12Number('abc'); // NaNtypeof NaN; // number isNaN methodNaN은 ==나 === 연산자로 NaN인지 판변할 수 없다. 어떤 숫자가 NaN인지 알기 위해서는 isNaN 메소드를 써야하는데, 2가지 종류가 있으며 다르게 동작하니 알아두면 좋다. isNaN() (window.isNaN) : built-in 메소드로, 특이한 형변환을 수행한다. argument가 Number 형이 아닐 경우 값을 순간적으로 Number로 형변환 한 후 NaN인지 검사한다. 즉, argument가 Number로 강제 형변환 될 경우의 NaN 여부를 반환한다. Number.isNaN() : 위의 global isNaN()의 보다 엄격한 버전으로, 주어진 값이 NaN인지 검사한다. 개선된 점으로 argument가 Number 형이고 값이 NaN일 때만 true를, 아니면 false를 반환한다. 즉, argument를 강제로 Number 형으로 변환하지 않고 Number 형이 아닌 argument를 전달받을 경우 false를 반환한다. 1.3. Number MethodNumber 객체의 메소드 1.3.1. Number.isFinite(testValue: number): boolean ES6Number.isFinite() 메소드는 parameter에 전달된 값이 정상적인 유한수인지를 검사하고 결과를 Boolean으로 리턴한다. Number.isFinite()는 전역 함수 isFinite()와 달리 argument를 숫자로 강제 형변환 하지 않는다. 숫자가 아닌 argument가 들어오면 언제나 false를 리턴한다. 123456789Number.isFinite(Infinity); // falseNumber.isFinite(NaN); // falseNumber.isFinite(Number.EPSILON); // trueNumber.isFinite(0); // trueNumber.isFinite('0'); // false// isFinite()와 Number.isFinite()isFinite(null); // trueNumber.isFinite(null); // false 1.3.2. Number.isInteger(testValue: number): boolean ES6Number.isInteger() 메소드는 parameter에 전달된 값이 정수(Integer)인지 검사하고 결과를 Boolean으로 리턴한다. 이 또한 검사 전에 argument를 강제로 Number 형으로 변환하지 않는다. 12345Number.isInteger(3.14); // falseNumber.isInteger(3.0000); // trueNumber.isInteger(3); // trueNumber.isInteger(NaN); // falseNumber.isInteger('string'); // false 1.3.3. Number.isNaN(testValue: number): boolean ES6Number.isNaN() 메소드는 parameter에 전달된 값이 NaN인지를 검사하고 결과를 Boolean으로 리턴한다. 검사 전에 argument를 숫자로 변환하지 않는다. global isNaN()과 다르다. 123456Number.isNaN(true); // falseNumber.isNaN(null); // falseNumber.isNaN(Infinity); // falseNumber.isNaN(37); // falseNumber.isNaN(NaN); // trueNumber.isNaN('string'); // false 1.3.4. Number.isSafeInteger(testValue: number): boolean ES6Number.isSafeInteger() 메소드는 parameter에 전달된 값이 정수 표현 범위 내의 안전한 정수 값인지 검사하고 결과를 Boolean으로 리턴한다. 역시 검사 전에 argument를 숫자로 변환하지 않는다. 안전한 정수 값은 -(253 - 1) 이상 (253 - 1) 이하의 정수를 말한다. 12345Number.isSafeInteger(2**53); // falseNumber.isSafeInteger(2**53 - 1); // trueNumber.isSafeInteger(-(2**53)); // falseNumber.isSafeInteger(-(2**53 - 1)); // trueNumber.isSafeInteger(Infinity); // false 1.3.5. Number.prototype.toExponential(fractionDigits?: number): string ES3Number.prototype.toExponential() 메소드는 호출 대상을 지수 표기법으로 변환하여 문자열로 리턴한다. 지수 표기법(Exponential Notation)이란 큰 숫자를 표기할 때 e(Exponent) 앞에 있는 숫자에 10의 n 제곱을 하는 형식으로 수를 나타내는 방식이다. 12312345 = 1.2345e+30.0000891 = 8.91e-5 12340.0000891.toExponential() // \"8.91e-5\"12345.toExponential() // SyntaxError: Invalid or unexpected token12345 .toExponential() // \"1.2345e+4\"12345.0.toExponential() // \"1.2345e+4\" 12345.toExponential()이 SyntaxError를 발생시키는 이유는 무엇일까? 다른 객체와 달리 숫자값 뒤의 .는 2가지 의미를 가진다. 부동소숫점의 소숫점 구분 기호 객체 프로퍼티에 접근하기 위한 마침표 표기법(Dot Notation) 자바스크립트 엔진은 숫자 뒤의 .를 부동 소숫점 숫자의 일부로 해석한다. 따라서 12345.toExponential()이 숫자가 아니기 때문에 문법 오류로 SyntaxError가 발생하는 것이다. 그렇다면 12345 .toExponential()이 에러를 발생시키지 않는 이유는 무엇일까? .가 숫자 바로 뒤에 오는 것이 아니기 때문에 객체 프로퍼티 접근을 위한 Dot Notation으로 해석했기 때문이다. 1234Object .prototype === Object.prototype; // trueObject. prototype === Object.prototype; //trueObject . prototype === Object.prototype; // true// 띄어쓰기는 Dot Notation에 영향을 주지 않지만 굳이 그렇게 써야할 필요가 없다. 정수 리터럴에 Number.prototype의 메소드를 사용할 경우 아래처럼 괄호로 묶는 것이 권장된다. 1(12345).toExponential() 1.3.6. Number.prototype.toFixed(fractionDigits?: number): string ES3Number.prototype.toFixed() 메소드는 parameter로 지정된 소숫점 자리를 반올림해서 문자열로 리턴한다. 12345678910111213const num = 12345.6789;// default: 0// 소숫점 이하 반올림console.log(num.toFixed()); // '12346'// 소숫점 이하 1자리수에서 반올림console.log(num.toFixed(1)); // '12345.7'// 소숫점 이하 2자리수에서 반올림console.log(num.toFixed(2)); // '12345.68'// 소숫점 이하 3자리수에서 반올림console.log(num.toFixed(3)); // '12345.679'// 소숫점 이하 4자리수에서 반올림console.log(num.toFixed(4)); // '12345.6789' 1.3.7. Number.prototype.toPrecision(precision?: number): string ES3Number.prototype.toPrecision() 메소드는 parameter로 지정된 전체 자릿수(소숫점 자리 아님)까지만 유효하도록 나머지 자릿수를 반올림해서 문자열로 리턴한다. 표현할 수 없는 경우 지수 표기법(Exponential Notation)으로 결과를 반올림한다. 123456789101112131415const num = 12345.6789;// default: 전체 자릿수// 전체 자릿수 유효console.log(num.toPrecision()); // '12345.6789'// 전체 1 자릿수만 유효console.log(num.toPrecision(1)); // '1e+4'// 전체 2 자릿수만 유효console.log(num.toPrecision(2)); // '1.2e+4'// 전체 3 자릿수만 유효console.log(num.toPrecision(3)); // '1.23e+4'// 전체 4 자릿수만 유효console.log(num.toPrecision(4)); // '1.235e+4'// 전체 5 자릿수만 유효console.log(num.toPrecision(5)); // '12346' 1.3.8. Number.prototype.toString(radix?: number): string ES1Number.prototype.toString() 메소드는 숫자를 문자열로 변환해서 리턴한다. radix로 진법(2 ~ 36: 기본 10진수)을 지정할 수 있지만 생략 가능하다. 123456const num = 17;console.log(num.toString()); // '17'console.log(num.toString(2)); // '10001'console.log(num.toString(8)); // '21'console.log(num.toString(16)); // '11' 1.3.9. Number.prototype.valueOf(): number ES1Number.prototype.valueOf() 메소드는 Number 객체의 primitive value를 리턴한다. 12345const numObj = new Number('30');const num = numObj.valueOf();typeof numObj; // objecttypeof num; // number 2. Math ObjectMath Object : 수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 built-in 객체. Math 객체의 프로퍼티와 메소드는 전부 static 프로퍼티와 메소드이다. 생성자 함수 또한 존재하지 않아 직접 Math.property, Math.method()로 호출하면 된다. 2.1. Math Property2.1.1.Math.PIMath.PI는 PI값(&pi;)을 리턴한다. 1Math.PI; // 3.141592653589793 2.2. Math Method2.2.1. Math.abs(x: number): number ES1Math.abs() 메소드는 숫자의 절댓값(Absolute Value)을 리턴한다. Number.prototype의 메소드처럼 엄격한 type 검사를 하지 않는다. 12345678910Math.abs(-1); // 1Math.abs('-1'); // 1Math.abs(-Infinity); // InfinityMath.abs('-Infinity'); // InfinityMath.abs(null); // 0Math.abs([]); // 0Math.abs({}); // 0Math.abs(undefined); // NaNMath.abs('string'); // NaNMath.abs(); // NaN 2.2.2. Math.round(x: number): number ES1Math.round() 메소드는 숫자를 가장 인접한 정수로 올림 또는 내림 한다. 123456Math.round(10.4); // 10Math.round(10.499999999999999); // 10Math.round(10.4999999999999992); // 11Math.round(-10.5); // -10Math.round(-10.500000000000001); // -11Math.round(-10.6); // -11 2.2.3. Math.sqrt(x: number): number ES1Math.sqrt() 메소드는 숫자의 양의 제곱근(square root)을 리턴한다. 1234567Math.sqrt(16); // 4Math.sqrt(-16); // NaNMath.sqrt('16'); // 4Math.sqrt(Infinity); // InfinityMath.sqrt(null); // 0Math.sqrt([]); // 0Math.sqrt({}); // NaN 2.2.4. Math.ceil(x: number): number ES1Math.ceil() 메소드는 숫자를 자신과 가장 가까우면서 큰 정수로 올림한다. Ceil은 천장을 뜻하니 올림한다고 생각하자. 12Math.ceil(3.14); // 4Math.ceil(-3.14); // -3 2.2.5. Math.floor(x: number): number ES1Math.floor() 메소드는 숫자를 자신과 가장 가까우면서 작은 정수로 내림한다. Floor는 바닥을 뜻한다. 12Math.floor(3.14); //3Math.floor(-3.14); // -4 2.2.6. Math.random(): number ES1Math.random() 메소드는 0 이상 1 미만의 임의의 숫자를 리턴한다. 0은 포함하지만 1은 포함하지 않는다는 것에 유의하자. Math.random() 메소드의 결과에 원하는 숫자를 곱해서 PesudoRandom 수를 자유자재로 얻을 수 있다. 12345Math.random(); // 0 이상 1 미만의 소수// 1부터 10까지의 랜덤 정수Math.floor(Math.random() * 10 + 1);Math.ceil(Math.random() * 10); 2.2.7. Math.pow(x: number, y: number): number ES1Math.pow(base, exponent) 메소드는 첫번째 argument를 밑(base), 두번째 argument를 지수(exponent)로 한 거듭제곱을 리턴한다. 1234Math.pow(2, 8); // 256// ES7 Exponentiation Operator2 ** 8; // 256 2.2.8. Math.max(… values: number[]): number ES1Math.max() 메소드는 argument들 중 가장 큰 수를 리턴한다. 12345678Math.max(1, 2, 3, 4, 5); // 5Math.max([1, 2, 3, 4, 5]); // NaNconst arr = [1,2,3,4,5];Math.max.apply(null, arr); // 5// ES6 Spread OpertatorMath.max( ... arr); // 5 Math.max 의 argument로 배열을 전달할 수 없기 때문에 Function.prototype.apply() 메소드를 이용해서 배열 argument를 전달할 수 있었다. 그러나 ES6에서는 Spread Operator의 도입으로 apply() 메소드를 사용하지 않아도 배열을 열거된 list argument처럼 풀어서 전달할 수 있다. 2.2.9. Math.min(… values: number[]): number ES1Math.min() 메소드는 argument들 중 가장 작은 수를 리턴한다. 사용법은 Math.max와 같다. 3. String Object","link":"/2019/05/15/21-Number-Math-Date-and-String-Object/"},{"title":"27. Class","text":"자바스크립트는 Prototype-based 객체지향 언어이다. Prototype-based 프로그래밍은 클래스 없이 프로토타입과 클로저 등으로 상속, 캡슐화 등의 개념을 구현할 수 있다. 대부분의 객체 지향 언어가 클래스 기반인 점을 고려하여 ES6에서 클래스를 도입했다. 그러나 그 클래스도 사실은 함수이고 기존의 프로토타입 기반 객체지향 패턴으로 동작한다. 1. Calss DefinitionES6 클래스는 다른 언어들과 같이 class 키워드를 사용해 정의한다. 12345678910111213class Student { // constructor constructor(name) { this._name = name; } // default method definition: class's prototype method sayHello() { console.log(`Hi! ${this._name}`); }}const mimi = new Student('Mimi');mimi.sayHello(); // Hi! Mimi 표현식으로도 클래스를 정의할 수 있으나 일반적이지 않다. 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근할 수 없기 때문이다. 클래스가 함수처럼 동작하는 것은 사실 클래스도 함수이기 때문이다. 2. Creation of InstanceClass의 instance를 생성하기 위해서는 new 연산자와 함께 constuctor를 호출한다. 클래스 선언식으로 정의한 클래스의 이름은 constructor와 동일하다. 12345678class Foo {}const foo = new Foo();console.log(Foo === Foo.prototype.constructor); // trueconsole.log(Foo === Object.getPrototypeOf(foo).constructor); // trueconst foo2 = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new' new 연산자를 사용하지 않고 constructor를 호출하면 TypeError가 발생한다. 즉, 클래스의 constructor는 new 연산자 없이 호출할 수 없다. new 연산자 없이 호출시 오류 없이 생성자 대신 일반 함수로 호출되던 생성자 함수와 다른 점이다. 3. Constructorconstructor는 인스턴스를 생성하고 클래스 필드를 초기화하는 특수한 메소드이다. Class Field= Data Member, Member Variable. 클래스 내부의 캡슐화된 변수. Instance의 프로퍼티 또는 Static 프로퍼티를 Class field 라고 한다. class 내에는 최대 한 개의 constructor만 존재할 수 있다. new 연산자와 constructor로 인스턴스 생성시 constructor의 파라미터로 전달한 값으로 클래스의 필드를 초기화한다. class 내부에 constructor 정의를 생략하면 default로 constructor() {} 가 동작한다. 즉, 빈 객체 { }를 생성한다. constructor는 인스턴스의 생성과 동시에 클래스 필드의 생성과 초기화를 실행한다. 123456789101112class Foo {}class Bar { constructor(num) { this.num = num; }}const foo = new Foo();console.log(foo); // Foo {}const bar = new Bar(200);console.log(bar); // Bar {num: 200} 4. Class Field클래스 내부에는 메소드만 선언할 수 있다. 모든 프로퍼티(인스턴스의 멤버 변수)는 반드시 constructor 내부에 선언해야 한다. Class Field Declarations Proposal아직 표준은 아니지만 stage3 단계에 Class FIeld 선언 관련된 표준안이 있다. Field Declaration Private Field Static Public Fields 1234567&gt; class Foo {&gt; x = 1; // 생성자 함수 밖에서도 field 선언 가능&gt; #p = 2; // private field&gt; static y = 3; // Static puplic field&gt; // 현재 field declaration만 chrome에 구현됨&gt; }&gt; 12345678910class Student { // default 값 설정 constructor(name = '') { this._name = name; } sayHello() { console.log(`Hi! ${this._name}`); }} constructor 내부의 this는 클래스가 생성할 인스턴스이다. constructor는 this, 즉 생성할 인스턴스에 선언한 프로퍼티를 바인딩한다. 이런 방식으로 constructor는 클래스가 생성할 인스턴스와 인스턴스의 프로퍼티를 생성하고 초기화한다. 클래스 프로퍼티는 언제나 public이다. 생성된 인스턴스를 통해서 클래스 외부에서도 클래스 내부의 프로퍼티에 접근할 수 있다. ES6의 클래스는 다른 객체지향 언어처럼 private, public, protect 등의 Access Modifier(접근 제한자)를 지원하지 않는다. 5. Hoisting클래스는 ES6에서 추가 도입된 let, const와 같이 Hoisting 되지 않는 것처럼 동작한다. 선언 이전에 참조하면 ReferenceError가 발생한다. Hoisting 되지 않는 것처럼 동작한다는 것123&gt; // x 선언 없이 참조&gt; console.log(x); // ReferenceError: x is not defined&gt; 코드 전역에서 x의 선언 없이 x를 참조하면 x is not defined, 즉 정의되지 않았다는 참조 에러가 뜬다. 그러나 let으로 선언하기 전에 x를 참조하면 다르게 동작한다. 1234&gt; // x를 참조하고 밑에서 let 키워드로 선언&gt; x; // ReferenceError: Cannot access 'x' before initialization&gt; let x = 10; &gt; 위와 같이 x가 정의되지 않았다고 하지 않고, initialization 전에 x에 접근할 수 없다는 참조 에러가 뜬다. 왜일까? var 키워드와 다르게 let, const 키워드는 런타임 이전에 자바스크립트 엔진이 선언문을 미리 실행할 때, 1. 선언 단계(Declaration Phase)와 2. 초기화 단계(Initialization Phase)가 함께 진행되지 않는다. let, const 키워드로 선언한 변수는 1. 선언 단계만 미리 실행되어 스코프에 변수 명이 등록되지만 2. 초기화 단계는 런타임에 선언문이 실행될 때 실행된다. 2. 초기화 단계는 변수의 값을 위한 메모리 공간을 할당하고 undefined라는 값을 암묵적으로 넣어주는 것이다. 이런 초기화 단계를 진행하지 않았으니 참조 에러가 나는 것이다. 1234&gt; // 클래스 Gee를 선언하기 전에 참조&gt; const f = new Gee(); // ReferenceError: Cannot access 'Gee' before initialization&gt; class Gee {};&gt; 마찬가지로 class도 let이나 const 키워드로 선언한 변수처럼 동작한다. 호이스팅을 하지 않는 것처럼 동작한다고 하는 이유는, 런타임 이전에 1. 선언 단계가 진행되어 정말로 선언되지 않은 변수를 참조했을 때 발생하는 is not defined와는 다른 에러가 발생하기 때문이다. ES6의 class도 사실은 함수이지만, function 키워드로 선언한 함수 선언식은 호이스팅 되는 반면 class로 선언한 함수는 호이스팅 되지 않는다. 즉, 선언만 해놓고 초기화를 하지 않아 호이스팅되지 않는 것처럼 동작한다. let이나 const 나 class 등의 선언문 이전을 TDZ(Temporal Dead Zone)이라고 한다. 선언만 되고 초기화되지 않아 참조할 수 없는 구간을 말한다. 6. getter, setter객체 지향 언어에서 클래스를 사용하는 목적은 내부 상태(내부 데이터)에 접근하는 방법을 제한하고 최소한의 인터페이스를 제공해서 데이터의 캡슐화를 구현하기 위함이다. 접근자 프로퍼티 (getter, setter)를 사용하는 이유도 이와 같다. 클래스 내의 프로퍼티를 참조할 때는 get 함수, 프로퍼티를 설정할 때는 set 함수만을 이용할 수 있도록 구현해야 한다. 6.1. gettergetter는 클래스 프로퍼티에 접근할 때 사용한다. getter는 메소드 이름 앞에 get 키워드를 사용해서 정의한다. 이 때 메소드 이름은 클래스 프로퍼티 키처럼 사용된다. 즉, getter는 호출하는 것이 아니라 프로퍼티처럼 참조하는 것이고, 참조할 때 메소드가 호출된다. getter는 데이터를 얻기위해(get) 사용하므로 반드시 무언가를 리턴해야 한다. 6.2. settersetter는 클래스 프로퍼티에 값을 할당할 때 사용한다. setter는 메소드 이름 앞에 set 키워드를 사용해서 정의한다. get 메소드와 마찬가지로 메소드 이름은 클래스 프로퍼티 키로 사용되어 참조되는 형식으로 메소드를 호출한다. setter는 데이터를 할당하기 위해서 호출하는 것이므로 메소드를 사용해서 할당할 때 set 메소드가 호출된다. 123456789101112131415161718192021222324class Student { // default 값 설정 constructor(firstname = '', lastname = '') { this.firstname = firstname; this.lastname = lastname; } get fullName() { return `${this.firstname} ${this.lastname}`; } set fullName(fullname) { [this.firstname, this.lastname] = fullname.split(' '); }}const mimi = new Student('Mimi', 'Kim'); // 메소드를 직접 호출하는 것이 아니라 프로퍼티에 접근하는 방식으로 getter, setter를 내부적으로 호출한다.console.log(mimi.fullName); // Mimi Kim (getter)mimi.fullName = 'Mimi Park'; // setterconsole.log(mimi.fullName); // Mimi Park (getter) 7. Static MethodClass는 static 메소드를 정의할 때 static 키워드를 사용한다. 정적 메소드는 인스턴스가 아니라 클래스 이름으로 호출하는 메소드이다. 12345678910111213141516171819class Foo { constructor(prop) { this.prop = prop; } static staticMethod() { /* 정적 메소드는 this를 사용할 수 없다. 정적 메소드 내부에서 this는 클래스의 인스턴스가 아닌 클래스 자신을 가리킨다. */ return 'staticMethod'; } prototypeMethod() { return this.prop; }}console.log(Foo.staticMethod()); // staticMethod 정적 메소드는 클래스의 인스턴스 생성 없이 클래스 이름으로 호출하며 클래스의 인스턴스로는 호출할 수 없다. 8. Class Inheritance8.1. extends Keywordextends 키워드는 parent 클래스를 생속받는 child 클래스를 정의할 때 사용한다. 12345678910111213141516171819202122232425262728293031323334353637// parent classclass Circle { constructor(radius) { this.radius = radius; } getDiameter() { return 2 * this.radius; } getArea() { return Math.PI * (this.radius ** 2); }}// child classclass Cylinder extends Circle { constructor(radius, height) { super(radius); this.height = height; } // parent class Circle의 getArea overriding getArea() { return (this.height * super.getPerimeter()) + (2 * super.getArea()); } // 자신의 메소드 정의 getVolume() { return super.getArea() * this.height; }}// Cylinder class는 Circle class를 상속한다.Cylinder.__proto__ === Circle // true// Cylinder의 prototype은 Circle의 prototype을 상속한다.Cylinder.prototype.__proto__ === Circle.prototype 8.2. super Keywordsuper 키워드는 parent 클래스를 참조하거나 parent 클래스의 constructor를 호출할 때 사용한다. super 클래스가 메소드로 사용될 때는 parent 클래스의 constructor를 호출한다. child 클래스의 constructor에서 super()를 호출하지 않으면 this에 대한 ReferenceError가 발생한다. child 클래스의 인스턴스를 만들 때 parent 클래스의 인스턴스를 우선 만들고 상속한다. 1234567// parent 클래스의 constructor를 호출한다.class Cylinder extends Circle { constructor(radius, height) { // super가 parent class의 constructor처럼 사용됨 super(radius); this.height = height; } ECMAScript의 스펙을 살펴보면 super가 argument를 전달받으며 호출될 때는 내부적으로 자신의 parent 클래스의 constructor를 호출하여 constructor가 리턴한 this 객체를 child 클래스 constructor의 this(child 클래스가 생성할 인스턴스)에 바인딩한다. super 클래스가 객체로 사용될 때는 parent 클래스를 참조한다. 123456789101112// super가 parent class Circle처럼 사용됨// parent class Circle의 getArea overriding getArea() { return (this.height * super.getPerimeter()) + (2 * super.getArea()); } // 자신의 메소드 정의 getVolume() { return super.getArea() * this.height; }} 8.3. Inheritance of Static Method and Prototype MethodChild 클래스의 static 메소드 내부에서 super 키워드를 사용하면 parent 클래스의 static 메소드를 호출할 수 있다. child 클래스는 프로토타입 체인에서 parent 클래스의 정적 메소드를 참조할 수 있기 때문이다. 그러나 child 클래스의 일반 메소드(prototype 메소드) 내부에서는 super 키워드를 사용해서 parent 클래스의 static 메소드를 호출할 수 없다. 이는 child 클래스의 인스턴스는 프로토타입 체인에 의해 parent 클래스의 static 메소드를 참조할 수 없기 때문이다. child 클래스의 인스턴스는 프로토타입 체인 상에 parent 클래스가 아니라 parent 클래스의 prototype만 가지고 있다. 123456789101112131415161718192021222324252627282930313233class Foo { constructor(prop) { this.prop = prop; } static staticMethod() { /* 정적 메소드는 this를 사용할 수 없다. 정적 메소드 내부에서 this는 클래스의 인스턴스가 아닌 클래스 자신을 가리킨다. */ return 'staticMethod'; } prototypeMethod() { return this.prop; }}class Bar extends Foo { static staticMethod2() { return super.staticMethod(); } prototypeMethod() { return super.staticMethod(); }}console.log(Bar.staticMethod2()); // staticMethodconst bar = new Bar();console.log(bar.prototypeMethod()); // TypeError: (intermediate value).staticMethod is not a function","link":"/2019/05/21/27-Class/"},{"title":"30. Event","text":"1. Event브라우저의 이벤트는 사용자의 동작에 따라 어느 시점에 발생할 지 미리 알 수 없고 순서 또한 예측할 수 없다. 브라우저에서는 이벤트를 감지할 수 있고 이벤트 발생 시 통지를 해서 사용자와 웹 페이지의 Interaction이 가능케 한다. 이벤트 발생시 실행될 함수를 등록할 수 있다. 이벤트와 함수를 연결하면 함수는 이벤트 발생 전에는 실행되지 않다가 이벤트가 발생하면 실행된다. 이런 함수를 Event Handler 또는 Event Listener라고 한다. Synchronous &amp; Asynchronous Processing Model Synchronous 프로세스가 직렬적, 즉 순차적으로 task를 처리하는 처리 모델 따라서 중간에 시간이 오래 걸리는 작업이 있으면 다음 작업은 대기한다. 서버에서 데이터를 요청받아야할 I/O 작업이 실행될 경우에 이후의 작업들은 Block되어 대기한다. 이를 I/O Blocking이라고 한다. Asynchronous Non-Blocking Process Model이라고도 하는 Asyncoronous 처리 모델 어떤 task가 종료되지 않은 상태라고 해도 대기하지 않고(Non-Blocking) 즉시 다음 task로 넘어간다. 대부분의 Event를 Asncronous하게 처리한다. 2. Event Loop and Concurrency브라우저는 Single-thread에서 Event-driven 방식으로 동작한다. Single-threadSingle thread는 하나의 thread만을 사용하기 때문에 어느 한 순간에 하나의 task만을 처리할 수 있다는 것을 의미한다. 그러나 브라우저를 사용하는 사용자는 동시에 여러 웹 애플리케이션을 실행하고 있는 것처럼 느낄 것이다. Event Loop가 자바스크립트의 동시성(Concurrency)을 지원하기 때문이다. Call Stack스택은 LIFO(Last In First Out)으로 마지막에 들어온 task가 먼저 실행된다. 자바스크립트는 하나의 Call Stack을 사용한다. 이는 어떤 task가 종료하기 전에 다른 task는 수행될 수 없음을 의미한다. HeapDynamic하게 생성된 Object Instance가 할당되는 영역 Event Queue(Task Queue)Asynchronous process function의 callback 함수, asynchronous event handler, Timer 함수의 callback 함수가 보관되는 영역. Event Loop에 의해 Call Stack이 비었을 때 순차적으로 Call Stack으로 이동해서 실행된다. 이벤트 발생시 이벤트 핸들러는 Event Queue에 들어갔다가 Call Stack이 비면 Event Loop에 의해서 Call Stack에 진입해 실행된다. Event LoopEvent Loop는 Call Stack의 task와 Event Queue의 task를 주기적으로 확인한다. Call Stack이 비어있는 시점에 Event Queue 내의 Task를 Call Stcak으로 이동시켜 실행하게 한다. Event Loop가 빠르게 돌며 task를 순간순간 전환하기 때문에 사용자는 여러개의 task를 동시에 실행하고 있다고 느끼는 것이다. 이렇게 한 번에 하나의 task을 처리하면서 마치 동시에 처리하는 것처럼 동작시키는 방법을 Pseudo Parallel이라고 한다. 3. Type of EventsEvent Reference 4. Register Event Handler 인라인 이벤트 핸들러 이벤트 팬들러 프로퍼티 addEventListener 메소드 4.1. Inline Event Handler12345678&lt;button class=\"btn\" onclick=\"foo()\"&gt;Click me!&lt;/button&gt;&lt;script&gt; const $button = document.querySelector('.btn'); function foo() { console.log('Clicked!'); }&lt;/script&gt; HTML element의 이벤트 핸들러 attribute에 inline으로 핸들러를 등록 4.2. Event Handler Property 1234567&lt;button class=\"btn\"&gt;Click me!&lt;/button&gt;&lt;script&gt; const $button = document.querySelector('.btn'); $button.onclick = function () { console.log('Clicked!'); };&lt;/script&gt; HTML과 JavaScript 코드가 섞이지 않지만 한 개의 Event Handler 프로퍼티에 하나의 Event Handler만을 바인딩할 수 있다. 4.3. addEventListener Method1234567&lt;button class=\"btn\"&gt;Click me!&lt;/button&gt;&lt;script&gt; const $button = document.querySelector('.btn'); $button.addEventListener('click', function() { console.log('Clicked!'); });&lt;/script&gt; EventTarget.addEventListener(eventType, functionName[, useCapture]) EventTarget : 대상 element eventTarget: 대상 element에 바인딩될 이벤트 (String) fuinctionName: 이벤트 발생 시 호출될 함수 명, 또는 함수 정의 useCapture(option): capture 사용 여부 Dafault: false (Bubbling) true: capturing addEventListener의 장점 하나의 이벤트에 여러 개의 이벤트 핸들러를 추가할 수 있다. 캡처링을 사용할 수 있다. HTML element 뿐만 아니라 DOM 요소(HTML, XML, SVG)에도 동작한다. IE9 이상에서 동작하므로 IE8 이하에서는 attachEvent 메소드를 사용한다. 5. this in Event Handler Inline Event Handler 이벤트 핸들러가 일반 함수로 호출되므로 내부의 this는 전역 객체 window이다. Event Handler Property 이벤트 핸들러가 메소드이므로 내부의 this는 이벤트에 바인딩된 element를 가리킨다. event 객체의 currentTarget 프로퍼티 값과 같다. addEventListener Method 이벤트 핸들러 내의 this는 addEventListener 메소드를 호출한 element, 즉 이벤트 리스너에 바인딩된 element를 가리킨다. event 객체의 currentTarget 프로퍼티 값과 같다. 이벤트 핸들러 property와 addEventListener method로 등록한 이벤트 핸들러 내부의 this = 이벤트 리스너에 바인딩된 element = event.currentTarget 6. Event FlowEvent PropagationHTML element에 이벤트가 발생할 경우 속한 계층을 따라서 이벤트가 전파(Event Propagation)된다. Event Capturing : child element에서 발생한 이벤트가 parent element부터 시작해서 이벤트를 발생시킨 child element까지 도달하는 것 Event Bubbling : child element에서 발생한 이벤트가 parent element까지 전이되는 것 버블링과 캡처링은 둘 중 하나만 발생하는 것이 아니라 캡처링으로 시작해 버블링으로 끝난다. addEventListener 메소드의 세번째 argument를 true로 주면 캡처링으로 이동하는 이벤트를 캐치하고, flase 또는 주지 않으면 default로 버블링으로 이동하는 이벤트를 캐치한다. 7. Event Object이벤트 발생시 event 객체가 동적으로 생성되어 이벤트를 처리할 핸들러에 argument로 전달된다. 1234function eventHandler(e) { console.log(e.clientX, e.clientY);}addEventListener('click', eventHandler); Event.targete.target은 실제로 이벤트를 발생시킨 element를 가리킨다. Event.target은 this와 반드시 일치하지 않는다. Event.currentTarget이벤트에 바인딩된 DOM element를 가리킨다. addEventListener로 지정한 이벤트 핸들러 내부의 this와 일치한다. Event.type발생한 이벤트의 종류를 나타내는 문자열을 리턴한다. Event.cancelableelement의 기본 동작을 취소시킬 수 있는지를 나타낸다. =&gt; Boolean Event.eventPhase이벤트가 event flow 상에서 어떤 event phase에 있는지 리턴한다. Return Meaning 0 No Event 1 Capturing Phase 2 Target 3 Bubbling Phase 8. Event Elegation여러 child element의 이벤트를 캐치하고 싶을 때 이벤트 위임을 이용해서 parent element에 이벤트 핸들러를 바인딩한다. 또한 어떤 ul element에 동적으로 child li element들이 추가되는 경우, 동적으로 추가되는 element는 DOM에 아직 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다. 이런 경우에도 parent element인 ul에 이벤트 핸들러를 바인딩해 event elegation을 사용한다. 이벤트 위임(Event Delegation)은 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법이다. Event Delegation은 이벤트가 Event flow에 의해서 bubbling이 되기 때문에 가능한 것이다. 실제로 이벤트를 발생시킨 element는 event.target으로 찾는다. 9. Change Default OperationEvent object는 element의 default 동작을 가지며 element의 parent element들이 이벤트에 대응하는 방법을 변경할 수 있도록하는 메소드를 가진다. Event.preventDefault()form을 submit하거나 link를 클릭하면 default로 다른 페이지로 이동하는데, 이처럼 element가 가진 default 동작을 막는 메소드가 preventDefault()이다. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"http://www.google.com\"&gt;go&lt;/a&gt; &lt;script&gt; document.querySelector('a').addEventListener('click', function (e) { console.log(e.target, e.target.nodeName); // a 요소의 기본 동작을 중단한다. e.preventDefault(); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Event.stopPropagation()Event flow 상의 어떤 한 element에서 이벤트를 처리한 후에, 더이상 이벤트가 전파되는 것을 중단하게끔 하는 메소드이다. 주로 child와 parent에 동일한 event에 대한 핸들러가 각각 다르게 등록되어있는 경우에 사용한다. child에서 일어난 event에서 op1을 동작해야 하는데 parent로 이벤트가 전파되어 op2가 동작되면 안되기 때문이다. 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; html, body { height: 100%;} &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;버튼을 클릭하면 이벤트 전파를 중단한다. &lt;button&gt;버튼&lt;/button&gt;&lt;/p&gt; &lt;script&gt; const body = document.querySelector('body'); const para = document.querySelector('p'); const button = document.querySelector('button'); // default: 버블링 body.addEventListener('click', function () { console.log('Handler for body.'); }); // default: 버블링 para.addEventListener('click', function () { console.log('Handler for paragraph.'); }); // default: 버블링 button.addEventListener('click', function (event) { console.log('Handler for button.'); // 이벤트 전파를 중단 event.stopPropagation(); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; preventDefault &amp; stopPropagationdefault 동작과 bubbling/capturing을 동시에 중단시킬 수 있는 방법이 있다. 이벤트 핸들러 내에서 return false;를 하면 되는데, 이 방법은 jQuery를 사용하거나 inline event handler로 이벤트 핸들러를 return할 때만 동작한다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;a href=\"http://www.google.com\" onclick='return handleEvent()'&gt;go&lt;/a&gt; &lt;script&gt; function handleEvent() { return false; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;a href=\"http://www.google.com\"&gt;go&lt;/a&gt; &lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // within jQuery $('a').click(function (e) { e.preventDefault(); // OK }); $('a').click(function () { return false; // OK --&gt; e.preventDefault() &amp; e.stopPropagation(). }); // pure js document.querySelector('a').addEventListener('click', function(e) { // e.preventDefault(); // OK return false; // NG!!!!! }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2019/05/22/30-Event/"},{"title":"31. Ajax","text":"1. Ajax (Asynchronous JavaScript and XML)브라우저에서 웹페이지를 요청하거나 링크를 클릭하면 서버에서 요청받은 페이지(HTML)을 반환한다. 이 때 HTML에서 로드하는 CSS나 JavaScript 파일도 함께 반환한다. 서버에서 웹페이지를 받으면 브라우저는 파일을 렌더링해서 화면에 표시한다. URI이 바뀌면 전체 화면 렌더링을 다시해야해서 화면이 깜빡하는 문제가 있다. Ajax(Asynchronous JavaScript and XML) XML : JSON이 나오기 이전에 서버와 Data를 주고받기 위해 사용됨 자바스크립트를 이용해서 Asynchronous하게 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식 Ajax는 서버로부터 웹페이지를 받아서 화면 전체를 다시 그리는 것이 아니라, 페이지 일부만 갱신할 수 있게 한다. 페이지 전체를 로드해서 렌더링할 필요가 없으므로 퍼포먼스가 빨라지고 화면 표시 효과가 부드러워진다. 2. JSON (JavaScript Object Notation)JSON은 클라이언트와 서버 간 데이터 교환을 위한 규칙. 즉, 데이터 포맷이다. JSON은 일반 텍스트 포맷보다 효과적으로 데이터를 구조화할 수 있다. XML 포맷보다 가볍고 사용하기 간편하고 가독성이 우수하다. 자바스크립트의 객체 리터럴과 비슷하지만 JSON은 순수한 텍스트로 구성된 규칙이 있는 Data Structure이다. JSON은 String이다. 12345{ \"id\": 1, \"name\": \"Park\", \"checked\": true} JSON에서 Key는 반드시 &quot; &quot;로 둘러싸야 한다. (‘ ‘ 사용 불가) 2.1. JSON.stiringifyJSON.stringify 메소드는 객체를 JSON 형식 string으로 변환한다. 1234567function init() { const hospitalKey = 'hospital'; const partskey = 'parts'; ... localStorage.setItem(hospitalkey,JSON.stringify(hospital)); localStorage.setItem(partskey, JSON.stringify(parts));} 2.1. JSON.parseJSON.parse 메소드는 JSON 형식 data string을 객체로 변환한다. 1234567891011121314function checkSelectedPart(part) { const parts = JSON.parse(localStorage.getItem(partskey)); let checkedPart; parts.forEach(element =&gt; { if (element.id === part) { element.checked = true; checkedPart = element; } else { element.checked = false; } }); localStorage.setItem(partskey, JSON.stringify(parts)); showParts(checkedPart);} 서버에서 브라우저로 전송하는 JSON 데이터는 모두 string이다. 이 string을 자바스크립트의 객체로 사용하기 위해서는 Internal Object인 JSON의 static 메소드 JSON.parse를 사용한다. JSON.stringify가 encoding / serialization이면 JSON.parse는 decoding / deserialization이다. 3. XMLHttpRequest브라우저는 XMLHttpRequest 객체를 이용해 Ajax Request를 생성하고 전송한다. 서버가 브라우저의 Request에 Response하면 Ajax Request를 생성했던 XMLHttpRequest 객체가 결과를 처리한다. 3.1. Ajax Request1234567// XMLHttpRequest 객체의 생성var xhr = new XMLHttpRequest();// 비동기 방식으로 Request를 open. open하며 method와 action 지정// 상대주소는 html 출처 server 기준. 다른 출처로 요청하면 동일출처원칙에 어긋담xhr.open('GET', '/users');// Request를 전송한다xhr.send(); XMLHttpRequest.opennew 연산자로 XMLHttpRequest 객체의 인스턴스를 생성 후, XMLHttpRequest.open 메소드를 사용해서 서버로 보낼 Request를 오픈한다. XMLHttpRequest.open(method, url[, async]) method HTTP method “GET”, “POST”, “PUT”, “DELETE” url Request를 보낼 URL async default true로 asynchronous 동작 false면 synchronous =&gt; blocking 발생 XMLHttpRequest.sendXMLHttpRequest.send 메소드로 준비된 Request를 서버에 전달한다. Request의 method가, GET일 때 : 데이터를 URL의 일부인 query string으로 서버로 전송. Pay Load 없고 URL에 넣어 보내므로 send(null) POST일 때 : 데이터(Pay Load)를 Request Body에 담아서 서버로 전송 XMLHttpRequest.send 메소드에는 Request Body에 담아서 서버로 전송할 arguments를 전달할 수 있다. 12345xhr.send(null);// xhr.send('string');// xhr.send(new Blob()); // file 등 binary contents 보내는 방법// xhr.send({ form: 'data' });// xhr.send(document); Request Method가 POST가 아니라 GET일 때는 send 메소드의 argument는 무시되고 request body는 null로 설정됨 XMLHttpRequest.setRequestHeaderXMLHttpRequest.setRequestHeader 메소드는 HTTP Request Header의 값을 설정한다. 헤더 설정 전에 반드시 XMLHttpRequest.open 메소드로 Request를 오픈한 상태여야 한다. Content-typeRequest Body에 담아 전송할 데이터의 MIME-type 정보 표현 (contents type) MIME-type(Multipurpose Internet Mail Extensions)클라이언트에 전송된 문서의 다양성을 알려주기 위한 매커니즘. 웹에서 파일의 확장자는 별 의미가 없으므로 각 문서와 함께 올바른 MIME-type을 전송하도록 서버가 정한다. 브라우저는 MIME-type을 사용해서 리소스를 내려받은 후 해야 할 기본 동작을 결정한다. 자주 사용되는 MIME-type Type Subtype text Type text/plain, text/html, text/css, text/javascript Application Type application/json, application/x-www-form-urlencode Type to upload a File multipart/formed-data 1234// json으로 전송xhr.open('POST', '/users');// 서버로 전송할 데이터의 MIME-type 지정xhr.setRequestHeader('Content-type', 'application/json'); AcceptHTTP 클라이언트가 서버에 요청할 때 서버로부터 받을 데이터의 MIME-type을 Accept로 지정 가능. 12// 클라이언트가 Request시 서버가 Send back할 데이터의 MIME-type 지정xhr.setRequestHeader('Accept', 'application/json'); 3.2. Ajax ResponseXMLHttpRequest.onreadystatechange는 요청한 Request에 대해서 서버가 보낸 Response를 감지하고 callback 함수를 실행한다. XHLHttpRequest.readyState 프로퍼티가 변경될 때마다 onreadystatechange 이벤트 핸들러가 호출된다. 1234567891011// XMLHttpRequest 객체 생성const xhr = new XMLHttpRequest();// Asynchronous Request openxhr.open('GET', 'data/test.json');// send Requestxhr.send();// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 이벤트 핸들러 호출xhr.onreadystatechange = function (e) { // 이 함수는 Response가 클라이언트에 도달하면 호출된다.}; XMLHttpRequest.readyState로 서버가 보낸 Response가 클라이언트에 도착했는지 알 수 있다. XMLHttpRequest.readyState의 값은 아래와 같다. Value State Description 0 UNSENT XMLHttpRequest.open() 메소드 호출 이전 1 OPENED XMLHttpRequest.open() 메소드 호출 완료 2 HEADERS_RECEIVED XMLHttpRequest.send() 메소드 호출 완료 3 LOADING 서버 응답 중(XMLHttpRequest.responseText 미완성 상태) 4 DONE 서버 응답 완료 XMLHttpRequest.status로 Response를 분석할 수 있다. 4. Web Server Web ServerHTML, CSS, JavaScript, img, XML 등 client가 요청하는 Static file(resource)를 제공 Application ServerStatic resource를 제공할 수 있는 기능은 물론 REST API를 처리할 수 있다. 웹서버(Web Server)는 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고 HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램이다. Node.js로 간단한 웹서버를 생성해서 Ajax 실습을 해보자. http://localhost:3000에서 Hello World!를 표시하면 성공 5. Ajax Example5.1. Load HTML위에서 만든 webserver-express의 루트인 public 폴더에 data/data.html 파일을 준비한 후, 아래 html 파일을 만들고 실행해본다. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"https://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; // XMLHttpRequest 객체의 생성 const xhr = new XMLHttpRequest(); // 비동기 방식으로 Request를 오픈 xhr.open('GET', 'data/data.html'); // Request를 전송한다 xhr.send(); console.dir(xhr); // Event Handler xhr.onreadystatechange = function () { // 서버 응답 완료 if (xhr.readyState === XMLHttpRequest.DONE) { // 정상 응답 if (xhr.status === 200) { console.log(xhr.responseText); document.getElementById('content').innerHTML = xhr.responseText; } else { console.log(`[${xhr.status}] : ${xhr.statusText}`); } } }; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 정상 실행 되었을 때의 log이다. 서버에 요청해서 응답받은 data/data.html을 xhr.responseText로 취득한다. xhr.open(‘GET’, ‘data/data2.html’)로 코드를 수정해서 없는 file을 요청하면 Request의 status는 404, statusText는 Not Found이다. 5.2. Load JSON다음은 위에서처럼 html을 통째로 받아오는 것이 아니라 JSON 객체를 전달받아 parsing하고 필요한 정보를 뽑아서 렌더링하는 예제이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"https://poiemaweb.com/assets/css/ajax.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script&gt; // XMLHttpRequest 객체의 생성 var xhr = new XMLHttpRequest(); // 비동기 방식으로 Request를 오픈 xhr.open('GET', 'data/data.json'); // Request를 전송 xhr.send(); xhr.onreadystatechange = function () { // 서버 응답 완료 if (xhr.readyState === XMLHttpRequest.DONE) { // 정상 응답 if (xhr.status === 200) { console.log(xhr.responseText); // Deserializing (String → Object) responseObject = JSON.parse(xhr.responseText); // JSON → HTML String let newContent = '&lt;div id=\"tours\"&gt;&lt;h1&gt;Guided Tours&lt;/h1&gt;&lt;ul&gt;'; responseObject.tours.forEach(tour =&gt; { newContent += `&lt;li class=\"${tour.region} tour\"&gt; &lt;h2&gt;${tour.location}&lt;/h2&gt; &lt;span class=\"details\"&gt;${tour.details}&lt;/span&gt; &lt;button class=\"book\"&gt;Book Now&lt;/button&gt; &lt;/li&gt;`; }); newContent += '&lt;/ul&gt;&lt;/div&gt;'; document.getElementById('content').innerHTML = newContent; } else { console.log(`[${xhr.status}] : ${xhr.statusText}`); } } }; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.3. Load JSONP Same-origin Policy (동일출처원칙)보안상의 이유로 다른 도메인(http, https / 다른 port)로 요청하는 Cross-domain Request는 제한된다. 동일출처원칙을 우회하는 방법 세가지 웹서버의 프록시파일 Proxy (원격 서버로부터 데이터를 수집하는 별도 기능)를 서버에 추가 JSONP 이해 안 감 Cross-Origin Resource Sharing (CORS)서버에서 처리하니까 백엔드에 요청하면 됨","link":"/2019/05/26/31-Ajax/"},{"title":"36. SPA","text":"SPA (Single Page Application)Single Page Application은 모던 웹 패러다임으로, 기본적으로 하나의 페이지로 구성된다. 하나의 페이지라는 것은 html 파일이 하나라는 뜻이다. 기존의 Sever-side 렌더링과 비교할 때 배포가 간단하고 Native application과 유사한 UX를 제공할 수 있다는 장점이 있다. 전통적인 웹 방식은 link tag를 사용해서 새로운 페이지를 요청한다. 새로운 페이지(html)를 요청할 때마다 필요한 static resource가 다운로드되고 전체 페이지를 다시 렌더링해야하므로 새로고침이 발생된다. &lt;a&gt; tag&lt;a&gt; tag 클릭시 href attribute의 url의 page로 이동한다. 즉, 화면 전환이 일어나 새로운 html이 렌더링된다. 화면 전환시 화면이 깜빡거리는 웹의 특성은 Native App과 비교해 단점으로 언급되어왔다. SPA는 기본적으로 Web Application에 필요한 모든 static resource를 처음 한 번에 다운로드한다. 이후에 새로운 페이지를 요청하면 갱신에 필요한 데이터만 전달받고 변경이 필요한 부분만 렌더링하므로 트래픽이 감소하고 Native application과 유사한 UX를 제공한다. 특히 모바일 사용이 증가하고 있는 요즘 SPA는 트래픽의 감소와 속도, 사용성, 반응성 등 사용자 경험(UX) 향상 면에서 가치를 갖는다. Mobile First 전략에 부합한다. 그러나 모든 Software Architecture에는 trade-off가 존재하므로 SPA 또한 구조적인 단점을 갖는다. 초기 구동 속도가 느리다.SPA는 Web Application에 필요한 모든 static resource를 최초 한 번에 다운로드 하므로 초기 구동 속도가 상대적으로 느리다. 그러나 한 번 다운로드가 이루어진 이후에는 모든 resource를 가지고 있으므로 속도가 향상된다. SEO(Search Engine Optimization) IssueSPA는 Server Rendering 방식이 아닌, 자바스크립트 기반 비동기 모델(Client Rendering 방식)이다. 따라서 SEO가 단점으로 꼽힌다. 그러나 Angular 또는 React 등의 SPA 프레임워크는 Server Side Rendering을 지원하는 SEO 대응 기술이 존재하고 있다. Web Page vs. Web Application일반적인 정보를 제공하는 단순한 웹 사이트는 Web Page 사용자가 웹 사이트에서 일 (데이터를 입력, 저장, 수정, 삭제 등등)을 하면 Web Application RoutingRouting은 source에서 destination까지의 경로를 결정하는 기능이다. Application의 routing은 사용자가 task를 수행하기 위해서 어떤 화면(view)에서 다른 화면으로 화면을 전환하는 Navigation을 관리하기 위한 기능을 의미한다. 일반적으로 사용자가 요청한 URL 또는 Event를 해석하고 새로운 페이지로 전환하기 위한 데이터를 얻기 위해서 서버에 필요한 데이터를 요청하고 화면을 전환하는 행위를 말한다. 브라우저가 화면을 전환하는 경우 3 브라우저 주소창에 URL을 입력해서 해당 페이지로 이동 웹 페이지의 링크를 클릭해서 해당 페이지로 이동할 수 있다. 브라우저의 뒤로가기, 앞으로가기 버튼으로 사용자가 방문한 웹페이지 history의 뒤, 앞으로 이동 123window.history.back();window.history.forward();window.history.go(); AJAX Request에 의해서 서버로부터 받은 데이터로 화면을 생성하는 경우, 브라우저 주소창의 URL은 변경되지 않는다. URL이 변경되지 않으면 사용자의 history를 관리할 수 없고 이는 SEO 이슈가 된다. history 관리를 위해서는 각 페이지가 브라우저의 주소창에서 구별할 수 있는 유일한 URL을 소유해야 한다. SPA and Routing1. HashBang Methodhtml 내에서 element의 id 앞에 #를 붙이면 페이지 리소스를 다시 요청하지 않는다. 그러나 주소창의 uri는 변경되므로 페이지마다 고유한 uri를 만들어 history를 이용할 수 있다. 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;SPA&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt; &lt;script src=\"js/index.js\" defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#service\"&gt;Service&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=\"app-root\"&gt;Loading...&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960(function () { const root = document.querySelector('.app-root'); function render(data) { const json = JSON.parse(data); root.innerHTML = `&lt;h1&gt;${json.title}&lt;/h1&gt;&lt;p&gt;${json.content}&lt;/p&gt;`; } function renderHtml(html) { root.innerHTML = html; } function get(url) { return new Promise((resolve, reject) =&gt; { const req = new XMLHttpRequest(); req.open('GET', url); req.send(); req.onreadystatechange = function () { if (req.readyState === XMLHttpRequest.DONE) { if (req.status === 200) resolve(req.response); else reject(req.statusText); } }; }); } // switch 문 대신 쓰는 방법 const routes = { '': function () { get('/data/home.json').then(render); }, 'service': function () { get('/data/service.json').then(render); }, 'about': function () { get('/data/about.html').then(renderHtml); }, otherwise() { root.innerHTML = `${location.hash} Not Found`; } }; function router() { // url의 hash를 취득 const hash = location.hash.replace('#', ''); // property 참조 방식 1. o.prop 2. o['prop'] (routes[hash] || routes.otherwise)(); } // 네비게이션을 클릭하면 uri의 hash가 변경된다. 주소창의 uri가 변경되므로 history 관리가 가능하다. // 이때 uri의 hash만 변경되면 서버로 요청을 수행하지 않는다. // 따라서 uri의 hash가 변경하면 발생하는 이벤트인 hashchange 이벤트를 사용하여 hash의 변경을 감지하여 필요한 AJAX 요청을 수행한다. // hash 방식의 단점은 uri에 불필요한 #이 들어간다는 것이다. window.addEventListener('hashchange', router); // DOMContentLoaded은 HTML과 script가 로드된 시점에 발생하는 이벤트로 load 이벤트보다 먼저 발생한다. (IE 9 이상 지원) // 새로고침이 클릭되었을 때, 웹페이지가 처음 로딩되었을 때, 현 페이지(예를들어 loclahost:5003/#service)를 요청하므로 index.html이 재로드되고 DOMContentLoaded 이벤트가 발생하여 router가 호출된다. window.addEventListener('DOMContentLoaded', router);}()); 결국 HashBang의 목적은 주소창의 uri가 바뀌어도 서버로 해당 uri를 요청하지 않는 것인데, HTML5에서 이를 지원하는 기능을 도입했다. DOMContentLoaded and loadDOMContentLoaded 이벤트는 DOM이 만들어지면 발생하는 이벤트로 load 이벤트보다 먼저 발생한다. load 이벤트는 모든 리소스를 다 load했을 때 발생하는 이벤트이다. 2. PJAX MethodHTML5의 Histroy API인 pushState와 popstate 이벤트를 사용한 PJAX 방식이다. pushState와 popstate은 IE 10 이상에서 동작한다. 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;PJAX&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt; &lt;script src=\"js/index.js\" defer&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;nav&gt; &lt;ul id=\"navigation\"&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/service\"&gt;Service&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/about\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=\"app-root\"&gt;Loading...&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 이는 Server Side Rendering (Server에서 html을 주는 것)방식과 AJAX 방식이 혼합된 것이다. 그러나 브라우저의 새로고침 버튼을 클릭하면 요청이 서버로 전달된다. 따라서 복잡한 처리가 요구된다. 모던 웹 SPA를 구현하기 위해서는 프레임워크를 사용하는 게 좋을 것 같다.","link":"/2019/06/10/36-SPA/"},{"title":"5. Data Type","text":"What is Data Type?Data Type is type of values. All of the data in JavaScript have data type. Allocatation of memory space by Data TypeAll of values used in programming language can be stored in memory and referenced. To store values in memory, computer need to know the size of memory space it need. Because size of memory depends on data type. JavaScript uses a double-precision 64-bit floating-point format when creating numeric binary values. Access memory by Data TypeWhen refer to memory space by identifier, computer need to know the size of memory it need to read once. If variable soup is Number type, computer should access memory by only 8 byte. Data Type provides that informations to computer and human. Here’s reasons why Data Type need: To determine the size of memory space that must be free when storing values To determine how much memory space should be read at once when referring to a value To determine how to interpret the binary be read from memory. (To Number, String etc.) ValueValue is one of expression that can not be evaluated any more. The expression is statement that makes value. In other words, expression make value by being evaluated. 12// 1 + 2 is an expression. And this expression evaluated and make a value 3.1 + 2 1 + 2 is an expression. It is made up of value 1, 2 and operator +. The expression is evaluated by the JavaScript engine to produce a new value of 3. In other words, expression 1 + 2 is equivalent with value 3. The newly created value of 3 can not be evaluated anymore. When you evaluate 3, it is always 3. 12// The variable is assigned the value 3, which is the evaluated value of expression 1 + 2.var sum = 1 + 2; After the assignment operator =, value must be located. The expression creates value. So the expression can be located after operator =. Function in JavaScript is an object. And an object is a value. So function also can be evaluated to a value. Creation of ValueValue can created by many expressions. The most basic method to create value is using literal notation. The expression is more comprehensive concept that includes literal notation, identifier expression, etc. LiteralA literal is a fixed value itself created directly in the source code. More specifically, literal values are evaluated by the JavaScript engine. Literal notation creates literal. Literal notation is method that make literal. The literal notation allows the generation of various types of values (Number, String, Boolean, null, undefined, object, array, function, regular expression, etc.) available in JavaScript. When JavaScript engines meet codes written in literal notation, they interpret the literal at the time the code is executed (runtime) and generate values. Literal is the most basic method to generates value. 1234567891011121314151617181920212223242526272829303132333435363738394041// Integer literal10// Floating point literal10.2// Binary literal0b011010101// Octal literal0o010101// Hexa literal0xd100ff// String literal'Hello'\"Subin\"``// Boolean literaltruefalse// null literalnull// undefined literalundefined// Object literal{ name: 'Park', color: 'yellow' }// Array literal[ 1, 2, 3]// Function literalfunction(){}// Regular expression literal/ab+c/ Literal notation can be understood as a promise between the JavaScript engine and the developer. The JavaScript engine can interpret literal notation. For example, if you want to generate a numeric value, the developer uses the numeric literal notation to ask the JavaScript engine to generate a numeric value. The JavaScript engine responds to the developer’s request to interpret numeric literals and generate numeric values. Relation of Value and Literal1var soup = 100; At the right side, 100 is directly created literal by literal notation. This literal is both literal and value at the same time because it cannot be evaluated any more and can be assigned to variable. Another example, 1var soup = 50 + 50; At the right side, 50 made by literal notation and + operator was used to sum. This expression create a new value 100. As such, statement that generates value in program called expression. The right side of this code is expression and generates a new value 100. So 50 is literal but created value 100 is not a literal, a value. A literal can be a value in itself, but not all values are literal. ExpressionsA value can be generated by various methods. Various methods are expressions. The expression refers to combination of literal, identifier(variable name, function name), operator and function calls. The expression generate one value as a result of evaluation. In the other words, the expression is a statement that can be evaluated to one value. Everything that produces a value is an expression. 1234567891011121314151617// literal notation10'Hello'// identifier expression(Assuming that a declaration already exists)sumperson.namearr[1]// operator expression10 + 20sum = 10 //assignment statementsum !== 10// function/method call expression(Assuming that a declaration already exists)square()person.getName() The assignment statement is evaluated as a assigned value. Classification of Data typesAll of the values in JavaScript have a data type. JavaScript provides 7 data types. 7 data types can be classified into primitive types and object(reference) types. Primitive type Number type : Number(Integer and Real number) String type : Strings Boolean type : logical true and false undefined type : The implicitly assigned value that declared but not explicitly assigned null type : The value used to indicate intentionally that there is no value. Symbol type : Seventh type that newly introduced in ES6 Object /reference type Object, funtcions, array etc. For example, Number 1 and String ‘1’ are look similar but completely different values. Size of memory space that needs to be occupied is different, binary digits that are stored in memory is different, and method of reading and interpreting is different. Also the purpose of value is different. Number type values are for arithmetic operation and String type values are for printing out text to screen. As such, developers will create values by distinguishing between types with clear intentions and JavaScript engines will treat values by distinguishing between types. Number TypeIn C and Java, they distinguish integer and real number so there are various number types like int, long, float, double. But JavaScript has only one Number type. As ECMAScript specification, Number type follows double-precision 64-bit floating-point format(numbers between -(253 -1) ~ 253 -1 ). JavaScript treats all of the Numbers as real number, has no integer type. Special number types Infinity : positive infinity -Infinity : negative infinity NaN : no arithmetic operation(not-a-number) Infinity is not a mathematical term, but a number that goes beyond what JavaScript can express. JavaScript is case-sensitive so NaN != nan, NAN, naN, Nan. String TypeThe String type is used to refer text data. String is a collection of more than 0 16 bit Unicode characters (UTF-16) that can represent most of the world’s characters. How to know the size of String?The purpose of Data Type is to determine the size of memory space that must be free when storing values and to determine how much memory space should be read at once when referring to a value. String can be generated by ‘’, “”, ``. The most general expression is using ‘’. 12345678// String Typevar string;string = \"문자열\"; // double quotesstring = '문자열'; // single quotesstring = `문자열`; // backtickstring = \"A 'single quote' in a string enclosed in double quotes is recognized as a string.\";string = 'The \"double quotes\" in strings enclosed in single quotes are recognized as strings.'; Unlike languages such as C and Java, JavaScript strings are primitive types and are immutable values. Immutable means that once a string is generated, it cannot be changed. Template literalES6 introduced new string expression, called template literal. Template literal seems like general string, it uses backtick (`). In a typical string, the line is not allowed and in order to represent a white space, an escape sequence beginning with a backslash () must be used. Unlike a typical string, ES6 template literal can write strings across multiple lines, and all spaces within the template literal apply as they are. 12345678const template = `&lt;ul class=\"nav-items\"&gt; &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#news\"&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`;console.log(template); And Strings can be concatenated using the + string operator. The + operator concatenate operands if at least one of the operand is a String. 12345var first = 'Subin';var last = 'Park';// ES5: String Concatenationconsole.log('My name is ' + first + ' ' + last + '.'); Template literal provides String Interpolation to insert new string without using + string operator. 12345var first = 'Subin';var last = 'Park';// ES6: String Interpolationconsole.log(`My name is ${first} ${last}.`); String Interpolation wraps expression with ${ extension}. The evaluation results of the expression are then forced to type into a string. 1console.log(`1 + 1 = ${1 + 1}`); The sequence is that Number 1 + 1 evaluated to Number 2, and be type casted to String 2. Boolean TypeThe boolean type values are only true and false. It is used to condition statement as a flow control. undefined TypeThe value of undefined type is unique, a undefined. The implicitly assigned value that declared but not explicitly assigned. If the value of variable is undefined, it means that the variable only be declared but not be assigned yet. Declaration and Definitionundefined means not defined. The definition refers to clarifying the substance of a variable by assigning a value to the variable. In C, definition of variable is important because if the variable only declared but not assigned, it can be contain a garbage value. But JavaScript assign undefined when at the time a variable is declared. In JavaScript, the boundaries between declarations and definitions are ambiguous and do not distinguish between them. null TypeThe value of null type is unique, a null. JavaScript is case-sensitive so null != Null, NULL. In programming language, null is used to represent intentional absence. However, assigning null to a variable is not used very well. If the function can not return a valid value, it may explicitly return null. For example, Document.getElementById(id) return null if given id is not exist in document. Object TypeAll of the JavaScript data type excepts primitive types are object type. Dynamic TypingStatic type languageStatic / Strong type languages ​​such as C or Java must declare a data type in advance. This is called an explicit type declaration. The following is an example of declaring an integer type variable in C. 12345// 4 byte integer typeint num;// 1 byte integer typechar c; Static type language can not change a type of value and only can assign values that match the type declared in the variable. Representative static type languages are C, C++, Java, Kotlin, Go, Hashell, Rust, Scala etc. Dynamic type languageJavaScript does not declare the type of variable when declaration. But only use the keywords such as var, let, const to declare a variable. JavaScript can assign any type of values. 1234567891011121314151617181920212223242526var foo;console.log(typeof foo); // undefinedfoo = 3;console.log(typeof foo); // numberfoo = 'Hello';console.log(typeof foo); // stringfoo = true;console.log(typeof foo); // booleanfoo = null;console.log(typeof foo); // objectfoo = Symbol(); // symbolconsole.log(typeof foo); // symbolfoo = {}; // objectconsole.log(typeof foo); // objectfoo = []; // arrayconsole.log(typeof foo); // objectfoo = function () {}; // 함수console.log(typeof foo); // function A static type language determines the type of a variable at the time of variable declaration and can not change the type of a variable. JavaScript can dynamically determine the type of the variable at the time of assigning the value and change the type of the variable at any time. In other words, JavaScript variables are type-determined by assignments rather than declarations. And the type of variable can be changed by reassignment at any time. This feature is called Dynamic Typing, and JavaScript is called a Dynamic / weak type language to distinguish it from Static type languages. Typical dynamic type languages ​​are JavaScript, Python, PHP, Ruby, Lisp, and Perl. Parameter and Argument12345678// x, y: parameterfunction add(x, y){ // type check is needed return x, y;}// 1, 2: argumentadd(1, 2) A parameter is a variable in a method definition. When a method is called, the arguments are the data you pass into the method’s parameters. Parameter is variable in the declaration of function. Argument is the actual value of this variable that gets passed to function. Things to keep in mind when using variables Actively reduce the use of variables. The greater the number of variables, the higher the probability of error occurrence. Do not use global variables. Make the life cycle of the variable as short as possible. Use a constant rather than a variable to suppress the change of value. Use const instead let if a variable is never reassigned. The variable name is named so that the reason for the existence of the variable can be grasped. Reference Data type &amp; Variable","link":"/2019/04/30/5-Data-Type/"},{"title":"Angular Form","text":"Angular FormAngular Form은 Template-driven Forms와 Ractive Forms를 제공한다. Template-driven Forms 간단한 form (Form Control 한두개)을 구성할 때 사용 Reactive Forms 복잡한 form을 구성할 때 사용 Form은 Client side에서 중요한 역할을 한다. 사용자의 입력을 서버로 전송하고 페이지를 전환할 수 있는 element이다. Server는 많은 Client 요청을 처리하므로 form을 통해서 받은 사용자 입력의 유효성 검사(validation)를 Client side에서 하는 것이 기본이다. Template-driven Forms Template-driven Form은 Component template에서 Directive를 사용해서 Form을 구성하는 방식 각 field의 형식이나 validation 검증 규칙을 모두 template에서 정의 Template-driven Form은 NgForm, NgModel, NgModelGroup Directive 중심으로 동작123456// app.module.tsimport { FormsModule } from '@angular/forms';@NgModule({ imports: [FormsModule],}) NgForm Directive Template-driven Form 전체를 관리하는 Directive root module에 FormsModule 추가하면 NgForm Directive 선언하지 않아도 모든 form element에 자동으로 적용되어 Template-driven Form으로 동작 HTML standard form의 validation을 사용하지 않고 Template-driven Form의 validation을 사용하려면 아래와 같이 form element에 novalidate Attribute를 추가한다. 최신 Angular는 FormsModule을 import하면 novalidate가 자동으로 추가된다. 1&lt;form novalidate&gt;&lt;/form&gt; 반대로 NgForm Directive를 사용하지 않고 HTML standard form을 사용하려면 ngNoForm을 추가한다. 1&lt;form ngNoForm&gt;&lt;/form&gt; HTML Standard Form과 Template-driven Form의 차이 HTML Standard Form은 submit button 클릭시 form data를 서버로 전송하고 페이지를 전환 NgForm Directive가 적용된 Template-driven Form은 submit event를 Intercept해서 submit의 기본 동작을 막음 대신 submit시 ngSubmit event를 사용해서 onSubmit event handler 사용 123&gt; &lt;form #f=\"ngForm\" (ngSubmit)=\"onNgSubmit(f)\" novalidate&gt;&gt; &lt;/form&gt;&gt; #f=&quot;ngForm&quot;으로 Native DOM 대신 NgForm Instance를 Template 참조 변수에 할당한다. Native DOM 요소와 다르게 ngForm Instance는 ng-valid, ng-touched 등 유용한 프로퍼티를 제공한다. NgForm Directive는 NgForm Instance 생성시 자신이 적용된 Form 요소의 값이나 validation 검증 산태를 추적할 수 있는 FormGroup Instance를 생성한 후 NgForm Instance의 property로 할당한다. 12345678910111213141516171819202122&lt;form #f=\"ngForm\" (ngSubmit)=\"onSubmit(f)\"&gt; &lt;input type=\"text\" placeholder=\"email\" name=\"email\" pattern=\"^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]{2,3}$\" ngModel required #email=\"ngModel\" /&gt; &lt;input type=\"password\" placeholder=\"password\" name=\"password\" pattern=\"^[a-zA-Z0-9]{4,10}$\" ngModel required #password=\"ngModel\" /&gt; &lt;button [disabled]=\"f.invalid\"&gt;Submit&lt;/button&gt;&lt;/form&gt; Form의 Input 요소들에 ngModel을 추가해야 Form의 Form Control로 등록된다. Reactive Forms Template이 아닌 Component class에서 form element의 상태를 관리하는 객체인 Form Model을 구성하는 방식 Template-driven Form 보다 복잡한 form을 구성할 때 사용 123456// app.module.tsimport { ReactiveFormsModule } from '@angular/forms';@NgModule({ imports: [ReactiveFormsModule],}) Reactive Form은 FormGroup, FormControl, FormArray를 중심으로 동작 1234567891011121314151617181920212223242526import { Component, OnInit } from '@angular/core';import { FormGroup, FormControl } from '@angular/forms';@Component({ selector: 'app-root', template: ` &lt;form [formGroup]=\"userForm\"&gt; &lt;input type=\"text\" placeholder=\"userid\" formControlName=\"userid\" /&gt; &lt;input type=\"password\" placeholder=\"userpw\" formControlName=\"userpw\" /&gt; &lt;button&gt;Login&lt;/button&gt; &lt;/form&gt; `, styles: [] })export class AppComponent implements OnInit { userForm: FormGroup; constructor() {} ngOnInit() { this.userForm = new FormGroup({ userid: new FormControl(), userpw: new FormControl() }); }} FormGroup Instance가 template의 form을 관리하도록 mapping 1&lt;form [formGroup]=\"userForm\"&gt;&lt;/form&gt; FormGroup의 FormControl을 생성해서 input element와 mapping 12&lt;input type=\"text\" placeholder=\"userid\" formControlName=\"userid\" /&gt; &lt;input type=\"password\" placeholder=\"userpw\" formControlName=\"userpw\" /&gt; FormControl FormControl 이름으로 getter 만들기 123456789101112131415161718192021222324252627282930313233343536import { Component, OnInit } from '@angular/core';import { FormGroup, FormControl, Validators } from '@angular/forms';@Component({ selector: 'app-root', template: ` &lt;form [formGroup]=\"userForm\"&gt; &lt;input type=\"text\" placeholder=\"userid\" formControlName=\"userid\" /&gt; &lt;em *ngIf=\"userid.errors?.required &amp;&amp; userid.touched\"&gt;아이디를 입력해주세요&lt;/em&gt; &lt;em *ngIf=\"userid.errors?.pattern &amp;&amp; userid.touched\"&gt;아이디를 형식에 맞게 입력해주세요&lt;/em&gt; &lt;input type=\"password\" placeholder=\"userpw\" formControlName=\"userpw\" /&gt; &lt;button&gt;Login&lt;/button&gt; &lt;/form&gt; &lt;pre&gt;userForm.value: {{ userForm.value | json }}&lt;/pre&gt; &lt;pre&gt;userForm.valid: {{ userForm.valid }}&lt;/pre&gt; `, styles: [] })export class AppComponent implements OnInit { userForm: FormGroup; constructor() {} ngOnInit() { this.userForm = new FormGroup({ userid: new FormControl('', [Validators.required, Validators.pattern('[a-zA-Z]{4,10}')]), userpw: new FormControl('', [Validators.required, Validators.pattern('[a-zA-Z]{4,10}')]) }); console.dir(this.userForm); } get userid() { return this.userForm.get('userid'); }} 비밀번호 확인을 위한 Custom Validation method 12345&lt;--! template --&gt; &lt;div formGroupName=\"passwordGroup\"&gt; &lt;input type=\"password\" placeholder=\"password\" formControlName=\"password\" /&gt; &lt;input type=\"password\" placeholder=\"confirm password\" formControlName=\"confirmPassword\" /&gt;&lt;/div&gt; 12345678910111213141516171819// component.tsngOnInit() { this.userForm = new FormGroup({ userid: new FormControl('', [Validators.required, Validators.pattern('[a-zA-Z]{4,10}')]), passwordGroup: new FormGroup( { password: new FormControl('', [ Validators.required, Validators.pattern('[a-zA-Z]{4,10}') ]), confirmPassword: new FormControl('', [ Validators.required, Validators.pattern('[a-zA-Z]{4,10}') ]) }, PasswordValidator.match ) }); } 12345678910// password-validator.tsimport { AbstractControl } from '@angular/forms';export class PasswordValidator { static match(passwordGroup: AbstractControl) { const password = passwordGroup.get('password').value; const confirmPassword = passwordGroup.get('confirmPassword').value; return password === confirmPassword ? null : { match: { password, confirmPassword } }; }} AbstractControl 모든 Control의 조상 12345678910111213// new FormGroup 대신 FormBuilder 사용 시ngOnInit() { this.userForm = this.fb.group({ userid: ['', [Validators.required, Validators.pattern('[a-zA-Z]{4,10}')]], passwordGroup: this.fb.group( { password: ['', [Validators.required, Validators.pattern('[a-zA-Z]{4,10}')]], comfirmPassword: ['', [Validators.required, Validators.pattern('[a-zA-Z]{4,10}')]] }, { validator: PasswordValidator.match } ) });}","link":"/2019/07/03/Angular-Form/"},{"title":"6. Operator","text":"Expression and OperatorOperator needs operand as value. And the expression is equivalent with value. So expressions can be located Values ​​can be generated in a variety of ways. The various methods mentioned here are expressions. Expressions in a programming language have a very important meaning. Expression is combination of tokens(literal, identifier(variable name, function name, etc), operator, function call). The expression is evaluated to produce a single value. That is, an expression is a statement that can be evaluated as a single value. Expression can be divided into a literal notation, an identifier expression, an operator expression, a function/method call expression, but they are all the same in that they are evaluated and made into a single value. The value that generated by evaluation of an expression is equivalent with an expression. In other words, expressions can be used like values. This means that an expression can also be placed where the value can be placed. 1234var x = 10;// expression x + 30 consists of a combination of an identifier expression(x), number literal(30) and operator(+)console.log(x + 30); //40 Statement and ExpressionA statement is a command to a JavaScript engine that consists of a combination of one or more expressions and keywords. A program is made up of a set of statements, and programming is to write the statements and sequence them. A statement can be divided into declare statement expression statement conditional statement loop statement. Statement should end up with semicolon(;). Do not add a semicolon after the code block. All codes of JavaScript are statements. An expression can itself be a statement. But the statement can not be an expression. It is difficult that distinguish statement and expression. The expression evaluates to produce a value, but can not do anything further. The statement can be used to create variables, functions, and classes using declarative keywords such as var, let, const, function (declare statement), and class and to control the program flow by generating conditional statements such as if, for, and while statements. The role of expression is that generates value. The role of statement is that command to JavaScript engine using a value that is generated by expression. Expression statement and Non-expression statementThere are expression statement and non-expression statement. A expression statement is a statement that can be evaluated as a value, and non-expression statement is a statement that can not be evaluated as a value. For example, assignment statement can not be evaluated as a value. So it’s non-expression statement. The simplest and most obvious way to distinguish expressions from expressions is to assign them to variables. An expression statement can be evaluated as value so it can be assigned to a variable. 12345678910111213141516171819202122// declare statement : non-expression statement&gt; var x;&lt; undefined// assignment statement : expression statement&gt; x = 5;&lt; 5// function declare statement : non-expression statement&gt; function foo(){}&lt; undefined// conditional statement : non-expression statement&gt; if(x &gt;= 5) { console.log(x); } 5&lt; undefined// loop statement&gt; for (var i = 0; i &lt; 2; i++) { console.log(i); } 0 1&lt; undefined Expression always prints a evaluated value in Chrome developer tool. What is Operator?An operator creates one value by performing arithmetic, assignment, comparison, logic, and type operations on one or more expressions. operand : the object of the operation The operand is also an expression because it is evaluated and a single value, and the expression is also an expression that combines the operand with the operator. Arithmetic OperatorThe Arithmetic Operator performs a mathematical computation on the operands to produce new numeric values. If arithmetic is not possible, NaN is returned. Arithmetic operators can be classified into binary arithmetic operators and unary arithmetic operators according to the number of operands. Binary Arithmetic OperatorThe binary arithmetic operator creates one Number type value by operating arithmetic on two operands. All binary arithmetic operators have no side effects that change the value of the operand. In other words, any arithmetic operation does not change the value of the operand. It always creates new values. Binary arithmetic operator Meaning Side effect + Addition X - Subtraction X * Multiplication X / Division X % Remainder X Unary Arithmetic OperatorUnary arithmetic operators perform arithmetic operations on a single operand to produce a numeric type value. The increment / decrement (++ / –) operator has side effects that change the value of the operand. Unary arithmetic operator Meaning Side effect ++ Increment O – Decrement O + No effect. Negative numbers are not reversed to positive numbers. X - Returns a positive number that is a negative number and a negative number that is a positive number. X The position of increment/decrement(++/–) operator has meaning. The prefix increment / decrement operator that located before the operand first increments / decrements the value of the operand, and then performs another operation. The postfix increment / decrement operator that located after the operand first performs other operation, and then increments / decrements the value of the operand. String Concatenation OperatorThe + operator acts as a string concatenation operator if at least one of the operands is a string. 12console.log('1' + 2); //12console.log(1 + '2'); //12 This is an implicit type coercion by the JavaScript engine, regardless of the developer’s intent. Assignment OperatorAssignment Operator assign the operand at right side to the variable at left side. The assignment operator changes the value of a variable by assigning it a value. Assignment Operator Example Same Expression Side Effect = x = 5 x = 5 O += x += 5 x = x + 5 O -= x -= 5 x = x - 5 O *= x *= 5 x = x * 5 O /= x /= 5 x = x / 5 O %= x %= 5 x = x % 5 O An assignment operation is an expression that evaluates to a single value. The assignment expression is evaluated to the assigned value. Comparison OperatorComparison Operator compares the left and right operands, and then returns a Boolean value. Comparison operators are often used in conditional expressions of control statements such as if statements and for statements. Loose Equality Operator and Strict Equality OperatorLoose equality operator and strict equality operator are both returns the Boolean value by comparing whether the left operand and the right operand have the same value. Loose equality operator (==) : loose comparison Strict equality operator (===) : strict comparison Equality Operator Meaning Example Explanation Side Effect == Loose equality comparison x == y values of x and y are equal X === Strict equality comparison x === y both value and type of x and y are equal X != Loose inequality comparison x != y values of x and y are different X !== Strict inequality comparison x !== y value and type of x and y are different X Loose equality operator (==) compares the types by implicit type conversion and then compares them with the same value. Thus, the loose equality operator returns true if the operand of the left and right terms is the same value after the implicit type conversion, even if the type is different. Strict equality operator (===) return false if the types of operands are different. But NaN is the only value that does not match itself. 12// NaN is the only value that does not match itself.console.log(NaN === NaN); //false Use the built-in function isNaN to check if a number is NaN. 1console.log(isNaN(NaN)); //true Relational Operators Relational Operator Name Example Side Effect &gt; Greater than operator x &gt; y X &lt; Less than operator x &lt; y X &gt;= Greater than or equal operator x &gt;= y X &lt;= Less than or equal operator x &lt;= y X Conditional Ternary OperatorThe ternary operator determines the value to return based on the evaluation of the conditional expression. It is the only ternary operator in JavaScript and has no side effects. 1Conditional expression ? return value when the conditional expression is true : return value when the conditional expression is false If the evaluation result of the conditional expression is not a Boolean value, it is implicitly typed as a Boolean value. Conditional ternary operator expressions are expressions that can be evaluated as values. Therefore, the conditional ternary operator expression can be part of another expression and is very useful. Logical Operator OR || Return true if only one operand is true AND &amp;&amp; Return false if any operand is false NOT ! Return true if operand is false, Return false if operand is true The logical OR operator and logical AND operator do not return only the boolean result of the operation. It returns one of the operands. But the NOT operator must return a boolean. 123console.log('Cat' &amp;&amp; 'Dog'); // 'Dog'console.log('Cat' || 'Dog'); // 'Cat'console.log(!'Cat'); //false Comma OperatorComma(,) operator evaluate from the left operand in turn, return the result of the last operand and return the result. 12var x, y, z;x = 1, y = 2, z = 3; Group OperatorGroup operator () evaluates the expression that is the operand first. Therefore, group operators can be used to control the priority of operators. typeof OperatorThe typeof operator returns the string as the data type of the operand after itself. The string returned by the typeof operator does not match the 7 data types. The typeof operator returns one of the 7 strings “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, or “function” It does not return “null”; it returns “function” for functions. 123456789101112typeof '' // \"string\"typeof 1 // \"number\"typeof NaN // \"number\"typeof true // \"boolean\"typeof undefined // \"undefined\"typeof Symbol() // \"symbol\"typeof null // \"object\"typeof [] // \"object\"typeof {} // \"object\"typeof new Date() // \"object\"typeof /test/gi // \"object\"typeof function () {} // \"function\" Since typeof null is an object, when checking null, use === operator. 1234var foo = null; console.log(typeof foo === null); // falseconsole.log(foo === null); // true If an identifier not declared by the typeof operator is computed, it returns “undefined”.","link":"/2019/05/01/6-Operator/"},{"title":"Responsive Web (1)","text":"반응형 웹 | Responsive Web Design 웹 환경의 변화 : Mobile Device의 등장 초기 모바일 환경을 위해 mobile 화면을 별도 구성 &gt; 비용과 유지보수 측면에서 risk 크다. One Source Multi Use : 반응형 웹의 필요성 대두 Contents는 물처럼 어느 그릇에나 담길 수 있어야한다. Contents의 본질을 가지고 Markup 후 CSS로 디자인만 달리 할 수 있어야한다. Flexible vs Adaptive RWD(반응형 웹 디자인) : flexible(latout이 고무줄처럼 유연하게 늘었다 줄었다 하는 것), adaptive(viewport에 따라서 layout이 각각 고정되는 것) &gt; 둘 다Device viewport에 반응하는 design AWD(적응형 웹 디자인) Flexible : 모든 환경에서 유연하게 움직임 Adaptive : Web viewport에서는 고정형, tablet이나 mobile에서는 flexible design 채택 DeskTop First vs Mobile First Mobile First 권장 Desktop CSS 먼저 불러온 후 Mobile로 재적용하면 mobile 환경에서 data 많이 듦 &gt; 성능문제 Flexible Layout Target / Context = Result ( 900px / 960px = 0.9375 * 100% = 93.75%!) Target이 context 안에서 차지하는 영역 고정적인 pixel 단위 사용 최대한 지양 %, viewport, em 등 유연한 단위 사용을 지향 Media Queries123456@charset \"utf-8\"/* All Device *//* Mobile Device */@media all and (min-width: 768px){ /* 사용자 해상도가 768px 이상일 때 실행됨 */} all : 어떤 device든 들어올 수 있다는 뜻 (printer 용 CSS 따로 정의할 수 있음) 코드 중복, 복잡도 증가 &gt; CSS가 복잡해짐! Sass (CSS 전처리기) &gt; build하면 CSS code로 떨어짐 Sass Scss Responsive Image1234img{ max-width: 100%; height: auto;} max-width: 100% &gt; 부모 크기를 기준으로 100%, 원본크기 이상은 늘어나지 않게 함 height: auto &gt; 원본 사이즈 비율을 기준으로 auto (width가 반 줄어들면 얘도 반 줄어들음) • 용량으로 인한 성능, 속도 고려 필요 • Mobile Responsive Web test site: Troy - Responsive web tester • 현재 기기의 Pixel Ratio 알 수 있는 사이트: myDevice.io • 다양한 Image Format 대응 SVG : Vector 형식 이미지 WebP : 구글 제안 • 해결 &lt;img&gt;의 srcset, sizes 속성 &lt;picture&gt; 해상도 따라 조절하는 신규 요소 : &lt;picture&gt; 모를 때를 대비한 fallback image 있어야함 반응형 이미지123456789.rwd-container{ width: 50%; box-sizing: border-box; border: 10px solid #000;}.rwd-container img, .rwd-container video{ width: 100%; height: auto;} &lt;img&gt;가 parent container의 width가 줄어들 때마다 같이 줄어든다. &lt;video&gt;도 가능. 그러나 모두 크기 조절을 위해 wrapping해야한다. &lt;iframe&gt;을 반응형으로 만들기 &lt;iframe&gt; 삽입 123&lt;div class=\"rwd-iframe\"&gt; &lt;iframe src=\"https://www.youtube.com/embed/2S24-y0Ij3Y?controls=0\" allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt; 12345678.rwd-iframe{ border: 10px solid #00f; width: 80%;}.rwd-iframe iframe{ width: 100%; height: auto;} &lt;img&gt;나 &lt;video&gt;처럼 하면 안 먹음 &lt;iframe&gt;은 wrapping &lt;div&gt; 2개 필요함 비율별 module화 123456789101112.rwd-iframe{ position: relative; padding-top: calc(9 / 16 * 100%); background: pink; width: 100%;}.rwd-3-4{ padding-top: calc(3 / 4 * 100%);}.rwd-9-16{ padding-top: calc(9 / 16 * 100%);} 12345678910&lt;div class=\"rwd-container\"&gt; &lt;div class=\"rwd-iframe rwd-9-16\"&gt; &lt;iframe src=\"https://www.youtube.com/embed/2S24-y0Ij3Y?controls=0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"rwd-container\"&gt; &lt;div class=\"rwd-iframe rwd-3-4\"&gt; &lt;iframe src=\"https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d2974.021471174445!2d127.05441626516713!3d37.54323347980236!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x357ca49534790c57%3A0xc115101cbaecb40e!2z7JWE7YGs67C466as7ISc67mE7Iqk!5e1!3m2!1sko!2skr!4v1555310320240!5m2!1sko!2skr\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/div&gt; GRIDContainer에 display: grid 적용 123.container{ display: grid;} Grid-template 12345.container{ display: grid; grid-template-columns: 50% 50%; grid-template-rows: 50% 50%;} Grid는 FireFox에서 개발자도구로 보는 것이 가장 편하다! Grid fraction 123456.container{ background: yellow; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 100px 100px;} Grid 배치 1234567.items4{ background: lime; grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;} Start나 end 중 하나를 지정해주지 않으면 자동으로 한 칸만큼을 차지한다. 단축표기법 123456.items4{ background: lime; /* start / end */ grid-column: 2 / 3; grid-row: 1 / 2;} 여러 track 차지하기 12345.items2{ background: orange; grid-column: 1 / 4; grid-row: 2 / 3;} Grid-area 12345.items2{ background: orange; /* row-start / column-start / row-end / column-end */ grid-area: 2 / 1 / 3 / 4;} Grid template areas Grid item에 name 주고 container에서 grid-template-areas로 위치 잡기 Grid 속성 요약 12345678.container{ background: yellow; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 100px 100px; grid-template-areas: \"item2 . item1\" \"item4 item4 item3\"} Grid IE 환경 코드로 autoprefixAuto Prefixer 🌟 Grid calculatorGrid Calculator 🌟column 크기 65px, gutter 20px, page width와 column width 소수점 안 나오게 조정 Grid column, gutter(gap) 설정123456.container{ background: yellow; display: grid; grid-template-columns: repeat(12, 65px); grid-column-gap: 20px; } : repeat(반복 횟수, 크기) method 사용 Grid area 잡기 : DeskTop Version 1234567891011121314151617181920212223242526272829303132333435363738394041.container{ max-width: 1000px; margin: 0 auto; background: silver; display: grid; grid-template-columns: repeat(12, 65px); /* grid-template-rows: ; */ grid-column-gap: 20px; }.header{ background: pink; grid-area: 1 / 1 / 2 / 13;}.navigation{ background: skyblue; grid-area: 2 / 1 / 3 / 13;}.book{ background: lime; grid-area: 3 / 1 / 4 / 5;}.news{ background: orange; grid-area: 3 / 5 / 4 / 13;}.board{ background: blanchedalmond; grid-area: 4 / 1 / 5 / 5;}.favorite{ background: gold; grid-area: 4 / 10 / 5 / 13;}.twitter{ background: brown; grid-area: 4 / 5 / 5 / 10;}.footer{ background: teal; grid-area: 5 / 1 / 6 / 13;} Grid area 잡기 : Mobile Device 12345678/* Mobile Device */@media all and (max-width: 999px){ .container{ display: grid; grid-template-columns: repeat(4, 1fr); padding: 0 20px; }} 알파, 오메가 margin 따로 없으니까 좌우 padding으로 줌 Margin 빼고 나머지 부분을 4등분하려고 fr 단위 사용 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Mobile Device */@media all and (max-width: 999px){ .container{ display: grid; grid-template-columns: repeat(4, 1fr); grid-column-gap: 20px; padding: 0 20px; grid-template-areas: \"header header header header\" \"nav nav nav nav\" \"book book news news\" \"board board favorite favorite\" \"twitter twitter twitter twitter\" \"footer footer footer footer\" } .header{ background: yellow; grid-area: header; } .navigation{ background: pink; grid-area: nav; } .book{ background: skyblue; grid-area: book; } .news{ background: lime; grid-area: news; } .board{ background: purple; grid-area: board; } .favorite{ background: orange; grid-area: favorite; } .twitter{ background: aqua; grid-area: twitter; } .footer{ background: hotpink; grid-area: footer; }}","link":"/2019/04/16/Responsive Web (1)/"},{"title":"TypeScript (2)","text":"TypeScript의 주요 기능 타입 선언 Class Interface Generic Type Declaration12let num: number;let num2 = 2; // 선언과 동시에 할당할 때는 바로 그 type으로 지정됨 123function mult(x: number, y: number): number { return x * y;} Parameter의 type을 모두 명시해준 경우 Return type은 추론이 가능하므로 생략이 가능하다. Type은 any가 나오지 않게끔만 지정하면 된다. void: return을 하지 않는다. 사실은 undefined가 return되지만 void라고 한다. Types of TypeScriptFrom JavaScript: boolean, null, undefined, number, string, symbol, object Added in TypeScript: array, tuple, enum, any, void, never void와 never 차이never는 함수가 종료하지 않아 결코 return하지 않을 때 사용된다. 무한루프 혹은 Error 메시지를 throw할 때 return type이 never이다. void는 return 값이 없을 뿐이지 함수는 종료한다. array12let list1: number[] = [1, 2, 3];let list2: Array&lt;number&gt; = [1, 2, 3]; // Generic Array Type tuple123let tuple: [string, number];tuple = ['hello', 10];tuple.push('good', 30); 배열인데 고정된 element의 수만큼 type을 미리 선언한다. enum12enum Season {Spring, Summer, Fall, Winter};let s1: Season = Season.Spring; ClassTypeScript가 지원하는 Class는 ES6의 Class와 유사하지만 몇 가지 고유한 확장 기능을 가진다. 1. Class DefinitionES6 Class와 다르게 constructor 외부, 즉 Class body에 Class field를 미리 선언해야 한다. 그렇지 않으면 Error가 발생한다. 12345678class Circle { // Class field 미리 선언 radius: number; constructor(radius: number) { this.radius = radius; }} constructor의 parameter에 Access Identifier를 사용하면 아래와 같이 선언할 수 있다. 12345class Circle { constructor(public radius) { // this.radius = radius;도 안 해줘도 됨 }} 2. Access Identifier public : Class 내부, Child Class 내부, Class Instance에서 접근 가능 protected: Class 내부, Child Class 내부에서 접근 가능 private: Class 내부에서만 접근 가능 Access identifier를 지정해주지 않으면 암묵적으로 public이 된다. 따라서 public으로 지정하고자 하는 Member variable과 method는 access identifier를 생략한다. constructor parameter를 선언할 때 public를 붙이면 할당까지 이루어지고 Class 내부의 member variable이 된다. public을 쓰지 않으면 constructor 내부에서만 참조 가능한 지역 변수가 된다. 3. readonly Keywordreadonly가 선언된 클래스 프로퍼티는 선언할 때 또는 생성자 내부에서만 값을 할당할 수 있다. 그 외의 경우에는 값을 할당할 수 없고 오직 읽기만 가능한 상태가 된다. 상수를 선언할 때 사용한다. 4. static Keyword메소드 뿐만 아니라 프로퍼티도 static으로 지정할 수 있다. 5. Abstract ClassAbstract class는 하나 이상의 abstract method를 포함하며 일반 method도 가질 수 있다. Abstract method란 구현 없이 method 이름과 type만이 선언된 method를 말한다. 선언시 abstract 키워드를 사용한다. Abstract class는 직접 instance를 생성할 수 없고 상속만을 위해 사용된다. Abstract class를 상속한 class는 반드시 abstract class의 abstract method를 구현해야 한다. Interface는 모든 method가 abstract이다. InterfaceInterface는 일반적으로 type check를 위해서 사용된다. 변수, 함수, 클래스에 사용할 수 있다. Interface는 여러가지 type을 갖는 property로 이루어진 새로운 type을 정의하는 것과 같다. Interface에 선언된 property와 method의 구현을 강제해서 일관성을 유지할 수 있게 한다. 1. Variable and Interface1234567891011121314151617// Definition of interfaceinterface Todo { id: number; content: string; completed: boolean;}// 변수의 type으로 interface Todo를 선언let todo: Todo;// 변수 todo는 Todo interface를 따라야한다.todo = { id: 1, content: 'typescript', completed: false };// 함수 parameter를 interface Todo로 선언function addTodo(todo: Todo) { ...} 필요에 따라서 새로운 타입을 생성하는 것과 같다. 함수의 parameter 선언시에도 interface를 사용하여 전달되는 argument의 type 형식을 제한할 수 있다. 2. Function and Interface1234567891011// 함수 인터페이스의 정의interface SquareFunc { (num: number): number;}// 함수 인테페이스를 구현하는 함수는 인터페이스를 따라야 한다.const squareFunc: SquareFunc = function (num: number) { return num * num;}console.log(squareFunc(10)); // 100 잘 안 씀 3. Class and Interface12345678910111213141516171819202122232425// 인터페이스의 정의interface IPerson { name: string; sayHello(): void;}/*인터페이스를 구현하는 클래스는 인터페이스에서 정의한 프로퍼티와 추상 메소드를 반드시 구현하여야 한다.*/class Person implements IPerson { // 인터페이스에서 정의한 프로퍼티의 구현 constructor(public name: string) {} // 인터페이스에서 정의한 추상 메소드의 구현 sayHello() { console.log(`Hello ${this.name}`); }}function greeter(person: IPerson): void { person.sayHello();}const me = new Person('Lee');greeter(me); // Hello Lee 4. Duck TypingInterface를 implements해서 구현하지 않아도, 해당 interface 내부의 property나 method를 모두 구현하면 type check에서 통과된다. 12345678910111213141516171819202122interface IDuck { // 1 quack(): void;}class MallardDuck implements IDuck { // 3 quack() { console.log('Quack!'); }}class RedheadDuck { // 4 quack() { console.log('q~uack!'); }}function makeNoise(duck: IDuck): void { // 2 duck.quack();}makeNoise(new MallardDuck()); // Quack!makeNoise(new RedheadDuck()); // q~uack! // 5 Interface IDuck을 명시적으로 implements하지 않은 RedheadDuck의 instance도 IDuck 내부를 완벽하게 구현했다면 type이 IDuck으로 인정된다. 즉, implements 여부가 아니라 interface 구현 여부가 check된다. 5. Optional Property in InterfaceInterface 내부에서 ?가 붙은 property는 구현을 생략해도 된다. 123456interface StudentInfo { name: string; number: string; age? : number; address? : string;} GenericC나 C++ 등 정적 타입 언어에서는 함수 또는 클래스를 정의할 때 parameter나 return 값의 타입을 선언해야 한다. TypeScript도 정적 타입 언어이므로 정의 시점에 타입을 선언해야하는데, 함수 또는 클래스를 정의할 때 parameter나 return type을 선언하기 어려운 경우가 있다. TypeScript는 선언시 타입을 지정하지 않으면 any타입이 되어 type check를 할 수 없게 된다. Stack이나 Queue를 구현하는 경우 배열에 어떤 type을 담을 것인지 정의할 때 확정짓기 어렵다. 이런 경우에 Generic을 사용한다. 123456789class Stack&lt;T&gt; { protected data: Array&lt;T&gt; = []; push(item: T) { this.data.push(item); } pop(): T { return this.data.pop(); }} 위의 class Stack을 정의할 때 타입을 따로 지정하지 않고 &lt;T&gt;를 사용했다. &lt;T&gt;는 Type Paremeter이며 Type의 약자이다. 어느 type이던 사용할 수 있음을 의미한다. Generic은 선언 시점이 아니라 생성 시점에 타이블 명시해서 다양항 타입을 사용할 수 있도록 하는 기법이다. 123function sort&lt;T&gt;(items: T[]): T[] { return items.sort();} 위는 함수에서 Generic을 사용한 것이다. 어떤 type으로 이루어지는지는 모르지만 배열을 parameter로 받아서 sorting한 배열을 리턴한다.","link":"/2019/06/12/TypeScript-2/"},{"title":"35. Closure","text":"Purpose of Closure: Maintain Status클로저의 주된 목적은 안전한 상태 유지를 하는 것이다. 다른 객체지향 프로그래밍 언어의 경우 private, public, protect 등의 접근 제한자(Access Specifier)를 제공하지만 자바스크립트에는 그런 기능이 없다. (ES6의 Class에 private이 도입된다고 하지만 아직 완벽하게 적용되지 않음) 자바스크립트의 클로저를 사용하면 상태를 안전하게 유지할 수 있다. What is Closure? “A closure is the combination of a function and the lexical environment within which that function was declared.” 클로저는 함수와 그 함수가 선언된 Lexical Environment의 조합이다. 함수가 선언된 Lexical Environment함수 내부에서 정의된 함수를 중첩 함수(nested function)라고 한다. 함수 정의는 평가되어 함수 객체가 된다. 함수 객체는 생성되는 시점에 실행중인 실행 컨텍스트(running execution context)의 LexicalEnvironment를 자신의 상위 스코프로 가진다. 함수 객체의 내부 슬롯 [[Environment]]에 running execution context의 LexicalEnvironment이 저장된다. 즉, 함수는 호출과 무관하게 선언된 위치에서 평가되어 함수 객체가 될 때 자신의 상위 스코프를 [[Environment]]에 저장한다. 이는 함수 객체가 소멸되기 전까지 유지되며 함수가 호출될 때마다 참조하여 상위 스코프로 삼는다. 함수가 호출되어 실행 컨텍스트가 생성될 때 Lexical Environment의 OuterLexicalEnvironmentReference에 그 함수의 [[Environment]]에 저장된 Lexical Environment의 참조값을 저장한다. 이렇게 함수가 어디서 호출되는지에 상관 없이 정의된 위치로 스코프를 결정하는 것을 Lexical Scope(또는 Static Scope)라고 한다. 스코프의 실체는 렉시컬 환경이다. 함수 객체의 내부 슬롯 [[Environment]]모든 함수 객체는 자신의 내부 슬롯 [[Environment]]에 상위 스코프의 참조, 즉 생성될 때 실행중이던 실행 컨텍스트의 Lexical Environment의 참조를 저장한다. 그리고 함수가 호출되어 평가될 때 생성되는 실행 컨텍스트의 OuterLexicalEnvironmentReference로 [[Environment]] 내부 슬롯에 저장해놓은 Lexical Environment를 바인딩해 스코프 체인을 구성한다. Closure and Lexical Environment자바스크립트에서 함수는 1급 객체(First-class Object)이므로 값처럼 취급된다. 따라서 함수에서 함수 객체를 argument로 받거나 리턴하는 것이 가능하다. 함수를 argument로 받거나 리턴하는 함수를 고차 함수(Higher Order Function)라고 한다. 12345678910111213const x = 1;// ①function outer() { const x = 10; const inner = function () { console.log(x); }; // ② return inner;}// 함수 outer를 호출하면 중첩 함수 inner를 반환한다.// 그리고 함수 outer의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop된다. (life cycle 마감)const innerFunc = outer(); // ③innerFunc(); // ④ 10 ③에서 outer 함수는 중첩 함수 inner를 리턴하고 종료한다. 함수가 종료하면 실행 컨텍스트가 실행 컨텍스트 스택에서 pop된다. 소멸되는 것이다. 일반적인 함수의 경우 실행 컨텍스트가 소멸할 때 Lexical Environment도 같이 소멸한다. 그러나 위의 outer 함수처럼 자신의 중첩 함수를 리턴하며 종료하는 경우, outer의 실행 컨텍스트는 소멸하더라도 중첩 함수 inner가 내부 슬롯 [[Environment]]로 outer의 Lexical Environment를 참조하고 있으므로 Reference Count가 남아있는 outer의 Lexical Environment는 소멸하지 않는다. 따라서 inner 함수가 호출되어 inner 실행 컨텍스트를 생성할 때마다 outer의 Lexical Environment를 자신의 상위 스코프로 삼고 outer의 변수를 참조할 수 있는 것이다. outer의 x와 같은 변수를 자유 변수(free variable)라고 한다. outer는 종료했으므로 outer의 Lexical Environment에 접근할 수 있는 것은 참조값을 가지고 있는 inner 함수 뿐이다. 따라서 outer 내부의 상태가 안전하게 유지된다. 이론적으로 모든 함수는 기본적으로 클로저이지만, 모던 브라우저에서는 상위 스코프의 식별자를 참조하지 않는 중첩 함수의 경우 해당 함수의 외부 Lexical Environment를 유지하지 않는다. 또한 외부 함수 내부에서 호출되는 등, 외부 함수와 life cycle을 함께 하는 중첩 함수도 클로저라고 하지 않는다.따라서 일반적으로 클로저는 자신의 외부 함수보다 오래 살아남고, 자신이 기억하는 상위 스코프의 식별자를 참조하는 함수를 말한다. Usage of Closure클로저는 상태를 안전하게 유지하기 위해서 사용한다. 즉, 상태가 의도치 않게 변경되지 않도록 정보 은닉(Information hiding)을 통해 캡슐화(Encapsulation) 하는 것이다. 어떤 상태를 안전하게 유지하기 위해서는 그 상태에 접근할 수 있는 방법을 제한해야한다. 즉, 상태 변경을 위해서 사용하는 메소드를 제외한 다른 외부로부터 상태를 숨겨야 한다. 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;button class=\"decrease\"&gt;-&lt;/button&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); const counter = (function () { // 카운트 상태를 유지하기 위한 자유 변수 let num = 0; // 클로저를 메소드로 갖는 객체를 반환한다. // 객체 리터럴은 스코프를 만들지 않는다. // 따라서 아래 메소드들의 상위 스코프는 즉시 실행 함수의 스코프이다. return { // num: 0, // 프로퍼티는 public이므로 정보 은닉이 되지 않는다. increase() { $counter.textContent = ++num; // 상태 변경 }, decrease() { if (num &lt;= 0) return; $counter.textContent = --num; // 상태 변경 } }; }()); document.querySelector('.increase').onclick = counter.increase; document.querySelector('.decrease').onclick = counter.decrease; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위의 스크립트가 실행되면 IIFE(즉시 실행 함수)가 호출되고 리턴문이 실행될 때 리턴하는 객체가 생성된다. 객체가 생성될 때 객체의 메소드인 increase와 decrease 함수 객체 또한 생성된다. 이 때 increase와 decrease 함수는 자신이 정의될 때의 running execution context인 IIFE 실행 컨텍스트의 Lexical Environment를 [[Environment]]에 기억한다. 그러므로 IIFE는 한 번 호출되고 종료했지만 리턴되어 counter 변수에 저장된 객체의 메소드로서 increase, decrease 함수가 호출될 때마다 IIFE의 Lexical Environment에 등록된 num에 접근하고 상태를 변경할 수 있는 것이다. 다시 말하면 increase, decrease 함수 외에는 num에 접근할 방법이 없으므로 num의 상태가 안전하게 유지된다. 이를 생성자 함수로 바꾸면 객체의 프로퍼티는 public이므로 다음과 같이 구현해야 한다. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;button class=\"decrease\"&gt;-&lt;/button&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); const Counter = (function () { // ① 카운트 상태를 유지하기 위한 자유 변수 let num = 0; function Counter() { // this.num = 0; // ② 프로퍼티는 public이므로 정보 은닉이 되지 않는다. } Counter.prototype.increase = function () { $counter.textContent = ++num; }; Counter.prototype.decrease = function () { if (num &lt;= 0) return; $counter.textContent = --num; }; return Counter; // Counter.prototype에 method 정의했으므로 Counter 함수 객체만 리턴 }()); const counter = new Counter(); document.querySelector('.increase').onclick = counter.increase; document.querySelector('.decrease').onclick = counter.decrease; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 생성자 함수의 프로퍼티가 아니라 자유 변수로 상태를 안전하게 유지한다. Counter.prototype의 메소드는 IIFE에서 정의되었으므로 IIFE의 변수 num에 접근할 수 있다. 함수형 프로그래밍변수의 사용을 가급적 자제하고, 상태 변화를 최소화 시키는 방법으로 프로그래밍 한다. mutable data를 피하고 immutable을 지향하는 함수형 프로그래밍에서 프로그래밍의 안정성을 높이기 위해 클로저는 적극적으로 사용된다. mutable value는 참조값이 전달되므로(Pass by reference) shared data가 되어 상태 변화의 위험성이 높아진다. 또한 외부 상태가 아니라 자신의 지역변수만을 변경시키는 pure function (순수 함수)의 사용을 지향한다. 123456789101112131415161718192021222324252627282930313233// 함수를 인자로 전달받고 함수를 반환하는 고차 함수// 이 함수가 반환하는 함수는 클로저로서 카운트 상태를 유지하기 위한 자유 변수 counter을 기억한다.function makeCounter(predicate) { // 카운트 상태를 유지하기 위한 자유 변수 let counter = 0; // 클로저를 반환 return function () { // 인자로 전달 받은 보조 함수에 상태 변경을 위임한다. counter = predicate(counter); return counter; };}// 보조 함수function increase(n) { return ++n;}// 보조 함수function decrease(n) { return --n;}// 함수로 함수를 생성한다.// makeCounter 함수는 보조 함수를 인자로 전달받아 함수를 반환한다const increaser = makeCounter(increase); // ①console.log(increaser()); // 1console.log(increaser()); // 2// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.const decreaser = makeCounter(decrease); // ②console.log(decreaser()); // -1 Closure Mistake123456789const arr = [];for (var i = 0; i &lt; 5; i++) { arr[i] = function() { return i; }}for (var j = 0; i &lt; 5; j++) { console.log(arr[j]()); // 5 5 5 5 5} 위 예제의 실행 결과는 5 5 5 5 5이다. 이유는 var 키워드로 선언한 i는 block-level scope를 지원하지 않기 때문이다. 즉, for문의 block이 scope를 만들지 않아서 arr의 element에 저장된 함수 객체들이 자신의 상위 스코프로 전역 렉시컬 환경을 기억한다. 이는 for 문 내부의 선언문에 let 키워드를 사용함으로써 보완할 수 있다. 1234567const arr = [];for (let i = 0; i &lt; 5; i++) { arr[i] = () =&gt; i;}for (let i = 0; i &lt; arr.length; i++) { console.log(arr[i]()); // 0 1 2 3 4} for 문은 자바스크립트 엔진에 의해 평가될 때 내부 선언문이 let인지, var인지, expression인지에 따라서 다르게 동작한다. let 키워드로 선언된 선언문일 경우 block-level scope를 만들어야하므로 LOOP Lexical Environment를 우선 생성하고 i를 환경 레코드에 등록한다. 그리고 나서 for문의 body를 평가하고 실행하는데 한 반복 당 하나의 per Iteration Lexical Environment를 생성하고, i의 값이 유효한지 검사하고, statement를 실행한 후 다음 반복을 위한 per Iteration Lexical Environment를 생성하고 increment를 진행한다. 이를 반복한다. 따라서 각 Iteration에서 생성된 함수는 각각 다른 Lexical Environment를 자신의 [[Environment]]로 참조하고 있기 때문에 원하는 결과를 얻을 수 있는 것이다. 비슷하게 Iterable에 사용할 수 있는 for of 문, 객체의 프로퍼티 순회에 사용할 수 있는 for in 문 내부의 선언문에 const 키워드를 사용할 수 있다. 123456789const o = { a: 1, b: 2 };for (const key in o) { console.log(o[key]);}const arr = [ 1, 2, 3 ];for (const item of arr) { console.log(item);} 이는 for of, for in 문의 선언부의 선언문은 for문 body 가장 상단에서 실행되는 것과 같이 동작하기 때문이다. 즉, 반복하는 횟수만큼 선언된다.","link":"/2019/06/07/35-Closure/"},{"title":"18. JavaScript Prototype","text":"JavaScript는 명령형 (Imperative) 함수형 (Functional) 프로토타입 기반 (Prototype-based) 객체지향 프로그래밍 을 지원하는 멀티 패러다임 프로그래밍 언어. 프로토타입은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 방식이다. 자바스크립트는 객체 기반 프로그래밍 언어로, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다. 1. Object-Oriented Programming이전에 포스팅한 객체 지향 프로그래밍 포스팅을 참고 4 Fundamental of Object Oriented Programming 객체지향 프로그래밍은 프로그래밍을 명령어 또는 함수의 목록으로 보는 명령형 프로그래밍의 절차지향적 관점에서 벗어나 프로그램을 여러개의 독립적 객체들의 집합으로 표현하려는 프로그래밍 패러다임을 말한다. 객체지향 프로그래밍에는 몇 가지 원칙이 있다. 추상화 (abstraction) : 다양한 속성 중에서 프로그램에 필요한 속성만을 간추려내어 표현하는 것을 추상화라고 한다. 불필요한 정보는 숨기고 필요한 정보만을 표현함으로써 공토 캡슐화 (encapsulation) : 모든 객체가 자신의 상태(state, private variavles)를 클래스 내부에 private으로 보유함으로써 지켜진다. 내부 상태를 내부 메소드로만 접근할 수 있게 한다. 상속 (inheritance) : 객체지향 프로그래밍의 핵심 개념으로 부모 객체의 프로퍼티를 자식 개체가 상속받아 그대로 사용할 수 있는 것을 말한다. 다형성 (polymorpism) : 부모 객체가 선언한 interface 메소드를 자식 객체가 재정의(overiding) 함으로써 하나의 interface로 상황에 따라 기능을 달리 하는 것을 말한다. 2. Inheritance and Prototype자바스크립트의 상속은 프로토타입(prototype)을 기반으로 구현된다. 상속을 사용해야 하는 이유는, 동일한 프로퍼티 구조를 갖는 객체를 여러개 만들 때 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리적 관점에서 비효율적이기 때문이다. 상속을 사용하면 하나의 프로토타입을 생성해 모든 인스턴스가 공유할 수 있다. 인스턴스를 생성할 때마다 메소드를 생성하므로 퍼포먼스적으로도 비효율적이다. 상속은 코드의 재사용이란 관점에서 유용하다. 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해놓으면 생성되는 인스턴스는 메소드 생성 없이 미리 구현된 프로토타입의 프로퍼티를 사용할 수 있다. 12345678910111213141516function Circle(radius) { this.radius = radius;}// Add getGeometer method to Circle's prototype object(prototype).// The prototype is bound to the prototype property of the Circle constructor function.Circle.prototype.getGeometer = function () { return 2 * this.radius;};const circle1 = new Circle(2);const circle2 = new Circle(5);// All instances of Circle constuctor have same prototype(Circle constuctor function's prototype proeprety).console.log(Object.getPrototypeOf(circle1) === Object.getPrototypeOf(circle2)) // trueconsole.log(Object.getPrototypeOf(circle1) === Circle.prototype) // true 3. prototype ObjectPrototype Object(prototype)는 Object간의 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 object의 Parent obect 역할을 하는 객체로, 다른 객체에 Shared property를 제공한다. Prototype을 상속받은 Child object는 Parent object의 프로퍼티를 자신의 프로퍼티처럼 사용할 수 있다. 모든 객체는 [[Prototype]] 내부 슬롯을 가지며, 내부 슬롯의 값으로 프로토타입 객체의 참조를 저장한다. 프로토타입은 객체의 생성 방식에 의해 결정된다. 객체 리터럴로 생성된 객체의 프로토타입은 Object.prototype이고, 생성자 함수에 의해 생성된 객체의 프로토타입은 자신을 생성한 함수의 prototype 프로퍼티이다. 모든 객체는 하나의 프로토타입을 가지며 모든 프로토타입은 생성자 함수와 연결되어 있다. 이는 객체와 프로토타입, 생성자 사이를 연결한다. Constructor Function : prototype property가 prototype object를 가리킴 Constructor Function.prototype Object : constructor property가 constructor function를 가리킴 Obejct : __ proto __ Accessor property로 자신을 생성한 함수의 prototype Obect에 접근할 수 있음 (내부 슬롯 [[Prototype]]이 가리키고 있음) 3.1. Object’s _proto_ Accessor Property모든 객체는 __ proto __ 접근자 프로퍼티를 통해 자신의 프로토타입 ([[Prototype]] 내부 슬롯)에 접근할 수 있다. _proto_ is an Accessor Property내부 슬롯은 프로퍼티가 아니므로 직접 접근할 수 없고 제공하는 접근자 프로퍼티를 통해서 접근할 수 있다. 접근자 프로퍼티는 접근자 함수로 구성된 프로터티다. 프로퍼티 정의 포스팅 참고 Object.prototype의 _proto_ 접근자 프로퍼티는 자신의 getter, settter 함수(get __proto__, set __proto__)를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 가져오거나 저장한다. Internal Method [[GetPrototypeOf]] &amp; [[SetPrototypeOf]]get __ proto __는 자신의 프로토타입 취득시 [[GetPrototypeOf]] 내부 메소드를 호출 set __ proto __는 새로운 프로토타입 할당시 [[SetPrototypeOf]] 내부 메소드를 호출 코드 내에서 _proto_ 접근자 프로퍼티 직접 사용 자제코드 내에서 _proto_ 직접 사용하는 것 대신 Object.getPrototypeOf, Object.setPrototypeOf 메소드를 사용하는 것을 권장한다. 12345function Person(name) { this.name = name;}console.log(Object.getPrototypeOf(Person) === Person.__proto__); // true _proto_ 접근자 프로퍼티는 상속을 통해 사용됨_proto_ 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아닌, Object.prototype으로부터 상속받은 프로퍼티이다. 모든 객체는 상속을 통해서 Object.prototype.__ proto __ 접근자 프로퍼티를 사용할 수 있다. Prototype Chain모든 객체는 프로토타입 계층 구조인 프로토타입 체인에 묶여있다. 자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 _proto_ 접근자 프로퍼티가 가리키는 링크를 따라서 부모 프로토타입의 프로퍼티를 검색한다. 프로토타입 체인의 최상위 객체는 Object.prototype이다. 모든 객체는 Object.prototype 객체를 상속하므로 Object.prototype의 프로퍼티를 사용할 수 있다. _proto_ 접근자 프로퍼티를 통해서 프로토타입에 접근하는 이유_proto_ 접근자 프로퍼티를 통해서 프로토타입에 접근하면 객체들이 서로가 자신의 프로토타입이 되어 순환 참조적 프로토타입 체인이 만들어지지 않도록 에러를 발생시킨다. 프로토타입 체인이 cyclic하게 되면 프로퍼티 검색시 무한 루프에 빠진다. 즉, Object.prototype의 set _proto_() (setter function)이 객체가 프로토타입을 상호참조할 때 에러를 발생시킨다. 3.2. Function Object’s prototype Property함수 객체는 _proto_ 접근자 프로퍼티 외에 prototype 프로퍼티도 소유한다. __proto__는 모든 객체가 가지는 자신의 프로토타입 접근자 프로퍼티이고, prototype 프로퍼티는 함수 객체가 자신이 생성할 인스턴스에 할당하는 프로토타입이다. 구분 prototype 프로퍼티 _proto_ 접근자 프로퍼티 소유 함수 객체 모든 객체 값 프로토타입의 참조값 프로토타입의 참조값 사용 주체 생성자 함수 모든 객체 사용 목적 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용 자신의 프로토타입에 접근하기 위해서 사용 3.3. Prototype’s constructor Property and the Constructor Function함수 객체가 소유한 prototype 프로퍼티는 상속할 프로토타입을 가리킨다. 모든 프로토타입은 constructor 프로퍼티를 갖는다. constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 생성자 함수가 생성될 때 암묵적으로 프로토타입과 생성자 함수 간의 연결이 이루어진다. 4. Constructor Functions and Prototypes of Objects Created by Literal Notation생성자 함수로 만들지 않은 객체도 Object.prototype을 상속받아야하므로 Object constructor function과도 연결된다. 프로토타입과 생성자 함수는 언제나 pair로 존재해야 하기 때문에 리터럴 표기법에 의해 생성된 객체는 엄밀히 말하면 생성자 함숭 의해 생성된 객체가 아니지만, 생성자 함수의 프로토타입과 연결된다. Literal Notation Constructor Function Prototype Object Literal Object Object.prototype Function Literal Function Function.prototype Array Literal Array Array.prototype RegExp Literal RegExp RegExp.prototype 5. When will prototypes be created?위에서 리터럴 표기법에 의해서 생성된 객체도 생성자 함수와 연결되는 것을 알아보았다. 생성자 함수는 사용자 정의 생성자 함수와 자바스크립트 built-in 생성자 함수로 구분할 수 있다. 프로토타입은 생성자 함수가 생성되는 시점에 생성된다. 5.1. User Defined Constructor Function and Prototype Creation화살표 함수나 ES6의 메소드 축약 표현으로 정의하지 않고 일반적으로 정의(함수 선언문, 함수 표현식)한 함수는 내부 메소드 [[Constructor]]가 구현되어 new 연산자와 함께 호출하면 생성자 함수로 호출할 수 있다. 생성자 함수로 호출할 수 있는 constructor는 함수 객체가 생성될 때 프로토타입도 함께 생성된다. 함수 객체는 함수 정의가 평가될 때 생성된다. 123456// 함수 정의는 Hoisting되어 런타임 이전에 함수 객체를 생성하므로 Student.prototype도 함께 생성되어있다.console.log(Student.prototype);function Student(name) { this.name = name;} 함수의 생성 시점 함수 선언문으로 정의한 함수 함수 선언문으로 정의한 함수는 자바스크립트 엔진이 런타임 이전에 모든 선언문을 미리 실행할 때 평가되어 함수 객체가 된다. 이 때 생성된 함수 객체는 암묵적으로 함수명과 동일한 이름을 가진 변수에 할당된다. 함수 표현식으로 정의한 함수 함수 표현식으로 정의한 함수는 런타입에 변수에 할당될 때, 즉 런타임에 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. 5.2. Built-in Constructor Function and Prototype CreationObject, Function, Number, String, Array, RegExp, Date, Promise 등과 같은 built-in 생성자 함수도 마찬가지로 built-in 생성자 함수가 생성되는 시점에 프로토타입이 같이 생성된다. 모든 built-in 생성자 함수는 전역 객체(window)가 생성되는 시점에 생성된다. 전역 객체는 웹 애플리케이션 실행시 가장 처음으로 생성된다. 웹 애플리케이션 실행시 전역 객체 window 가 만들어지고, built-in 생성자 함수들이 만들어짐과 동시에 프로토타입 객체도 생성되어 built-in 생성자 함수의 prototype 프로퍼티에 바인딩된다. 6. How to Create an Object and Determine its Prototype객체는 다양한 방식으로 생성할 수 있다. 객체 리터럴 Object 생성자 함수 생성자 함수 Object.create 메소드 클래스 (ES6) 객체 리터럴로 생성하는 방식이 가장 간단한 객체 생성 방식이다. 객체 생성방식은 여러가지지만 모두 추상 연산 ObjectCreate에 의해 생성된다. 추상 연산 ObjectCreate는 필수로 자신이 생성할 객체의 프로토타입을 argument로 전달받는다. 추상 연산 ObjectCreate는 객체를 생성한 후 인수로 전달받은 프로토타입을 자신이 생성한 객체의 [[Prototype]] 내부 슬롯에 할당한 후, 생성한 객체를 반환한다. ObjectCreate의 proto parameter로 전달될 argument는 객체가 생성되는 시점에, 객체 생성 방식에 따라서 결정된다. 6.1. Prototype of Object Created by Object Literal자바스크립트 엔진은 객체 리터럴을 평가해서 객체를 생성할 때 추상 연산 ObjectCreate를 호출한다. 이 때 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다. 즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다. 123456const obj = {};// 객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이다.console.log(Object.getPrototypeOf(obj) === Object.prototype); // true// 객체 리터럴의 생성자 함수는 Object 생성자 함수와 연결된다.console.log(obj.constructor === Object); // true 6.2. Prototype of Object Created by Object Constructor FunctionObject 생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다. Object 생성자 함수를 호출하면 객체 리터럴을 평가할 때와 같이 추상 연산 ObjectCeate를 호출한다. 이 때 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다. 12345const obj = new Object;// Object 생성자 함수에 의해 생성된 객체의 프로토타입은 Object.prototype이다.console.log(Object.getPrototypeOf(obj) === Object.prototype); // trueconsole.log(obj.constructor === Object); // true 6.3. Prototype of Object Created by Constructor Functionnew 연산자와 함께 생성자 함수를 호출해서 인스턴스를 생성하면 역시나 추상 연산 ObjectCreate를 호출한다. 이 때 추상 연산 ObjectCreate에 전달되는 프로토타입은 호출된 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 즉, 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩된 객체이다. 123456789function Student(name) { this.name = name;}const me = new Student('Park');// 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩된 객체이다.console.log(Object.getPrototypeOf(me) === Student.prototype); // trueconsole.log(me.constructor === Student); // true 생성자 함수의 prototype 프로퍼티에 바인딩된 프로토타입 객체는 프로퍼티와 메소드를 동적으로 추가할 수 있다. 7. Prototype Chain12345678910111213function Student(name) { this.name = name;}// Student.prototype에 메소드 추가Student.prototype.callMyName = function () { console.log(`Hi! I'm ${this.name}.`);};const me = new Student('Park');console.log(me.hasOwnProperty('name')); // trueconsole.log(me.hasOwnProperty('callMyName')); // false 위의 예제에서 name 프로퍼티는 Student의 인스턴스인 me의 고유 프로퍼티이지만, callMyName은 me 프로토타입의 프로퍼티이므로 hasOwnProperty가 false를 리턴한다. 그런데 hasOwnProperty는 어느 객체의 메소드인데 별다른 정의 없이 호출할 수 있는 것일까? hasOwnProperty는 Object.prototype의 메소드로, 모든 객체가 Object.prototype을 상속하므로 호출할 수 있다. 조금 복잡해보이는 me 객체, me 객체의 prototype, Object.prototype의 관계를 그림으로 표현하면 아래와 같다. 자바스크립트 엔진은 객체의 프로퍼티에 접근하려고 할 때 해당 객체에서 우선 프로퍼티를 검색하고, 없으면 _proto_ 접근자 프로퍼티가 가리키는 프로토타입 객체의 프로퍼티를 순차적으로 검색한다. 이렇게 연결된 프로토타입들을 프로토타입 체인이라고 한다. 프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘이다. 프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. Object.prototype을 프로토 타입 체인의 종점(End ofprototype chain)이라고 한다. Object.prototype의 [[Prototype]]에 __proto__로 접근하면 null이다. 프로퍼티 체인의 끝까지 올라가 검색했는데도 프로퍼티를 찾지 못 할 경우 에러가 아니라 undefined를 리턴한다. 식별자의 검색은 함수의 중첩 관계로 이루어진 스코프의 계층적인 구조에서 이루어지고, 프로퍼티의 검색은 객체 간의 상속 관계로 이루어진 프로토타입의 계층적인 구조에서 이루어진다. 8. Static Property/MethodStatic 프로퍼티(메소드 포함)는 생성자 함수로 인스턴트를 생성하지 않아도 참조하거나 호출할 수 있는 프로퍼티를 말한다. Static 메소드 내부에는 this를 쓸 필요가 없다. 1234567891011121314151617// Constructor Functionfunction Student(name) { this.name = name;}Student.staticProp = 'static property';Student.staticMethod = function () { console.log('static method');};Student.staticProp; // 'static property'Student.staticMethod(); // 'static method'const me = new Student('Park');me.staticMethod(); // Uncaught TypeError: me.staticMethod is not a function Student 생성자 함수는 객체이므로 자신의 프로퍼티와 메소드를 소유할 수 있다. 생성자 함수가 소유한 프로퍼티와 메소드를 정적 프로퍼티, 정적 메소드(Static property, method)라고 부른다. Static 프로퍼티와 메소드는 생성자 함수가 생성한 인스턴스로는 참조하거나 호출할 수 없다. 이는 프로토타입 체인을 이해하고 있다면 당연한 결과이다. 위 예제에서 인스턴스 객체 me가 프로퍼티를 검색하는 프로토타입 체인에는 Student의 staticProp와 staticMethod()가 없기 때문이다. 프로토타입 객체에 정의되어있는 메소드를 Prototype Method, 생성자 함수에 정의되어있는 메소드를 Static Method라고 한다. 8. Property Existance Check : in Operatorin 연산자는 객체 내에 프로퍼티가 존재하는지 확인해 Boolean 값을 반환한다. 12345678const student = { name: 'Park', grade: '3'};console.log('name' in student); // trueconsole.log('grade' in student); // trueconsole.log('address' in student); // false in 연산자는 확인의 대상이 되는 객체 (student)의 프로퍼티 뿐만 아니라 그 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인한다. 그 객체의 고유 프로퍼티만 검색하고 싶다면 Object.hasOwnProperty(prototype)을 사용한다. 9. Property Enumeration객체의 모든 프로퍼티를 순회하려면 for…in 문을 사용한다. for…in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다. 1234567891011121314const student = { name: 'Park', grade: '3', address: 'Seoul', age: 22};for (const prop in student) { console.log(`${prop}: ${student[prop]}`);}// name: Park,// grade: 3,// address: Seoul,// age: 22 for…in 문은 객체의 프로퍼티 개수만큼 반복해서 prop에 student의 프로퍼티를 할당한다. in 연산자와 마찬가지로 순회 대상 객체의 프로퍼티 뿐만 아니라 객체가 상속받은 모든 프로토타입의 프로퍼티를 열거한다. 그러나 왜 Object.prototype의 프로퍼티들은 열거되지 않았을까? Object.prototype의 프로퍼티들의 프로퍼티 어트리뷰트 [[Enumarable]]의 값이 false로, 열거할 수 없도록 정의된 프로퍼티이기 때문이다. 배열에는 for…in 문 대신 일반적인 for문이나 for…of, Array.prototype.forEach 메소드를 사용하는 게 좋다. 10. Disallow use of Object.prototypes builtins directlyESLint: no-prototype-builtins ECScript 5.1에서 Object.create가 도입되면서 특정한 [[Prototype]]을 지정하여 객체를 생성할 수 있게 되었다. 123const parent = { a: 1 };// parent 객체를 상속받는 child 객체를 생성한다.const child = Object.create(parent); 그러나 만약 Object.create()의 argument를 null로 호출할 경우 생성된 객체는 프로토타입 체인에 홀로 존재하게 된다. 즉, Object.prototype의 메소드에 접근할 수 없다. 123456789const obj = Object.create(null);console.log(Object.getPrototypeOf(obj)); // null// obj가 Object.prototype을 상속받지 않았으므로 obj.hasOwnProperty는 undefined이다.obj.hasOwnProperty('bar'); // TypeError: obj.hasOwnProperty is not a function// Object.prototype의 static method를 호출하였으므로 정상 호출된다.Object.prototype.hasOwnProperty.call(obj, 'bar'); // false 게다가 Object.prototype을 상속한 객체라고 할지라도 자신의 고유 메소드로 Object.prototype의 builtin 메소드를 overriding 할 수 있다. 이를 자바스크립트에서는 Property Shadowing이라고 한다. C++에서는 Polymorphism을 구현하는 방식이 상속받은 객체의 overriding이다. Object.prototype의 builtin 메소드를 인스턴스에서 재정의한 경우에도 의도치 않은 동작이 발생할 수 있으니, Object.prototype의 builtin 메소드는 Object.prototype의 static 메소드로서 호출하는 것이 좋다.","link":"/2019/05/12/18-JavaScript-Prototype/"},{"title":"29. DOM","text":"1. DOM (Document Object Model) DOM : DOM Tree + DOM API 브라우저의 렌더링 엔진이 웹 문서를 파싱해서 메모리에 저장한 결과물 즉, DOM이란 모든 element와 element의 attribute, text를 각각의 객체로 만들고 이 객체들을 부모-자식 관계를 나타낼 수 있는 트리 구조로 구성한 것 DOM은 자바스크립트를 통해 동적으로 변경할 수 있고 변경된 DOM은 브라우저 렌더링에 반영된다. DOM API(Application Programming Interface) : 웹 문서의 동적 변경을 위해서 DOM에 접근할 수 있도록 제공하는 자바스크립트 객체의 프로퍼티와 메소드의 집합. DOM API를 통해서 DOM에 접근하고 변경해서 웹 페이지를 동적으로 변경할 수 있다. DOM tree | HTML 문서에 대한 모델 구성브라우저가 HTML 문서를 로드한 후 해당 문서에 대한 모델을 트리 구조로 메모리에 생성한 것 DOM API ㅣ HTML 문서 내의 각 요소에 접근, 수정모델 내의 각 객체에 접근하고 수정할 수 있도록 DOM이 제공하는 프로퍼티와 메소드. DOM이 수정되면 브라우저를 통해 웹페이지의 내용이 변경된다. jQuery DOM 객체를 보다 직관적으로 조작 SPA에는 안 맞음 SPA(Single Page Application) SPA Framework : Angular, React html 문서를 하나를 계속 씀 JavaScript로 html 다시 그림 2. DOM treeHTML 문서 내부에서 element의 중첩 관계는 트리에서 부모-자식 관계로 표현된다. HTML Element 별로 다른 속성을 표현하기 위해서 브라우저에서는 DOM Parsing시 Element의 정보를 DOM 객체의 상속관계로 표현한다. DOM Element(node)는 HTML Element의 상태를 보관한다. DOM tree는 4 종류의 노드로 구성된다. Document Node트리의 최상위 루트(root). 각 Element, Attribute, Text node에 접근하기 위해서는 트리의 루트인 Document Node를 시작으로 검색해야 한다. Element NodeElement node는 HTML element를 표현한다. HTML element는 nesting(중첩)에 의해서 부모-자식 관계를 가지며 이를 통해서 정보를 구조화한다. 따라서 Element Node는 문서의 구조를 표현한다. Attribute, Text node에 접근하기 위해서는 우선 Element node에 접근해야 한다. 각 Element의 특성을 표현하기 위해서 객체의 상속을 이용한다. 이 때 모든 Element node는 HTMLElement 객체를 상속한다. Attribute NodeAttribute Node는 HTML element의 attribute를 표현. Attribute Node는 자신을 가지는 Element의 자식이 아니라 형제(sibling)로 표현된다. Text NodeText Node는 HTML element의 텍스트를 표현한다. Text Node는 Element node의 자식이며 자신의 자식을 가질 수 없다. 즉 DOM tree의 단말 노드이다. 3. DOM QueryDOM을 통해 웹페이지를 조작하기 위해서는 우선 DOM 객체(element)에 접근할 수 있어야 한다. DOM API를 이용해서 DOM Element에 접근할 수 있다. document 객체에 DOM API가 정의되어있다. HTML element에 id 사용을 자제해야하는 이유 중복되면 안되지만 중복되어도 에러가 나지 않는다. HTML element의 id는 전역변수이다. 되도록 class를 사용하는 것이 좋다. document.getElementById(id) id attribute 값으로 Element Node 하나를 선택한다. id가 중복될 경우 첫번째 element만 리턴한다. Return: HTMLElement를 상속받은 객체 모든 브라우저에서 동작한다. 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .red { color: red; } .blue { color: blue; } .yellow { color: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;Cities&lt;/h1&gt; &lt;ul&gt; &lt;li id=\"one\" class=\"red\"&gt;Seoul&lt;/li&gt; &lt;li id=\"two\" class=\"blue\"&gt;London&lt;/li&gt; &lt;li id=\"three\" class=\"red\"&gt;Newyork&lt;/li&gt; &lt;li id=\"four\"&gt;Tokyo&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const elem = document.getElementById('one'); elem.className = 'yellow'; console.log(elem); // &lt;li id=\"one\" class=\"blue\"&gt;Seoul&lt;/li&gt;console.log(elem.__proto__); // HTMLLIElementconsole.log(elem.__proto__.__proto__); // HTMLElementconsole.log(elem.__proto__.__proto__.__proto__); // Elementconsole.log(elem.__proto__.__proto__.__proto__.__proto__); // Node &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; document.querySelector(cssSelector) CSS Selector를 사용해서 Element Node를 한 개 선택한다. 여러 개가 선택되면 첫번째 element만 리턴한다. Return: HTMLElement를 상속받은 객체 IE8 이상 브라우저에서 동작 Can I use document.querySelector ? getElement계열보다 querySelector를 쓰자. 조건에 부합하는 대상이 없을 경우 null 리턴 document.getElementByClassName(class) class attribute 값으로 Element Node를 모두 선택. id가 중복될 경우 첫번째 element만 리턴 Return: (live)HTMLCollection 123456789101112131415161718&lt;body&gt; &lt;div&gt; &lt;h1&gt;Cities&lt;/h1&gt; &lt;ul&gt; &lt;li id=\"one\" class=\"red\"&gt;Seoul&lt;/li&gt; &lt;li id=\"two\" class=\"red\"&gt;London&lt;/li&gt; &lt;li id=\"three\" class=\"red\"&gt;Newyork&lt;/li&gt; &lt;li id=\"four\"&gt;Tokyo&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const elems = document.getElementsByClassName('red'); console.log(elems); for (let i = 0; i &lt; elems.length; i++) { elems[i].className = 'yellow'; } &lt;/script&gt;&lt;/body&gt; HTMLCollection이란, 배열이 아닌 유사배열 객체(array-like object)이다. HTMLCollection은 실시간으로 Node의 상태가 변경될 때마다 Collection에 반영하기 때문에 liveHTMLCollection이라고도 한다. 위 코드의 실행 결과로 두번째와 네번째 Element의 색이 바뀌지 않은 것은 elems가 참조하는 HTMLCollection이 실시간으로 변경되어 누락되었기 때문이다. for 문을 역방향으로 돌리기 while 문 사용 HTMLCollection을 배열로 변경 querySelectorAll 메소드를 사용해서 non-live NodeList를 리턴하게 함 등으로 이런 현상을 방지할 수 있다. IE9 이상의 브라우저에서 동작 document.getElementsByTagName(tagName)1234567 &lt;script type=\"text/javascript\"&gt; const elems = document.getElementsByTagName('li'); console.log(elems); // HTMLCollection(4) [li#one.red, li#two.red, li#three.red, li#four, one: li#one.red, two: li#two.red, three: li#three.red, four: li#four] for (var i = 0; i &lt; elems.length; i++) { elems[i].className = 'blue'; }&lt;/script&gt; getElementsByTagName 메소드도 HTMLCollection을 리턴한다고 명세에 써있으나 Webkit에서는 NodeList를 리턴한다. 크롬에서는 NodeList를 리턴한다. document.querySelectorAll(selector) CSS Selector를 사용하여 Element Node를 모두 선택. Return: NodeList (non-live) IE8 이상 브라우저에서 동작 여러개 선택할 때는 getElements 대신 querySelectorAll을 쓰자. 조건에 부합하는 대상이 없을 경우 빈 NodeList [] 리턴 element.classNameclass=&quot;red blue&quot;에서 ‘red blue’를 의미. class를 한 번에 전부 수정하는 데에 좋다. 하나를 추가하고 싶을 때는 아래와 같이 쓴다. 12const elem = document.querySelector('#one');elem.className += 'yellow'; 추가나 삭제에는 classList의 method를 사용하는 것이 편리하다. 123const elem = document.querySelector('#one');elem.classList.add('blue');elem.classList.remove('blue'); DOM TraversalparentNode자신의 parent 노드를 탐색. HTMLElement를 상속받은 객체를 리턴하며 모든 브라우저에서 동작한다. firstChild, lastChild자신의 첫번째 child, 마지막 child 노드를 탐색. HTMLELement를 상속받은 객체를 리턴하며 IE9 이상의 브라우저에서 동작한다. IE를 제외한 대부분의 브라우저에서는 element 사이의 공백과 줄바꿈을 Text Node로 취급하기 때문에 주의해야 한다. hasChildNodes()child 노트가 있는지 확인하고 Boolean을 리턴. 모든 브라우저에서 동작 childNodeschild 노드의 Collection을 리턴. NodeList(non-live)가 리턴됨. 모든 브라우저에서 동작 childrenchild 노드의 Collection을 리턴. HTMLCollection(live)가 리턴됨. IE9 이상 브라우저에서 동작. childNodes 대신 children을 쓰자 previousSibling, nextSiblingText Node를 포함한 모든 형제 노드를 탐색. HTMLElement를 상속받은 객체가 리턴됨. 모든 브라우저에서 동작 previosElementSibling, nextElementSibling,Element type의 형제 노드만을 탐색. HTMLElement를 상속받은 객체가 리턴됨. IE9 이상 브라우저에서 동작 4. DOM Manipulation1. Text Node Access and Manipulation Text Node의 parent인 Element Node를 선택한다. firstChild 프로퍼티로 Text Node를 탐색한다. Text Node의 프로퍼티 nodeValue를 이용해서 텍스트에 접근하고 수정한다. nodeValue 노드의 값을 반환 Return: 텍스트 노드의 경우는 문자열, 요소 노드의 경우 null 반환 IE6 이상의 브라우저에서 동작 2. Attribute Node Access and ManipulationAttribute Node 조작을 위해서 다음 프로퍼티 또는 메소드를 사용할 수 있다. className class attribute 값에 접근하고 할당할 수 있다. class attribute가 없는데 className을 할당하면 class atrribute를 생성하고 설정한다. className이 여러개일 경우 ' '(공백)으로 구분된 string이 반환되므로 String.split(‘ ‘)를 사용해서 변경한다. 모든 브라우저에서 동작 classList add, remove, item, toggle, contains, replace method 제공 어떤 element의 class attribute를 추가, 삭제, 검사할 때 유용하다. IE10 이상 브라우저에서 동작한다. id id attribute의 값에 접근하고 변경할 수 있다. className과 마찬가지로 없는데 할당시 생성하고 설정한다. 모든 브라우저에서 동작 hasAttribute(attribute) 지정한 어트리뷰트를 가지고 있는지 검사. Return : Boolean IE8 이상의 브라우저에서 동작. getAttribute(attribute) 어트리뷰트의 값을 취득. Return : 문자열 모든 브라우저에서 동작. setAttribute(attribute, value) 어트리뷰트와 어트리뷰트 값을 설정. Return : undefined 모든 브라우저에서 동작. removeAttribute(attribute) 지정한 어트리뷰트를 제거. Return : undefined 모든 브라우저에서 동작. Difference between Attribute and Propertycheckbox input element의 상태를 변경하는 방법 2가지 attribute이용, property 이용 Attribute 이용 element.setAttribute(‘chekced’, true); setting 전에는 변하지 않는 것. element의 초기값 Property 이용 element.checked = true; 실시간으로 값이 변함. element의 현재값(최신 상태) 4.3. HTML Contents ManipulationHTML contents를 조작하기 위해 아래와 같은 프로퍼티와 메소드를 사용할 수 있으나 Markup이 포함된 content를 추가하는 것은 XSS(Cross-Site Scripting Attacks)에 취약하므로 조심해야 한다. textContent Element의 text content에 접근하고 변경할 수 있다. 이 때 입력 문자열에 Markup이 포함되더라도 그냥 텍스트로 출력된다. IE9 이상 브라우저에서 동작 innerText textContent와 같이 element의 text content에만 접근할 수 있지만 비표준이며 CSS를 고려한다. 사용하지 않는 것이 좋음 innerHTML 해당 element 내부의 모든 html contents를 하나의 string으로 취득하고 변경할 수 있다. Markup을 포함한다. 그러나 Markup이 포함된 contents를 추가하는 것은 Cross-Site Scripting Attack에 취약하다. 4.4 DOM Manipulation Method보안상 취약한 innerHTML 프로퍼티를 사용하지 않고 새로운 content를 추가할 수 있는 방법은 DOM을 직접 조작하는 것이다. 주로 하나의 element를 추가하는 경우 사용한다. createElement() method로 새로운 Element Node를 생성. Argument로 tag이름 전달. createTextNode() method로 새로운 Text Node를 생성. 1에서 만든 Element Node에 TextNode를 추가하지 않으면 content가 비어있는 element가 된다. appendChild() method로 생성된 element를 DOM에 추가한다. removeChild() method로는 DOM tree에서 node를 삭제할 수 있다. createElement(tagName) 노드의 값을 리턴 Return: 텍스트 노드의 경우는 문자열, 요소 노드의 경우 null 리턴 IE6 이상의 브라우저에서 동작 createTextNode(text) 텍스트를 인자로 전달하여 텍스트 노드를 생성 Return: Text 객체 모든 브라우저에서 동작 appendChild(Node) argument로 전달한 노드를 마지막 자식 요소로 DOM 트리에 추가 Return: 추가한 노드 모든 브라우저에서 동작 removeChild(Node) argument로 전달한 노드를 DOM 트리에 제거 Return: 추가한 노드 모든 브라우저에서 동작 4.5 insertAdjacentHTML()insertAdjacentHTML(position, string) 인자로 전달한 텍스트를 HTML로 파싱하고 그 결과로 생성된 노드를 DOM 트리의 지정된 위치에 삽입한다. position : insert position ‘beforebegin’ ‘afterbegin’ ‘beforeend’ ‘afterend’ string: 삽입할 element string 모든 브라우저에서 동작 4.6. innerHTML vs. DOM manipulation vs. insertAdjacentHTML() 장단점 innerHTML DOM manipulation insertAdjacentHTML() 장점 DOM 조작 방식에 비해 빠르고 간편간편하게 문자열로 정의한 여러 요소를 DOM에 추가할 수 있음콘텐츠를 취득할 수 있음 특정 노드 한 개(노드, 텍스트, 데이터 등)를 DOM에 추가할 때 적합 간편하게 문자열로 정의된 여러 요소를 DOM에 추가할 수 있음요소가 삽입되는 위치를 선정할 수 있음 단점 XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 사용자 이름 등)를 추가할 때 주의해야 함해당 요소의 내용을 덮어 쓴다. 즉, HTML을 다시 파싱한다. 비효율적 innerHTML보다 느리고 더 많은 코드가 필요 XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 사용자 이름 등)를 추가할 때 주의해야 함 결론적으로 Text를 추가하거나 변경할 때는 textContent, 새로운 element를 추가하거나 삭제할 때는 DOM manipulation 방식(createElement() 등)을 사용한다. 5. style Propertystyle 프로퍼티를 사용하면 inline style 선언을 생성한다. 특정 element에 inline style을 지정할 때 사용한다. 1234567const $four = document.getElementById('four');// inline 스타일 선언을 생성$four.style.color = 'blue';// font-size와 같이 '-'으로 구분되는 프로퍼티는 카멜케이스로 변환해 사용한다.$four.style.fontSize = '2em'; 6. DOM load, “DOMContentLoaded” event123456789function getTodos() { ...}// DOM parsing 되고 resource도 로드됐을 때 발생하는 eventwindow.onload = getTodos;// getTodos에 argument 넘길 수 있음window.onload = function() { getTodos;}; DOMContentLoaded는 리소스 상관 없이 DOM parsing만 완료되었을 때 발생하는 event Reference","link":"/2019/05/22/29. DOM/"},{"title":"34. Execution Context","text":"실행 컨텍스트(Execution Context)는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. Context는 문맥, 맥락이라는 뜻이다. 프로그램에도 맥락이 있다. 예를 들면 식별자가 어느 스코프에서 사용되었는지에 따라서 다른 값을 참조한다. 1. Executable Code실행 가능한 코드(Executable Code)를 4가지 유형으로 구분한다. Executable Code Explaination Global code 전역에 존재하는 Text code. 전역에 정의된 함수나 클래스의 내부 코드는 포함되지 않음 Function code 함수 내부에 존재하는 Text code. 함수 내부에 중첩된 함수나 클래스의 내부 코드는 포함되지 않음 Eval code Built-in 전역 함수인 eval 함수에 argument로 전달된 Text code Module code 모듈 내부에 존재하는 Text code. 모듈 내부의 함수나 클래스의 내부 코드는 포함되지 않음 전역 코드 Global Code전역 코드는 전역 스코프를 생성해야하며 전역 객체와 연결되어야 한다. 이를 위해서 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다. var 키워드로 선언한 전역 변수는 전역 객체(window)의 프로퍼티가 된다. 그러나 전역 스코프를 통해서도 검색이 가능해야한다. let과 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되는 것이 아니라 전역 스코프에 등록된다. 함수 코드 Function Code함수 코드는 지역 스코프를 생성해야하며 생성된 지역 스코프는 스코프 체인의 최상위인 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결되어야 한다. 이를 위해서 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다. 2. Evaluation and Execution of Executable Code모든 Executable code는 실행하기 전에 평가 과정을 거친다. 1. 코드의 평가 과정코드의 평가 과정에서 실행 컨텍스트가 생성된다. 변수, 함수, 클래스 등의 선언문이 우선 평가되고 그 결과가 실행 컨텍스트에 등록된다. Evaluation and Hoistingvar 키워드로 선언한 변수 선언문은 평가되어 변수명(식별자)이 실행 컨텍스트에 등록된다. 이 때 1. 선언 단계(Declaration Phase)로 변수명을 등록하고 2. 초기화 단계(Initialazation Phase)로 변수명에 undefined를 할당한다. 이는 자바스크립트 엔진에 변수의 존재를 알려 변수를 관리하도록 한다. let이나 const 키워드로 선언한 변수 선언문은 평가되어 실행 컨텍스트에 등록될 때 1. 선언 단계만 거친다. 2. 초기화 단계로 undefined를 할당하는 것이 아니라 자바스크립트 엔진이 알고 있는 특별한 값을 할당하여 초기화 이전에 해당 값을 참조하면 ReferenceError: Cannot access 'x' before initialization을 발생시킨다. let이나 const 키워드로 선언한 변수의 2. 초기화 단계는 코드의 실행 중 선언문을 실행시킬 때 이루어진다. 함수 선언문의 경우 함수명과 동일한 변수명을 실행 컨텍스트에 등록하고, 즉시 함수 객체를 생성해서 변수명에 할당한다. 함수 호출시 진행되는 함수 코드의 평가에서는 parameter와 내부 코드의 선언문을 평가한다. 이 때 parameter는 var 키워드로 선언한 변수로 취급되어 undefined로 초기화된다. 또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체도 생성되어 지역 스코프에 등록된다. arguments 객체는 유사배열객체(Array-like Object)로, spread 연산자를 사용해서 배열로 만들어 사용할 수 있다. 2. 코드의 실행코드의 평가 과정이 끝나면 선언문을 제외한 코드가 순차적으로 실행된다. 이 때 할당문 등 코드 실행에 필요한 정보를 실행 컨텍스트에서 가져온다. 코드의 실행 결과는 실행 컨텍스트에서 관리된다. 코드 실행 중 식별자를 만나면 우선 해당 실행 컨텍스트의 스코프에서 검색하고, 없으면 전역 스코프까지 올라간다. console 같은 식별자의 경우 전역 스코프에 등록되지 않았다. 그러나 ReferenceError가 나지 않는다. 이는 전역 스코프에서 식별자를 못 찾을 시 전역 객체의 프로퍼티를 검색하기 때문이다. 전역 객체의 프로퍼티는 마치 전역 스코프에 등록된 식별자처럼 동작한다. 3. Role of Execution Context1. 전역 코드 평가전역 코드를 한 줄씩 실행하기 이전에 전역 코드가 평가된다. 평가 과정에서 변수 선언문과 함수 선언문이 평가된다. 그 결과로 전역 변수와 전역 함수가 전역 스코프에 등록된다. var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티가 된다. let이나 const 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 아니라 전역 스코프의 식별자로 등록된다. 2. 전역 코드 실행전역 코드 평가가 끝나면 전역 코드를 순차적으로 실행한다. 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 전역 코드의 실행이 멈추고 호출된 함수 내부로 진입한다. 3. 함수 코드 평가함수 내부로 진입하면 함수 내부 코드를 실행하기 이전에 함수 코드가 평가된다. 이 때 parameter와 지역 변수 선언문이 평가된다. 그 결과로 parameter와 지역 변수는 지역 스코프에 등록된다. arguments 객체도 생성되어 스코프에 등록된다. 4. 함수 코드 실행함수 코드가 순차적으로 실행되고 종료되면 함수를 빠져나와 함수 호출 다음의 전역 코드를 실행한다. 결국 실행 컨텍스트가 해야하는 역할은 다음과 같다. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분해서 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리해야 한다. 스코프 중첩 관계에 의해서 스코프 체인을 형성해야 한다. 스코프 체인을 통해서 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다. 함수 호출 등으로 현재 실행중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수 있어야 한다. 실행 컨텍스트(Execution Context)는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 다시 말해, 실행 컨텍스트는 식별자(변수, 함수, 클래스, this 등)를 등록하고 관리하기 위한 스코프와 실행 순서 관리를 구현한 내부 매커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다. 4. Execution Context StackStack은 LIFO(Last In First Out) 방식의 자료구조이다. Stack의 가장 윗부분을 Top이라고 하고, 데이터를 넣는 것을 push, 꺼내는 것을 pop이라고 한다. 함수 호출 등에 따라서 생성되는 실행 컨텍스트는 Stack 자료구조로 관리된다. 이를 실행 컨텍스트 스택이라고 한다. 우리가 익히 알고 있는 Call Stack이 Execution context stack이다. 123456789101112cosnt x = 1;funtcion foo() { const y = 2; function bar() { const z = 3; console.log(x + y + z); } bar();}foo(); 1. 전역 코드의 평가와 실행자바스크립트 엔진은 자바스크립트 파일을 로드하고 실행하기 이전에 평가 과정을 거치며 전역 실행 컨텍스트를 생성한다. 전역 객체는 전역 실행 컨텍스트 이전에 생성되어있다. 그러므로 전역 코드를 평가할 때 var 키워드 등으로 선언한 변수를 전역 객체의 프로퍼티로 추가할 수 있는 것이다. 전역 실행 컨텍스트는 생성되는 즉시 Execution Context Stack에 push된다. 이 때 전역 변수 x와 전역 함수 foo는 전역 실행 컨텍스트에 등록된다. 이후에 전역 코드가 실행되며 x에 값이 할당되고 foo가 호출된다. 2. foo 함수의 평가와 실행전역 함수 foo가 호출되면 전역 코드의 실행이 멈추고 control이 foo 함수 내부로 이동한다. 자바스크립트 엔진은 foo 함수 내부의 함수 코드를 평가해서 foo 함수 실행 컨텍스트를 생성하고 Execution Context Stack에 push한다. foo 함수 평가가 끝나고 실행을 하다가 중첩 함수 bar를 만나면 bar를 호출한다. 3. bar 함수의 평가와 실행중첩 함수 bar가 호출되면 foo 코드의 실행이 멈추고 control이 bar 함수 내부로 이동한다. 자바스크립트 엔진은 bar 함수 내부의 함수 코드를 평가해서 bar 함수 실행 컨텍스트를 생성하고 Execution Context Stack에 push한다. bar 함수는 실행을 마치고 종료한다. 4. foo 함수 코드로 복귀5. 전역 코드로 복귀5. Lexical EnvironmentLexical Environment는 식별자가 선언되는 환경, 즉 렉시컬 스코프를 의미한다. 렉시컬 환경은 스코프와 식별자를 관리한다. 실행 컨텍스트는 LexicalEnvorinment 컴포넌트와 VariableEnvironment 컴포넌트로 구성된다. 생성 초기에 두 컴포넌트는 하나의 동일한 렉시컬 환경을 참조한다. with 문을 사용하지 않으면 둘은 언제나 동일한 렉시컬 환경을 참조한다. EnvironmentRecord : 환경 레코드. 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소. 환경 레코드는 Executable Code의 종류에 따라 내용이 다르다. 예를 들어 전역 코드의 경우 전역 객체와 연결되어야하고 함수 코드는 그렇지 않다. Outer Lexical Enciromnent Reference : 외부 렉시컬 환경을 가리키는 참조를 저장. 해당 실행 컨텍스트를 생성한 Executable code를 포함하는 상위 코드의 렉시컬 환경을 말한다. 이를 통해서 One-way linked list인 스코프 체인을 구현한다. ThisBinding : this 바인딩. 렉시컬 환경의 this에 바인딩된 객체(ThisBinding)를 나타낸다. this 바인딩은 Abstract operation ResolveThisBinding을 통해 결정할 수 있다. 결국 스코프 체인은 각 실행 컨텍스트의 Lexical Environment의 link로 구성된 Linked List이다. 6. Creation of Executable Context and Identifier Search Process123456789101112131415var x = 1;const y = 2;function foo (a) { var x = 3; const y = 4; function bar (b) { const z = 5; console.log(a + b + x + y + z);} bar(10);}foo(20); // 42 1. 전역 객체 생성전역 객체는 생성자 함수를 제공하지 않으므로 의도적으로 생성할 수 없다. 전역 객체는 애플리케이션 로딩시 전역 코드가 평가되기 이전에 생성된다. 전역 객체에는 전역 프로퍼티와 전역 함수, builtin 객체가 추가되며 Client Side인 경우 CIient-side Web API를 포함한다. 2. 전역 코드 평가1. 전역 실행 컨텍스트 생성전역 실행 컨텍스트를 생성하고 즉시 실행 컨텍스트 스택에 생성된 전역 실행 컨텍스트를 push한다. 2. 전역 렉시컬 환경 생성전역 Lexical Environment를 생성하고 전역 실행 컨텍스트의 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트에 바인딩한다. Lexical Environment는 EnvironmentRecord, OuterLexicalEnvironmentReference, ThisBinding의 3가지 컴포넌트로 구성된다. 2.1. 전역 환경 레코드 생성 Global Environment Record전역 환경 레코드(Global Environment Record)는 함수 환경 레코드와는 다르게, 객체 환경 레코드(Object Environment Record)와 선언적 환경 레코드(Declarative Environment Record)로 구성되어 있다. Object Environment Record와 Declarative Environment Record는 서로 협력해 전역 스코프와 전역 객체를 관리한다. 2.1.1. 객체 환경 레코드 생성 Object Environment Recordvar 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 Object Environment Record에 등록되고 관리된다. 정확히 말하면 Object Environment Record는 bindingObject라는 객체와 연결되는데, Object Environment Record에 등록한 식별자는 bindingObject의 프로퍼티가 된다. Global Environment Record의 경우 Object Environment Record의 bindingObject는 전역 객체(window)이다. 따라서 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티가 된다. 등록된 식별자를 Global Environment Record의 Object Environment Record에서 검색하면 전역 객체의 프로퍼티를 검색해서 반환한다. 따라서 var x = 1과 같이 선언한 변수는 x 또는 window.x로 검색할 수 있는 것이다. 전역 함수 또한 마찬가지이다. 변수 호이스팅과 함수 호이스팅var 키워드로 선언한 변수는 Object Environment Record에 바인딩된 bindingObject에 변수 식별자를 등록(1. 선언 단계)한 다음, 암묵적으로 undefined로 초기화(2. 초기화 단계)한다. 함수 선언문으로 정의한 함수는 평가되면 함수명과 동일한 이름의 식별자를 Object Environment Record에 등록하고, 함수 객체를 생성해서 즉시 할당한다. 그래서 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있는 것이다. 2.1.2. 선언적 환경 레코드 생성 Declarative Environment Recordlet, const 키워드로 선언된전역 변수는 Declarative Environment Record에 등록되고 관리된다. let, const 키워드로 선언한 변수는 1. 선언 단계와 2. 초기화 단계가 분리되어 진행된다. 평가 단계에서는 선언 단계만 진행되어 식별자가 등록이 되고, 초기화 단계는 실행 시간에 선언문을 실행할 때 진행되므로 선언문 실행 이전까지를 TDZ(Temporal Dead Zone)라고 한다. 이들은 전역 객체의 프로퍼티가 아니라 Global Lexical Environment의 Declarative Environment Record에 등록되어 관리된다. 2.2. 외부 렉시컬 환경에 대한 참조 할당 Outer Lexical Envronment Reference전역(Global)은 코드의 가장 외부이므로 Global Lexical Environment의 Outer Lexical Environment Reference는 null이다. 즉, Global Lexical Environment은 모든 Scope Chain의 최상위 종점이 된다. 2.3. this 바인딩 ThisBindingGlobal Environment Record의 this에는 전역 객체(브라우저에서는 window)가 바인딩된다. 3. 전역 코드 실행평가를 마친 전역 코드는 한 줄씩 순차적으로 실행된다. 선언문을 제외한 할당문 등이 실행되어 전역 변수 x, y에 값이 할당되고 함수 foo가 실행된다. 변수 x, y에 값을 할당하는 과정에서 우선 식별자 검색을 거친다. 현재 running execution context인 Global Execution Context의 Lexical Environment의 Environment Record에서 식별자를 검색한다. var 키워드로 선언된 변수 x는 Object Environment Record에 바인딩된 객체인 window의 프로퍼티로 존재하고 있으며, const 키워드로 선언된 변수 y는 Declarative Environment Record에 등록되어있다. var 키워드로 선언한 변수와 같이 Object Environment Record에 등록된 함수 foo를 검색해 실행한다. 이때 스코프 체인 상에서 식별자를 끝내 찾지 못하면 ReferenceError가 발생한다. 식별자 검색과 프로퍼티 검색식별자 검색은 Scope chain 상에 식별자가 없을 때 ReferenceError를 발생시킨다. 그러나 프로퍼티 검색은 Prototype chain에 찾는 식별자가 없으면 에러 대신 undefined를 리턴한다. 4. 함수 코드 평가1. 함수 실행 컨텍스트 생성foo 함수 호출문이 실행되면 우선 foo 함수 실행 컨택스트가 생성되고 Execution Context Stack에 push된다. 2. 함수 Lexical Environment 생성foo Funtion Lexical Environment를 생성하고 foo 함수 실행 컨텍스트의 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트에 바인딩한다. Lexical Environment는 Environment Record, Outer Lexical Environment Reference, this Binding으로 구성된다. 2-1. 함수 Environment Record 생성Function Environment Record는 함수의 parameter, arguments 객체, 함수 내에 선언된 변수와 함수 등의 식별자를 등록하고 관리한다. 2-1. Outer Lexical Environment Reference 할당함수는 함수 정의가 평가되어 함수 객체가 생성될 때, 현재 실행 중인 실행 컨텍스트의 Lexical Environment를 함수 객체의 내부 슬롯 [[Environment]]에 저장한다. 즉, 생성된 함수 객체가 호출되어 평가될 때 생성되는 함수 실행 컨텍스트의 Lexical Environment의 OuterLexicalEnvironmentReference 컴포넌트의 참조는 해당 함수 객체의 내부 슬롯 [[Environment]]에 저장된 Lexical Environment와 같다. 2-3. this 바인딩일반적으로 this는 호출되는 방식에 따라서 다르게 바인딩된다. this를 참조하는 순간 추상 연산 ResolveThisBinding 메소드가 도는데, 화살표 함수의 경우 선언된 코드가 실행중인 실행 컨텍스트의 Lexical Environment의 this, 즉 Lexical this를 자신의 this로 바인딩한다. 일반 함수로 호출되는 함수의 this는 전역 객체 생성자 함수로 호출되는 함수의 this는 함수가 생성할 instance 메소드로 호출되는 함수의 this는 메소드를 호출한 객체가 된다. 5. 함수 코드 실행평가가 끝난 함수는 순차적으로 실행된다. 이 때 식별자는 현재 running execution context의 Environment Record에서 우선 검색하고, 없을 경우 Outer Lexical Environment의 Environment Record로 넘어가며 검색한다. 7. Execution Context and Block-level ScopeECMAScript block spec 스코프는 렉시컬 환경으로 구현된다. 즉, 블록 레벨 스코프를 만들기 위해서는 Block 렉시컬 환경을 만들어야한다. 그러나 실행 컨텍스트는 4가지 실행 가능한 코드(Executable Code)만이 생성할 수 있다. 그러므로 블록문이 평가될 때는 실행 컨텍스트가 아닌 Lexical Environment만 생성한다. Block: { Statement }가 평가될 때 일어나는 일은 다음과 같다. 변수 oldEnv에 running execution context의 LexicalEnvironment를 담는다. 변수 blockEnv = NewDeclarativeEnvironment(oldEnv) NewDeclarativeEnvironment(E) env = new LexicalEnvironment envRec = 바인딩 안 된 new declarative Environment Record env의 EnvironmentRecord = envRec env의 OuterLexicalEnvironmentReference = E env를 리턴 즉 현재 실행중인 실행 컨텍스트의 Lexical Environment를 OuterLexicalEnvironment로 하는 새로운 Block Lexical Environment를 생성해 blockEnv에 담는다. 이 Lexical Environment의 Environment Record 컴포넌트로 Declarative Environment Record를 가진다. BlockDeclarationInstantiation(StatementList, blockEnv) 수행 Block 또는 CaseBlock이 평가되면 새로운 Declarative Environment Record가 생성되고 블록에서 선언 된 각 block scoped 변수, 상수, 함수 또는 클래스에 대한 바인딩이 환경 레코드에서 인스턴스화된다. BlockDeclarationInstantiation ( code, env ) envRec = env의 EnvironmentRecord (Deciarative) code에서 각 선언문 평가하며 식별자와 값을 바인딩해서 envRec에 추가한다. running execution context의 LexicalEnvironment를 새로 생성한 blockEnv로 지정한다. (blockEnv에는 내부 코드가 평가되어 식별자가 등록된 상태) StatementList(block 문 내부의 문들)을 평가하고 결과를 blockValue에 넣는다. running execution context의 LexicalEnvironment를 oldEnv (blockEnv의 상위 Env)로 다시 돌려놓는다. block 문의 실행 결과인 blockValue를 리턴한다. 쉽게 말하면 블록 문을 실행하면 현재 실행 컨텍스트는 변화하지 않는다. 대신 새로운 Block LexicalEnvironment를 생성해서 현재 실행중인 실행 컨텍스트의 LexicalEnvironment로 잠시 대체한다. 원래의 LexicalEnvironment는 oldEnv에 저장해놓는다. 새로 생성한 blovkEnv는 oldEnv를 상위 스코프로 삼는다. blockEnv를 LexicalEnvironment로 참조하는 상태에서 블록 문을 실행한 후에 현재 실행중인 실행 컨텍스트의 LexicalEnvironment를 다시 oldEnv, 즉 블록문을 실행하기 전의 LexicalEnvironment로 돌려놓는다. Before Closure클로저를 이해하기 위해서는 실행 컨텍스트에 대한 선행 지식이 요구된다. 실행 컨텍스트와 스코프 체인, 프로토 타입을 이해하고 있어야 풀 수 있는 아래 문제를 먼저 풀고 넘어가자. foo 함수의 호출 결과는 무엇일까? 1234567function foo() { console.log(x);}Object.prototype.x = 1;foo(); Object.prototype에 x 프로퍼티 추가 전역 객체 window 또한 객체(object)이므로 Object.prototype을 상속받는다. 자바스크립트 엔진은 객체의 프로퍼티에 접근할 때 [[Get]] 내부 메소드를 호출한다. [[Get]] 내부 메소드는 프로토타입 체인에서 프로퍼티를 검색하고 값을 리턴한다. 객체의 프로퍼티에 접근해서 값을 할당할 때는 [[Set]] 내부 메소드를 호출하는데, 똑같이 프로토타입 체인에서 프로퍼티를 검색한다. 그러나 [[Set]] 내부 메소드는 검색한 프로퍼티가 없으면 프로퍼티를 추가하고 할당하는 역할까지 한다. Object.prototype에 x라는 프로퍼티가 없었으므로 [[Set]] 내부 메소드가 Object.prototype에 x 프로퍼티를 추가하고 1을 할당한다. foo 함수 실행식별자 x를 찾기 위해서는 스코프 체인에서 검색을 한다. 따라서 우선 실행 컨텍스트 스택의 top인 실행중인 실행 컨텍스트(running execution context)의 환경 레코드에서 x를 검색한다. foo 함수의 실행 컨텍스트에는 식별자 x가 존재하지 않으므로 foo 함수의 OuterLexicalEnvironmentReference로 참조하는, 즉 상위 스코프인 Global Lexical Environment의 환경 레코드로 이동해서 검색을 시작한다. Global(전역)의 경우 환경 레코드가 Object, Declarative 2개의 컴포넌트로 구성된다. Declarative Environment Record에도 x가 없으므로 Object Environment Record에 바인딩된 window 객체의 프로퍼티 중에 x가 있는지 검색한다. 이 때 x는 프로퍼티로 검색되는 것이므로 프로토타입 체인에서 검색된다. window 객체는 Object.prototype을 상속한다고 했다. 그러므로 1이 할당된 x가 검색되는 것이다. 여기서 알아야할 것은 스코프 체인과 프로토타입 체인은 별개가 아니라 서로 협력하는 관계라는 것이다.","link":"/2019/06/05/34-Execution-Context/"},{"title":"자바스크립트 키워드 정리","text":"자바스크립트 키워드 20개 1. Data TypeData type은 값의 종류를 말한다. 대부분의 프로그래밍 언어는 데이터 타입을 지원한다. 왜일까? 값을 구분할 필요가 있기 때문이다. 메모리 공간은 연속된 메모리 주소로 구분한다. 값을 메모리에 저장할 때는 데이터의 형태가 다르더라도 모두 2진수로 저장된다. 값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해서, 메모리에 저장해둔 값을 참조할 때 한 번에 읽어들일 메모리 공간의 크기를 결정하기 위해서, 메모리에서 읽어들인 2진수를 어떻게 변환할 지 결정하기 위해서 데이터 타입이 필요하다. 자바스크립트의 데이터 타입은 크게 원시 타입(Primitive Type)과 객체 타입(Object Type)으로 나뉜다. 원시 타입을 제외한 데이터는 모두 객체 타입이다. 그러므로 원시 타입을 우선 살펴보겠다. Primitive Type자바스크립트의 원시 타입은 6종류가 있다. Number 자바스크립트는 정수와 실수를 구분하지 않고 모든 수를 실수로 표현한다. 배정밀도 64비트 부동소수점 형식을 따른다. -(253 -1) ~ 253 -1 사이의 숫자 값을 표현할 수 있다. Infinity -Infinity NaN String 문자열은 0개 이상의 16bit (2byte) 유니코드 문자 (UTF-16)들의 집합으로 전세계 대부분의 문자를 표현할 수 있다. 자바스크립트에서는 일반적으로 작은 따옴표(‘’)를 사용해서 문자열을 표현한다. C나 Java와 달리 자바스크립트의 문자열은 원시타입이고 immutable value다. 한 번 생성된 문자열은 재할당하지 않고서는 변경할 수 없다. Template Literal 템플릿 리터럴은 backtick(``)을 사용하며 다음과 같은 특징을 가진다. Template literal 내의 모든 공백은 그대로 적용된다. (줄바꿈 포함) String interpolation을 사용해서 간단하게 새로운 문자열을 삽입할 수 있다. ${ expression }으로 표현식을 감싸면 표현식의 평과 결과가 문자열로 강제 타입 변환 된다. Boolean true, false undefined undefined 타입의 값은 undefined뿐이다. 선언만 하고 명시적으로 값을 할당하지 않은 변수에는 undefiend가 들어있다. C 에서는 변수를 선언하고 초기화해주지 않으면 선언만 한 변수에는 garbage value가 들어가있지만, 자바스크립트는 선언문을 평가할 때 암묵적으로 변수를 undefined로 초기화한다. null null 타입의 값은 null이 유일하다. null은 변수에 값이 없음을 의도적으로 명시할 때 사용한다. 함수가 유효한 값을 반환할 수 없을 때 명시적으로 null을 반환하기도 한다. Symbol symbol은 ES6에서 추가된 타입으로 이름이 충돌하면 안되는 객체의 유일한 Property key를 만들기 위해서 사용한다. Object (Reference) Type객체, 함수, 배열 등 원시타입을 제외한 모든 것이 객체이다. typeof undefined는 undefined인데 typeof null은 object임 자바스크립트는 동적 타입(Dynamic Type) 언어로, 선언할 때가 아니라 할당할 때 타입이 결정된다. 그러므로 재할당에 의해서 변수의 타입이 동적으로 변한다. 2. LiteralLiteral은 소스 코드 안에서 직접 만들어낸 고정된 값 그 자체를 말한다. 리터럴은 자바스크립트 엔진에 의해 해석되어 값으로 평가된다. Literal은 Literal Notation으로 생성한다. Literal Notation리터럴 표기법은 값을 생성하는 방법. 리터럴은 사람이 이해할 수 있는 표기법으로 자바스크립트 엔진에게 값의 생성을 명령하는 것이다. 리터럴 표기법으로 작성한 리터럴은 자바스크립트 엔진에 의해 해석되어 값으로 평가된다. 리터럴은 결국 값이 되므로 리터럴을 값 자체라고 할 때가 많다. 리터럴은 그 자체로 표현식이며 표현식의 일부로 다른 값을 생성할 때 사용된다. 숫자 리터럴 표기법 12345678910// 정수 리터럴100// 부동 소숫점 리터럴10.5// 2진수 리터럴(0b로 시작)0b01000001// 8진수 리터럴(ES6에서 도입. 0o로 시작)0o101// 16진수 리터럴(ES6에서 도입. 0x로 시작)0x41 문자열 리터럴 표기법 123// 문자열 리터럴'Hello'\"World\" 불리언 리터럴 표기법 123456789// 불리언 리터럴truefalse// null 리터럴null// undefined 리터럴undefined 객체 리터럴 표기법 12// 객체 리터럴{ name: 'Lee', gender: 'male' } 배열 리터럴 표기법 12// 배열 리터럴[ 1, 2, 3 ] 함수 리터럴 표기법 12// 함수 리터럴function() {} 정규표현식 리터럴 표기법 12// 정규표현식 리터럴/ab+c/ 등을 사용해서 리터럴을 생성하고, 리터럴은 평가되어 값이 된다. 3. Expression표현식은 리터럴 식별자(변수명, 함수명) 연산자 함수 호출 등의 조합을 말한다. 표현식은 평가되어 하나의 값을 만든다. 표현식은 하나의 값으로 평가될 수 있는 문(statement)이다. 표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식으로 나뉜다. 문(statement)은 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령이다. 문의 집합으로 이루어진 게 프로그램이다. 문은 선언문, 표현식 문, 조건문, 반복문으로 구분한다. 표현식인 문과 표현식이 아닌 문을 구분하기 위해서는 변수에 할당하는 것이 가장 빠른 방법이다. 아니면 크롬 개발자 도구에 찍어볼 수도 있다. Completion Value크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력한다. 이를 완료 값(Completion value)이라고 한다. 4. Primitive type vs. Object type자바스크립트에서는 데이터 타입을 원시 타입과 객체 타입으로 구분한다. 둘은 그만큼 구분되는 성질을 가진다. 원시 타입 값은 immutable value이고 객체 타입 값은 mutable value이다. 원시 값을 변수에 할당하면 변수의 메모리 공간에는 실제 값이 저장되고 객체를 변수에 할당하면 메모리 공간에 참조 값이 저장된다. Pass by value 원시 값을 가지는 변수를 다른 변수에 할당하면 원본 원시 값이 복사되어 전달된다. Pass by reference 객체를 가리키는 변수를 다른 변수에 할당하면 원본 참조 값이 복사되어 전달된다. 그렇다면 immutable value란 무엇일까? 변경 불가능한 값. 즉, read only한 값이다. 값을 변경할 수 없다는 것은 변수가 참조하는 메모리 공간에 저장된 값을 수정할 수 없음을 의미한다. 원시 값이 저장된 변수의 값을 바꾸기 위해서는 새로운 원시 값을 재할당하는 수밖에 없다. 원시 값을 재할당하면 원래 참조하던 메모리 공간에 새로운 원시 값을 뒤집어 쓰는게 아니라 새로운 메모리 공간에 새로운 값을 저장하고 변수가 그 메모리를 참조하게 된다. 나는 처음 immutable 개념을 공부할 때 변경할 수 없다는 말 때문에 immutable value와 const로 선언한 변수(constant 상수)를 혼동했었는데, constant는 그저 선언과 동시에 할당한 값을 재할당할 수 없는 변수일 뿐이고, constant에 저장되는 값의 종류가 immutable과 mutable인 것이다. 그러므로 그 둘은 개념이 다르다. Pass by value란 값에 의한 전달이다. 변수에 변수를 할당했을 때, 변수가 원시 값을 참조하고 있다면 저장되어있는 값 자체가 복사되어 전달된다. 반면 변수가 객체 값을 참조하고 있다면 저장된 참조값이 복사되어 전달된다. 이처럼 참조값이 전달되는 것을 Pass by reference라고 한다. 5. Function Definition함수 정의를 통해서 함수를 생성할 수 있다. 자바스크립트에서 함수는 함수 선언문 함수 표현식 Function 생성자 함수 화살표 함수 로 정의할 수 있다. 그러나 Function 생성자 함수를 통한 함수 정의는 잘 하지 않는다. 함수 선언문 함수 선언문은 표현식이아닌 문으로 해석된다. 함수 선언문은 실행되어 함수 객체를 생성한다. 함수 선언문을 작성할 때는 함수의 이름을 생략할 수가 없다. 자바스크립트 엔진이 선언문을 실행해서 함수 객체를 생성할 때 함수 객체를 저장할 변수를 암묵적으로 함수명과 동일한 이름으로 선언하기 때문이다. 결국 우리가 선언한 함수를 호출할 때 부르는 함수명은 함수 객체를 참조하는 변수명이다. 실제 함수명은 함수 내부에서만 참조할 수 있는 식별자이다. 주로 재귀함수에서 사용한다. 함수 표현식 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이렇게 변수에 함수를 할당하는 함수 정의 방식을 함수 표현식이라고 한다. 주의해야할 점은, 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수는 호이스팅할 때 다르게 동작한다는 것이다. 함수 선언문은 선언문이므로 자바스크립트 엔진이 런타임 이전에 먼저 실행시켜 함수 객체를 생성하지만, 함수 표현식은 런타임 도중에 할당문이 실행되는 시점에 평가되어 함수 객체가 생성된다. 즉, 함수 표현식으로 생성한 함수는 호이스팅 되지 않는다. 화살표 함수 ES6에서 도입되었으나 모든 함수를 대체하기 위한 것은 아니다. 기존 함수와 다르게 호출 시점이 아니라 선언될 때 상위 lexical scope의 this와 바인딩되고, prototype 프로퍼티가 없고 argument 객체를 생성하지 않는다. 6. Scope변수의 유효 범위를 scope라고 한다. 변수는 자신이 선언된 위치에 의해서 scope가 결정된다. 유효 범위, scope란 다른 코드가 변수 자신을 참조할 수 있는 범위를 말한다. scope는 전역과 지역으로 나눌 수 있는데, 함수 가장 바깥을 전역이라고 하고 전역에서 선언된 변수를 전역 변수라고 한다. 전역 변수는 코드 상 어디에서나 참조할 수 있다. 지역은 함수 몸체 내부(또는 블록 내부)를 의미하며 지역 스코프에서 선언된 변수를 지역 변수라고 한다. 지역 변수는 자신의 지역 스코프와 그 하위 지역 스코프에서 유효하다. scope는 중첩될 수 있으며 scope는 중첩 관계를 바탕으로 scope chain을 만든다. scope는 자바스크립트 엔진이 참조할 변수를 검색할 때 사용되는 규칙이라고 할 수 있다. 변수를 참조할 때 자바스크립트 엔진은 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하면서 변수를 검색한다. 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 연결한 것으로, 함수의 렉시컬 환경은 함수가 호출되며 생성된다. 스코프 체인 내의 식별자 검색은 상위 방향으로만 이루어지므로 하위 스코프의 식별자를 상위 스코프에서 참조할 수 없다. 자바스크립트의 스코프는 Lexical Scope (Static Scope)로 함수를 어디서 정의했는지에 따라서 함수의 상위 스코프를 결정한다. 7. Lexical Scope자바스크립트의 스코프는 Lexical Scope (Static Scope)로 함수를 어디서 정의했는지에 따라서 함수의 상위 스코프를 결정한다고 했다. 함수가 호출된 위치에 따라서 스코프가 결정되는 것은 Dynamic Scope이다. 자바스크립트는 렉시컬 스코프를 따르므로 모든 함수 정의가 평가되어 함수 객체를 생성할 때, 자신이 정의된 스코프를 기억한다. 함수가 기억하는 것은 Lexical Enviromnent인데, 함수 객체의 내부 슬롯 [[Environment]]에 저장한다. 12345678910111213var x = 1;function foo() { var x = 10; bar();}function bar() { console.log(x);}foo(); // 1bar(); // 1 bar() 함수는 foo() 함수 내부에서 호출되었으나, 전역에서 선언되었기 때문에 전역 스코프의 x =1을 우선 찾는다. 8. 전역 변수의 문제점 암묵적 결합 모든 코드가 전역 변수를 참조하고 변경할 수 있기 때문에 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있어 위험하다. 긴 생명 주기 생명 주기가 길다는 것은 리소스가 변경될 수 있는 시간이 길어진다는 것을 의미한다. 또한 브라우저가 종료하기 전까지 소멸되지 않아 메모리 상에 남아있다는 문제가 있다. 스코프 체인 상에서 종점에 존재 변수를 검색할 때 전역 변수가 가장 마지막에 검색되기 때문에 검색 속도가 가장 느리다. 네임 스페이스 오염 파일이 분리되어 있다고 해도 결국 하나의 전역을 갖게 된다. 따라서 각각 다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다. 9. var 키워드로 선언한 변수의 문제점var 키워드로 선언한 변수는 크게 세가지의 문제점을 가진다. 같은 스코프 내에서 중복 선언이 허용된다. 나중에 작성된 변수 선언문은 마치 var키워드가 없는 것처럼 동작한다. 즉, 오류를 내지 않고 재할당한다. 의도치 않게 재할당되어 먼저 선언된 값이 변경되는 결과를 초래할 수 있다. block-level scope 를 지원하지 않는다. (function-level scope) 제어문(if문, for문)의 평가식에 선언한 변수는 전역 변수가 된다. 전역 변수를 남발할 가능성이 높아진다. for문에서 반복을 위해 사용된 변수 i는 for문 외부에서 사용할 일이 없지만 var 키워드로 선언하면 전역 변수가 된다. 이는 예상치 못한 결과를 가져올 수 있다. 변수 호이스팅 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 변수 선언문 이전에 참조할 수 있다. 이는 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다. 이를 보완하기 위해서 ES6에서 let과 const keyword를 도입했다. let과 const의 특징은 다음과 같다. 같은 스코프 내에서 중복 선언을 할 수 없다. block-level scope를 지원한다. hoisting 되지 않는 것처럼 동작한다. 10. Constructor Function생성자 함수란? new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의 빌트인(intrinsic 내장) 생성자 함수를 제공한다. 생성자 함수는 다른 함수와 구별하기 위해 함수명의 맨 앞 글자를 대문자로 사용한다. 생성자 함수는 어떤 특별한 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 정의하고 new연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다. 생성자 함수에 의한 객체 생성 방식의 장점 생성자 함수로 객체를 생성하면 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 내부메소드 constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다. 생성자 함수로서 호출할 수 있다 new 연산자(또는 super 연산자)와 함께 생성자 함수로서 호출되면 내부 메소드 [[Constructor]]가 호출된다 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다. 화살표 함수와 ES6의 메소드 축약 표현으로 정의된 함수는 생성자 함수로 호출할 수 없다. 생성자 함수의 동작 방식 생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성 하는 것과 생성된 인스턴스의 프로퍼티 값을 초기화하는 것이다. 123456789101112131415function Circle(radius) { // 1. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다. // 2. 생성된 빈 객체를 가리키는 this를 사용하여 프로퍼티나 메소드를 추가하고 초기화한다. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; }; // 3. 암묵적으로 this를 반환한다.}// 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환한다.const circle = new Circle(1);console.log(circle); // Circle {radius: 1, getDiameter: ƒ} 생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손한다. 따라서 생성자 함수 내부에서 return 문을 반드시 생략해야 한다. 11. thisthis는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수이다. this가 가리키는 객체는 함수 호출 방식에 따라 동적으로 결정된다. 함수 호출 방식 this가 가리키는 객체 일반 함수로서 호출 전역 객체 메소드로서 호출 메소드를 호출한 객체 생성자 함수로서 호출 생성자 함수가(미래에) 생성할 인스턴스 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다. 이벤트 핸들러 내부의 this는 이벤트가 발생한 요소 객체를 가리킨다. Function.prototype.apply/call/bind 메소드에 의한 간접 호출 =&gt; this는 메소드에 argument로 전달한 객체를 가리킨다. 바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수는 할당에 의해 값이 바인딩된다. 12. DOMDOM이란? 브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라 한다. 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계를 표현할 수 있는 트리 구조로 구성한 것이 DOM이다. DOM은 자바스크립트를 통해 동적으로 변경할 수 있으며 변경된 DOM은 렌더링에 반영된다. 동적 변경을 위해 DOM은 프로그래밍 언어가 자신에게 접근하고 수정할 수 있는 방법을 제공하는데 일반적으로 프로퍼티와 메소드를 갖는 자바스크립트 객체로 제공된다. 이를 DOM API라고 부른다. DOM은 ECMAScript에서 정의한 표준이 아닌 별개의 W3C의 공식 표준이다. DOM에서 모든 요소, 어트리뷰트, 텍스트는 하나의 객체이며 Document 객체의 자식이다 DOM의 두 가지 기능 HTML 문서에 대한 모델 구성 브라우저는 HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성한다. 이때 모델은 객체의 트리로 구성되는데 이것을 DOM tree라 한다. HTML 문서 내의 각 요소에 접근 / 수정 DOM은 모델 내의 각 객체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공한다. DOM이 수정되면 브라우저를 통해 사용자가 보게 될 내용 또한 변경된다. DOM tree의 네 종류 노드 문서 노드 트리의 최상위에 존재 DOM tree에 접근하기 위한 시작점 요소 노드 HTML 요소를 표현(div, h1, ul 등) 중첩에 의해 부자 관계를 가진다. 어트리뷰트, 텍스트 노드에 접근하려면 먼저 요소 노드를 찾아 접근해야 한다. HTMLElement 객체를 상속한 객체로 구성된다 어트리뷰트 노드 HTML 요소의 어트리뷰트를 표현 해당 어트리뷰트가 지정된 요소의 자식이 아니라 해당 요소의 일부로 표현 텍스트 노드 HTML 요소의 텍스트를 표현 요소 노드의 자식이며 자신의 자식 노드를 가질 수 없다. 즉, 텍스트 노드는 DOM tree의 최종단이다. 13. 브라우저 동작 브라우저는 동기(Synchronous)적으로 HTML, CSS, 자바스크립트를 처리한다. 이것은 script 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 script 태그의 위치는 중요한 의미를 갖는다. body 요소의 가장 아래에 script 태그를 위치시키면 이미 HTML 파서가 HTML 요소를 모두 파싱하여 DOM 객체를 생성하였기 때문에 자바스크립트가 DOM 조작 시 에러가 발생하지 않는다. 또한, HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다. 웹 브라우저의 동작 순서 클라이언트가 서버에게 Request(요청)을 보낸다. 서버가 Response(응답)을 보낸다. 클라이언트가 서버의 응답을 받아서 HTML, CSS, JavaScript, 이미지 등의 파일을 Load한다. 렌더링 엔진의 HTML 파서와 CSS 파서가 HTML, CSS 파일을 파싱(Parsing)한다. 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 파싱된 결과를 바탕으로 HTML은 DOM tree, CSS는 CSSOM tree, JavaScript는 syntax tree로 변환한다. 자바스크립트가 DOM tree와 CSSOM tree를 제어한다. DOM tree와 CSSOM tree가 렌더 트리로 결합된다. 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 표시한다. 14. Event Delegation이벤트 위임이란? 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법 이벤트가 이벤트 흐름에 의해 이벤트를 발생시킨 요소의 부모 요소에도 영향**(버블링)**을 미치기 때문에 가능한 것 이벤트 위임이 효과적인 경우 모든 li 요소가 클릭 이벤트에 반응하는 처리를 구현하고 싶은 경우 =&gt; 부모요소인 ul요소에 클릭 이벤트 핸들러를 바인딩하는 것이 효율적이다. 동적으로 li 요소가 추가되는 경우, 아직 추가되지 않은 요소는 DOM에 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다. 15. Event Capturing vs. Event BubblingCapturing 이벤트가 window 객체에서 출발해서 DOM 트리를 통해서 이벤트 타깃까지 전파되는 것. 이벤트 타깃이 이벤트를 수신하기 전에 이벤트를 빼돌리는 단계라는 뜻에서 캡처링 단계라는 이름이 붙음 Bubbling 이벤트가 이벤트 타깃에서 출발해서 DOM 트리를 타고 window 객체까지 전파되는 것. 이벤트가 마치 거품이 올라오는 것처럼 DOM트리 아래에서부터 위로 올라온다는 뜻에서 버블링 단계라는 이름이 붙음 16. Class대부분의 객체 지향 언어가 클래스 기반인 점을 고려하여 ES6에서 클래스를 도입했다. 그러나 그 클래스도 사실은 함수이고 기존의 프로토타입 기반 객체지향 패턴으로 동작한다. 클래스는 상속을 빼놓고 말할 수 없다. 상속이란 객체지향의 핵심적인 기능으로, 클래스는 상속을 지원한다. 클래스의 기본적인 문법은 아래와 같다. 12345678910111213class Student { // constructor constructor(name) { this._name = name; } // default method definition: class's prototype method sayHello() { console.log(`Hi! ${this._name}`); }}const mimi = new Student('Mimi');mimi.sayHello(); // Hi! Mimi 클래스 정의 내부에는 최대 한 개의 constructor가 필요하며 constructor를 생략할 경우에 default connstructir() {}가 실행되어 인스턴스 생성시 빈 객체가 생성된다. constructor는 인스턴스를 생성하고 클래스 필드를 초기화하는 특수한 메소드이다. Class Field클래스 내부에는 메소드만 선언한다. 모든 프로퍼티(인스턴스의 멤버 변수)는 constructor 내부에 선언한다. contstructor는 생성자 함수와 같이 this로 빈 객체를 생성해서 프로퍼티를 추가하고 this를 리턴한다. Class HoistingClass는 let이나 const와 같이 호이스팅 되지 않는 것처럼 동작한다. 선언 이전에 참조하면 ReferenceError가 발생한다. 호이스팅되지 않는 것처럼 동작한다는 것var 키워드와 다르게 let, const 키워드는 런타임 이전에 자바스크립트 엔진이 선언문을 미리 실행할 때, 1. 선언 단계(Declaration Phase)와 2. 초기화 단계(Initialization Phase)가 함께 진행되지 않는다. let, const 키워드로 선언한 변수는 1. 선언 단계만 미리 실행되어 스코프에 변수 명이 등록되지만 2. 초기화 단계는 런타임에 선언문이 실행될 때 실행된다. 2. 초기화 단계는 변수의 값을 위한 메모리 공간을 할당하고 undefined라는 값을 암묵적으로 넣어주는 것이다. 이런 초기화 단계를 진행하지 않았으니 참조 에러가 나는 것이다. ES6의 class도 사실은 함수이지만, function 키워드로 선언한 함수 선언식은 호이스팅 되는 반면 class로 선언한 함수는 호이스팅 되지 않는다. 즉, 선언만 해놓고 초기화를 하지 않아 호이스팅되지 않는 것처럼 동작한다. let이나 const 나 class 등의 선언문 이전을 TDZ(Temporal Dead Zone)이라고 한다. 선언만 되고 초기화되지 않아 참조할 수 없는 구간을 말한다. 17. super1. extends Keywordextends 키워드는 parent 클래스를 생속받는 child 클래스를 정의할 때 사용한다. 2. super Keywordsuper 키워드는 parent 클래스를 참조하거나 parent 클래스의 constructor를 호출할 때 사용한다. super 클래스가 메소드로 사용될 때는 parent 클래스의 constructor를 호출한다. child 클래스의 constructor에서 super()를 호출하지 않으면 this에 대한 ReferenceError가 발생한다. child 클래스의 인스턴스를 만들 때 parent 클래스의 인스턴스를 우선 만들고 상속한다. 1234567// parent 클래스의 constructor를 호출한다.class Cylinder extends Circle { constructor(radius, height) { // super가 parent class의 constructor처럼 사용됨 super(radius); this.height = height; } ECMAScript의 스펙을 살펴보면 super가 argument를 전달받으며 호출될 때 내부적으로 자신의 parent 클래스의 constructor를 호출하고 constructor가 리턴한 this 객체를 child 클래스 constructor의 this(child 클래스가 생성할 인스턴스)에 바인딩한다. super 클래스가 객체로 사용될 때는 parent 클래스를 참조한다. 123456789101112// super가 parent class Circle처럼 사용됨// parent class Circle의 getArea overriding getArea() { return (this.height * super.getPerimeter()) + (2 * super.getArea()); } // 자신의 메소드 정의 getVolume() { return super.getArea() * this.height; }} 18. Prototype상속 (inheritance) : 객체지향 프로그래밍의 핵심 개념으로 부모 객체의 프로퍼티를 자식 개체가 상속받아 그대로 사용할 수 있는 것을 말한다. 자바스크립트의 상속은 프로토타입(prototype)을 기반으로 구현된다. 상속을 사용해야 하는 이유는, 동일한 프로퍼티 구조를 갖는 객체를 여러개 만들 때 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리적 관점에서 비효율적이기 때문이다. 상속을 사용하면 하나의 프로토타입을 생성해 모든 인스턴스가 공유할 수 있다. 인스턴스를 생성할 때마다 메소드를 생성하므로 퍼포먼스적으로 비효율적이다. 상속은 코드의 재사용이란 관점에서 유용하다. 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해놓으면 생성되는 인스턴스는 메소드 생성 없이 미리 구현된 프로토타입의 프로퍼티를 사용할 수 있다. _proto_ &amp; prototype property모든 객체는 [[Prototype]] 내부슬롯에 자신의 프로토타입을 가지고, 접근하기 위해서 _proto_ 접근자 프로퍼티를 사용한다. 함수 객체는 _proto_ 접근자 프로퍼티 외에 prorotype 프로퍼티도 소유하는데, 이 둘을 헷갈리면 안된다. __proto__는 모든 객체가 가지는 자신의 프로토타입 접근자 프로퍼티이고, prototype 프로퍼티는 함수 객체가 자신이 생성할 인스턴스에 할당하는 프로토타입이다. 구분 prototype 프로퍼티 _proto_ 접근자 프로퍼티 소유 함수 객체 모든 객체 값 프로토타입의 참조값 프로토타입의 참조값 사용 주체 생성자 함수 모든 객체 사용 목적 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용 자신의 프로토타입에 접근하기 위해서 사용 프로토타입은 생성자 함수가 생성되는 시점에 함께 생성된다. Prototype Chain 자바스크립트 엔진은 객체의 프로퍼티에 접근하려고 할 때 해당 객체에서 우선 프로퍼티를 검색하고, 없으면 _proto_ 접근자 프로퍼티가 가리키는 프로토타입 객체의 프로퍼티를 순차적으로 검색한다. 이렇게 연결된 프로토타입들을 프로토타입 체인이라고 한다. 프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘이다. 프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. Object.prototype을 프로토 타입 체인의 종점(End ofprototype chain)이라고 한다. 프로퍼티 체인의 끝까지 올라가 검색했는데도 프로퍼티를 찾지 못 할 경우 에러가 아니라 undefined를 리턴한다. 식별자의 검색은 함수의 중첩 관계로 이루어진 스코프의 계층적인 구조에서 이루어지고, 프로퍼티의 검색은 객체 간의 상속 관계로 이루어진 프로토타입의 계층적인 구조에서 이루어진다. 19. Promise자바스크립트는 비동기 처리를 위해서 callback 함수 패턴을 사용한다. 그러나 callback 패턴은 가독성이 나쁘고 에러의 예외 처리가 곤란하다. ES6에서 Asynchronous processing을 위한 패턴으로 Promise를 도입했다. Promise는 비동기 처리를 하고 Response가 오면 해야할 일을 약속하는 것이다. 콜백 패턴의 단점 콜백 헬 콜백 패턴을 사용할 때 처리 순서를 위해서 여러 개의 콜백 함수가 중첩되어 프로그래밍의 복잡도가 높아진다. 그래서 콜백 헬이 발생한다. 에러 처리의 한계 Exception(예외)는 Caller 방향으로 전파되는데, 콜백 함수의 경우 Caller를 찾을 수 없으므로 try catch로 에러를 캐치할 수 없다. 이러한 콜백의 단점을 보완하기 위해서 ES6에서 Promise를 도입했다. Promise 생성123456789const promise = new Promise((resolve, reject) =&gt; { // Asynchronous process if (/* Asynchronous process Fulilled */) { resolve('result'); } else { /* Asynchronous process Rejected */ reject('failure reason'); }}); Promise constructor function은 비동기 작업을 수행할 callback 함수를 argument로 전달받는다. 이 callback 함수는 resolve, reject 함수를 argument로 전달받는다. resolve 함수는 argument로 실행 결과를 전달하며 호출, reject 함수는 argument로 에러 메시지를 전달하며 호출한다. Promise 후속 처리비동기 함수는 Promise 객체를 리턴해야 한다. 그러면 Promise 객체의 메소드인 then과 catch를 사용해서 후속 처리를 한다. thenthen 메소드는 두 개의 콜백 함수를 argument로 전달받는다. 첫 번째 callback 함수는 성공(fulfilled, resolve 함수가 호출된 상태) 시 호출되고 두 번째 callback은 실패(rejected, reject 함수가 호출된 상태) 시 호출된다. 1234567&gt; p.then(onFulfilled, onRejected);&gt; p.then(function(value) {&gt; // fulfilled&gt; }, function(reason) {&gt; // rejected&gt; });&gt; onFulfilled ​ Promise가 성공했을 때 호출되는 function. Fulfillment value (수행 결과) (Promise의 resolve argument에 넘겨준 response) 하나를 argument로 받는다. Promise를 리턴한다. onRejected ​ Promise가 거부되었을 때 호출되는 function. Rejected reason (에러 이유) (Promise의 regect argument에 넘겨준 error mesagge) 하나를 argument로 받는다. Promise를 리턴한다. catch예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출된다. 123456&gt; p.catch(onRejected);&gt; &gt; p.catch(function(reason) {&gt; // rejected&gt; });&gt; onRejected ​ Promise가 거부되었을 때 호출되는 function. Rejected reason을 argument로 받는다. then과 catch 메소드도 Promise 객체를 리턴하므로 Promise Chaining이 가능하다. 콜백을 중첩시키지 않고서도 처리 순서를 지킬 수 있다. 20. 동기식 처리 모델 vs. 비동기식 처리 모델동기식 처리 모델(Synchronous Processing Model)은 Blocking model이라고도 불리며, 어떤 작업 도중에 클라이언트가 서버에 데이터를 요청하는 것과 같이 시간이 오래 걸리는 일이 발생하면 다른 작업을 Blocking 시켜놓고 해당 작업이 끝날 때까지 기다리는 것과 같이 동작한다. 반면 비동기식 처리 모델(Asynchronous Processing Model)은 작업 도중 서버로의 요청 등 시간이 오래 걸리는 일이 발생하면 기다리지 않고 (non-blocking) 바로 다음 작업을 실행한다. 자바스크립트의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기식 처리 모델로 동작한다.","link":"/2019/05/31/자바스크립트-키워드-정리/"}],"tags":[{"name":"OOP","slug":"OOP","link":"/tags/OOP/"},{"name":"ADT","slug":"ADT","link":"/tags/ADT/"},{"name":"Encapsulation","slug":"Encapsulation","link":"/tags/Encapsulation/"},{"name":"Abstraction","slug":"Abstraction","link":"/tags/Abstraction/"},{"name":"자바스크립트","slug":"자바스크립트","link":"/tags/자바스크립트/"},{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"Computational Thinking","slug":"Computational-Thinking","link":"/tags/Computational-Thinking/"},{"name":"Scope","slug":"Scope","link":"/tags/Scope/"},{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"HTML, CSS","slug":"HTML-CSS","link":"/tags/HTML-CSS/"},{"name":"immutable","slug":"immutable","link":"/tags/immutable/"},{"name":"mutable","slug":"mutable","link":"/tags/mutable/"},{"name":"primitive","slug":"primitive","link":"/tags/primitive/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"pass by reference","slug":"pass-by-reference","link":"/tags/pass-by-reference/"},{"name":"pass by value","slug":"pass-by-value","link":"/tags/pass-by-value/"},{"name":"FDS12","slug":"FDS12","link":"/tags/FDS12/"},{"name":"Hackaton","slug":"Hackaton","link":"/tags/Hackaton/"},{"name":"window","slug":"window","link":"/tags/window/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"RegExp","slug":"RegExp","link":"/tags/RegExp/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"ECMA","slug":"ECMA","link":"/tags/ECMA/"},{"name":"Modlue","slug":"Modlue","link":"/tags/Modlue/"},{"name":"Destructuring","slug":"Destructuring","link":"/tags/Destructuring/"},{"name":"REST API","slug":"REST-API","link":"/tags/REST-API/"},{"name":"Polymorphisim","slug":"Polymorphisim","link":"/tags/Polymorphisim/"},{"name":"Inheritance","slug":"Inheritance","link":"/tags/Inheritance/"},{"name":"Variable","slug":"Variable","link":"/tags/Variable/"},{"name":"Hoisting","slug":"Hoisting","link":"/tags/Hoisting/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Web Browser","slug":"Web-Browser","link":"/tags/Web-Browser/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"Pipe","slug":"Pipe","link":"/tags/Pipe/"},{"name":"Angluar","slug":"Angluar","link":"/tags/Angluar/"},{"name":"Service","slug":"Service","link":"/tags/Service/"},{"name":"Dependency Injection","slug":"Dependency-Injection","link":"/tags/Dependency-Injection/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Call by Value","slug":"Call-by-Value","link":"/tags/Call-by-Value/"},{"name":"Call by Reference","slug":"Call-by-Reference","link":"/tags/Call-by-Reference/"},{"name":"Call by Object Reference","slug":"Call-by-Object-Reference","link":"/tags/Call-by-Object-Reference/"},{"name":"Fisrt-class Function","slug":"Fisrt-class-Function","link":"/tags/Fisrt-class-Function/"},{"name":"Substring","slug":"Substring","link":"/tags/Substring/"},{"name":"Subsequence","slug":"Subsequence","link":"/tags/Subsequence/"},{"name":"javaScript","slug":"javaScript","link":"/tags/javaScript/"},{"name":"global variable","slug":"global-variable","link":"/tags/global-variable/"},{"name":"local variavble","slug":"local-variavble","link":"/tags/local-variavble/"},{"name":"Class","slug":"Class","link":"/tags/Class/"},{"name":"Access Modifier","slug":"Access-Modifier","link":"/tags/Access-Modifier/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"},{"name":"Quick sort","slug":"Quick-sort","link":"/tags/Quick-sort/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"Babel","slug":"Babel","link":"/tags/Babel/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Routing","slug":"Routing","link":"/tags/Routing/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Reactive Programming","slug":"Reactive-Programming","link":"/tags/Reactive-Programming/"},{"name":"Observable","slug":"Observable","link":"/tags/Observable/"},{"name":"Function","slug":"Function","link":"/tags/Function/"},{"name":"Object","slug":"Object","link":"/tags/Object/"},{"name":"First-class object","slug":"First-class-object","link":"/tags/First-class-object/"},{"name":"일급 객체","slug":"일급-객체","link":"/tags/일급-객체/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"Higher Order Function","slug":"Higher-Order-Function","link":"/tags/Higher-Order-Function/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Number","slug":"Number","link":"/tags/Number/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Wrapper","slug":"Wrapper","link":"/tags/Wrapper/"},{"name":"Event","slug":"Event","link":"/tags/Event/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"SPA","slug":"SPA","link":"/tags/SPA/"},{"name":"Single Page Application","slug":"Single-Page-Application","link":"/tags/Single-Page-Application/"},{"name":"Data Type","slug":"Data-Type","link":"/tags/Data-Type/"},{"name":"Expression","slug":"Expression","link":"/tags/Expression/"},{"name":"Statement","slug":"Statement","link":"/tags/Statement/"},{"name":"Operater","slug":"Operater","link":"/tags/Operater/"},{"name":"Prototype","slug":"Prototype","link":"/tags/Prototype/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"실행 컨텍스트","slug":"실행-컨텍스트","link":"/tags/실행-컨텍스트/"}],"categories":[{"name":"Computer Engineering","slug":"Computer-Engineering","link":"/categories/Computer-Engineering/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Data Structure","slug":"Computer-Engineering/Data-Structure","link":"/categories/Computer-Engineering/Data-Structure/"},{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"Angular","slug":"JavaScript/Angular","link":"/categories/JavaScript/Angular/"},{"name":"Computer Graphics","slug":"Computer-Engineering/Computer-Graphics","link":"/categories/Computer-Engineering/Computer-Graphics/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"CodeWars","slug":"Algorithm/CodeWars","link":"/categories/Algorithm/CodeWars/"},{"name":"Basic","slug":"Computer-Engineering/Basic","link":"/categories/Computer-Engineering/Basic/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","link":"/categories/Algorithm/LeetCode/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Algorithm","slug":"Computer-Engineering/Algorithm","link":"/categories/Computer-Engineering/Algorithm/"},{"name":"React","slug":"JavaScript/React","link":"/categories/JavaScript/React/"},{"name":"HTML/CSS","slug":"HTML-CSS","link":"/categories/HTML-CSS/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"UnderScore","slug":"Algorithm/UnderScore","link":"/categories/Algorithm/UnderScore/"}]}