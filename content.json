{"pages":[{"title":"","text":"","link":"/about/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"1. OOP and ADT","text":"Object-oriented DesignObject-oriented design has fundamnental defferences from structured programming design methods. The two methods are similar in that they develop complex systems with divide and conquer, but differ in how to divide a given task. Algorithmic Decomposition vs Object-oriented DecompositionTraditional programming techniques used to algoritmicc decomposition. Algorithmic or functional decomposition treats software as a process and breaks it down into modules that represent the steps of the process. These modules are implemented in language syntax such as procedure of Pascal, subprogram of FORTRAN, function in C. Data Structure to implement the program is of secondary concern and should be considered only after the project has been divided into functional modules. Object-oriented decomposition views software as set of Well-defined objects that model software well for entity in applications. These objects form software sysyem by interaction. Functional decomposition should be considered after system decomposied to objects. The majot positive of object-oriented design is reuse of software. This enables flexible software systems that can change and evolve as the requirements of the system change. Basic concept of Object-oriented ProgrammingDefinition : An object is an entity that performs calculations and has states. So object can be considered compination of data and operations. Definition : OOP has methods such as .. An object is basic building block. Each object is instance of some type(class). Classes are connected each other by inheritance. (Programming not using inheritance does not considered as object-oriented programming) Definition : Called object-oriented language if some language has a function like .. Support object All objects are involved in class Support inheritance A language support 1, 2 not 3 called “object-based language”. (JavaScript) Data Abstraction and EncapsulationThe concept of abstraction and encapsulation is used to human-machine interaction. Definition : Data encapsulation(or Information Hiding) hides the detailed implementation of data objects from the outside world. Definition : Data abstraction is the separation of specification and implementation of data objects. C++ has char, int, float, double as a default data type. These data types are modified if short, long, signed, unsigned keywords are used. All programming languages provide at least a minimum of predefined data types, plus the ability to create new user-defined types. Definition : Data type is set of objects and operations of that objects. Whatever program addresses default data type or user-defined data type, object and operation must be considered. Definition : ADT(Abstraction Data Type) is a data type in which the specifications of objects and the specifications of operations on these objects are separated from the representation of the objects and the implementation of the operations. To emphasize the separation of specification and implementation, the ADT definition of the object will begin first. In this way, people can understand the essential elements of an object without a complex description of the representation of the object and the actual implementation of the operation. ADT NaturalNumber is Object : from 0 to MAXINT Functions : All x, y in NaturalNumber","link":"/2019/04/29/1-OOP-and-ADT/"},{"title":"1. What is Programming?","text":"1. Computational ThinkingProgramming is communication that sends commands to be performed to the computer. In order to define the “command to be performed,” the resolution task (problem/requirements) must be clearly understood, the complexity must be simply deconstructed, the data organized and sorted by modeling, and the actions arranged in sequence. In other words, clear understanding of reguirements and proper definitaion of solution are needed before programming. What is required at this time is the problem-solving skill. Some people tend to equate problem-solving abilities with algorithms, but it does not. Of course studying algorithm is very helpful to get problem-solving skill, but problem-solving skill is more higher level of ability. Programming is just a means of expression to produce the final result of solving a problem. Programming itself doesn’t solve the problem. Considering the solution of the problem, you should look at preoblem from a computer’s point of view. Computational thinking is required this kind of time. You should do computational thinking with solving problems. This requires logical and mathematical thinking, and all concepts that will be used within the programming should be defined as assessable, breaking down and patterning the resolution tasks into smaller units. 2. Programming LanguageAs above, solution defined based on problem-solving skill should be communicated to computer. At this point, computer do perform the commands. So the command should be communicated by machine code, not a natural language. But it is very difficult that human to understand machine code. It is even described in bits. The most useful alternative to delivering commands in direct mechanical language is to use a kind of translator to write a program using “programming language” consisting of promised phrases (Syntax) that humans can understand and then convert it into machine language that computers can understand. This kind of translator is called complier or interpreter. Programming is a kind of communication that sends commands to the computer that you want to perform using the programming language. The programming language is expressed as a combination of Syntax and Semantics. 3. Syntax &amp; SemanticsUnderstanding both syntax and semantics properly is important to use language well. In the end, solutions created through problem-solving ability are expressed through the syntax of programming languages. The code is a specific implementation of the solution. This is only archeive semantics when the requirements are fulfilled(problem solved). Most of programming languages provide syntax such as variables and values, keywords, operators, expressions, flow control by conditional and loop statements, statements, functions(set of statements), and data structures such as objects and arrays. What a programmer needs to do is find a solution for problem and implement it in a code that has correct syntax. Implemented code should act as expected and solve the problem. It should be predictable and explainable how the code work inside the computer and what it will give back. To do this, it is important to have an accurate understanding of the basic concepts and operating principles of programming language. If you just copy &amp; paste code without understand basic concept and principle, that code is not reliable. And problem-solving skills will not grow anymore. Reference 프로그래밍이란?","link":"/2019/04/29/1-What-is-Programming/"},{"title":"190314-TIL","text":"Today I Learned JavaScript Methodwindow 객체의 method를 통해 사용자 입력, 화면 제어, 스크롤 제어 등을 하는 방법을 새로 배웠다. 외에도 screen, history, navigator, location 객체의 method를 활용해 사용자 분석을 위한 정보를 parsing하는 걸 프론트엔드에서 할 수 있다는 것을 알았다. Interval &amp; Timer네트워크 프로그래밍 수업 때 잠시 배웠던 Push, Polling 기법과 timeout을 간략하게 들었다. 시간이 날 때 개념을 확실히 하기 위해 노트에 적어두었다. jQueryjQuery의 selector를 이용, 요소의 이벤트를 처리하고 속성값을 이용해 기능을 구현했다. TO DO LIST과제로 TO DO LIST를 만들었다. 느낀 점:할 일을 추가, 수정, 삭제, field를 나눠서 보여주는 것만 하면 되는데도 생각해야할 것들이 많았다. 사용자가 작은 기능이라도 편하게 이용할 수 있도록 프로그래밍하는 것이 하나도 쉬운 게 없다. 💘 My To do list git 주소 To Do List","link":"/2019/03/14/190314-TIL/"},{"title":"190315-TIL","text":"Today I Learned 오늘 한 일 LeetCode Medium 문제를 풀었다. C나 C++이 아니고 익숙하지 않은 JavaScript로 알고리즘 문제를 풀려니 메소드를 하나하나 찾아야해서 시간이 오래 걸렸다. 🐸 2. Add Two Numbers : if문을 잔뜩 사용한 내 코드와 달리 carry를 이용한 솔루션을 보고 알고리즘 공부를 꾸준히 해서 효율성을 높여야겠다는 목표가 생겼다. 적어도 하루에 하나씩은 LeetCode 문제를 풀려고 한다. 오후엔 JavaScript를 이용해 Lotto 추첨기를 만들었다. 느낀 점:사용자의 입력을 받아서 화면에 적절히 출력하는 게 아직 어렵다. 3명이 팀별로 진행하다보니 알고리즘을 짜는 데에도 토의를 하느라 시간이 길어졌다. 협엽과 HTML, CSS, JS를 다루는 법에 조금 더 익숙해져야겠다. 🐸 Lottery Machine git address LOTTERY Machine","link":"/2019/03/15/190315-TIL/"},{"title":"190313-TIL","text":"Today I Learned 오늘부터 하루하루 내가 배우고 공부한 것들을 정리해놓기로 한다. 오전 - 팀 토의일주일이 조금 넘게 웹 기초를 배우며 과제를 진행한 것에 대해서 팀원들과 토의를 나눴다. 나는 Grab 홈페이지에서 설명을 누르면 이미지가 바꾸도록 jQuery를 써보는 과제가 인상 깊었다. Responsible Web 과 SEO 등 집중해서 공부하고 싶은 것들이 생겼다. 오후 - git1. git으로 블로그 만들기 : HEXOLorem ipsum 등 dummy text를 넣어 html 디자인 전 레이아웃을 잡는 방법을 알았다. github에서 제공하는 github.io Blog를 만들었다. Hexo를 설치하고 포스팅하는 방법을 알았다. : hexo new post, hexo generate, _config.yml을 수정한 후 hexo deploy : deployment - the use of something or someone in an effective way 2. git branch &amp; checkout &amp; merge 협업을 위해 중요한 git의 branch와 commit 개념을 배웠다. 익숙해지면 버전관리와 개발에 많은 도움이 될 것 같다. 난 Markdown Emoji가 좋다 🐷Markdown Emoji","link":"/2019/03/13/190313-TIL/"},{"title":"190317-TIL","text":"Today I Learned어제는 처음으로 토익을 보러 갔다. 피곤해서 컴퓨터를 켜지도 못했지만 앞으로 알고리즘 문제를 하나라도 풀어야겠다. 오전 LeetCode Easy 문제: 7. Reverse Integer 와 관련문제 190. Reverse Bits를 풀었다. 오후 Hexo blog의 이름을 바꾸고 전부터 적용하고 싶었던 Hexo Clexy 테마를 적용했다. 처음에는 어떻게 해야할 지 몰랐지만 Clexy github description을 보며 따라하니 어떻게 적용이 됐다.내 마음대로 디자인을 바꾸려면 공부를 더 해야겠다. 카테고리를 나눠서 알고리즘 풀이, HTML/CSS와 javaScript 등 공부한 내용을 정리해서 올리고 싶어서 카테고리를 추가하는 방법을 찾아봤는데 잘 알 수 없었다. 강사님께 물어봐야겠다.","link":"/2019/03/17/190317-TIL/"},{"title":"190318-TIL","text":"Today I Learned 오전 LeetCode Easy 문제 : 🌈 9. Palindrome Number 이번 문제는 비교적 쉽게 풀렸다. 주말에 Reverse Integer와 Reverse Bit 문제를 풀었을 때 썼던 알고리즘을 응용하니 문제가 풀렸다. CSS로 3가지 형태의 메뉴 만들기 BootStrap을 이용하지 않고 CSS와 jQuery를 이용해서 다운드롭, 햄버거 메뉴를 만들었다. jQueryUI의 slide()를 이용해서 왼 쪽에서 나오는 햄버거 메뉴를, CSS의 hover를 이용해 전체 드롭다운 메뉴와 특정 메뉴의 하단메뉴만 드롭다운으로 보여주는 메뉴를 만들었다. 오후 다음 우편번호 서비스를 이용해 회원가입 홈페이지 만들기 다음 우편번호 API를 이용해 우편번호를 찾고, 사용자 입력을 받아 정규표현식으로 Validation 하는 것까지 진행했다. 느낀 점 JavaScript로 처음 알고리즘 문제를 풀 때는 한 줄 치기도 어려웠는데 며칠 문제를 풀다보니까 조금씩 익숙해지는 것 같다. HTML 레이아웃을 짤 때 &lt;div&gt;에 의존하지 않고 &lt;ul&gt;과 &lt;li&gt; 태그를 자주 이용해야겠다는 생각을 했다. 매번 잊어버리므로 유념하자. 🌈 Simple Sign Up Page git address ▶ [Simple Sign Up Page] ◀","link":"/2019/03/18/190318-TIL/"},{"title":"190319-TIL","text":"Today I Learned 오늘 한 일 LeetCode Easy 문제 : 🌟 13. Roman to Integer if로 I, X, C일 때 경우를 나누어 풀었다. 시간이 짧게 걸린 알고리즘들은 let, const를 썼는데 나는 아직 var로 선언하는 방법밖에 공부하지 않아 더 공부를 해야겠다. webStorage 공부 localStorage, sessionStorage의 차이와 활용방법에 대해서 배웠다. localStorage.setItem(storage_key, storage_value), localStorage.getItem(storage_key) 를 사용하여 localHost에서 사용자가 입력한 정보를 유지하는 기능을 다수 추가했다. To do List, Signup Page 보완 locaStorage를 이용해 기존에 만들었던 html에 유지기능을 추가했다. Select, Input: radio 등 다양한 input type 학습 단순히 text type의 input뿐만이 아니라 select.val, option.text 등을 다루는 방법을 공부했다. 느낀 점 localStorage를 이용하는 것 뿐인데 해야할 일이 대폭 많아졌다. 꼼꼼하게 정리해놓고 해당 기능을 사용할 때마다 참고해야겠다. Upgrade ver. To do List ▶ 🌟 Upgrade ver. Sign Up Page ▶ 🌟","link":"/2019/03/19/190319-TIL/"},{"title":"190321-TIL","text":"Today I Learned 오늘 한 일 Naver Maps API를 이용한 맛집 리뷰 어플리케이션 : Naver가 제공하는 Naver Maps API를 이용해 웹에 지도를 띄우고, 다음 우편번호 서비스로 주소를 입력받아 해당 주소의 좌표에 마커를 찍는다. : 마커를 클릭했을 때 리뷰가 없다면 리뷰를 등록하고, 이미 리뷰가 등록됐다면 등록된 리뷰를 infoWindow로 보여준다. : 어려웠던 점! for문 내에서 marker객체와 infoWindow 객체를 각각 만들어 addEvent를 해주면 scope 문제로 마지막 이벤트 리스너만 살아남게 된다. 정확한 내용은 공부를 더 해야 알겠지만 우선 forEach문으로 해결했다. 참고한 페이지에서는 let으로 선언(block-scoping)해도 된다고 한다. 어제 배운 git fork &amp; merge를 이용해 팀원들과 협업을 했다. 패스트캠퍼스 수료생 선배들과 티타임을 가지며 개발자가 되기 위한 과정에 대해서 들었다. 꾸준히 열심히 하고 모르는 것을 넘어가지 않는 게 중요한 것 같다. 맛집 리뷰페이지 ▶ 🍩 Yummy 🍩","link":"/2019/03/21/190321-TIL/"},{"title":"190320-TIL","text":"Today I Learned 오늘 한 일 HTML, CSS, JS의 전체적인 개념을 복습했다. git 으로 협업하기를 배웠다. git flow를 이용해 branch를 만들고 작업, merge를 쉽게 하는 방법에 대해서도 공부했다. Fork &amp; Merge를 이용해서 여러명과 협업하고 repo에 contribute하는 방법을 새로 알았다. 느낀 점 몸이 안 좋아 알고리즘 문제 하나를 다 풀지 못했다. 하루종일 집중력 저하로 충전의 필요성을 느꼈다. git은 여러명과 프로젝트를 진행하며 불편했던 점들을 한 번에 해소해주는 느낌이었다. 더이상 카카오톡이나 텍스트파일로 코드를 주고받고 일일히 합치지 않아도 된다는 점이 굉장히 매력적으로 다가왔다. 자주 이용해 손에 익도록 만들어야겠다.","link":"/2019/03/20/190320-TIL/"},{"title":"190322~24 TIL","text":"Today I Learned 배운 것 LeetCode 14. Longest Common Prefix를 풀었다. : 쉬운 문제를 이틀에 걸쳐 풀었는데, javaScript에 String method 중 유용한 indexOf()라는 method가 있다는 것을 알았다. C++에서부터 나는 문자열을 다루는 데에 익숙하지 않다. var의 scope와 javaScript의 Hoisting에 대해 배웠다. var, let, const: var는 function-scoped고, let이나 const는 block-scoped이다. : let은 재할당이 가능, 선언한 이후에 할당할 수 있는 반면 const는 선언과 동시에 값을 할당하여야 하고 그 값을 변경시킬 수 없다. (C처럼) Hoisting: hoisting은 끌어올린다는 뜻이다. 자바스크립트에서는 변수가 끌어올려진다. 이 때, 변수의 선언은 hoist되지만 할당부(값)는 hoist되지 않는다. 즉 함수의 선언은 hoist되지만 변수의 값으로 선언한 함수는 hoist되지 않는다. 그래서 for문에서 var i =0으로 선언한 후 함수 종료 후에 i를 부르면 정의되지 않았다고 뜬다. 그러나 var i가 아니라 그냥 i=0 로 선언하면 i가 hoisting되어 global variable이 된다. 느낀 점scope와 hoisting 등 javaScript를 공부하니 그동안 아무 것도 모르는 상태에서 이것저것 만들어 보면서, 이해되지 않던 오류들이 조금씩 이해되기 시작했다. 어쩌다보니 LeetCode 알고리즘을 스터디로 함께 풀게 됐다. 어려명과 함께 공부하는 건 처음이지만 배울 점이 많을 거라고 생각한다. indexOf() 등 여러 javaScript String 관련 method를 접할 때마다 정리하고 활용할 수 있도록 해야겠다.","link":"/2019/03/24/190322-24-TIL/"},{"title":"190325-TIL","text":"Today I Learned 웹 애플리케이션 프로젝트오늘부터 5일간 팀원들과 함께 프로젝트를 진행한다. 간단한 프론트 기초 지식만 배운 상태에서 완벽한 애플리케이션을 만들기에는 부족함이 있지만 오늘 기획단계를 끝냈다.백엔드가 없어 데이터를 localStorage에 저장하고 불러올 예정이다. 회원가입과 로그인 기능도 뺐다. 디자인을 위해 전공 소프트웨어 공학 수업시간에 배운 Use Case Diagram, step-by-step Description, Communication Diagram을 작성해 기능들을 나눴다. 우리는 식단, 운동을 제공하고 사용자가 날짜별로 건강관리를 기록할 수 있는 프로그램을 만들 예정이다. 나는 운동 부위(상체, 복근, 하체, 전신)와 운동 종류(근력, 유산소, 스트레칭)에 따른 Youtube 운동 영상을 미리 수집해 분류한 후 사용자의 Option 선택에 따라 운동 영상을 제시하는 기능을 맡았다. 사용자는 또한 운동 기록을 저장하고 관리할 수 있다. 오늘은 전체적인 프로그램 디자인과 html 레이아웃을 마쳤다. Youtube API를 잠깐 써봤는데 생각보다 어렵지 않을 것 같다.","link":"/2019/03/25/190325-TIL/"},{"title":"190326-TIL","text":"Today I Learned 프로젝트 진행 중! 무식하면 몸이 고생한다를 뼈저리게 느끼고 있다. 백엔드가 없고 DB를 관리할 수가 없어서 리소스와 데이터를 수동으로 정리해 폴더에 넣는 작업을 했다. Dictionary가 익숙해질수록 편하게 쓰고 있다. 오늘 한 일 운동 부위, 종류에 따른 youtube 동영상 주소(고유주소ID, 썸네일, 이름) 모으고 각 selector로 사용할 id 부여 (upper_weight_1 등): Load할 때마다 workouts 먼저 그려놓고 숨겨놓음 selectBodyPart() -&gt; showHealthList() : Health Option select 조건에 따라 분류해놓은 운동 영상을 보이게 한다. selectHealthType() -&gt; showHealthList() : Health Option select 조건에 따라 분류해놓은 운동 영상을 보이게 한다. clickHealth() -&gt; showHealthDetail(id) : div에 배치된 운동 영상 클릭시 해당 영상의 상세 페이지를 팝업으로 띄운다. 배운 것 Dictionary key값이 string일 때는 Dict[‘key’] 잊지 말기!!!! 계속 ‘’ 를 잊어버린다. var today = new Date().toISOString().slice(2, 10); 날짜를 19-03-26 형식으로 만들어준다!!!!","link":"/2019/03/26/190326-TIL/"},{"title":"190328-TIL","text":"Today I Learned 오늘 배운 것 프로젝트의 모든 정보를 localStorage에 load하고 save하는 기능을 끝냈다. 점점 객체와 배열을 다루는 방법이 익숙해진다. 어렵던 select의 option value와 option:selected).text도 잘 알았다. 디자인을 수정하고 메인 페이지를 full video background로 설정했다. 알고리즘 스터디에서 Array.reduce와 eval method를 새로 알았다. 주말에 더 공부 해야겠다. LeetCode 중 Medium 3. Longest Substring Without Repeating Characters 문제를 풀었다. 오랜만에 새로운 알고리즘 문제를 푸니 재미있었다. LeetCode에 console.log를 찍어 stdout을 확인할 수 있다는 것을 처음 알았다. 앞으로 자주 사용해야겠다. 프로젝트가 마무리되며 볼만해진다. 공공 데이터 포탈에서 제공하는 미세먼지 API를 사용해 메인 페이지에 마스크 사용여부를 알려주고 싶었는데 낮에 신청한 직후에는 잘 안 됐다. 그런데 밤에 해보니까 결과가 나와서 내일 다시 시도해볼 예정이다.","link":"/2019/03/28/190328-TIL/"},{"title":"190327-TIL","text":"Today I Learned 오늘 한 일프로젝트 clickSaveButton() -&gt; saveHealth() : 운동 영상의 상세 페이지에서 운동 기록 저장 버튼을 클릭시 해당 운동의 이름이 localStorage에 저장된다. showDiary() : 운동 기록을 저장한 후 반영된 페이지로 이동한다. clickMyHealthButton() -&gt; showMyHealthPop() : 나의 운동 버튼 클릭시 사용자 정의 운동을 입력하고 저장할 수 있는 페이지를 팝업으로 띄운다. clickSaveButton() -&gt; showSavedPage() : 팝업 창에서 운동 이름, youtube 주소, 운동 부위와 종류를 입력하면 기록이 localStorage에 저장된다. 외에도 알고리즘 스터디를 했다. 나는 5개 정도 문제를 미리 풀어놔서 복습하는 개념으로, 다른 사람들의 풀이에서 많은 걸 배우고 있다. 배운 것 ! 어떤 element를 클릭하고 새로 뜬 창에서 어떤 버튼을 눌렀을 때 맨 처음 element 값 전달하고 싶을 때는 button의 attr에 data-key 같은 식으로 정보를 전달해준다. 1234567891011121314151617181920212223242526 $('div.workout').click(function(){ //showWorkoutDetail var key = this.id; var workout = workouts[key]; var id = workout['YT_id']; $('#saveHealthButton').attr('data-key',key); $('#popModal').modal('show'); $('#popTitle').text(workout['name']); console.log(id); player = new YT.Player('player', { height: '300', width: '450', videoId: id, events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange } }); }); $('#saveHealthButton').click(function(){ console.log($(this).attr('data-key'));//잘 뜸!! saveWorkout(); }); ! 외부 API를 사용하는 것은 어렵다. 조금만 수정하려고 해도 내 마음처럼 되지 않는다. 경험을 늘려야겠다. 운동 영상 썸네일 클릭시 Modal을 띄워 해당 운동 영상을 보여주려고 했는데, iframe을 사용하지 않고 new YT_player로 player를 만드는 API를 사용했더니 맨 처음 생성된 player만 뜨는 문제가 있었다. 구글 검색으로 해결했다! Modal show event마다 내가 원하는 youtube 보여주기!! How to embed YouTube video in Bootstrap modalAnswer: Insert YouTube Code inside Modal Bodyhttps://www.tutorialrepublic.com/faq/how-to-embed-youtube-video-inside-bootstrap-modal.php ! javaScript에서는 Array.length, String.length로 둘 다 뒤에 ()를 붙이지 않는다. java와 헷갈리지 말자. 느낀 점 프로젝트 기획 때 Use Case와 Communication을 잘 정리하고 나니 그 때 명세한 기능을 구현하기만 돼서 편하다. 순서대로 구현을 하니 딱히 커다란 문제가 생기지 않았다. 소프트웨어 공학 시간에도 그렇지만 다시 한 번 디자인이 중요하다고 느꼈다.","link":"/2019/03/27/190327-TIL/"},{"title":"190329-TIL","text":"Today I Learned 오늘 한 일 jQeury 플러그인을 통해 Diary 화면의 배경에 ripples 효과를 줬다. 50px정도 여백에 효과가 적용되지 않는 문제가 있어 body background에 효과를 주는 것으로 해결했다. 알고리즘 스터디에서 Longest Common Prefix 문제를 다시 한 번 훑어보았다. 프로젝트 페이지의 폰트와 버튼 hover event 등을 추가하고 마무리했다. 느낀 점 프로젝트를 하며 겪었던 자잘한 문제들과 해결방법을 정리해두어야겠다. 첫 팀 프로젝트는 생각보다 재미있었다. 해결하지 못할 문제는 없다는 것을 다시 한 번 알았다. ✨ My Health Diary ✨","link":"/2019/03/29/190329-TIL/"},{"title":"190330~31 TIL","text":"Today I Learned 토요일에 특강을 들었다. 실제로 현업에서 개발을 어떻게 하는지, 개발 방법에는 Waterfall보다 Agile를 많이 쓰는 추세라는 것을 알았다.","link":"/2019/04/01/190330-31-TIL/"},{"title":"190403-TIL","text":"Today I Learned 오늘 한 일 &amp; 느낀 점 🍀 LINEplus 홈페이지를 Markup해보는 시간을 가졌다. 홈페이지를 선형화하고, semantic하게 요소를 정하고 class 이름을 짓는 것만 해도 머리가 아팠다. data를 다루는 function들은 그 관계를 정의하고 흐름을 파악하기가 쉬운데, Markup은 당장 이런 요소를 쓰면 되겠다고 생각을 해도 아직은 머릿속에 바로 그려지지가 않는다. 🍀 3월에 일주일간 진행했던 프로젝트 발표 시간을 가졌다. 다들 열심이 만들어서 동기부여가 됐다. 🍀 오전에 flex에 대해서 공부했다. 과제를 하느라 배운 걸 다 정리하지 못해서 내일 아침에 마저 정리할 예정이다. 🐾 My linepluscorp markup page 🐾","link":"/2019/04/03/190403-TIL/"},{"title":"190402-TIL","text":"Today I Learned 오늘 한 일 CSS의 기초 문법, 상속과 겹침 그리고 우선순위에 대해 배웠다. 상속(Inheritance): 부모에게 적용한 style이 자식에게 적용되는 것: 영역에 관한 속성이 아닌 꾸미기 속성 등이 상속된다. 겹침(Cascading): 하나의 element에 여러 style이 겹쳐질 수 있다.: 우선순위가 같을 경우 가장 밑의 style이 적용된다. 우선순위: 각각 selector마다 가진 우선순위가 다름 정적블로그 특강 : jekyll을 이용해 블로그 만들기: 나는 지금 hexo를 이용해서 블로깅을 하고 있는데 jekyll에 대해서도 배웠다. 느낀 점 의미있는 태그. Semantic Markup이 중요함을 점점 더 느낀다. Web Accessibility를 고려하면 간단한 화면 배치도 간단하지 않다. Markup은 공부할수록 깊이있는 언어같다. 객체지향언어에서 class를 의미있고 효율적으로 짜는 데에도 관심이 많았기 때문에 이 부분을 잘 살려서 코딩을 하고 싶다. hexo를 계속 이용하기로 했다. 익숙하기도 하고, 나중에 내가 테마를 조금씩 수정하거나 만들고 싶다.","link":"/2019/04/02/190402-TIL/"},{"title":"190401 TIL","text":"Today I Learned 오늘 배운 것 오늘부터 4주간 HTML/CSS를 새로 배운다. 첫 수업이었는데 많은 것을 새롭게 알았다. 웹 접근성과 웹 표준이 무엇이며 얼마나 중요한지, 개발자에 자세에 대해서 배웠다. HTML5의 역사와 특징에 대해 다시 한 번 배웠다. Web page 제작을 위한 단계를 배웠다. 선형화(layout) 단계 : design이 아닌 논리적 구조를 linearize Semantic Element : &lt;div&gt;만 사용하는 것이 아니라 &lt;header&gt;, &lt;footer&gt;, &lt;article&gt; 등 사용 Naming : element naming and grouping 편리한 Emmet Cheatsheet를 알았다. 진짜 편하다! CSS Box Model : content-box(defualt)와 border-box의 차이점을 알았다. flex를 이용해서 layout을 잡는 것과, 호환되지 않을 때를 대비하여 float를 이용하는 방법을 여러 case를 통해서 배웠다. Margin collapsing, clear: both 등 float CSS trick들을 배웠다. 느낀 점 지난 한달 간 나에게 가장 어려운 건 javascript보다는 HTML/CSS로 layout을 잡는 것이었는데, 내 생각대로 요소들이 배치되지 않았기 때문이다. 수업에서 CSS의 여러 속성들과 기능을 배우면서 왜 그렇게 되지 않았는지 알게 되었다. flex와 float는 확실히 공부하고 넘어가야겠다.","link":"/2019/04/01/190401-TIL/"},{"title":"190404-TIL","text":"Today I Learned 오늘 한 일 주요 메뉴인 &lt;nav&gt;요소의 main menu를 마크업하고 CSS 디자인을 했다. 웹 접근성을 고려해서 submenu를 따로 ul로 분리하지 않고 menu-item인 li 안에 넣는 게 어려웠는데, 해결을 했다. HTML5의 flex model을 공부했다. container와 item에 따로 주던 flex 속성 값들이 이해되지 않았는데 flex-direction과 justify-content, align-item과 align-content가 어떻게 다른지 정리했다. 어제 만들었던 LINEplus 홈페이지를 조금 수정했다. 접근성을 높이기 위해서 몇 몇 요소의 위치를 바꾸고, CSS로 배치를 했다. ▶ &lt;option&gt; 안에는 &lt;a&gt;가 올 수 없다! Interactive요소 안에는 interactive 요소가 올 수 없다. a 안에 button 등 ▶ W3 문서를 확인해보니 &lt;h&gt;안에 &lt;a&gt;가 오는 게 아니고 그 반대가 맞는 것 같다. CSS Animation에 대해서 배웠다. timing-function을 이용한 animation이 흥미로웠다. 이번 주말에 나도 한 번 만들어보고 싶다. ▶ 참고 링크 : steps를 이용한 애니메이션 느낀 점 HTML/CSS 수업을 3일 들었는데 지난 한 달간 궁금하던 점이 많이 해결되었다. 웹 표준을 준수하고 접근성을 높이기 위해서 고려해야할 게 한두가지가 아니다. 처음 배우는 HTML을 기초부터 제대로 하는 것 같아 좋다. 시간이 빠르게 가는 것 같아 아깝다. 요즘은 하루하루가 바쁜만큼 더 많이 알고 싶다는 욕심이 생긴다. 🐸 Modified Lineplus site 🐸","link":"/2019/04/04/190404-TIL/"},{"title":"190406~07-TIL","text":"Today I Learned 오늘 한 일 음수마진에 대해서 배웠다. CSS grid framework에 대해서 배웠다.","link":"/2019/04/08/190406-07-TIL/"},{"title":"190405-TIL","text":"Today I Learned 오늘 한 일 로그인 메뉴를 구성하는 form tag와 input의 여러 속성에 대해서 배웠다. fieldset에 대해 처음 알았다. 접근성을 위해 label 과 input 을 bind 해야한다는 것을 알았다. box-shadow, section에 heading하는 법을 알았다. 느낀 점 오늘은 실습 위주의 수업이라 재미있었다. 하루종일 너무 많은 정보를 들어서 어지러운데 다 내 걸로 만들어야겠다!","link":"/2019/04/05/190405-TIL/"},{"title":"190409-TIL","text":"Today I Learned 오늘 배운 것 tab menu 마크업 했다. float, absolute, flex를 이용해서 여러가지로 마크업할 수 있다는 것을 알았다. jQuery로 메뉴의 mouseover, focusin 등 event를 입혔다.","link":"/2019/04/09/190409-TIL/"},{"title":"190408-TIL","text":"Today I Learned 오늘 한 일 ⭐️ &lt;dl&gt; tag에 대해서 배웠다. &lt;dl&gt; : Defines a definition list. &lt;dt&gt; : Defines a term/name in a description list. &lt;dd&gt; : Is used to describe a term/name in a description list. Ø 원래 &lt;dt&gt;와&lt;dd&gt; 를 &lt;div&gt;로 묶으면 안 됐었는데 허용됨 : 다만 맞는 &lt;dt&gt;를 설명하는 모든 &lt;dd&gt; 함께 묶어야 함. ⭐️ Web Cafe 예제 중 배너와 검색영역을 Markup, 디자인 설계 했다. &gt; 웹 관련 용어 배너 디자인 : float 사용 &gt; Logical order and Markup design ⭐️ LINEcorp 페이지 Markup을 처음부터 다시 했다. 디자인 관점이 아닌 컨텐츠 관점으로 논리적인 Markup 순서를 정하고 html과 CSS를 작성했다. 느낀 점 경험이 부족해서인지 아직 content에 맞게 semantic한 tag를 생각해내는 게 어렵다. 👼 More Semantic LINEpluscorp","link":"/2019/04/08/190408-TIL/"},{"title":"190410-TIL","text":"Today I Learned오늘 한 일 🌷 LINEpluscorp 마크업을 다시 한 html에 header CSS 를 입혔다. 언어선택창에 Tab, Click event를 적용했다. 1234567891011&lt;div class=\"language\"&gt; &lt;button class=\"btn-language\"&gt;한국어&lt;/button&gt; &lt;ul class=\"language-list\"&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;English&lt;/a&gt;&lt;/li&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;日本語&lt;/a&gt;&lt;/li&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;한국어&lt;/a&gt;&lt;/li&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;中文(繁體)&lt;/a&gt;&lt;/li&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;中文(简体)&lt;/a&gt;&lt;/li&gt; &lt;li class=\"language-item\" tabindex=\"0\"&gt;&lt;a href=\"#\" tabindex=\"-1\"&gt;ภาษาไทย&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031var buttonLang = $('.btn-language');var listLang = $('.language-list'); // language button click eventbuttonLang.on('click keyup', function(e){ if(e.keyCode === 9){ listLang.parent().addClass('language-act'); } else{ // tab 아니고 click 됐을 떄 listLang.parent().toggleClass('language-act'); }});// event capturing &amp; bubbling// div.language 외의 영역 click시 닫기document.addEventListener(\"click\", function(e) { console.log(e); if (!e.path.includes(document.querySelector(\".language\"))) { listLang.parent().removeClass('language-act'); }});// div.language 외의 영역에 tab key 눌리면 닫기document.addEventListener(\"keyup\", function(e){ if(e.keyCode === 9){ if (!e.path.includes(document.querySelector(\".language\"))) { listLang.parent().removeClass('language-act'); } }}); Header에 mouseenter, mouseleave event를 적용했다.: flex를 쓰지 않고 해보고 싶었는데 결국 flex를 적용한 채 오늘은 마무리했다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;nav class=\"navigation\"&gt; &lt;ul class=\"menu\"&gt; &lt;li class=\"menu-item menu-item1 menu-act\"&gt; &lt;a href=\"#\"&gt;회사소개&lt;/a&gt; &lt;ul class=\"sub-menu submenu1\"&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;회사소개&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt; &lt;a href=\"#\"&gt;LINE's Mission&lt;/a&gt; &lt;ul class=\"mission-menu\"&gt; &lt;li class=\"mission-menu-item\"&gt;&lt;a href=\"#\"&gt;MISSION&lt;/a&gt;&lt;/li&gt; &lt;li class=\"mission-menu-item\"&gt;&lt;a href=\"#\"&gt;LINE STYLE&lt;/a&gt;&lt;/li&gt; &lt;li class=\"mission-menu-item\"&gt;&lt;a href=\"#\"&gt;LINE CODE&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;LINE그룹 행동 규범&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;LINE 로고 사용 가이드&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;a href=\"#\"&gt;사업&lt;/a&gt; &lt;ul class=\"sub-menu submenu2\"&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;서비스&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;서비스사업&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;a href=\"#\"&gt;홍보&lt;/a&gt; &lt;ul class=\"sub-menu submenu3\"&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;Global News&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;기사 및 보도자료&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;Blog &amp; SNS&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"menu-item\"&gt; &lt;a href=\"#\"&gt;채용&lt;/a&gt; &lt;ul class=\"sub-menu submenu4\"&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;일과 사람&lt;/a&gt;&lt;/li&gt; &lt;li class=\"sub-menu-item\"&gt;&lt;a href=\"#\"&gt;채용공고&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=\"sitemap\"&gt; &lt;a href=\"#\"&gt;SITEMAP&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 12345678910var menuItem = $('.menu-item');menuItem.on('mouseenter', function(){ menuItem.removeClass('menu-act'); $(this).addClass('menu-act');});menuItem.on('mouseleave', function(){ $(this).removeClass('menu-act');}); 새로 배운 것 Event Capturing과 Bubbling으로 문제를 해결했다. 원리는 꼭 정리해놔야겠다! 한 기능을 구현하면 다른 기능이 문제가 생긴다. 아직 HTML과 CSS에 대한 이해가 부족한 것 같다. 🌷 More semantic LINE git","link":"/2019/04/10/190410-TIL/"},{"title":"190413~14-TIL","text":"Today I Learned오늘 한 일 4월 1일부터 2주간 김데레사 강사님의 HTML/CSS 수업을 들은 내용을 Github Repository에 Markdown file로 정리해 올렸다. 꼬박 네 시간은 더 걸렸다. Markdown 작성법은 익숙해진 것 같다. Google Analytics를 블로그에 연결했다. 참고하려고 주소만 첨부해놓고 정리하지 않은 Referance 페이지가 정말 많다! 틈틈히 공부하고 정리해야겠다. 😅 💞 GO to my Markup Summary Repo 💞","link":"/2019/04/14/190413-14-TIL/"},{"title":"190412-TIL","text":"Today I Learned오늘 한 일 계속 헷갈렸던 (그리고 어려웠던) CSS의 Transition(전이)과 Transform(변형)을 배웠다. CSS Animation은 정말 재밌다! mouseover와 mouseenter의 차이를 다시 한 번 복습했다. HEXO 테마를 바꿨다. 이제 정말 마지막이다!","link":"/2019/04/12/190412-TIL/"},{"title":"190411-TIL","text":"Today I Learned오늘 한 일 Web Cafe의 새소식 영역을 &lt;section&gt;과 &lt;article&gt;을 이용해 Markup 했다. [Web Cafe 새소식 영역] [Markup Design] 123456789101112131415161718&lt;!-- news section HTML Code --&gt;&lt;section class=\"news\"&gt; &lt;h2 class=\"news-heading\"&gt;새소식&lt;/h2&gt; &lt;article class=\"news-item\"&gt; &lt;a href=\"#\"&gt; &lt;h3 class=\"news-item-subject\"&gt;W3C 사이트가 리뉴얼 되었습니다.&lt;/h3&gt; &lt;time class=\"news-item-date\" datetime=\"2019-04-11T11:19:37\"&gt;2019.04.11&lt;/time&gt; &lt;p class=\"news-item-brief\"&gt; 디자인 및 다양한 view 환경을 고려하여 구성되어 있으며, 기존보다 최신 정보 및 개발자를 위한 기술 가이드도 찾기 쉽도록 구성되어 있습니다. &lt;/p&gt; &lt;figure class=\"news-item-thumbnail\"&gt; &lt;img src=\"images/news.gif\" alt=\"\"&gt; &lt;figcaption&gt;W3C 리뉴얼&lt;/figcaption&gt; &lt;/figure&gt; &lt;/a&gt; &lt;/article&gt; &lt;a href=\"#\" class=\"news-more icon-plus\" target=\"_blank\"&gt;더보기&lt;/a&gt;&lt;/section&gt; : 처음으로 &lt;article&gt;과 &lt;figure&gt; tag를 써봤다. &lt;section&gt; 내에 &lt;article&gt;을 nesting하는 것은 신문의 스포츠 섹션에 단일 기사를 싣는 것과 같다는 글을 읽어 이해가 쉬웠다. Semantic HTML을 접하고 처음 &lt;div&gt; 범벅이던 코드를 만났을 때보다 훨씬 이해가 쉽고 직관적으로 구조를 짤 수 있게 된 기분이 든다. HTML5부터 inline인 &lt;a&gt; 안에 block 요소등을 넣을 수 있게 됐다. 그러나 focus를 받을 때 다음과 같은 문제가 생길 수 있다. ‘2019.04.11’이 inline인 time tag라서 그 부분이 들어간 모습 이는 &lt;a&gt;의 display를 block으로 바꿔주면 해결할 수 있다. Image Replacing and Sprite 웹 기초 수업 때 instagram 등 Social Media의 로고로 실습을 했던 Image Sprite 기법을 다시 한 번 적용해 Web Cafe 예제를 진행했다. [신규 이벤트 &amp; 관련 사이트 영역] [신규 이벤트 &amp; 관련 사이트 Design] Image Replacement: image가 들어갈 영역의 크기를 지정해놓고, 해당 높이나 너비만큼 padding을 주고 overflow: hidden 처리를 한 후 image를 sprite로 처리한다. Image Sprite: server가 제공하는 image 최소화하기위해 한 image만 준비하고 background 위치 조정해서 보여주는 것 : 단점으로 &lt;button&gt;에 focus시 outline이 안 보이는 문제가 있었는데, ARIA를 사용해 role을 주고 button의 textnode를 삭제해 해결했다. 123456789101112131415161718.btn-event{ position: absolute; top: 0; right: 0; height: 18px; padding: 2px;}.btn-event-prev, .btn-event-next { width: 19px; height: 18px; padding: 0; border: none; background-image: url(images/back_forward.png); background-position: 0 0;}.btn-event-next{ background-position: 100% 0;} 하루를 마무리 하며오늘 Semantic HTML과 tag의 효율성 등을 알아보다가 좋은 사이트를 알게 되었다. 많은 도움이 될 것으로 보여 기분이 좋다. 밑에 첨부한다. HEXO 테마를 바꾸고 싶은데 마땅히 마음에 드는 게 없어 만들어볼까 생각중이다. 이번 주말을 활용해 알아봐야겠다. 😊 INTERNETING IS HARD 😊","link":"/2019/04/11/190411-TIL/"},{"title":"190415-TIL","text":"Today I Learned 오늘은 드디어 Web Cafe 예제를 끝마치고, 반응형 웹에 대해서 배웠다. 매번 아리송하던 Grid에 대해서 알고나니 속이 시원했다. 강력한 Layout 기능인데 우리나라에선 IE 점유율이 높아 잘 사용되지 않는다고 한다. 제대로 써보고 싶은데 아쉽다. Image, Video, iframe 등을 flexible하게 처리하는 방법을 배웠다. LeetCode Easy 26번 문제를 풀었다. 영어로 된 문제다보니까 문제를 제대로 파악을 하지 못해 매번 헛수고를 한다.","link":"/2019/04/15/190415-TIL/"},{"title":"190417-TIL","text":"Today I Learned오늘 한 일오전 알고리즘 스터디에서 LeetCode 말고 다른 알고리즘 풀이 사이트를 이용하자는 의견이 나와 오늘부터 CodeWars에서 문제를 풀어보기로 했다. 6급 문제를 풀었는데 생각보다 쉬워서 LeetCode 문제를 하나 더 풀었다. 오후 컴퓨터공학 기초 수업을 8일간 듣는다. 자료구조, 알고리즘과 Python을 배운다고 한다. 오늘은 Memory와 Number type, Binary 연산을 공부했다. 학교 전공 수업을 다시 복습해야겠다. position: sticky는 top, left, right 중 값 한가지를 넣어야 동작한다!!!","link":"/2019/04/17/190417-TIL/"},{"title":"190416-TIL","text":"Today I Learned오늘 한 일 LeetCode 27번 Remove Element 문제를 풀었다. 혼자 생각하며 알고리즘을 푸는 것은 어렵지 않은데, 다른 사람에게 논리적으로 설명하려고 하면 말문이 막힌다. 내가 알고 있는 것을 논리적으로 잘 전달하는 연습을 해야겠다. HTML/CSS 마지막 수업으로 반응형 이미지, 배경 이미지 처리, Grid를 이용한 Mobile, DeskTop layout 등을 실습했다. 4월 15일부터 16일까지 이틀간 진행한 내용 또한 Markup Summary에 올릴 예정이다. 느낀 점 김데레사 강사님과 2주 간의 수업을 마쳤다. 짧은 시간 동안 정말 많은 것을 배웠다. 도저히 무슨 의미와 성질을 가지는지 몰랐던 HTML과 CSS에 대해 이해할 수 있게 되었다. 무엇보다 접근성을 고려한 웹 개발을 지향하게 되었다는 점이 가장 뜻깊다. 🌟 FDS12th HTML/CSS Summary 🌟","link":"/2019/04/16/190416-TIL/"},{"title":"190418-TIL","text":"Today I Learned오늘 한 일 Epsilon, Number Digit 등 컴퓨터에서 실수를 표현하는 방식과 상대오차에 대해서 깊게 배웠다. 실수형의 논리비교를 위한 is_equal 함수를 만들었다. 123456789101112131415function is_equal(x, y, allowed=0){ // 둘 중 큰 수의 다음 숫자와의 오차의 allowed 배 정도 되는 범위 안에 있으면 같다고 판단한다. return (Math.abs(x-y) &lt;= Math.max(Math.abs(x), Math.abs(y))*Number.EPSILON*Math.pow(2, allowed));}function main(){ var sum = 0; for(var i =0; i&lt; 100; i++){ sum += 0.01; } if(is_equal(sum, 1.0, 2)){ console.log(\"THE SAME\"); } else{ console.log(\"NOT THE SAME\"); }} Python을 배우는데 너무 재미있다. 익숙하지 않아 찾아보는 것이 번거롭지만 문법이나 기능이 흥미롭다.","link":"/2019/04/18/190418-TIL/"},{"title":"190420-TIL","text":"Today I LearnedSass 특강 임기완 강사님의 Sass 특강을 들었다. Sass는 CSS의 preprocessor이다. Preprocessor란, 컴파일러와 같이 자신의 input data로 만들어낸 ouput data가 다른 프로그램의 input data가 되게끔 하는 프로그램을 말한다. scss 를 css로 변환하는 방법과, variable, partial, import, mixin, @extend를 이용한 inheritance, data type 등 전체적인 부분을 훑어봤다. HEXO로 블로그를 하기 위해서 살펴보았던 .ejs 나 .jade 파일에서 보았던 이상한 문법들이 이해가 되는 순간이었다! mixin이 많은 도움이 될 것 같다. 🐊 구닥다리 공룡을 위한 오늘날의 CSS 알고리즘 CodeWars Directions Reduction 문제를 풀었다. 😈 알고리즘 풀이 보러가기","link":"/2019/04/20/190420-TIL/"},{"title":"190419-TIL","text":"Today I Learned오늘 한 일새로운 언어를 배우는 방법 자료형 연산자 제어문, 반복문 함수 call by reference, call by value, call by object reference First class function인지 Class 지원하는지 ( Encapsulation Inheritance Virtual function 지원 여부) Python Data Type과 기본 Data Structure 실습Text 가위바위보 게임123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import randomdef get_player_choice(): \"\"\" get_player_choice() -&gt; string Return \"바위\" or \"가위 or \"보\" \"\"\" choice = input(\"가위바위보! : \") while choice != \"가위\" and choice != \"바위\" and choice != \"보\": choice = input(\"가위바위보! : \") return choicedef get_computer_choice(): \"\"\" get_computer_choice -&gt; string Return \"바위\" or \"가위 or \"보\" \"\"\" tup = (\"가위\", \"바위\", \"보\") return tup[random.randint(0,2)]def who_wins(player, computer): \"\"\" who_wins(player, com) -&gt; string Return if player wins 'player' elif computer wins 'computer' else None \"\"\" if player == computer: return None if (player == \"바위\" and computer == \"가위\") or\\ (player == \"가위\" and computer == \"보\") or\\ (player == \"보\" and computer == \"바위\"): return 'player' else: return 'computer'def play_one(): \"\"\" play_one -&gt; string Return if player wins 'player' elif computer wins 'computer' \"\"\" player_win = 0 computer_win = 0 while player_win == computer_win: player = get_player_choice() computer = get_computer_choice() result = who_wins(player, computer) print(f'Player {player} vs Computer {computer}') if result == 'player': player_win += 1 elif result == 'computer': computer_win += 1 if player_win &gt; computer_win: return 'player' else: return 'computer'def check_final_winner(result): \"\"\" check_final_winner(result) -&gt; string result : ex) ['player', 'player'] Return if 'player' &gt;= 2 in result, 'Player' elif 'computer' &gt;=2 in result, 'Computer' else None \"\"\" print(f\"Player {result.count('player')}승 | Computer {result.count('computer')} 승\") if result.count('player') &gt;= 2: return 'Player' else: return 'Computer'def play(): \"\"\" play() -&gt; None 3판 2선승가위바위보 \"\"\" result_list = [] for i in range(3): result_list.insert(i, play_one()) print(check_final_winner(result_list)+\" Wins!!\")if __name__==\"__main__\": play() ASCII와 UNICODEASCII와 UNOCODE의 역사, UNICODE의 Encoding, Decoding 방법도 배웠다. Python Bubble Sort1234567891011def bubble_sort(li): n = len(li) for i in range(n-1): for j in range(n-1-i): if li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j]if __name__ == \"__main__\": li=[6, 2, 1, 4] bubble_sort(li) print(li) 간단한 Bubble Sort function을 만들었다. 알고리즘CodeWars 6kyu. Persistent Bugger 그리고 LeetCode의 Medium Level 문제를 풀려고 했는데 Dynamic Programming 개념이 들어가 쉽지 않다. 주말 내내 풀어야겠다.","link":"/2019/04/19/190419-TIL/"},{"title":"190422-TIL","text":"Today I Learned오늘 한 일 Python Functions(호출 방식, stack, map filter 등)을 배우고 posting으로 정리했다. LeetCode 알고리즘을 풀고, 알고리즘 스터디를 했다.","link":"/2019/04/22/190422-TIL/"},{"title":"190421-TIL","text":"Today I LearnedLeetCode 5. Longest Palindromic Substring금요일부터 오늘까지 내내 나를 괴롭히던 문제를 해결(?) 했다. 시간을 많이 들여도 도저히 답이 나오지 않으면 포기하기보다 다른 사람들의 Solution을 보고 분석하는 것 또한 공부라고 생각한다. Python에 익숙해질겸, Dynamic Programming을 재정리할겸 여러 시도를 해보았지만 내가 생각하지 못한 기발한 방법으로 문제를 해결한 사람들이 많았다.","link":"/2019/04/21/190421-TIL/"},{"title":"190423-TIL","text":"Today I Learned오늘 한 일 Big-O notation을 다시 한 번 정리하며 성능순으로 정리했다. O(1) : 상수 시간 엄청 빠름 array의 indexing, linked list의 insert, delete O(logn) : 로그 시간 Binary Search Tree의 insert, search, delete O(n) : 선형 시간 linked list의 search, 특정 array의 insert, delete O(nlogn) : 선형 로그 시간 quicksort, merge sort comparision sorting의 경우 quick sort보다 성능 좋을 수 없다. O(n2) : 지수시간(?) bubble sort, select sort, insert sort 등 Memory | Performance of fbstring Memory에 관련된 영상 하나를 보고 Memory 공부를 했다. Performance of fbstring 나는 전공 수업에서 OS를 들으며 배웠던 내용이라, 그 때 배웠던 것들을 처음부터 정리하며 복습 했다. Process and Thread 어렵고 다룰 게 많은 주제인데 한 번에 후다닥 나가는 느낌이라 아쉬웠다. OS를 복습할 겸 Chapter 별로 정리해 포스팅할 계획을 세웠다. Process와 Memory 개념 정리 Codewars 5kyu Sum of Pairs 문제를 풀었다. 자꾸 Timeout이 나서 성능을 좋게 만들려고 최대한 노력했다.","link":"/2019/04/23/190423-TIL/"},{"title":"190425-TIL","text":"Today I Learned Fastcampus에서 진행한 졸업생과의 티타임 시간에 졸업한 개발자분을 만나뵙고 경험들을 들었다. 많은 도움이 됐다. Network를 대략적으로 살펴봤다. 나는 학교에서 배웠지만 오래되어 다시 한 번 정리하는 게 필요할 것 같다. TCP/IP 네트워크 스택 이해하기 Quick Sort의 성능 분석 및 정리해서 posting 했다.","link":"/2019/04/25/190425-TIL/"},{"title":"190424-TIL","text":"Today I Learned오늘 한 일 Python Class 선언과 instance를 만드는 방법에 대해서 배웠다. Object-Oriented Programming에 대해서 정리한 내용을 포스팅했다. ✨4 Fundamentals of OOP Python Access Modifier에 대해서 알고 정리했다. Network 계층 및 Eathernet과 IP Protocol에 대해서 배웠다. Quick sort | Divide and Conquer - Python으로 Code를 짰다","link":"/2019/04/24/190424-TIL/"},{"title":"190426-TIL","text":"Today I Learned Simulated and implemented Merge sort. Studied python Stack and queue. Also implemented stack using 2 queues, queue using 2 stacks. Review linked list in python. Solve CodeWars 6kyu Take a Number And Sum Its Digits Raised To The Consecutive Powers And ….¡Eureka!!","link":"/2019/04/26/190426-TIL/"},{"title":"190430-TIL","text":"Today I LearnedAlgorithm study Studied history, variable, data type and operation of JavaScript","link":"/2019/04/30/190430-TIL/"},{"title":"190429-TIL","text":"Today I LearnedSolved Morse code decoding problem my Algorithm Post Wrote posting about JavaScript 1. What is Programming? Studied Data Structure and posted 1. OOP and ADT","link":"/2019/04/29/190429-TIL/"},{"title":"3. JavaScript Develop Environment and Execute","text":"Before this chapter, What is Web API?While the most common scripting language ECMAscript (more widely known as JavaScript) is developed by Ecma, a great many of the APIs made available in browsers have been defined at W3C. What is scripting?A script is program code that doesn’t need pre-processing(e.g. compiling) before being run. In the context of Web browser, scripting usually refers to program code written in JavaScript that is executed by browser when a page is downloaded, or in response to an event triggered by the user. Scripting can make Web pages more dynamic.For Example, without reloading a new version of a page it may allow modifications to the content of that page : DHTML(Dynamic HTML) allow content to be added to or sent from that page : AJAX(Asyncronous JavaScript and XML) What scripting interfaces are available ?The most basic scripting interface developed by W3C is the DOM, the Document Object Model which allows programs and scripts to dynamically access and update the content, structure and stype of documents. DOM specifications form the core of DHTML. Modifications of the content using the DOM by the user and by scripts trigger events that developers can make use of to build rich user interface. A number of more advanced interfaces are being standardized, for instance: XMLHttpRequest makes it possible to load additional content from the Web without loading a new document, a core component of AJAX, the Geolocation API makes the user’s current location available to browser-based applications, several APIs make the integration of Web applications with the local file system and storage seamless. Execution Environment of JavaScriptAll browsers have JavaScript engine that can inpterpreter and execute JavaScript. Not only browser but also Node.js has JavaScript engine. So JavaScript can operate in both browser and Node.js environment. Basically code that operate in browser also operate in Node.js environment too. But the browser and Node.js have different purpose. The main purpose of browser is execute HTML, CSS, JavaScript to rendering web page on screen, but the other one is provide server development envorinment. So both of browser and Node.js can operate ECMAScript(core of JavaScript) but additional features provided by Node.js and browser and ECMAScript are incompatible. Node.js environment ES + Node.js API (file control) Browser Rendering HTML, CSS JavaScript : ES + Web API (created by browser vendors and managed by W3C) (DOM API, event) only browser can execute As such, the browser supports ECMAScript and client side Web APIs such as DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, and Web worker. Node.js does not support client side Web APIs and supports ECMAScript and Node.js-specific APIs. Web BrowserHow does a Web Browser work?Most programming languages run on Operating System, but JavaScript in Web application runs with HTML and CSS in a browser. So efficient JavaScript programming is available when considering Web browser environment. Core function of Web browser is that request the Web page user want and represent the response from server in browser. Web browser receives HTML, CSS, JavaScript, and image files from the server. HTML and CSS files are parsed by the rendering enginde’s HTML parser and CSS parser, converted into DOM tree and CSSOM tree, and combined into a Render Tree. Browser represent Web pages by this Render tree. JavaScript is processed by JavaScript engine, not the Rendering engine. HTML parser stops DOM construction process when meet the script tag, and passes control to the JavaScript engine to execute JavaScript code. Control passed JavaScript engine loads, parses and executes the JavaScript code in script tag or JavaScript file defined in script tag’s src attribute. Interpreter that used in most modern Web browser doesn’t compile like typical compiler language but compiles and executes a part of source code in complex way. Interperter Translates program one statement at a time. It takes less amount of time to analyze the source code but the overall execution time is slower. No intermediate object code is generated, hence are memory efficient. Continues translating the program until the first error is met, in which case it stops. Hence debugging is easy. Programming language like Python, Ruby use interpreters. Compiler Scans the entire program and translates it as a whole into machine code. It takes large amount of time to analyze the source code but the overall execution time is comparatively faster. It takes large amount of time to analyze the source code but the overall execution time is comparatively faster. It generates the error message only after scanning the whole program. Hence debugging is comparatively hard. Programming language like C, C++ use compilers. Source code is composed of simple strings. So interpret string codes to make the AST(Abstrack Syntax Tree) that has syntax and semantics. TokenizingSeparate the source code into tokens, the smallest unit of meaning, by lexical analysis. ParsingSyntactically analysis the set of tokens to create AST. Execute codeCreated AST is converted to byte code or optimized machine code and run by interpreter. If execution of JavaScript is finished, pass control to HTML parser and resume DOM creation from the time when browser stopped. As such, browsers process HTML, CSS, and JavaScript synchronously. This means creation of DOM can be delayed by blocking from script tag. So the position of script tag has important meaning. You should put script code at bottom of HTML file. It prevent error that can be occured when JavaScript touch DOM before DOM creation completed. Node.jsA client side, or simple web application that works on a web browser, can be developed with just a browser. However, as the project grows in size, it is necessary to introduce external libraries such as React and jQuery, or to use several tools such as Babel, Webpack, ESLint, etc. Node.js and npm are required. Node.js and npmNode.js, announced by Ryan Dahl in 2009 is a JavaScript runtime environment built with Chrome V8 JavaScript engine. Simply, Node.js is JavaScript execution environment that enable JavaScript to run in addition to browser. npm(node package manager) is JavaScript package manager. Itself a repository include packaged modules available in Node.js and provide CLI to install and management. Reference JavaScript Web API Hello world","link":"/2019/04/30/3-JavaScript-Develop-Environment-and-Execute/"},{"title":"2. What is JavaScript?","text":"1. Creation of JavaScriptIn 1995, the Netscape Communications decided to introduce a lightweight programming language to dynamically express static HTML. So JavaScript developed by Brendan Eich. JavaScript was mounted on Netscape Navigator 2 which is web browser of Netscape Communications, named “Mocha” in March, 1996. In September, renamed to “LiveScript” and finally named as “JavaScript” in December. So JavaScript is now the standard programming language for all browsers. But JavaScript has not grown smoothly 2. Fragmentation and Standardization of JavaScriptIn August 1996, Microsoft added a derived version of JavaScript, “JScript”, to Internet Explorer 3.0. But the problem is that JScript and JavaScript are not standardized and are moderately compatible. In other words, they have competitively begun adding features that only work with their browsers to gain market share in their browsers. This has led to cross-browsing issues where webpages are not working properly, and it has become extremely difficult to develop webpages that work across all browsers. Thus, the need for stadard of JavaScript which works same in all browser has begun to be raised. For this, Netscape Communications requested standardization of JavaScript to ECMA International in November 1996. Version Release Specification ES1 1997 First version ES2 1998 Application of the same standards as ISO/IEC 16262 international standards ES3 1999 Regular Expression, try … catch Exception ES5 2009 Standard released with HTML5. JSON, strict mode, accessor property(getter, setter), improved array manipulation (forEach, map, filter, reduce, some, every) ES6 (ECMAScript 2015) 2015 let, const, class, arrow function expression(=&gt;), template literal, destructuring assignment, spread operator, rest parameter, Symbol, Promise, Map/Set, iterator/generator, module import/export ES7 (ECMAScript 2016) 2016 Exponential operator(**), Array.prototype.includes, String.prototype.includes ES8 (ECMAScript 2017) 2017 async/await, Object static method(Object.values, Object.getOwnPropertyDescriptors) ES9 (ECMAScript 2018) 2018 Object Rest/Spread Property 3. History of JavaScriptEarly JavaScript was used for limited purposes to perform the supplementary functions of webpages. During this time, most logics were run primarily on Web servers and browsers were simply rendering HTML and CSS delivered from the server. Rendering?Rendering refers to interpreting data expressed in HTML and CSS and expressing it visually on a browser. In 1999, Ajax(Asynchronous JavaScript and XML), a communication function that allows server and browser to exchange data asynchronously using JavaScript, has emerger under the name of XMLHttpRequest. Previous webpages worked by receiving complete HTML from the server and rendering the entire web page. So when screen switches, it received a new HTML file from server and started rendering a whole web page again from beginning. This is a disadvantageous way because unnecessary data communication occurs when receive HTML including unchanged parts from a server and browser should be rendering that whole HTML again including unchanged parts. This causes the screen to flash momentarily when a screen transition occurs, which has been accepted as the limit for web applications. The advent of Ajax changed the previous paradigm. In other words, it make possible to do not rendering again the parts unnecessary to change and rendering only the part need to change by receiving only a necessary data from server. This enables fast performance and smooth screen transitions similar to desktop applications in web browsers. In 2005, Google Maps, which operates on JavaScript and Ajax in a web browser, has shown performance and smooth screen transitions that are comparable to desktop applications. In 2006, the advent of jQuery made it easier to control the rather cumbersome DOM(Document Object Model) and resolved cross-browsing issues to some extent. jQuery quickly secured a large user base. This resulted in the mass production of developers who preferred jQuery, which was easier to learn and more intuitive than JavaScript. In 2008, V8 JavaScript Engine from google made more fast performance in web browser. With the advent of the V8 JavaScript engine, JavaScript has become a web application development programming language that can provide a user experience(UX) similar to that of desktop applications. In 2009, the Node.js that enable operate JavaScript in an environment other than a browser emerged. JavaScript is now a standard for web programming languages that cover not only front-end but also back-end areas. 4. JavaScript and ECMAScriptECMAScriptECMAScript refers ECMA-262, which standard specification of JavaScript and defines core syntax such as the type, value, objace and property, function, built-in object, etc. Each JavaScriptJavaScript is typically a programming language that encompasses ECMAScript as a core and client side Web API, which is supported separately by the browser. Web APIDOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker, etc. Apart from ECMAScript, the client side Web API is managed as a separate specification by the World Wide Web Consortium (W3C). 5. Characteristics of JavaScriptJavaScript is one of the components that compose the web with HTML and CSS, and is the only programming language that works with a web browser. It use basic syntax from C, prototype-based inheritance from Self, first-class function from Scheme. JavaScript is interpreter language that developer not have to do compile work. Almost modern JavaScript engines(V8 by Chrome, Spidermonkey by FireFox, JavaScriptCore by Safari, Chakra by Microsoft Edge) combined advantage of interpreter and compiler to resole disadvantage of slow interpreter. Actually JavaScript complie but not make executable file. So JavaScript is interpreter lanuage. JavaScript is a multi-paradigm programming language that supports imprerative, functional, and prototype-based object-oriented programming. Reference 자바스크립트란?","link":"/2019/04/29/2-What-is-JavaScript/"},{"title":"190501-TIL","text":"Today I LearnedI learned about the operation principle and process of web browser. HTML parser creates DOM tree, CSS parser creates CSSOM tree and JavaScript parser creates AST(Abstract Syntax Tree). Now I can explain JavaScript and ECMAScript.","link":"/2019/05/01/190501-TIL/"},{"title":"4 Fundamental of Object Oriented Programming","text":"추상화 | Abstraction ? 추상화란, 복잡한 로직을 가지고 있는 기능에서 그것을 다루기 위해 필요한 최소한의 핵심만을 추출해내는 것을 말한다. 정의만 들으면 어렵다. TV 전원을 예로 들어 생각해보자. 새로 산 TV의 설명서를 보면 TV를 켜려면 전원 버튼을 누르라고 되어있다. 사용자는 전원 버튼을 누르면 쉽게 TV를 켤 수 있다. 그러나 실제로 TV의 전원 버튼을 누르는 순간 내부 전기회로에서는 복잡한 기능이 실행될 것이다. 사용자는 그것을 알 수 없고, 알 필요도 없다. TV 제작 회사에서 TV에 대한 추상화를 시켜 사용자가 쉽게 TV를 동작시킬 수 있도록 한 것이다. 함수를 보통 function, routine, procedure 라고 부른다. 이 때, procedure 단위로 추상화를 하고 procdural하게 진행하는 프로그램을 절차 지향 프로그램이라고 한다. 그러나 프로그램이 거대해지고, 코드가 길어지자 프로그램을 객체(object)로 추상화하는 방법론이 나왔고 그걸 적용한 게 객체 지향 프로그램이다. 절차 지향 Procedural Programming : procedure 단위 추상화객체 지향 Object Oriented Programming : Object 단위 추상화Function Abstraction Function Signature (Interface) : function name, parameter, return calue Implementation : operations 함수의 명세(Function Signature)와 내부구현(Implementation)을 분리하는 것 4 Fundamental of Object Oriented ProgrammingEncapsulationEncapsulation은 모든 object가 그 state(private variables)를 class내부에 private으로 보유하고 있을 때 지켜진다. 다른 object들은 그 state에 직접 접근할 필요 없이, 해당 object의 public object(method)를 호출한다. 결과적으로 object는 자신의 state를 method를 통해 관리한다. Abstraction추상화는 encapsulation을 자연스럽게 확장한 것으로 볼 수 있다.추상화를 적용한다는 것은, 각 object를 사용할 때 오직 high-level machanism만을 공개해야한다는 것이다. 이 mechanism은 내부 implementation을 숨기고, 오직 관련된 객체의 operation으로만 접근할 수 있다. 즉, 사용자는 class의 method가 어떻게 작동하는지 알 필요 없이 제공된 interface(method name, parameter, return value)만 알고 사용할 수 있다. Inheritance대부분의 object는 비슷하고 공통된 logic을 공유한다. 상속을 통해 중복되는 코드를 최대한 방지하는 것이 inheritance의 핵심이다. Parent class로부터 child class를 만들 수 있으며, child class는 parent class의 모든 영역을 재사용할 수 있는 특권을 가진다. Parent class의 기능에 자신만의 method를 추가하거나 재정의(override)할 수 있다. Polymorphism | One Interface and Multiple Implementations.다형성. 우리가 parent class와 그로부터 상속받은 여러 child class를 가지고 있을 때, 이 모든 class를 collection처럼 한번에 쓰고 싶을 때가 있을 것이다. Polymorphism은 class를 이렇게 사용할 수 있게 하는 방법 제공한다. Parent class에 interface method를 선언하고(implementation은 하지 않는다!) child class에서 그 method의 implementation을 담당하는 것이다. 상속은 많은 형태의 변화를 가능케 한다. Parent class를 상속하는 child class는 parent class로 정의될 수 있다. (ex. Child C = new Parent(); ) Function OverLoading : 이름은 같지만 signature(parameter 수, data type)는 다른 method를 중복으로 선언하는 것method 이름은 같아야 한다. Parameter 수는 달라야 하며, 같다면 data type이 달라야 한다. Method OverRiding : 부모 클래스의 method 동작 방법을 재정의하여 우선적으로 사용하는 것.override 하고자 하는 method가 상위 클래스에 존재해야 한다. Method 이름이 같아야 하며, parameter 개수, data type, return type 등 모든 signature를 동일하게 사용한다. 달라지는 것은 내부 구현 뿐이다. 부르는 object만 달라질뿐 method 이름을 동일하게 하면 하나의 method로 여러 기능을 실행할 수 있다. 참고 자료 How to explain object-oriented programming concepts to a 6-year-old","link":"/2019/04/24/4-Fundamental-of-Object-Oriented-Programming/"},{"title":"4. Variable","text":"What is variable?Application uses data. And the variable is core concept for managing data. Computer is computing machine. To do simple operation like sum of 1 and 2, computer should memorize these operand 1 and 2 in register. Computer uses memory to memorze the data. MemoryMemory is a collection of memory cells that can store data. Size of one cell is 1byte(8bit) and computer read or wirte data by one cell, 1 byte size. Each memory cell has its own address. That address means location of memory space and can be represented from 0 to memory size. Computer can simply compute 1 + 2, but how to use this result of sum? What you need at this point is the variable. To store data in memory and read to use data from memory, programming language provide variable. Variable refers name of memory space or memory space itself. Simply, variable is mechanism that store and refer data values. Through variable, developer can store, refer and change value wihout access to memory directly. Just, like it. 1var result = 1 + 2; In JavaScript, var means variable. In that code, ‘result’ is a name of the variable and 3 is a value of the variable. Storing value in variable is called assignment and reading data from variable is called reference. Declaration of variableVariable name is the name given to memory space. To use a variable, variable must be declared. Use var, let, const keywords to declare variable. Before ES6 introduced let and const keywords, var was the only method to declare variable. KeywordKeyword is kind of command that defines the actions performed by JavaScript engines that execute JavaScript code. 1var soup; The avobe variable declaration register name of variable and make memory space to store a value. Now there is a undefined value in variable soup. It is primitive value of JavaScript. JavaScript do assignment and initialization at same time. If you reference the variable without declaration, error will occur. Variable Declaration run time and Hoisting123console.log(soup);var soup; In C, the avobe code will occur compile error because it access to the variable before its declaration. But in JavaScript print undefined instead of ReferenceError. Variable declaration is processed at parsing-time, before the run-time that source code execute in line step. In other words, JavaScript engine estimate entire source code in advance. At this time, it finds all of declaration(variable declariation, function declaration), declare and initialize identifiers. After that run source codes sequentially except declarations. What is Hoisting?Hoist means to lift something. It is a variable that is hoisted in JavaScript. Hoist means that the definition of a variable is separated into declarations and allocations according to its scope.Declarations execute before other codes so it seems like declarations are hoisted to top of the source code. In JavaScript, all of variable declarations are hoisted. Warning Function hoisting hoists function declarations too, but not hoist the value of variables. So think seperate declarations and assignment is important. It’s relevant with run-time and parsing-time. 1234567891011foo();function foo(){ console.log('ok');};// Okfoo();var foo = function foo(){ console.log('ok');};// Syntax error! Assignment of Values1234var soup; // Variable Declarationsoup = 3; // Assignment valuevar soup = 3; // Variable declaration and assigment Variable declaration is executed at parsing-time and assignment is executed in run-time, affter the parsing-time. Of course when declare variable, it is initialized to undefined. 12345console.log(soup); // undefinedvar soup = 3; // Variable declaration and assigmentconsole.log(soup); // 3 So soup is re-initialized to 3. Reassignment of Value12var soup = 3; // Declaration and Assignmentsoup = 5; // Reassignment Variable that declared by var keyword can be reassigned. Reassignment is that variable discards the current value and store new value. Reassignment changes old value to new value. If the reassignment is not possible, it is called a constant not a variable. A constant is a value that does not change once set. In other words, constants are variables that can be assigned only once. const keywordIntroduced from ES6, variable that declared by const is prohibited reassignment. But const keyword does not only used for constant. Reference Data type &amp; Variable","link":"/2019/04/30/4-Variable/"},{"title":"CodeWars 6kyu. Dubstep","text":"CodeWars 6kyu. Dubstep덥스텝 제목을 Decoding 하기 Polycarpus works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them. Let’s assume that a song consists of some number of words (that don’t contain WUB). To make the dubstep remix of this song, Polycarpus inserts a certain number of words “WUB” before the first word of the song (the number may be zero), after the last word (the number may be zero), and between words (at least one between any pair of neighbouring words), and then the boy glues together all the words, including “WUB”, in one string and plays the song at the club. For example, a song with words “I AM X” can transform into a dubstep remix as “WUBWUBIWUBAMWUBWUBX” and cannot transform into “WUBWUBIAMWUBX”. Recently, Jonny has heard Polycarpus’s new dubstep track, but since he isn’t into modern music, he decided to find out what was the initial song that Polycarpus remixed. Help Jonny restore the original song. Input The input consists of a single non-empty string, consisting only of uppercase English letters, the string’s length doesn’t exceed 200 characters Output Return the words of the initial song that Polycarpus used to make a dubsteb remix. Separate the words with a space. Examples12songDecoder(\"WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\") // =&gt; WE ARE THE CHAMPIONS MY FRIEND 요구조건 input으로 200자를 넘지 않고 비어있지 않은 string 하나가 들어오면 WUB가 끼어들어가있지 않은 원래의 song 제목으로 decoding해 return 한다. 각 단어는 space로 나눠져야 한다. 해결책여러가지 방법으로 해결했다. Regular Expression을 활용해 string을 처리했다. replace method와 RegEx를 사용해 song에 존재하는 모든 “WUB”를 “ “(space)로 대체한다. 단어 사이에 space가 여러개 있을 수 있으니 하나 이상의 space(\\s+)로 string을 배열로 조각낸 후, 각 단어를 다시 space를 사이에 넣어 join한다. 1-1. 이렇게 되면 string의 시작과 끝에 존재하는 공백이 처리되지 않는다. 처음 Solution 1을 작성할 때는 trim() method를 몰랐으므로 직접 if문으로 처리했다. filter() method와 새로운 function 문법 =&gt; 를 써보고 싶어 작성한 Suolution 정규 표현식과 trim method를 활용해 코드의 길이를 줄였다. javaScript Solution 1123456789101112function songDecoder(song){ let result = song.replace(/WUB/gi, ' ').split(/\\s+/).join(' '); if(result[0] === ' '){ result = result.slice(1); } if(result[result.length-1] === ' '){ result = result.slice(0, -1); } return result;} javaScript Solution 21234function songDecoder(song){ return song.replace(/WUB/g, ' ').split(' ').filter(word=&gt;word!='').join(' ');;} javaScript Solution 3 123function songDecoder(song){ return song.replace(/(WUB)+/g,\" \").trim();} Regular Expression ^x : 문자열의 시작이 x x$ : 문자열의 끝이 x .x : x로 끝나는 임의의 문자 x+ : x가 1번 이상 반복 x* : x가 0번 이상 반복 x? : x가 존재하거나 존재하지 않음 x{n} : x를 n번 반복한 문자를 찾음 x{n,} : x를 n번 이상 반복한 문자를 찾음 x{n, m} : x를 n번 이상, m번 이하 반복하는 문자를 찾음 Flags g (Global) : 문자열 내에 존재하는 모든 패턴을 찾음 i (Ignore Case) : 대소문자 구분 없이 찾음 m (Multi Line) : 문자열의 행이 바뀌어도 찾음 12// 객체초기화(Object initializer) 방법var regExp = /정규표현식/[Flag];","link":"/2019/04/18/CodeWars-6kyu-Dubstep/"},{"title":"Call by Value, Call by Reference and Call by Object Reference","text":"우선 Parameter와 Argument의 차이를 짚고 가도록 한다. ParameterThe names given in the function definition are called Parameters. ArgumentThe values supplied in the function call are called Arguments. Call by Value 함수를 호출할 때, 변수의 값을 복사하여 argument로 넘기는 것 123456789101112#include &lt;stdio.h&gt;void change_value(int x, int val) { x = val; printf(\"x : %d in change_value \\n\", *x);}int main(void) { int x = 10; change_value(x, 20); printf(\"x : %d in main \\n\", x);} 위 코드에서는 단순히 x에 10이라는 값이 복사되어 들어가기 때문에, change_value(x, 20)에서 x를 변경하더라도 main 함수에서의 x에 영향을 미치지 못한다. Call by Reference 함수를 호출할 때 변수의 값을 넘기는 것이 아니라, 변수의 주소(변수의 위치)를 복사하여 함수에 넘긴다. 넘겨받은 주소로 실제 변수에 접근하고 값을 변경할 수 있다. 123456789101112#include &lt;stdio.h&gt;void change_value(int * x, int val) { *x = val; printf(\"x : %d in change_value \\n\", *x);}int main(void) { int x = 10; change_value(&amp;x, 20); printf(\"x : %d in main \\n\", x);} 주소값을 전달 (참조값을 전달) : 주소값을 알고 있으면 해당 memory 주소에 저장되어있는 값을 참조할 수 있다. *x가 x를 참조하고 있다 : 가리키고 있다. 이를 이해하기 위해서는 pointer에 대한 이해가 필요하다. Pointer 123int *pnum;int num = 12345;pnum = &amp;num //num의 주소값을 return하여 pnum에 저장 변수를 만들 때 변수 이름 앞에 *를 붙이면 pointer 변수 됨 &amp;연산자: &amp;오른쪽에 오는 피연산자의 주소값을 반환 *연산자: 포인터가 가리키는 메모리 공간에 접근할 때 사용되는 연산자. 포인터 변수를 이용해 포인터 변수가 가리키는 변수의 값을 바꿀 수도 있다. Call by Assignment (Call by Object Reference) The actual parameters (arguments) to a function call are introduced in the local symbol table of the called function when it is called; thus, arguments are passed using call by value (where the value is always an object reference, not the value of the object). [1] When a function calls another function, a new local symbol table is created for that call. 이 문장이 나를 얼마나 헷갈리게 했는지 모른다. 그러니까 Python에서는 function의 argument가 call by value로 넘어오는데, 그 value는 언제나 object의 값이 아닌 object의 reference라는 것이다. Actually, call by object reference would be a better description, since if a mutable object is passed, the caller will see any changes the callee makes to it (items inserted into a list). 정확하게는 call by object reference라는 설명이 더 맞다. 왜냐면 mutable 객체가 넘어올 때에는 call by reference처럼 원본 값을 변경할 수 있기 때문이다. 파이썬은 모든 것이 object이고, Object에는 두 종류가 있다. Immutable object int, float, str, tuple Immtable 객체가 함수의 인자로 전달되면, 처음에는 call by reference로 받지만 값이 변경되면 call by value로 동작한다. 즉, 함수 내에서 formal parameter 값이 바뀌어도 actual parameter에는 영향이 없다. 함수 내부에서 값을 변경할 수 없다! 그래서 tuple은 변경하려면 함수에서 element와 tuple 인자로 넘겨 아예 새로 할당해줘야 함 Mutable object list, dict, set Mutable 객체가 함수의 인자로 넘어가면 call by reference도 동작한다. 즉, object referene가 전달되어 actual parameter의 값에 영향을 미칠 수도 있다. 새로운 객체를 할당하는 게 아니라면, 함수 내부에서 값을 변경할 수 있다! 정리 Python은 함수를 실행할때 Call by reference같은 느낌으로 reference를 넘겨준다. 하지만 이때 넘겨주는 것은 변수(Variable)의 reference가 아니라 변수가 담고 있는 자료(Data)의 reference이다. 자료가 mutable하다면 변경해도 reference가 보존되므로 결과적으로 Call by reference처럼 보일 것이고, 자료가 immutable하다면 결과적으로 Call by value처럼 보일 것이다.","link":"/2019/04/22/Call-by-Value-Call-by-Reference-and-Call-by-Object-Reference/"},{"title":"6. Operator","text":"Expression and OperatorValues ​​can be generated in a variety of ways. The various methods mentioned here are expressions. Expressions in a programming language have a very important meaning. Expression is combination of tokens(literal, identifier(variable name, function name, etc), operator, function call). The expression is evaluated to produce a single value. That is, an expression is a statement that can be evaluated as a single value. Expression can be divided into a literal notation, an identifier expression, an operator expression, a function/method call expression, but they are all the same in that they are evaluated and made into a single value. The value that generated by evaluation of an expression is equivalent with an expression. In other words, expressions can be used like values. This means that an expression can also be placed where the value can be placed. 1234var x = 10;// expression x + 30 consists of a combination of an identifier expression(x), number literal(30) and operator(+)console.log(x + 30); //40 Statement and ExpressionA statement is a command to a JavaScript engine that consists of a combination of one or more expressions and keywords. So when the statement is executed, the command is executed and something happens. It is a program that is made up of a set of statements, and programming is to write the statements and sequence them. A statement can be divided into declare statement, expression statement, conditional statement and loop statement. When variable declare statement is executed, the variable is declared and when assignment statement that is expression statement is executed, a value is assigned. When conditional statement is executed, execution of code block is determined by given condition and a code block is repeatedly executed when an iteration statement is executed. Statement should end up with semicolon(;). Do not add a semicolon after the code block. All codes of JavaScript are statements or expressions. If the statement is a complete sentence ending with a period, the expression is the same element as the phrase that constitutes the statement. An expression can itself be a statement. But the statement can not be an expression. It is difficult that distinguish statement and expression. The expression evaluates to produce a value, but can not do anything further. The statement can be used to create variables, functions, and classes using declarative keywords such as var, let, const, function (declare statement), and class and to control the program flow by generating conditional statements such as if, for, and while statements. The role of expression is that generates value. The role of statement is that command to JavaScript engine using a value that is generated by expression. Expression statement and Non-expression statement","link":"/2019/05/01/6-Operator/"},{"title":"CodeWars 6kyu. Decode the Morse code","text":"CodeWars 6kyu. Decode the Morse codeDecode Morse code to plain text The Morse code encodes every character as a sequence of “dots” and “dashes”. For example, the letter A is coded as ·−, letter Q is coded as −−·−, and digit 1 is coded as ·−−−−. The Morse code is case-insensitive, traditionally capital letters are used. When the message is written in Morse code, a single space is used to separate the character codes and 3 spaces are used to separate words. For example, the message HEY JUDE in Morse code is ···· · −·−− ·−−− ··− −·· ·. NOTE: Extra spaces before or after the code have no meaning and should be ignored. In addition to letters, digits and some punctuation, there are some special service codes, the most notorious of those is the international distress signal SOS (that was first issued by Titanic), that is coded as ···−−−···. These special codes are treated as single special characters, and usually are transmitted as separate words. Your task is to implement a function that would take the morse code as input and return a decoded human-readable string. 12decodeMorse('.... . -.-- .--- ..- -.. .')//should return \"HEY JUDE\" Each word distinguished by &quot; &quot; (3 spaces) Free to use the preloaded Morse code table as a dictionary. By MORSE_CODE['.--'] javaScript Solution 1234567891011121314151617decodeMorse = function(morseCode){ var words = morseCode.split(\" \"); var string = \"\" for (var i in words){ if(words[i] != ''){ var word = words[i].split(\" \"); for(var j in word){ if(word[j] != ''){ string += MORSE_CODE[word[j]]; } } if(i &lt; words.length-1){ string += \" \" } } }","link":"/2019/04/29/CodeWars-6kyu-Decode-the-Morse-code/"},{"title":"CodeWars 5kyu. Directions Reduction","text":"CodeWars 6kyu. Dubstep뒤죽박죽 방향 지시를 효율적으로 만들기 Instruction이 길어 생략하도록 하겠다. 위의 링크를 참조하도록 하자. 요구조건 북쪽으로 갔다가 남쪽으로, 동쪽으로 갔다가 서쪽으로. 움직이지 않는 것만 못한 비효율적인 지시를 제거하는 문제다. [NORTH + SOUTH], [EAST + WEST] 와 같이 두 방향이 인접해야지만 제거할 수 있다. [SOUTH, EAST, WEST, NORTH]와 같은 경우, 첫번째로 EAST + WEST가 사라지고 나면 SOUTH + NORTH가 인접하게 되므로 이것 또한 제거해 효율적인 지시를 내려야 한다. 해결책이전에 LeetCode에서 두어번 풀어보았던 in-place 알고리즘이 떠올랐다. input을 담을 자료구조를 따로 만들지 않고 input 자체에 연산을 하는 작업이다. Call by reference로 parameter를 넘겨줄 때만 유효한 알고리즘이다. input arr의 item이 한개 이하라면 그냥 arr를 return한다. 각 대응되는 direction들을 dictionary의 key와 value로 mapping한다. for문을 돌며 만약 서로 대응되는 방향이 인접해있다면 그 둘을 arr에서 잘라내고, i를 초기화해서 처음부터 다시 arr를 순회한다. javaScript Solution123456789101112131415function dirReduc(arr){ if(arr.length &lt;= 1) return arr; var direction = {\"NORTH\": \"SOUTH\", \"EAST\": \"WEST\", \"SOUTH\": \"NORTH\", \"WEST\": \"EAST\"}; for(var i = 0; i &lt; arr.length; i++){ if(direction[arr[i]] == arr[i+1]){ arr.splice(i, 2); i = -1; } }","link":"/2019/04/20/CodeWars-5kyu-Directions-Reduction/"},{"title":"CodeWars 5kyu Maximum subarray sum","text":"CodeWars 5kyu. Maximum subarray sumReturn maximum sum of subarrays The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers: maxSequence([-2, 1, -3, 4, -1, 2, 1, -5, 4]) // should be 6: [4, -1, 2, 1] Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead. Empty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist/subarray. Requirement Should return maximum sum of any subarrays including empty list. Return 0 when all of list’s element is negative numbers. SolutionI used Dynamic Programming - Bottom up approach to solve this problem. Because I learned on some online lectures about Dynamic Programming recently. First I catched that all the start and end element in subarray is positive numbers. So I decided to put all positive numbers’ index in positive_index list. Make a 2 dementional array, sum[][] to keep the sum of subarrays. Drew the recurrance Induction of this problem. Basis sum[i][i] = arr[positive_index[i]] sum[i][i+1] = arr[positive_index[i]] to arr[positive_index[j]] (i &lt; positive_index.length - 1) Inductive Step sum[i][j] = sum[i][j-1] + sum[j-1][j] - arr[positive_index[j-1]] javaScript Solution 12345678910111213141516171819202122232425262728293031323334353637var maxSequence = function(arr){ var positive_index = [] arr.filter(function positive_check(element, index){ if(element&gt;0){ positive_index.push(index); } }) if (positive_index.length == 0) return 0; var sum = Array(positive_index.length).fill(null).map(() =&gt; Array(positive_index.length)); var max = Number.MIN_SAFE_INTEGER; for(var i=0; i&lt;positive_index.length; i++){ sum[i][i] = arr[positive_index[i]]; if(max &lt; sum[i][i]){ max = sum[i][i]; } if(i+1&lt;positive_index.length){ sum[i][i+1] = arr.slice(positive_index[i], positive_index[i+1]+1).reduce((a,b)=&gt;a+b); if(max &lt; sum[i][i+1]){ max = sum[i][i+1]; } } } for(var i=0; i&lt; positive_index.length; i++){ for(var j=i+2; j&lt; positive_index.length; j++){ sum[i][j] = sum[i][j-1] + sum[j-1][j] - arr[positive_index[j-1]]; if(max &lt; sum[i][j]){ max = sum[i][j]; } } } return max;} PPT slidesMade presentations for my algorithm study group","link":"/2019/04/25/CodeWars-5kyu-Maximum-subarray-sum/"},{"title":"CodeWars 6kyu. Multiples of 3 or 5","text":"CodeWars 6kyu. Multiples of 3 or 53 또는 5의 배수의 합 구하기 If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in. Note: If the number is a multiple of both 3 and 5, only count it once. Courtesy of ProjectEuler.net 요구조건어떤 자연수 number 미만의 3 또는 5의 배수를 찾는 문제 해결책 input number가 3 또는 5로 나누어 떨어지면 sum에 더하는 방식이다. 문제가 너무 간단하게 풀려서 새로운 방법으로 생각 해보기로 했다. number를 3, 5로 나누면 그 몫의 개수만큼만 for loop을 돌며 추가한다. 5로 나눈 몫이 항상 3으로 나눈 몫보다 작기 때문에 한 번 더 검사를 해주었다. javaScript Solution 1123456789function solution(number){ var sum = 0; for (var i = 0; i &lt; number; i++) { if (i % 3 === 0 || i % 5 === 0) { sum += i; } } return sum;} javaScript Solution 212345678910function solution(number){ var sum = 0; var threeMultiples = number/3; var fiveMultiples = number/5; for(var i=1; i&lt; threeMultiples; i++){ if(i%5 != 0) sum += i*3; if(i &lt; fiveMultiples) sum += i*5; } return sum;}","link":"/2019/04/17/CodeWars-6kyu-Multiples-of-3-or-5/"},{"title":"CodeWars 6kyu. Persistent Bugger","text":"CodeWars 6kyu. Persistent Bugger각 자릿수의 곱이 한자릿수가 되는 횟수를 구하기 Write a function, persistence, that takes in a positive parameter num and returns its multiplicative persistence, which is the number of times you must multiply the digits in num until you reach a single digit. For example: 1234567persistence(39) === 3 // because 3*9 = 27, 2*7 = 14, 1*4=4 // and 4 has only one digitpersistence(999) === 4 // because 9*9*9 = 729, 7*2*9 = 126, // 1*2*6 = 12, and finally 1*2 = 2persistence(4) === 0 // because 4 is already a one-digit number 해결책split()을 사용해서 숫자를 각각 문자열 배열의 원소로 떼어내면 쉬울 것 같았는데 나는 고전적인 방법으로 숫자 그대로를 parsing하고 싶었다. 그래서 이전 LeetCode의 Palindrome 문제를 풀 때 사용한 숫자의 pop 기법을 이용해 한자리씩 숫자를 분리했다. javaScript Solution 1 123456789101112131415161718192021222324let pop = 0; let count;let mult, nums; function mul(num){ mult = 1; while(num &gt; 0){ pop = num%10; num = (num-pop)/10; mult *= pop; } nums = mult;}function persistence(num) { if(num &lt; 10) return 0; count = 0; nums = num; do{ count++; mul(nums); }while(mult &gt;= 10) return count;}","link":"/2019/04/19/CodeWars-6kyu-Persistent-Bugger/"},{"title":"CodeWars 6kyu. Find The Parity Outlier","text":"CodeWars 6kyu. Find The Parity OutlierFind one odd / even number in last all even / odd numbers. You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. Write a method that takes the array as an argument and returns this “outlier” N. Examples 12345[2, 4, 0, 100, 4, 11, 2602, 36]Should return: 11 (the only odd number)[160, 3, 1719, 19, 11, 13, -21]Should return: 160 (the only even number) First Solution 1234567891011121314151617181920212223242526272829303132333435363738394041function findOutlier(integers){ var isOdd = true; if (integers[0]%2 == 0){ // even if (integers[1]%2 == 0){ // even even isOdd = false; } else{ // even odd if(integers[2]%2 ==0){ // if even odd even, return odd return integers[1]; } else{ // else if even odd odd, return even return integers[0]; } } } else{ // odd if (integers[1]%2 == 0){ // odd even if (integers[2]%2 == 0){ // if odd even even, return odd return integers[0]; } else{ // if odd even odd, return even return integers[1]; } } } if(isOdd == true){ for(var i=2; i&lt;integers.length; i++){ if(integers[i]%2 == 0) return integers[i]; } } else{ for(var i=2; i&lt;integers.length; i++){ if(integers[i]%2 != 0) return integers[i]; } }} Second Solution 123456function findOutlier(integers){ var even = integers.filter(a=&gt;a%2==0); var odd = integers.filter(a=&gt;a%2!=0); return even.length == 1 ? Number(even) : Number(odd);}","link":"/2019/05/01/CodeWars-6kyu-Find-The-Parity-Outlier/"},{"title":"CodeWars 6kyu. Playing with digits","text":"CodeWars 6kyu. Playing with digitsPlay with digits 😊 I changed the type of input n to cycle through each digit. 123456789function digPow(n, p){ let digitSum = 0; let strNum = String(n); for(let i in strNum){ digitSum += strNum[i]**p; p++; } return Number.isInteger(digitSum/n) ? digitSum/n : -1;}","link":"/2019/05/02/CodeWars-6kyu-Playing-with-digits/"},{"title":"Difference between Subsequence and Substring","text":"SubsequenceIn mathmatics, a subsequence is a sequence that can be derived from another sequence by deleting some or no elememts without changing the order of the remaining elememts. What is Sequence?In mathematics, a sequence is an enumerated collection of objects in which repetitions are allowed. Serial arrangement in which things follow in logical order or a recurrent pattern. SubstringSubstring can be derived from the string by deleting anoter substring. The substring is a refinement of the subsequence.","link":"/2019/04/29/Difference-between-Subsequence-and-Substring/"},{"title":"CodeWars 6kyu. Take a Number And Sum Its Digits Raised To The Consecutive Powers And ...","text":"CodeWars 6kyu. Take a Number And Sum Its Digits Raised To The Consecutive Powers And ….¡Eurekal!!Return a number that sum of each digit powered of its own number of digit. The number 89 is the first integer with more than one digit that fulfills the property partially introduced in the title of this kata. What’s the use of saying “Eureka”? Because this sum gives the same number. In effect: 89 = 8^1 + 9^2 The next number in having this property is 135. See this property again: 135 = 1^1 + 3^2 + 5^3 We need a function to collect these numbers, that may receive two integers a, b that defines the range [a, b] (inclusive) and outputs a list of the sorted numbers in the range that fulfills the property described above. Let’s see some cases: sumDigPow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] sumDigPow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] If there are no numbers of this kind in the range [a, b] the function should output an empty list. sumDigPow(90, 100) == [] 해결책 Put the numbers that fulfill the property to eureka[]. Used String type casting to use split and reduce method to each number. javaScript Solution 123456789101112function sumDigPow(a, b) { eureka = []; for(i=a; i &lt;=b; i++){ digits = String(i).split(''); if(i == digits.reduce(function(accumulator, currentValue, currentIndex){ return accumulator + currentValue**(currentIndex+1); }, 0)){ eureka.push(i); } } return eureka;}","link":"/2019/04/26/CodeWars-6kyu-Take-a-Number-And-Sum-Its-Digits-Raised-To-The-Consecutive-Powers-And-¡Eurekals/"},{"title":"First-class Function","text":"First-class Function 프로그래밍 언어 중 함수를 다른 변수와 동일하게 다루는 언어를 함수우선순위(First-class Functions) 가졌다고 표현한다. 함수를 다른 함수의 argument로 사용하고, 함수에서 함수를 return하거나 변수의 값으로 함수를 할당할 수 있다. 변수에 함수를 할당 12345const foo = function() { console.log(\"foobar\");}// 변수를 사용하여 호출foo(); 함수를 인자로 전달 12345678function sayHello() { return \"Hello, \";}function greeting(helloMessage, name) { console.log(helloMessage() + name);}// `sayHello`를 `greeting` 함수에 인자로 전달greeting(sayHello, \"JavaScript!\"); 다른 함수에 인자로 전달된 함수를 Call Back 함수라고 한다. 다른 언어들과 같이 sayHello()를 호출하면 바로 실행되지만, 위와 같이 greeting(satHello, “)의 인자로 전달된 sayHello의 경우 greeting 함수의 helloMessage parameter로 전달된 후에, 필요한 경우 helloMessage()에서 호출된다. 전달된 이후 나중에 호출되기 때문에 CallBack 함수라고 불린다. 함수를 return 값으로 전달 (함수 return) 12345function sayHello() { return function() { console.log(\"Hello!\"); }} 함수가 함수를 반환하는 예시문. JavaScript에서는 함수를 변수처럼 취급하므로 함수를 return할 수 있다. Higher-Order Function : 함수를 반환하는 함수","link":"/2019/04/22/First-class-Function/"},{"title":"LeetCode 26. Remove Duplicates from Sorted Array","text":"LeetCode 26. Remove Duplicates from Sorted Array정렬된 배열에서 중복되는 값 제거 : in-place Algorithm Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1:Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the returned length. Example 2:Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn’t matter what values are set beyond the returned length. 요구조건 배열 nums에서 중복되지 않는 원소의 수를 return한다. 배열 nums는 중복되지 않는 수로 앞부분이 정렬되어야한다. 문제는 위의 설명과 같이 nums라는 number형 array를 입력받아 중복되는 element 대신 다음 element를 그 자리에 오게 하는 것이다. 나는 처음에 중복된 element를 제거한 새로운 배열을 return해 여러 번 오류가 났었다. 이 문제의 핵심은 nums 배열이 referance로 넘어온다는 것이다. 즉, 새로운 배열을 만들지 않고 원본 nums의 값을 바꿔야한다. 솔루션을 도출하기까지 나를 헷갈리게 한 것은 한 element를 제거하고 나면 nums의 index부터 길이가 매번 변화한다는 것이다. 처음에 그 부분을 캐치하지 못해 여러 번 오류가 났다. 해결책 처음에 문제를 완벽하게 이해하지 못해서, nums 배열의 중복을 완전히 제거하는 것인줄로만 알았다. 그래서 array.splice method를 이용해서 중복되는 부분을 제거했다. 첫번째 Solution을 제출한 후 다른 사람들의 풀이를 보고 문제를 다시 제대로 이해했다. javaScript Solution 1: Runtime 92 ms | Memory Usage 37.3 MB 1234567891011121314151617/** * @param {number[]} nums * @return {number} */var removeDuplicates = function(nums) { var prev= nums[0]; for(var i = 1; i &lt; nums.length; i++){ if(nums[i] == prev){ prev = nums[i]; nums.splice(i, 1); i -= 1; } else{ prev = nums[i]; continue; } }}; javaScript Solution 2: Runtime 72 ms | Memory Usage 37.3 MB 123456789101112131415/** * @param {number[]} nums * @return {number} */var removeDuplicates = function(nums) { if(nums.length == 0) return 0; let prev = 0; for(let i = 1; i &lt; nums.length; i++){ if(nums[i] != nums[prev]){ prev++; nums[prev] = nums[i]; } } return prev+1;} 배운 점영어라고 해서 대충 Example만 보고 바로 문제를 풀려고 하는 습관을 고쳐야겠다. 문제를 제대로 해석하고, 알고리즘을 짜는 것이 훨씬 효율적인 것 같다.","link":"/2019/04/15/LeetCode-26-Remove-Duplicates-from-Sorted-Array/"},{"title":"LeetCode 27. Remove Element","text":"LeetCode 27. Remove ElementInput 배열의 요소를 제거하기 : in-place Algorithm Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn’t matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn’t matter what values are set beyond the returned length. 요구조건 배열 nums에서 val의 값을 가진 element를 제거한다. in-place algorithm으로 연산해야 한다. 이번 문제는 LeetCode 26. Remove Duplicates from Sorted Array를 오해해서 풀었을 때와 거의 흡사해서 푸는 데에 시간이 오래 걸리지 않았다. 해결책 혼자 풀었을 때는 for문에서 nums.length를 검사할 때, nums.length가 splice로 인해서 줄어든 길이를 인식하지 못한다고 생각하여 if문의 마지막에 length = nums.length로 재정의를 했다.스터디원들과 대화를 하며 nums를 직접 접근하고 변형하는 것이므로 그럴 필요가 없다는 것을 알았다. 배열 nums의 길이만큼 for문을 돌며 val과 같은 element를 만나면 배열에서 제거한다.i번 째 loop에서 index = i 자리의 원소가 사라져, i+1번째 원소가 앞으로 당겨지므로, splice 연산 뒤에 i에서 1을 빼준다. javaScript Solution : Runtime 60 ms | Memory Usage 34.6 MB 1234567891011121314/** * @param {number[]} nums * @param {number} val * @return {number} */var removeElement = function(nums, val) { for(let i = 0; i &lt; nums.length; i++){ if(val == nums[i]){ nums.splice(i, 1); i =- 1; } } return nums.length;}; 배운 점 array.splice method에 대해서 제대로 알게 되었다. 원소를 제거하는 것 뿐만 아니라 그 자리에 여러 element를 넣을 수도 있는 유용한 method다. 여러 명과 알고리즘에 대해 이야기하면 생각지 못한 풀이가 나오는 것이 재밌다.","link":"/2019/04/16/LeetCode-27-Remove-Element/"},{"title":"5. Data Type","text":"What is Data Type?Data Type is type of values. All of the data in JavaScript have data type. Allocatation of memory space by Data TypeAll of values used in programming language can be stored in memory and referenced. To store values in memory, computer need to know the size of memory space it need. Because size of memory depends on data type. Access memory by Data TypeWhen refer to memory space by identifier, computer need to know the size of memory it need to read once. If variable soup is Number type, computer should access memory by only 8byte. Data Type provides that informations to computer and human. Here’s reasons why Data Type need: To determine the size of memory space that must be free when storing values To determine how much memory space should be read at once when referring to a value To determine how to interpret the binary be read from memory. ValueValue is one of expression that can not be evaluated any more. The expression is statement that makes value. In other words, expression make value by being evaluated. 12// 1 + 2 is an expression. And this expression evaluated and make a value 31 + 2 1 + 2 is an expression. It is made up of value 1, 2 and operator +. The expression is evaluated by the JavaScript engine to produce a new value of 3. New created value 3 cannot be evaluated. If evaluate 3, it is always 3. Creation of ValueValue can created by many expressions. Basic method is using literal notation. LiteralLiteral is a notation for representing a fixed value in source code. More specifically, literals are valued by JavaScript engines. Literal notation creates literal. Literal notation is method that make literal. The literal notation allows the generation of various types of values (number, string, Boolean, null, undefined, object, array, function, regular expression, etc.) available in JavaScript. When JavaScript engines meet codes written in literal notation, they interpret the literal at the time the code is executed (runtime) and generate values. 12345678910111213141516171819202122232425262728293031323334353637383940// Integer literal10// Floting point literal10.2// Binary literal0b011010101// Octal literal0o010101// Hexa literal0xd100ff// String literal'Hello'\"Subin\"// Boolean literaltruefalse// null literalnull// undefined literalundefined// Object literal{ name: 'Park', color: 'yellow' }// Array literal[ 1, 2, 3]// Function literalfunction(){}// Regular expression literal/ab+c/ Relation of Value and Literal1var soup = 100; At the right side, 100 is directly created literal by literal notation. This literal is both literal and value at the same time because it cannot be evaluated any more and can be assigned to variable. Another example, 1var soup = 50 + 50; At the right side, 50 made by literal notation and + operator was used to sum. This expression create a new value. As such, statement that generates value in program called expression. The right side of this code is expression and generates a new value 100. A literal can be a value in itself, but not all values are literal. ExpressionsA value can be generated by various methods. Various methods mean expressions. The expression refers to combination of literal, identifier(variable name, function name), operator and function calls. The expression generate one value as a result of evaluation. In the other words, the expression is a statement that can be evaluated to one value. 1234567891011121314151617// literal notation10'Hello'// identifier expression(Assuming that a declaration already exists)sumperson.namearr[1]// operator expression10 + 20sum = 10sum !== 10// function/method call expression(Assuming that a declaration already exists)square()person.getName() Classification of Data typesAll of the values in JavaScript have a data type. JavaScript provides 7 data types. 7 data types can be classified into primitive types and object(reference) types. Primitive type Number type : Number(Integer and Real number) String type : Strings Boolean type : logical true and false undefined type : The implicitly assigned value that declared but not explicitly assigned null type : The value used to indicate intentionally that there is no value. Symbol type : Seventh type that newly introduced in ES6 Object /reference type Object, funtcions, array etc. For example, Number 1 and String ‘1’ are look similar but completely different values. Size of memory space that needs to be occupied is different, binary digits that are stored in memory is different, and method of reading and interpreting is different. Also the purpose of value is different. Number type values are for arithmetic operation and String type values are for printing out text to screen. As such, developers will create values by distinguishing between types with clear intentions and JavaScript engines will treat values by distinguishing between types. Number TypeIn C and Java, they distinguish integer and real number so there are various number types like int, long, float, double. But JavaScript has only one Number type. As ECMAScript specification, Number type follows double-precision 64-bit floating-point format(numbers between -(253 -1) ~ 253 -1 ). JavaScript treats all of the Numbers as real number, has no integer type. Special number types Infinity : positive infinity -Infinity : negative infinity NaN : no arithmetic operation(not-a-number) JavaScript is case-sensitive so NaN != nan, NAN, naN, Nan. String TypeThe String type is used to refer text data. String is a collection of more than 0 16 bit Unicode characters (UTF-16) that can represent most of the world’s characters. String can be generated by ‘’, “”, . The most general expression is using ‘’. Unlike languages such as C and Java, JavaScript strings are primitive types and are immutable values. Immutable means that once a string is generated, it cannot be changed. Template literalES6 introduced new string expression, called template literal. Template literal seems like general string, it uses backtick (`). In a typical string, the line is not allowed and in order to represent a white space, an escape sequence beginning with a backslash () must be used. Unlike a typical string, ES6 template literal can write strings across multiple lines, and all spaces within the template literal apply as they are. Template literal provides String Interpolation to insert new string. 12345var first = 'Subin';var last = 'Park';// ES6: String Interpolationconsole.log(`My name is ${first} ${last}.`); String Interpolation wraps expression with ${ extension}. The evaluation results of the expression are then forced to type into a string. Boolean TypeThe boolean type values are only true and false. It is used to condition statement as a flow control. undefined TypeThe value of undefined type is unique, a undefined. The implicitly assigned value that declared but not explicitly assigned. null TypeThe value of null type is unique, a null. JavaScript is case-sensitive so null != Null, NULL. In programming language, null is used to represent intentional absence. If the function can not return a valid value, it may explicitly return null. Dynamic TypingStatic type languageStatic / Strong type languages ​​such as C or Java must declare a data type in advance. This is called an explicit type declaration. The following is an example of declaring an integer type variable in C. 123int num;char c; Static type language can not change a type of value and only can assign values that match the type declared in the variable. Representitive static type languages are C, C++, Java, Kotlin, Go, Hashell, Rust, Scala etc. Dynamic type languageJavaScript does not declarethe type of variable when declaration. But only use the keywords such as var, let, const to declare a variable. JavaScript can assign any type of values. 1234567891011121314151617181920212223242526var foo;console.log(typeof foo); // undefinedfoo = 3;console.log(typeof foo); // numberfoo = 'Hello';console.log(typeof foo); // stringfoo = true;console.log(typeof foo); // booleanfoo = null;console.log(typeof foo); // objectfoo = Symbol(); // 심볼console.log(typeof foo); // symbolfoo = {}; // 객체console.log(typeof foo); // objectfoo = []; // 배열console.log(typeof foo); // objectfoo = function () {}; // 함수console.log(typeof foo); // function A static type language determines the type of a variable at the time of variable declaration and can not change the type of a variable. JavaScript can dynamically determine the type of the variable at the time of assigning the value and change the type of the variable at any time. In other words, JavaScript variables are type-determined by assignments rather than declarations. And the type of variable can be changed by reassignment at any time. This feature is called Dynamic Typing, and JavaScript is called a Dynamic / weak type language to distinguish it from Static type languages. Typical dynamic type languages ​​are JavaScript, Python, PHP, Ruby, Lisp, and Perl. Reference Data type &amp; Variable","link":"/2019/04/30/5-Data-Type/"},{"title":"LeetCode 28. Implement strStr()","text":"LeetCode 28. Implement strStr()strStr()을 구현하기 : javaScript, C Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 &gt; if needle is not part of haystack. Example 1: Input: haystack = “hello”, needle = “ll”Output: 2Example 2: Input: haystack = “aaaaa”, needle = “bba”Output: -1 요구조건 string haystack에서 needle이 처음으로 등장하는 index를 반환한다. 존재하지 않으면 -1을 반환한다. 해결책 javaScript의 indexOf() method를 이용해 해결했다. method를 쓰지 않고 C로 해결해보려고 했는데 한 1년 C를 쓰지 않았다고 기능이 기억이 나지 않아 여러 번 찾아봐야 했다. 포인터 개념도 다시 한 번 훑어봐야겠다. javaScript Solution : Runtime 56 ms | Memory Usage 33.8 MB 123456789/** * @param {string} haystack * @param {string} needle * @return {number} */var strStr = function(haystack, needle) { if (needle === \"\") return 0; return haystack.indexOf(needle);}; C Solution : Runtime 1300 ms | Memory Usage 7 MB 1234567891011121314151617181920int strStr(char* haystack, char* needle) { if(needle[0] == '\\0') return 0; int index = -1; int hayLen = strlen(haystack); int neeLen = strlen(needle); for(int i=0; i&lt; hayLen; i++){ if(haystack[i] == needle[0]){ index = i; for(int j=1; j &lt; neeLen ; j++){ if(i+j &gt;= hayLen || haystack[i+j] != needle[j]){ index = -1; break; } } } if(index &gt; -1) return index; } return -1;}","link":"/2019/04/17/LeetCode-28-Implement-strStr/"},{"title":"Local Variable and Global Variable","text":"전역변수 (global variable) / 지역변수 (local variable) 변수의 scope와 lifetime 변수는 선언하는 순간부터 속한 scope 내에서 lifetime을 가진다. 즉, 특정 범위의 코드가 실행되고 있을 때는 메모리에 존재하지만, 실행이 끝나면 이 변수는 메모리에서 사라진다. 변수의 선언 위치 a. Block 외부 : block({})으로 감싸진 main 함수와 여러 함수들의 외부 공간에 변수를 선언할 수 있다. b. Block 내부 : block 내부에 변수를 선언할 수 있다. C는 block의 최상단에 모든 지역변수를 선언해야한다. c. 함수의 parameter : 함수의 매개변수는 그 함수의 block 내에서 선언된 변수와 동일한 효과를 갖는다. 전역변수 (a case) Block 외부에 선언되는 변수. 전역 변수는 프로그램이 시작되는 순간부터 종료되는 순간까지 메모리를 차지하고 있으며 사라지지 않는다. C라면 main() 위, #include &lt;stdio.h&gt;와 함수 원형 밑 그 사이에 선언 전역변수는 어느 block에서도 언제든지 접근이 가능하다 &gt; sycncrinize 고려 지역변수 (b case, c case) 지역변수는 block 내부에서 선언되는 변수이다. { } 안에 선언되어있다면 무조건 지역변수 지역변수는 선언된 block 내부로 scope가 한정되며 그 block의 실행이 끝나면 lifetime 또한 소멸된다. 함수의 parameter로서 선언되는 local variable도 이와 같다. 함수 body 내에서 선언되는 것과 똑같다.","link":"/2019/04/22/Local-Variable-and-Global-Variable/"},{"title":"Hello Hexo","text":"Start Hexo❤ 안녕하세요. Sub2n 입니다. 오늘은 hexo를 이용해 블로그를 생성하는 방법에 대해 알아보겠습니다. 🐸 개구리 🐸","link":"/2019/03/13/Hello hexo/"},{"title":"LeetCode 35. Search Insert Position","text":"LeetCode 35. Search Insert PositionInsert할 Position을 찾는 문제 : C++, Binary Search 사용 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 Example 3: Input: [1,3,5,6], 7 Output: 4 Example 4: Input: [1,3,5,6], 0 Output: 0 요구조건input으로 들어오는 정렬된 배열 nums와 target으로, target이 nums에 있다면 그 index를 return하고 없다면 순서상 target이 있어야할 자리의 index를 return한다. 해결책처음 문제를 접하고 바로 Binary Search를 사용해야겠다고 생각했다. 원래는 값을 찾으면 return하고 없으면 -1을 return하지만, 이 문제에서는 target이 있어야 할 자리를 return하므로 end + 1을 return했다. C++ Solution : Runtime 8 ms | Memory Usage 8.7 MB 1234567891011121314151617181920class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { if(target &lt;= nums[0]) return 0; int start = 0; int end = nums.size() - 1; int mid; while(start &lt;= end){ mid = (start + end) / 2; if(target == nums[mid]) return mid; else if(target &lt; nums[mid]){ end = mid -1; }else { start = mid+1; } } if(start &gt; end) return end+1; return -1; }};","link":"/2019/04/18/LeetCode-35-Search-Insert-Position/"},{"title":"Python 3.7.3 | Jupyter 설치","text":"Window Python 3.7.3 및 Jupyter 설치파이썬을 공부하기 위해 작업환경을 우선 구축하기로 한다. Python 3.7.3 설치 Python 최신 릴리즈인 3.7.3 다운로드 페이지로 이동한다. Download for Windows의 Python 3.7.3 버튼을 누르면 자동으로 설치 실행 파일이 다운로드 된다. 다운받은 python-3.7.3.exe 파일을 관리자 권한으로 실행 후, 설치를 진행한다. PATH를 자동으로 생성하는 것이 좋다! 다운로드가 완료되면 cmd 창을 열어 python --version 명령어로 설치가 제대로 되었는지 확인한다. Jupyter 설치위의 Python 설치 4단계에서, cmd 명령으로 확인을 정상적으로 마쳤다면 추가적인 명령 한 줄로 Jupyter를 설치할 수 있다. cmd 창에 pip install jupyter를 입력한다. 여기까지 하면 Python 사용을 위한 간단한 작업 환경 구성이 완료된다.","link":"/2019/04/18/Python-3-7-3-Jupyter-설치/"},{"title":"LeetCode 5. Longest Palindromic Substring","text":"LeetCode 5. Longest Palindromic Substring가장 긴, 거꾸로 해도 똑같은 Substring을 찾는 문제 Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad” Output: “bab” Note: “aba” is also a valid answer. Example 2: Input: “cbbd” Output: “bb” 요구 조건요구 조건은 간단하다. 한 가지 용어만 정리하고 가면 된다. Palindrome : “aba” “dccd”와 같이 reverse한 결과와 원본이 같은 단어를 말한다. 주어지는 input의 substring 중 가장 긴 palindromic substring을 return하는 문제다. 해결책그러나 Solution은 간단하지 않았다. Palindromic Substring은 길이도 주어지지 않았고, 앞 뒤가 똑같은지 확인하기 위해서 비교해야할 변수가 많았다. 가장 중요한 건 효율성이다. 어떻게 하면 최소한의 비교로 가장 긴 Palindrome을 찾아낼 수 있을 지 오랫동안 고민했다. 이미 확인한 string은 다시 확인하지 않기 위해 Dynamic Programming을 이용하려고 했으나 실패했다. P[i][j] = P[i+1][j-1] and S[i] == S[j] 이 완벽해보이는 알고리즘을 이용해 해답을 찾으려고 했지만 내가 부족한지 자꾸 i+1, j-1이 이전에 계산이 되지 않아 원하는 답이 나오지 않았다. 아래 두 해답은 다른 사람들의 Solution을 참고한 것이다. Python Solution 1Runtime 5496 ms | Memory Usage 13.3 MB 1234567891011121314class Solution: def longestPalindrome(self, s: str) -&gt; str: long = \"\" if len(s) &lt;= 1: return s for i in range(len(s)): for j in range(len(s), i, -1): if len(long) &gt;= j-i: continue elif s[i:j] == s[i:j][::-1]: long = s[i:j] return long 정말 단순히, s의 모든 substring이 palindromic한지 검사하는 알고리즘이다. Python Solution 2Runtime 68 ms | Memory Usage 13.3 MB 12345678910111213class Solution: def longestPalindrome(self, s: str) -&gt; str: if len(s) &lt;= 1: return s i,l=0,0 for j in range(len(s)): if s[j-l: j+1] == s[j-l: j+1][::-1]: i, l = j-l, l+1 # print(s[i: i+l]) elif j-l &gt; 0 and s[j-l-1: j+1] == s[j-l-1: j+1][::-1]: i, l = j-l-1, l+2 # print(s[i: i+l]) return s[i: i+l] 이 Solution은 놀라웠다. 가장 긴 substring의 시작 index를 i에, 길이는 l에 저장한다. j로 s를 순회하면서 s[j-l-1:j+1], 즉 j를 기준으로 l+1만큼의 길이를 가진 (저장된 l의 길이보다 2 더 큰) substring이 palindrome인지 검사한다. 맞으면 i와 l을 update한다. 된다! 그리고 이해도 쉽게 된다. 느낀 점문제를 보는 능력을 기르려면 한참 멀었다는 생각이 들었다. 더 좋은 Solution을 많이 접하고 공부해야겠다.","link":"/2019/04/22/LeetCode-5-Longest-Palindromic-Substring/"},{"title":"Python Class and Access Modifier","text":"Python Class1234567891011121314151617181920212223242526272829303132333435363738class Account: # constructor # 객체를 생성할 때 \"반드시\" 한 번 호출한다. def __init__(self, cus_name, init_balance): # instance member self.name = cus_name self.balance = init_balance # descructor # 객체가 소멸될 때 \"반드시\" 한 번 호출 def __del__(self): pass # instance method(operator) def deposit(self, money): if money &lt; 0: print('0보다 작은 값을 저금할 수 없습니다.') return False self.balance += money print(f'잔고 {self.balance}') return True def withdraw(self, money): if money &gt; self.balance: print('잔고보다 출금하려는 돈이 더 많습니다.') return False self.balance -= money print(f'잔고 {self.balance}') return money def transfer(self, other, money): self.balance -= money # 다른 object의 member에 바로 접근하지 않는다!! (private없어서 접근 할 수는 있음(뭐임?)) # 다른 object의 member는 \"반드시\" 상대 object의 method를 호출해서 접근해야 한다. - Message Passing other.deposit(money) print(f'잔고 {self.balance}') Object : abstraction method (추상화 도구) 관련 있는 변수(member)와 기능(operator, method)를 묶어서 하나의 object로 만든다. Operator를 통해서만 member에 접근할 수 있다. Class와 Instance, object의 차이 클래스(class)란 똑같은 무엇인가를 계속해서 만들어낼 수 있는 설계 도면 같은 것이고(과자 틀), 객체(object)란 클래스에 의해서 만들어진 피조물(과자틀에 의해서 만들어진 과자)을 뜻한다. class에 의해서 만들어진 Object를 instance라고도 한다. 그렇다면 Object와 Instance의 차이는 무엇일까?이렇게 생각해 보자. a = Cookie() 이렇게 만들어진 a는 Object이다. 그리고 a라는 Object는 Cookie의 Instance이다. 즉, Instance라는 말은 특정 Object(a)가 어떤 Class(Cookie)의 객체인지를 관계 위주로 설명할 때 사용된다. 즉, “a는 instance” 보다는 “a는 object”라는 표현이 어울리며, “a는 Cookie의 object” 보다는 “a는 Cookie의 instance”라는 표현이 훨씬 잘 어울린다. Public, Private and Protected | Python Access ModifierC++, Java와 같이 클래식한 object-oriented 언어에서는 public, private, protected와 같은 키워드로 class의 member에 대한 접근을 제어한다. Class의 Private member는 class 외부에서 접근이 불가능하며 class 내부에서만 접근될 수 있다. Class 내의 Public member는 class 외부에서도 접근할 수 있다. 같은 class의 object는 public method를 호출하도록 요구된다. Private instance variable과 public method를 함께 써야지만 데이터 encapsulation의 원칙에 따르는 것이다. Class의 protected member는 오직 해당 class와 그 class를 상속받은 child class만이 접근할 수 있다. 이는 parent class가 child class에게 특정한 리소스를 상속할 수 있게 한다. 그런데 Python은 instance variable과 method에 대해서 접근 제한을 하는 방식이 따로 없다. Python vaiable이나 method의 이름 앞에 한개 또는 2개의 _(underscore)를 붙여서 protected와 private으로 구분하기로 약속한다. Public Attributes12345class Account: def __init__(self, cus_name, init_balance): # instance member self.name = cus_name self.balance = init_balance Protected Attribute12345class Account: def __init__(self, cus_name, init_balance): # instance member self._name = cus_name self._balance = init_balance Private Attribute12345class Account: def __init__(self, cus_name, init_balance): # instance member self.__name = cus_name self.__balance = init_balance 그런데 웃긴 건, underscore로 name mangling한 private variable을 class 외부에서 접근이 가능하다는 것이다. 다음의 방법을 사용하면 된다. 12myAccount = Account('subin', 10000)myAccount._Account__balance 정말 필요하다면 접근할 수 있지만, Python에서는 접근하지 말 것을 권고하고 있다. 참고 자료 점프 투 파이썬 TutorialsTeacher","link":"/2019/04/24/Python-Class-and-Access-Modifier/"},{"title":"Quick Sort","text":"Quick Sort Divide and Conquer Algorithm Use Recursion 정렬해야할 list, 시작점 start와 끝점 end를 넘겨 받는다. left = start, right = end로 정한다. 양방향의 left와 right를 pivot 방향으로 움직이며 pivot 값과 left, right index의 element 값을 비교한다. left의 element 값이 pivot 보다 크고, right의 element 값이 pivot보다 작을 때 둘을 교환하고 각 index를 하나씩 이동한다.(left면 +1, right면 -1) left와 right가 교차되기 전까지 반복하면서 sorting한다. 한 번 교차되면 while문을 빠져나오는데, 이 때 pivot을 기준으로 왼쪽은 pivot보다 작은 값들로, 오른쪽은 pivot보다 큰 값들로만 이루어져있다. Recursion으로 pivot을 포함하지 않고 왼쪽과 오른쪽을 각각 다시 돌려준다. 이 때 base case는 start가 end와 같아지거나 교차하면 return하는 것이다. 코드를 보는 게 더 이해가 쉬울 것 같다. 그림으로 그려보며 진행하는 게 가장 도움이 된다. 12345678910111213141516171819def quickSort(li, start, end): if start &gt;= end: return left = start right = end pivot = li[(left+right)//2] while left &lt;= right: while li[left] &lt; pivot: left += 1 while li[right] &gt; pivot: right -= 1 if left &lt;= right: li[left], li[right] = li[right], li[left] left += 1 right -= 1 quickSort(li, start, right-1) quickSort(li, left, end) 12345678910import randomwhile True: num_data=int(input('데이터 개수(0이면 종료):')) if not num_data: break data=[random.randint(1, 100) for _ in range(num_data)] print(data) quickSort(data, 0, len(data)-1) print(data) [Quick sort에 관련된 TED edu 영상] What’s the fastest way to alphabetize your bookshelf? 문제는 pivot을 어떻게 결정할 것이냐이다. Pivot이 정렬해야할 list의 모든 값들의 평균치일 때는 n/2번을 비교하는 것으로 가장 좋지만, 예를 들어 최솟값이나 최댓값을 기준으로 pivot이 선택될 경우 n번을 계산해야한다. pivot을 정렬된 list의 가운데 값으로 결정하는 것이 Best case지만, 정렬을 하기 위해서 pivot을 사용하는 것이므로 실현될 수 없는 이야기이다. Quick Sort의 Time Complexity는 O(nlogn)으로, average case일 때를 기준으로 한다. Pivot을 random pivot으로 둘 경우 확률적으로 avarage case를 만족한다. li의 start와 end와 mid를 정렬한 결과의 중간 값을 return한다. Random Pivot을 이용하기 위해 코드를 수정했다. 1234567891011121314def getMiddleIndex(li, start, mid, end): \"\"\" list의 맨 처음 값, 끝 값, 중간 값 정렬시 가운데 값의 index 반환 \"\"\" indices = [start, mid, end] if li[indices[0]] &gt; li[indices[1]]: indices[0], indices[1] = indices[1], indices[0] if li[indices[1] &gt; li[indices[2]]]: indices[1], indices[2] = indices[2], indices[1] if li[indices[0]] &gt; li[indices[1]]: indices[0], indices[1] = indices[1], indices[0] return indices[1] 전체 반영한 결과123456789101112131415161718192021222324252627282930313233343536373839404142def getMiddleIndex(li, start, mid, end): \"\"\" list의 맨 처음 값, 끝 값, 중간 값 정렬시 가운데 값의 index 반환 \"\"\" indices = [start, mid, end] if li[indices[0]] &gt; li[indices[1]]: indices[0], indices[1] = indices[1], indices[0] if li[indices[1] &gt; li[indices[2]]]: indices[1], indices[2] = indices[2], indices[1] if li[indices[0]] &gt; li[indices[1]]: indices[0], indices[1] = indices[1], indices[0] return indices[1]def quickSort(li, start, end): if start &gt;= end: return left = start right = end mid = (left+right)//2 #추가된 코드 mid_index = getMiddleIndex(li, start, mid, end) li[mid_index], li[mid] = li[mid], li[mid_index] pivot = li[mid] while left &lt;= right: while li[left] &lt; pivot: left += 1 while li[right] &gt; pivot: right -= 1 if left &lt;= right: li[left], li[right] = li[right], li[left] left += 1 right -= 1 quickSort(li, start, right-1) quickSort(li, left, end)","link":"/2019/04/24/Quick-Sort/"},{"title":"Recursion","text":"Recursion (재귀) 함수 호출 도중에 자기 자신을 다시 호출하는 것 Base case가 필수 (기초, 종료, 탈출 조건) Base case가 없으면 무한으로 자기 자신을 호출해서 stack overflow가 된다. 재귀함수를 만드는 방법 패턴을 찾는다. 즉, 점화식(Induction)을 만든다. Base case를 만든다. 예제1: Factorial ! Basis 0! = 1! = 1 Induction Step n! = (n-1) (n-2) (n-3) … 3 2 * 1 12345def factorial(n): if n &lt;= 1: return 1 else: return n*factorial(n-1) 예제2: Fibonacci Basis fib(0) = fib(1) = 1 Induction Step fib(n) = fib(n-1) + fib(n-2) 12345def fib(n): if n &lt;= 1: return 1 else: return fib(n-1) + fib(n-2) Fibonacci Dynamic Programming Memorization (Top Down) 123456789f = [-1 for _ in range(100)]def fib_memorize(n): if f[n] &gt; -1: return f[n] elif n &lt;= 1: f[n] = 1 else: f[n] = fib_memorize(n-1) + fib_memorize(n-2) return f[n] Bottom Up 123456f2 = [-1 for _ in range(100)]def fib_bottup(n): f2[0] = f[1] = 1 for i in range(2, n+1): f[n] = f[n-1] + f[n-2] return f[n] 예제3: Hanoi TowerPlay Tower of Hanoi 12345678def hanoi(n, _from, _by, _to): # base case if n==1: print(f'{n}번째 쟁반을 {_from}에서 {_to}로 옮긴다.') return hanoi(n-1, _from, _to, _by) print(f'{n}번째 쟁반을 {_from}에서 {_to}로 옮긴다.') hanoi(n-1, _by, _from, _to)","link":"/2019/04/23/Recursion/"},{"title":"Python Data Type and Data Structure | Jupyter 사용방법","text":"Jupyter 사용법 | Python Data TypeJupyter notebook window 사용을 기준으로 Window PowerShell을 실행한다. pwd로 현재 폴더를, ls로 현재 폴더에 존재하는 file들을 확인 후 mkdir 폴더이름 command로 python file을 만들고 실습할 폴더 하나를 생성한다. 나는 python-basic이라는 폴더를 만들고 cd python-basic 명령으로 해당 폴더로 이동했다. 만든 폴더로 이동한 후 cmd에 jupyter notebook command를 입력한다. 조금 기다리다보면 (10초 이상 소요) 브라우저 새 창으로 jupyter notebook이 실행된다. 그림과 같이 우측의 new button을 눌러 새로운 python file을 생성한다. 그럼 새로운 탭에 생성된 file이 보여진다. 제목을 수정하고 실습을 시작하면 된다! method 이름을 치고 Shift + Tab을 하면 function의 signature를 확인할 수 있다. object (variable)을 입력한 상태에서 Tab 키를 누르면 사용 가능한 method들을 확인할 수 있다. instruction을 작성한 후 Shift + Enter를 누르면 해당 line이 실행된다. 어떤 line에 focus가 있는 상태에서, ESC + m을 누르고 Enter를 치면 markdown으로 작성할 수 있다. Python Data Type Number Type : Int, Float javaScript와 다르게 C처럼 int, float등 정수형과 실수형을 구분한다. String character와 string의 구분 없이 str type을 가진다. Python Data StructureMutable and Immutable ObjectMutable object (변경 가능 객체) list dictionary set Immutable object (변경 불가능 객체) int, float 등 숫자는 immutable : 값을 덮어쓰는 것이 아니라 새로운 memory 공간에 할당하고 그 값을 가리킨다. 이름 객체가 값 객체를 가리키는 것을 binding이라고 한다. string Tuple Dynamic Typing Python은 Dynamic typing 언어로, C / C++ 같은 정적 타이핑 언어처럼 자료형을 미리 선언하지 않아도 알아서 동적으로 자료형을 할당할 수 있다. Data Assignment C : char a = 10; A라는 이름을 가진 공간에 10의 값이 저장된다. 20으로 변경시 같은 메모리 공간의 값을 변경한다. Python : a = 10; 10이라는 값을 가진 객체가 생기고, a라는 이름을 가진 객체가 10을 가리키게 된다. 만약 a=20으로 재할당할 경우 20이라는 값을 가진 객체가 생기고 a는 20을 가리켜, 10은 자신을 가리키는 객체가 없으므로 제거된다. 20으로 변경시 10의 메모리공간을 건드리지 않고 새로운 공간을 만든다. Integer, float등 number type은 immutable 객체 Python 성질 모든 것이 객체: integer가 그냥 4 byte가 아니라 객체로 필요한 것들이 붙어있어 크기를 더 차지함 Overflow: overflow 되는 대신 4 byte를 8 byte로 늘림. 대신 경계검사 하므로 속도 저하 Language Abstraction Hardware 의존적인 Assembly 언어에서 벗어나 하드웨어 독립적인 C언어로 Coding하고 각 하드웨어 별 어셈블러로 해석하게끔 함 ▶ 하드웨어 추상화 (각 어셈블러가 어떻게 동작하는지 몰라도 C로 코딩하면 됨) Assembly : low level language C / C++ : hardware abstraction 됐으나 memory abstraction X ▶ 메모리를 직접 할당, 해제 Java / C# : 언어 자체에서 메모리 할당, 해제 ▶ garbage collection. Memory abstraction O 그러나 Data Type은 선언해줘야함 Python / javaScript : Data type abstraction. Interpreter Language Level은 abstraction level을 말하는 것이지 급을 나누는 것이 아님 성능은 C/C++ 생산성은 Python","link":"/2019/04/18/Python-Data-Type-and-Data-Structure-Jupyter-사용방법/"},{"title":"Responsive Web (2)","text":"Responsive Web &lt;picture&gt; element Can I Use &lt;picture&gt;? CanIUse.com &lt;picture&gt; 문법 &lt;img&gt;를 fallback으로 첨부해야한다. &lt;picture&gt; 는 &lt;img&gt; tag가 없으면 인식되지 않는다! 1img {display: block; margin: 0 auto;} 12345&lt;picture&gt; &lt;source media=\"(min-width: 650px)\" srcset=\"images/kitten-stretching.png\"&gt; &lt;source media=\"(min-width: 465px)\" srcset=\"images/kitten-sitting.png\"&gt; &lt;img src=\"images/kitten-curled.png\" alt=\"a cute kitten\"&gt;&lt;/picture&gt; Pixel density descriptor 1x, 1.5x, 2x 그리고 3x와 같은 픽셀 밀도 서술자(Pixel density descriptor)들을 사용하여 고해상도 디스플레이 지원을 추가합니다. 새로 추가된 srcset 속성은 &lt;img&gt;와 &lt;source&gt; 엘리먼트 모두에 적용됩니다. letina부터는 2x 나오고 Android는 1.5x 등 정수가 아니고 소숫점으로 증가 Image 반응형으로 만들기 wrapper를 만들고, 그 안에 &lt;img&gt; max-width: 100%; height: auto; 12345678910111213141516 &lt;style&gt; .rwd-wrapper{ width: 30%; border: 5px solid blueviolet; } .rwd-wrapper img{ max-width: 100%; height: auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"rwd-wrapper\"&gt; &lt;img src=\"images/image-src.png\" alt=\"\"&gt; &lt;/div&gt;&lt;/body&gt; srcset 속성을 사용해서 Pixel density 설정 1234567&lt;div class=\"rwd-wrapper\"&gt;&lt;img src=\"images/image-src.png\" alt=\"\" srcset=\"images/image-1x.png 1x, images/image-2x.png 2x, images/image-3x.png 3x, images/image-4x.png 4x\"&gt;&lt;/div&gt; Viewport 별로 Art Direction 설정하기 &lt;picture&gt;의 &lt;source media=&quot;&quot;&gt;로 조건 줌 123456&lt;picture&gt; &lt;source media=\"(max-width: 650px)\" srcset=\"images/small.jpg\"&gt; &lt;source media=\"(min-width: 651px) and (max-width: 999px)\" srcset=\"images/media.jpg\"&gt; &lt;source media=\"(min-width: 1000px)\" srcset=\"images/large.jpg\"&gt; &lt;img class=\"rwd-img\" src=\"images/normal.jpg\" alt=\"\"&gt;&lt;/picture&gt; Background image를 반응형으로 만들기 image 원본 size를 알아내야한다. &gt; 가로, 세로 비율을 계산해야함 height를 0으로 하고, padding을 세로로 원본 image의 비율에 맞게 준다. 12345678.rwd-bg{ width: 100%; height: 0 !important; padding-top: calc(3280 / 4928 * 100%); background: url(\"images/light.jpg\") no-repeat; background-size: 100% 100%;} width 크기를 변경할 때는 새로운 wrapper를 만들어 그 wrapper의 width를 줄인다. 12345678910.wrapper{ width: 50%;}.rwd-bg{ width: 100%; height: 0 !important; padding-top: calc(3280 / 4928 * 100%); background: url(\"images/light.jpg\") no-repeat; background-size: 100% 100%;} 123&lt;div class=\"wrapper\"&gt; &lt;div class=\"rwd-bg\"&gt;&lt;/div&gt;&lt;/div&gt; .rwd-bg는 parent인 wrapper의 width 100%만큼 차지하므로 wrapper의 크기가 줄어들면 같이 줄어든다. Background-size: cover, contain CSS Trick Background-size 참고 사이트 cover : 이미지가 일부 잘리더라도 화면을 꽉 채우게 가장 작은 축을 기준으로 cover함 contain : 가로든, 세로든 가장 긴 축을 기준으로 화면에 잘리지 않게 하는 기법 Media query로 해상도 별 배경 image 다르게 하기 dpi : dot per inch - 1inch 당 들어가는 pixel 수 CSS는 1inch 당 96px이니까 192dpi는 2x임 12345@media all and (min-resolution: 192dpi){ .rwd-bg{ background-image: url(\"images/unsplash.jpg\"); }}","link":"/2019/04/16/Responsive Web (2)/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/13/hello-world/"},{"title":"Responsive Web (1)","text":"반응형 웹 | Responsive Web Design 웹 환경의 변화 : Mobile Device의 등장 초기 모바일 환경을 위해 mobile 화면을 별도 구성 &gt; 비용과 유지보수 측면에서 risk 크다. One Source Multi Use : 반응형 웹의 필요성 대두 Contents는 물처럼 어느 그릇에나 담길 수 있어야한다. Contents의 본질을 가지고 Markup 후 CSS로 디자인만 달리 할 수 있어야한다. Flexible vs Adaptive RWD(반응형 웹 디자인) : flexible(latout이 고무줄처럼 유연하게 늘었다 줄었다 하는 것), adaptive(viewport에 따라서 layout이 각각 고정되는 것) &gt; 둘 다Device viewport에 반응하는 design AWD(적응형 웹 디자인) Flexible : 모든 환경에서 유연하게 움직임 Adaptive : Web viewport에서는 고정형, tablet이나 mobile에서는 flexible design 채택 DeskTop First vs Mobile First Mobile First 권장 Desktop CSS 먼저 불러온 후 Mobile로 재적용하면 mobile 환경에서 data 많이 듦 &gt; 성능문제 Flexible Layout Target / Context = Result ( 900px / 960px = 0.9375 * 100% = 93.75%!) Target이 context 안에서 차지하는 영역 고정적인 pixel 단위 사용 최대한 지양 %, viewport, em 등 유연한 단위 사용을 지향 Media Queries123456@charset \"utf-8\"/* All Device *//* Mobile Device */@media all and (min-width: 768px){ /* 사용자 해상도가 768px 이상일 때 실행됨 */} all : 어떤 device든 들어올 수 있다는 뜻 (printer 용 CSS 따로 정의할 수 있음) 코드 중복, 복잡도 증가 &gt; CSS가 복잡해짐! Sass (CSS 전처리기) &gt; build하면 CSS code로 떨어짐 Sass Scss Responsive Image1234img{ max-width: 100%; height: auto;} max-width: 100% &gt; 부모 크기를 기준으로 100%, 원본크기 이상은 늘어나지 않게 함 height: auto &gt; 원본 사이즈 비율을 기준으로 auto (width가 반 줄어들면 얘도 반 줄어들음) • 용량으로 인한 성능, 속도 고려 필요 • Mobile Responsive Web test site: Troy - Responsive web tester • 현재 기기의 Pixel Ratio 알 수 있는 사이트: myDevice.io • 다양한 Image Format 대응 SVG : Vector 형식 이미지 WebP : 구글 제안 • 해결 &lt;img&gt;의 srcset, sizes 속성 &lt;picture&gt; 해상도 따라 조절하는 신규 요소 : &lt;picture&gt; 모를 때를 대비한 fallback image 있어야함 반응형 이미지123456789.rwd-container{ width: 50%; box-sizing: border-box; border: 10px solid #000;}.rwd-container img, .rwd-container video{ width: 100%; height: auto;} &lt;img&gt;가 parent container의 width가 줄어들 때마다 같이 줄어든다. &lt;video&gt;도 가능. 그러나 모두 크기 조절을 위해 wrapping해야한다. &lt;iframe&gt;을 반응형으로 만들기 &lt;iframe&gt; 삽입 123&lt;div class=\"rwd-iframe\"&gt; &lt;iframe src=\"https://www.youtube.com/embed/2S24-y0Ij3Y?controls=0\" allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt; 12345678.rwd-iframe{ border: 10px solid #00f; width: 80%;}.rwd-iframe iframe{ width: 100%; height: auto;} &lt;img&gt;나 &lt;video&gt;처럼 하면 안 먹음 &lt;iframe&gt;은 wrapping &lt;div&gt; 2개 필요함 비율별 module화 123456789101112.rwd-iframe{ position: relative; padding-top: calc(9 / 16 * 100%); background: pink; width: 100%;}.rwd-3-4{ padding-top: calc(3 / 4 * 100%);}.rwd-9-16{ padding-top: calc(9 / 16 * 100%);} 12345678910&lt;div class=\"rwd-container\"&gt; &lt;div class=\"rwd-iframe rwd-9-16\"&gt; &lt;iframe src=\"https://www.youtube.com/embed/2S24-y0Ij3Y?controls=0\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"rwd-container\"&gt; &lt;div class=\"rwd-iframe rwd-3-4\"&gt; &lt;iframe src=\"https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d2974.021471174445!2d127.05441626516713!3d37.54323347980236!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x357ca49534790c57%3A0xc115101cbaecb40e!2z7JWE7YGs67C466as7ISc67mE7Iqk!5e1!3m2!1sko!2skr!4v1555310320240!5m2!1sko!2skr\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/div&gt; GRIDContainer에 display: grid 적용 123.container{ display: grid;} Grid-template 12345.container{ display: grid; grid-template-columns: 50% 50%; grid-template-rows: 50% 50%;} Grid는 FireFox에서 개발자도구로 보는 것이 가장 편하다! Grid fraction 123456.container{ background: yellow; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 100px 100px;} Grid 배치 1234567.items4{ background: lime; grid-column-start: 2; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;} Start나 end 중 하나를 지정해주지 않으면 자동으로 한 칸만큼을 차지한다. 단축표기법 123456.items4{ background: lime; /* start / end */ grid-column: 2 / 3; grid-row: 1 / 2;} 여러 track 차지하기 12345.items2{ background: orange; grid-column: 1 / 4; grid-row: 2 / 3;} Grid-area 12345.items2{ background: orange; /* row-start / column-start / row-end / column-end */ grid-area: 2 / 1 / 3 / 4;} Grid template areas Grid item에 name 주고 container에서 grid-template-areas로 위치 잡기 Grid 속성 요약 12345678.container{ background: yellow; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 100px 100px; grid-template-areas: \"item2 . item1\" \"item4 item4 item3\"} Grid IE 환경 코드로 autoprefix: Auto Prefixer 🌟 Grid calculator: Grid Calculator 🌟 : column 크기 65px, gutter 20px, page width와 column width 소수점 안 나오게 조정 Grid column, gutter(gap) 설정123456.container{ background: yellow; display: grid; grid-template-columns: repeat(12, 65px); grid-column-gap: 20px; } : repeat(반복 횟수, 크기) method 사용 Grid area 잡기 : DeskTop Version 1234567891011121314151617181920212223242526272829303132333435363738394041.container{ max-width: 1000px; margin: 0 auto; background: silver; display: grid; grid-template-columns: repeat(12, 65px); /* grid-template-rows: ; */ grid-column-gap: 20px; }.header{ background: pink; grid-area: 1 / 1 / 2 / 13;}.navigation{ background: skyblue; grid-area: 2 / 1 / 3 / 13;}.book{ background: lime; grid-area: 3 / 1 / 4 / 5;}.news{ background: orange; grid-area: 3 / 5 / 4 / 13;}.board{ background: blanchedalmond; grid-area: 4 / 1 / 5 / 5;}.favorite{ background: gold; grid-area: 4 / 10 / 5 / 13;}.twitter{ background: brown; grid-area: 4 / 5 / 5 / 10;}.footer{ background: teal; grid-area: 5 / 1 / 6 / 13;} Grid area 잡기 : Mobile Device 12345678/* Mobile Device */@media all and (max-width: 999px){ .container{ display: grid; grid-template-columns: repeat(4, 1fr); padding: 0 20px; }} 알파, 오메가 margin 따로 없으니까 좌우 padding으로 줌 Margin 빼고 나머지 부분을 4등분하려고 fr 단위 사용 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Mobile Device */@media all and (max-width: 999px){ .container{ display: grid; grid-template-columns: repeat(4, 1fr); grid-column-gap: 20px; padding: 0 20px; grid-template-areas: \"header header header header\" \"nav nav nav nav\" \"book book news news\" \"board board favorite favorite\" \"twitter twitter twitter twitter\" \"footer footer footer footer\" } .header{ background: yellow; grid-area: header; } .navigation{ background: pink; grid-area: nav; } .book{ background: skyblue; grid-area: book; } .news{ background: lime; grid-area: news; } .board{ background: purple; grid-area: board; } .favorite{ background: orange; grid-area: favorite; } .twitter{ background: aqua; grid-area: twitter; } .footer{ background: hotpink; grid-area: footer; }}","link":"/2019/04/16/Responsive Web (1)/"}],"tags":[{"name":"OOP","slug":"OOP","link":"/tags/OOP/"},{"name":"ADT","slug":"ADT","link":"/tags/ADT/"},{"name":"Encapsulation","slug":"Encapsulation","link":"/tags/Encapsulation/"},{"name":"Abstraction","slug":"Abstraction","link":"/tags/Abstraction/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"Computational Thinking","slug":"Computational-Thinking","link":"/tags/Computational-Thinking/"},{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"HTML, CSS","slug":"HTML-CSS","link":"/tags/HTML-CSS/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Web Browser","slug":"Web-Browser","link":"/tags/Web-Browser/"},{"name":"ECMA","slug":"ECMA","link":"/tags/ECMA/"},{"name":"Polymorphisim","slug":"Polymorphisim","link":"/tags/Polymorphisim/"},{"name":"Inheritance","slug":"Inheritance","link":"/tags/Inheritance/"},{"name":"Variable","slug":"Variable","link":"/tags/Variable/"},{"name":"Hoisting","slug":"Hoisting","link":"/tags/Hoisting/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Call by Value","slug":"Call-by-Value","link":"/tags/Call-by-Value/"},{"name":"Call by Reference","slug":"Call-by-Reference","link":"/tags/Call-by-Reference/"},{"name":"Call by Object Reference","slug":"Call-by-Object-Reference","link":"/tags/Call-by-Object-Reference/"},{"name":"Expression","slug":"Expression","link":"/tags/Expression/"},{"name":"Statement","slug":"Statement","link":"/tags/Statement/"},{"name":"Operater","slug":"Operater","link":"/tags/Operater/"},{"name":"Substring","slug":"Substring","link":"/tags/Substring/"},{"name":"Subsequence","slug":"Subsequence","link":"/tags/Subsequence/"},{"name":"Fisrt-class Function","slug":"Fisrt-class-Function","link":"/tags/Fisrt-class-Function/"},{"name":"javaScript","slug":"javaScript","link":"/tags/javaScript/"},{"name":"Data Type","slug":"Data-Type","link":"/tags/Data-Type/"},{"name":"global variable","slug":"global-variable","link":"/tags/global-variable/"},{"name":"local variavble","slug":"local-variavble","link":"/tags/local-variavble/"},{"name":"Class","slug":"Class","link":"/tags/Class/"},{"name":"Access Modifier","slug":"Access-Modifier","link":"/tags/Access-Modifier/"},{"name":"Quick sort","slug":"Quick-sort","link":"/tags/Quick-sort/"},{"name":"Recursion","slug":"Recursion","link":"/tags/Recursion/"}],"categories":[{"name":"Computer Engineering","slug":"Computer-Engineering","link":"/categories/Computer-Engineering/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"Data Structure","slug":"Computer-Engineering/Data-Structure","link":"/categories/Computer-Engineering/Data-Structure/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"CodeWars","slug":"Algorithm/CodeWars","link":"/categories/Algorithm/CodeWars/"},{"name":"Basic","slug":"Computer-Engineering/Basic","link":"/categories/Computer-Engineering/Basic/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","link":"/categories/Algorithm/LeetCode/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Algorithm","slug":"Computer-Engineering/Algorithm","link":"/categories/Computer-Engineering/Algorithm/"},{"name":"HTML/CSS","slug":"HTML-CSS","link":"/categories/HTML-CSS/"}]}