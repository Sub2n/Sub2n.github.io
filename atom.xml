<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>수빈 개발블로그</title>
  
  <subtitle>Sub2n Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sub2n.github.io/"/>
  <updated>2019-06-25T05:12:37.938Z</updated>
  <id>https://sub2n.github.io/</id>
  
  <author>
    <name>Subin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Angular RxJS</title>
    <link href="https://sub2n.github.io/2019/06/25/Angular-RxJS/"/>
    <id>https://sub2n.github.io/2019/06/25/Angular-RxJS/</id>
    <published>2019-06-25T04:12:23.000Z</published>
    <updated>2019-06-25T05:12:37.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h2><blockquote><p><strong>Reactive Programming is programming with asynchronous data streams.</strong> <strong>You can listen to that stream and react accordingly.</strong></p></blockquote><p>Reactive Programming은 비동기적 데이터 스트림을 처리하는 프로그램이다. Data stream이란 연속적인 데이터의 흐름을 말한다. Reactive Programming은 모든 것을 stream으로 본다. 이벤트, AJAX 요청 등 모든 data stream을 시간 순서에 의해 전달되는 stream으로 처리한다.</p><a id="more"></a><h2 id="Observable-amp-Observer"><a href="#Observable-amp-Observer" class="headerlink" title="Observable &amp; Observer"></a>Observable &amp; Observer</h2><blockquote><p><strong>An observer subscribes to an Observable. An Observable emits items or sends notifications to its observers by calling the observers’ methods.</strong></p></blockquote><p>Data producer와 Data consumer 사이에 data stream을 전송하는 방법에는 두가지가 있다.</p><ol><li>Pull-scenario: Data consumer가 producer에게 data를 연속적으로 요청해서 획득한다. 이는 애플리케이션이 외부 환경에서 데이터를 끌어오는 방식이다.</li><li>Push-scenario: Data producer가 일정 시간 단위로 계속해서 data를 내보내면(emit) Data consumer가 producer를 관찰하고 있다가 data를 획득한다. 이는 외부 환경에서 애플리케이션으로 데이터를 밀어넣는 방식이다.</li></ol><p><strong>Observable</strong>: 외부 환경에서 애플리케이션 내부로 data stream을 생성하고 emit하는 객체</p><p><strong>Observer</strong>: Observable이 emit한 Notification(Observable이 emit할 수 있는 push 기반 event 값)을 획득해서 사용하는 객체</p><p>즉 Observer는 Data consumer이고 Observable은 Data producer이다. <strong>Observer는 Observable을 구독(subscribe)한다.</strong></p><p>Observable은 ES7에 제안되어있는 비동기 데이터 처리를 위한 표준으로, Reactive Programming은 Observer pattern을 더 심화한 패턴이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Reactive-Programming&quot;&gt;&lt;a href=&quot;#Reactive-Programming&quot; class=&quot;headerlink&quot; title=&quot;Reactive Programming&quot;&gt;&lt;/a&gt;Reactive Programming&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reactive Programming is programming with asynchronous data streams.&lt;/strong&gt; &lt;strong&gt;You can listen to that stream and react accordingly.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Reactive Programming은 비동기적 데이터 스트림을 처리하는 프로그램이다. Data stream이란 연속적인 데이터의 흐름을 말한다. Reactive Programming은 모든 것을 stream으로 본다. 이벤트, AJAX 요청 등 모든 data stream을 시간 순서에 의해 전달되는 stream으로 처리한다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Reactive Programming" scheme="https://sub2n.github.io/tags/Reactive-Programming/"/>
    
      <category term="Observable" scheme="https://sub2n.github.io/tags/Observable/"/>
    
  </entry>
  
  <entry>
    <title>Angular Service &amp; Dependency Injection</title>
    <link href="https://sub2n.github.io/2019/06/25/Angular-Service-Dependency-Injection/"/>
    <id>https://sub2n.github.io/2019/06/25/Angular-Service-Dependency-Injection/</id>
    <published>2019-06-25T04:12:04.000Z</published>
    <updated>2019-06-25T06:17:25.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Component는 View를 구성하고 관리하는 역할을 해야한다. 그러나 View를 구성하다보면 필요한 데이터를 가져오기 위해서 서버와 통신을 하는 등의 부가 기능이 필요하게 된다. 이런 기능을 Component에서 하지 않고 Service로 분리한다.</p><p>Component의 관심사와 Application 전역의 관심사를 분리하는 것이다. 이렇게 기능을 분리하면 Application의 복잡도가 낮아지고 서비스를 재사용할 수 있다. 또한 의존도가 낮아져 유지보수성이 좋아진다.</p><a id="more"></a><h2 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h2><p>Service는 Dependency Injection이 가능한 class이다. @Injectable 데코레이터로 정의한다.</p><p>Dependency Injection이란 말 그대로 의존성(dependency)을 주입(inject)한다는 것이다.</p><p>어떤 Component에서 Service의 method를 사용하는 경우 둘은 <strong>의존 관계(Dependency relationship)</strong>에 있다고 한다. Component 내부에서 Service class의 instance를 생성하는 경우 둘은 <strong>강한 결합(Tight Coupling)</strong>을 하고 있는 것이다. 반면 Component에서 직접 Service를 생성하는 것이 아니라 constructor의 parameter로 선언하여 Angular가 생성한 Service instance를 주입받는 것은 <strong>느슨한 결합(Loose Coupling)</strong>이다.</p><p> Tight Coupling은 많은 문제를 일으킨다. 하나의 Service의 생성 방법 등에 변동이 있을 경우 해당 Service와 의존 관계에 있는 모든 Component가 영향을 받는다. </p><p>재사용과 유지보수가 효율적인 프로그램을 만들기 위해서는 객체 사이의 <strong>의존 관계를 최소화</strong>해야 한다. 필요에 의해 의존 관계가 있을 경우 Tight Coupling은 지양해야 한다.</p><p>Dependency Injection은 Design pattern 중 하나로, tight coupling에서 loose coupling으로 전환하는 방법이다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> A &#123;</span><br><span class="line">  <span class="hljs-comment">// dependency의 instance를 직접 생성하지 않고 외부 환경에 요구</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> dependency: B</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo() &#123; <span class="hljs-keyword">this</span>.dependency.bar(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> B &#123;</span><br><span class="line">  bar() &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar'</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A class처럼 constructor에서 instance를 parameter로 받는 경우, A class에서는 해당 instance의 생성 방법을 알 필요가 없다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// greeting.service.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="hljs-string">'root'</span> <span class="hljs-comment">/* @Injectable 프로바이더 */</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GreetingService &#123;</span><br><span class="line">  sayHi() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'Hi!'</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Angular에서 Dependency Injection을 받기 위해서는 @Injectable 데코레이터에 meta data로 <code>providedIn: &#39;root&#39;</code>를 설정해야 한다. 해당 선언이 된 Service는 전역에서 Injectable하다.</p><p>또는 해당 Service를 주입받을 Component에서 @Compinent 데코레이터에 meta data로 <code>providers: [GreetingService]</code>를 설정해주면 된다. 이 Component를 포함한 Child component 들에서만 Injectable하다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Service&quot;&gt;&lt;a href=&quot;#Service&quot; class=&quot;headerlink&quot; title=&quot;Service&quot;&gt;&lt;/a&gt;Service&lt;/h2&gt;&lt;p&gt;Component는 View를 구성하고 관리하는 역할을 해야한다. 그러나 View를 구성하다보면 필요한 데이터를 가져오기 위해서 서버와 통신을 하는 등의 부가 기능이 필요하게 된다. 이런 기능을 Component에서 하지 않고 Service로 분리한다.&lt;/p&gt;
&lt;p&gt;Component의 관심사와 Application 전역의 관심사를 분리하는 것이다. 이렇게 기능을 분리하면 Application의 복잡도가 낮아지고 서비스를 재사용할 수 있다. 또한 의존도가 낮아져 유지보수성이 좋아진다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
      <category term="Service" scheme="https://sub2n.github.io/tags/Service/"/>
    
      <category term="Dependency Injection" scheme="https://sub2n.github.io/tags/Dependency-Injection/"/>
    
  </entry>
  
  <entry>
    <title>190624-TIL</title>
    <link href="https://sub2n.github.io/2019/06/25/190624-TIL/"/>
    <id>https://sub2n.github.io/2019/06/25/190624-TIL/</id>
    <published>2019-06-25T04:06:03.000Z</published>
    <updated>2019-06-25T04:07:28.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>ToastUI를 JavaScript와 Angular로 구현했다.</li><li>window.pageYOffset은 wiondow.scrollY보다 cross browsing에 적합(IE 9 지원)하므로 pageYOffset을 사용하는 게 좋다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ToastUI를 Jav
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Angular Directive</title>
    <link href="https://sub2n.github.io/2019/06/24/Angular-Directive/"/>
    <id>https://sub2n.github.io/2019/06/24/Angular-Directive/</id>
    <published>2019-06-24T06:28:00.000Z</published>
    <updated>2019-06-25T04:13:52.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h2><p>Directive는 DOM의 모양이나 동작 등을 관리하기 위한 명령이다. HTML Element 또는 Attribute 형태로 사용한다.</p><p>Directive를 사용하는 HTML Element를 Directive 내에서 Host element라고 부르며, Directive 내부에서 host element의 event를 처리하거나 style 등을 변경할 수 있다.</p><a id="more"></a><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'[textBlue]'</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> TextBlueDirective &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> el: ElementRef, <span class="hljs-keyword">public</span> renderer: Renderer2</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseenter'</span>) onMouse() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setColor(<span class="hljs-string">'blue'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseleave'</span>) offMouse() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setColor(<span class="hljs-literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setColor(color: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.renderer.setStyle(<span class="hljs-keyword">this</span>.el.nativeElement, <span class="hljs-string">'color'</span>, color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Directive class의 constructor에서 주입된 parameter는 class의 class field가 되어 class 전역에서 사용할 수 있다. 이를 constructor에 ElementRef instance가 Dependency Intect(의존성 주입)되었다고 한다.</p><ul><li><p>@Directive : meta data 객체에 Directive에 필요한 정보(selector등)를 입력한다.</p><table><thead><tr><th align="left">selector property</th><th align="left">설명</th></tr></thead><tbody><tr><td align="left">selector: ‘foo’</td><td align="left">foo element에 Directive가 적용된다.</td></tr><tr><td align="left">selector: ‘.foo’</td><td align="left">.foo class가 선언된 element에 Directive가 적용된다.</td></tr><tr><td align="left">selector: [foo]</td><td align="left">foo attribute가 선언된 element에 Directive가 적용된다.</td></tr><tr><td align="left">selector: [foo=bar]</td><td align="left">foo attribute의 값이 bar로 선언된 element에 Directive가 적용된다.</td></tr><tr><td align="left">selector: :not(foo)</td><td align="left">foo element를 제외한 모든 element에 Directive가 적용된다.</td></tr><tr><td align="left">selector: ‘foo, bar’</td><td align="left">foo 또는 bar element에 Directive가 적용된다.</td></tr></tbody></table><p>Directive의 selector는 attribute로 이용하는 것이 일반적이다. Component는 Directive를 상속받은 것으로 selector 규칙이 동일하게 적용된다.</p></li><li><p>ElementRef: host element를 감싼 wrapper object</p></li><li><p>el.nativeElement: host element</p></li><li><p>Renderer2: Angular에서는 el.nativeElement의 style 프로퍼티를 직접 변경하는 것이 아니라 Renderer2를 이용하는 것이 권장된다.</p></li><li><p>@HostListener : host element에서 발생한 event에 대한 event listener를 정의할 때 사용하는 데코레이터.</p></li></ul><h3 id="Directive로-data-보내기-property-binding"><a href="#Directive로-data-보내기-property-binding" class="headerlink" title="Directive로 data 보내기 | property binding"></a>Directive로 data 보내기 | property binding</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// app.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-root'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;!--The content below is only a placeholder and can be replaced.--&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;p [color]="color" textColor&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: []</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;</span><br><span class="line">  color = <span class="hljs-string">'red'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// text-color.directive.ts</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'[textColor]'</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> TextColorDirective &#123;</span><br><span class="line">  <span class="hljs-meta">@Input</span>() color: <span class="hljs-built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> el: ElementRef, <span class="hljs-keyword">public</span> renderer: Renderer2</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseenter'</span>) onMouse() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setColor(<span class="hljs-keyword">this</span>.color);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseleave'</span>) offMouse() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setColor(<span class="hljs-literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setColor(color: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.renderer.setStyle(<span class="hljs-keyword">this</span>.el.nativeElement, <span class="hljs-string">'color'</span>, color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Directive&quot;&gt;&lt;a href=&quot;#Directive&quot; class=&quot;headerlink&quot; title=&quot;Directive&quot;&gt;&lt;/a&gt;Directive&lt;/h2&gt;&lt;p&gt;Directive는 DOM의 모양이나 동작 등을 관리하기 위한 명령이다. HTML Element 또는 Attribute 형태로 사용한다.&lt;/p&gt;
&lt;p&gt;Directive를 사용하는 HTML Element를 Directive 내에서 Host element라고 부르며, Directive 내부에서 host element의 event를 처리하거나 style 등을 변경할 수 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>190622-TIL</title>
    <link href="https://sub2n.github.io/2019/06/22/190622-TIL/"/>
    <id>https://sub2n.github.io/2019/06/22/190622-TIL/</id>
    <published>2019-06-22T10:13:26.000Z</published>
    <updated>2019-06-23T01:15:44.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Front Endgame 컨퍼런스에 갔다왔다.</li><li>Angular와 React에 대한 정보를 많이 얻었다.</li><li>현직 프론트엔드 개발자들이 어떤 식으로 일 하는지 들을 수 있어 좋았다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Front Endgam
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Angular Pipe</title>
    <link href="https://sub2n.github.io/2019/06/21/Angular-Pipe/"/>
    <id>https://sub2n.github.io/2019/06/21/Angular-Pipe/</id>
    <published>2019-06-21T05:16:51.000Z</published>
    <updated>2019-06-21T07:34:36.071Z</updated>
    
    <content type="html"><![CDATA[<p>AngularJS에는 60여개의 built-in Pipe가 있었으나 Angular는 9개의 built-in pipe를 지원한다. 나머지 기능은 pipe를 직접 구현하여 사용할 수 있다.</p><table><thead><tr><th align="left">pipe</th><th align="left">meaning</th></tr></thead><tbody><tr><td align="left"><a href="https://angular.io/api/common/DatePipe" target="_blank" rel="noopener">date</a></td><td align="left">날짜 형식 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/JsonPipe" target="_blank" rel="noopener">json</a></td><td align="left">JSON 형식 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/UpperCasePipe" target="_blank" rel="noopener">uppercase</a></td><td align="left">대문자 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/LowerCasePipe" target="_blank" rel="noopener">lowercase</a></td><td align="left">소문자 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/CurrencyPipe" target="_blank" rel="noopener">currency</a></td><td align="left">통화 형식 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/PercentPipe" target="_blank" rel="noopener">percent</a></td><td align="left">퍼센트 형식 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/DecimalPipe" target="_blank" rel="noopener">decimal</a></td><td align="left">자리수 형식 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/SlicePipe" target="_blank" rel="noopener">slice</a></td><td align="left">문자열 추출</td></tr><tr><td align="left"><a href="https://angular.io/api/common/AsyncPipe" target="_blank" rel="noopener">async</a></td><td align="left">비동기 객체 출력</td></tr></tbody></table><a id="more"></a><p>new Date() 등으로 생성한 객체에 pipe를 사용하면 깔끔한 형식으로 출력할 수 있다.</p><p>객체 배열 형식으로 된 data를 확인하며 코딩할 때 <code>&lt;pre&gt;{ data | json }&lt;/pre&gt;</code>로 data를 확인할 수 있다.</p><p>Category가 있는 경우 category 별로 filtering해서 데이터를 보여줄 수도 있다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// filter.pipe.ts</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Pipe</span>(&#123;</span><br><span class="line">  name: <span class="hljs-string">'filter'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FilterPipe <span class="hljs-keyword">implements</span> PipeTransform &#123;</span><br><span class="line">  transform(todos: Todo[], active: NavItem): <span class="hljs-built_in">any</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (active === <span class="hljs-string">'All'</span>) <span class="hljs-keyword">return</span> todos;</span><br><span class="line">    <span class="hljs-keyword">return</span> active === <span class="hljs-string">'Active'</span></span><br><span class="line">      ? todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.completed)</span><br><span class="line">      : todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.completed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- todos.component.html --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let todo of (todos | filter: navState)"</span>&gt;</span></span><br><span class="line">  ....</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Angular는 template을 렌더링할 때 사용하는 data의 Reference value가 바뀌어야 상태 감지를 해서 재렌더링을 하며 pipe를 실행한다. 따라서 상태가 변경될 때는 명시적으로 재할당을 해주는 게 좋다. 재할당을 하지 않고 일부분만을 변경할 경우 pipe에 option을 주어야 한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ Pipe(&#123;</span><br><span class="line">  name: <span class="hljs-string">'filter'</span>,</span><br><span class="line">  pure: <span class="hljs-literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>pure: false</code> option을 주면 Reference value가 바뀌지 않더라도 상태를 감지하지만 퍼포먼스가 안 좋아진다. 재할당을 하자.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AngularJS에는 60여개의 built-in Pipe가 있었으나 Angular는 9개의 built-in pipe를 지원한다. 나머지 기능은 pipe를 직접 구현하여 사용할 수 있다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;pipe&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/DatePipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;date&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;날짜 형식 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/JsonPipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;json&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;JSON 형식 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/UpperCasePipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;uppercase&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;대문자 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/LowerCasePipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lowercase&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;소문자 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/CurrencyPipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;currency&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;통화 형식 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/PercentPipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;percent&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;퍼센트 형식 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/DecimalPipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;decimal&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;자리수 형식 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/SlicePipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;slice&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;문자열 추출&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/AsyncPipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;async&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;비동기 객체 출력&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
      <category term="Pipe" scheme="https://sub2n.github.io/tags/Pipe/"/>
    
  </entry>
  
  <entry>
    <title>190619-TIL</title>
    <link href="https://sub2n.github.io/2019/06/19/190619-TIL/"/>
    <id>https://sub2n.github.io/2019/06/19/190619-TIL/</id>
    <published>2019-06-19T07:34:38.000Z</published>
    <updated>2019-06-19T07:37:20.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Angular 계층적 구조를 가진 Component 간의 Data 통신을 Service로 한다는 것을 알았다.</li><li>Angular의 Service는 전체 프로그램에서 하나의 Instance만을 가지는 Singleton이기 때문에 상태 관리가 가능하다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Angular 계층적 
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190618-TIL</title>
    <link href="https://sub2n.github.io/2019/06/18/190618-TIL/"/>
    <id>https://sub2n.github.io/2019/06/18/190618-TIL/</id>
    <published>2019-06-18T08:47:42.000Z</published>
    <updated>2019-06-18T08:51:01.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Angular로 AnalogClock과 StopWatch를 구현했다.</li><li>Angular Built-in Directive에 대해서 배웠다.</li><li>부모-자식 Component간 통신을 이용해서 simpleTodo를 구현했다.</li><li>자식 &gt; 부모 Component로 Data를 보낼 때는 @Output() 에 EventEmmitter의 instance로 event를 발생시킨다. emit()을 호출해야 event가 발생한다.</li><li>부모 &gt; 자식 Compinent로 Data를 보낼 때는 부모 Component에서 자식 Component로 Property binding을 하는 방식으로 Data를 보낸다. 자식 Compinent는 해당 프로퍼티를 @Input()으로 정의하고 값을 받는다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Angular로 Ana
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Angular Built-in Directive</title>
    <link href="https://sub2n.github.io/2019/06/18/Angular-Built-in-Directive/"/>
    <id>https://sub2n.github.io/2019/06/18/Angular-Built-in-Directive/</id>
    <published>2019-06-18T04:24:13.000Z</published>
    <updated>2019-06-21T06:42:11.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-Directive"><a href="#What-is-Directive" class="headerlink" title="What is Directive?"></a>What is Directive?</h2><p>지시, 명령. View에 관련한 명령을 내리는 모든 것을 directive라고 한다.</p><p>Component의 공통된 기능을 외부로 내보낸다.</p><blockquote><h4 id="Dependency-Injective"><a href="#Dependency-Injective" class="headerlink" title="Dependency Injective"></a>Dependency Injective</h4><p>type 지정하면 Angular가 class Instance를 생성한다.</p></blockquote><a id="more"></a><h3 id="Component-Directive"><a href="#Component-Directive" class="headerlink" title="Component Directive"></a>Component Directive</h3><p>Component의 템플릿 표시를 위한 Directive.  @Component</p><h3 id="Attribute-Directive"><a href="#Attribute-Directive" class="headerlink" title="Attribute Directive"></a>Attribute Directive</h3><p>ngClass, ngStyle 등</p><h4 id="ngClass"><a href="#ngClass" class="headerlink" title="ngClass"></a>ngClass</h4><p>여러 개의 Class를 추가하고 제거할 때 간편하다. String, Array, Object 형태로 바인딩할 수 있다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngClass</span>] = <span class="hljs-string">"'active red'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- string --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngClass</span>] = <span class="hljs-string">""</span>['<span class="hljs-attr">active</span>', '<span class="hljs-attr">red</span>']"&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- array --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngClass</span>] = <span class="hljs-string">"&#123;'active': true, 'red': false&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- object --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ngStyle"><a href="#ngStyle" class="headerlink" title="ngStyle"></a>ngStyle</h4><p>여러 개의 Inline Style을 추가하고 제거한다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">"&#123; color: 'red', 'width.px': 100 &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="Host-Element"><a href="#Host-Element" class="headerlink" title="Host Element"></a>Host Element</h4><p>Attribute가 사용된 Element</p></blockquote><h3 id="Structural-Directives"><a href="#Structural-Directives" class="headerlink" title="Structural Directives"></a>Structural Directives</h3><p>구조 디렉티브는 DOM 요소를 조건에 따라서 추가/삭제(ngIf, ngSwitch)하거나 반복 생성(ngFor)할 때 사용한다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;What-is-Directive&quot;&gt;&lt;a href=&quot;#What-is-Directive&quot; class=&quot;headerlink&quot; title=&quot;What is Directive?&quot;&gt;&lt;/a&gt;What is Directive?&lt;/h2&gt;&lt;p&gt;지시, 명령. View에 관련한 명령을 내리는 모든 것을 directive라고 한다.&lt;/p&gt;
&lt;p&gt;Component의 공통된 기능을 외부로 내보낸다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;Dependency-Injective&quot;&gt;&lt;a href=&quot;#Dependency-Injective&quot; class=&quot;headerlink&quot; title=&quot;Dependency Injective&quot;&gt;&lt;/a&gt;Dependency Injective&lt;/h4&gt;&lt;p&gt;type 지정하면 Angular가 class Instance를 생성한다.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>190617-TIL</title>
    <link href="https://sub2n.github.io/2019/06/17/190617-TIL/"/>
    <id>https://sub2n.github.io/2019/06/17/190617-TIL/</id>
    <published>2019-06-17T08:46:05.000Z</published>
    <updated>2019-06-17T08:47:36.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Angular Component의 Data Binding에 대해서 배웠다.</li><li>Angular의 ngFor와 ngIf Directive를 적용해서 TabsUI를 구현해봤다.</li><li>Angular 문법이 아직 익숙하지는 않은데 재미있다. 생각을 전환하기가 쉽지 않다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Angular Comp
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Angular Data Binding</title>
    <link href="https://sub2n.github.io/2019/06/17/Angular-Data-Binding/"/>
    <id>https://sub2n.github.io/2019/06/17/Angular-Data-Binding/</id>
    <published>2019-06-17T05:35:22.000Z</published>
    <updated>2019-06-21T06:42:28.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Interpolation"><a href="#Interpolation" class="headerlink" title="Interpolation"></a>Interpolation</h2><p><code></code></p><h2 id="Property-Binding"><a href="#Property-Binding" class="headerlink" title="Property Binding"></a>Property Binding</h2><p><code>[propertyName] = &quot;expression&quot;</code></p><p><code>&quot; &quot;</code> 내부에는 string이 아니라 expression(표현식)이 오는 곳이므로 주의하자.</p><blockquote><h4 id="Attribute-and-Property"><a href="#Attribute-and-Property" class="headerlink" title="Attribute and Property"></a>Attribute and Property</h4><p>Attribute는 HTML Element의 attribute이고 Property는 DOM node object인 HTML Element 객체의 property이다. 초기에 HTML Attribute가 초기값으로 그려지고 Property는 실시간으로 변경되는 DOM 최신값을 반영한다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Initial Value"</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"Property Value"</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>앞의 value는 attribute이고 [value]는 property이다. Property는 최신값이므로 실행시 “Property Value”가 view에 보여지게 된다.</p></blockquote><a id="more"></a><h2 id="Attribute-Binding"><a href="#Attribute-Binding" class="headerlink" title="Attribute Binding"></a>Attribute Binding</h2><p><code>[attr.attName] = &quot;expression&quot;</code></p><p>Property와 달리 <code>attr.</code>를 붙여줘야 한다.</p><p>HTML Element의 Property와 Attribute는 항상 1 대 1로 대응하지 않는다. HTML Element 별로 어떤 Attribute와 Property가 있는지 알고 있어야 한다.</p><h2 id="Class-Binding"><a href="#Class-Binding" class="headerlink" title="Class Binding"></a>Class Binding</h2><p>Class binding은 2가지 방법으로 사용할 수 있다. </p><h5 id="class-className-quot-expression-quot"><a href="#class-className-quot-expression-quot" class="headerlink" title="[class.className] = &quot;expression&quot;"></a><code>[class.className] = &quot;expression&quot;</code></h5><p>expression의 평가 결과가 true일 때는 class를 적용하고, false일 때는 class를 적용하지 않는다. classList.add와 remove를 간단하게 할 수 있다.</p><h5 id="class-quot-className-List-quot"><a href="#class-quot-className-List-quot" class="headerlink" title="[class]=&quot;className List&quot;"></a><code>[class]=&quot;className List&quot;</code></h5><p>class에 className List를 적용한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classNames = <span class="hljs-string">'active red block'</span>;</span><br></pre></td></tr></table></figure><p>여러 Class를 조건 별로 다룰 때에는 Angular의 built-in ngClass Directive를 사용하는 것이 좋다.</p><h2 id="Style-Binding"><a href="#Style-Binding" class="headerlink" title="Style Binding"></a>Style Binding</h2><p><code>[style.styleProp]=&quot;expression&quot;</code></p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// style property 이름은 camelExpression과 kebab-expression 모두 사용</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">style.fontSize.px</span>] = <span class="hljs-string">"'64'"</span>&gt;</span>..<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">style.font-size.px</span>]=<span class="hljs-string">"'64'"</span>&gt;</span>..<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Event-Binding"><a href="#Event-Binding" class="headerlink" title="Event Binding"></a>Event Binding</h2><p><code>(event)=&quot;event handler()&quot;</code></p><p>함수 <strong>호출문</strong>을 써야 한다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onClick()"</span>&gt;</span>..<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Two-way-Data-Binding"><a href="#Two-way-Data-Binding" class="headerlink" title="Two-way Data Binding"></a>Two-way Data Binding</h2><p>Property와 event binding을 한 번에</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> (<span class="hljs-attr">input</span>)=<span class="hljs-string">"changeVal($event.target.value)"</span></span></span><br><span class="line"><span class="hljs-tag">       [<span class="hljs-attr">value</span>]=<span class="hljs-string">"value"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"remove()"</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;</span><br><span class="line">  value= <span class="hljs-string">''</span>;</span><br><span class="line">  </span><br><span class="line">  changeVal(value: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  remove() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = <span class="hljs-string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input event로 인해서 AppComponent class의 value가 바뀌면 그 바뀐 value에 의해서 또 HTMLInputElement의  value도 영향을 받는다.</p><p>이런 상황을 양방향 데이터 바인딩으로 작성할 수 있다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"value"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위  와 같이 고치면 input tag에 대해서 input event 발생시 AppCoㅊㅌ      mponent의 value도 변경되고, AppComponent의 value가 변경되면 view에;ㅀ 반영된다.</p><p>ngModel을 사용하기 위해서는 FormsModule을 모듈에 등록해야 한다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Interpolation&quot;&gt;&lt;a href=&quot;#Interpolation&quot; class=&quot;headerlink&quot; title=&quot;Interpolation&quot;&gt;&lt;/a&gt;Interpolation&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;Property-Binding&quot;&gt;&lt;a href=&quot;#Property-Binding&quot; class=&quot;headerlink&quot; title=&quot;Property Binding&quot;&gt;&lt;/a&gt;Property Binding&lt;/h2&gt;&lt;p&gt;&lt;code&gt;[propertyName] = &amp;quot;expression&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;quot; &amp;quot;&lt;/code&gt; 내부에는 string이 아니라 expression(표현식)이 오는 곳이므로 주의하자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;Attribute-and-Property&quot;&gt;&lt;a href=&quot;#Attribute-and-Property&quot; class=&quot;headerlink&quot; title=&quot;Attribute and Property&quot;&gt;&lt;/a&gt;Attribute and Property&lt;/h4&gt;&lt;p&gt;Attribute는 HTML Element의 attribute이고 Property는 DOM node object인 HTML Element 객체의 property이다. 초기에 HTML Attribute가 초기값으로 그려지고 Property는 실시간으로 변경되는 DOM 최신값을 반영한다.&lt;/p&gt;
&lt;figure class=&quot;highlight html hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Initial Value&quot;&lt;/span&gt; [&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;]=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Property Value&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;앞의 value는 attribute이고 [value]는 property이다. Property는 최신값이므로 실행시 “Property Value”가 view에 보여지게 된다.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular Component</title>
    <link href="https://sub2n.github.io/2019/06/14/Angular-Component/"/>
    <id>https://sub2n.github.io/2019/06/14/Angular-Component/</id>
    <published>2019-06-14T07:00:45.000Z</published>
    <updated>2019-06-25T05:15:42.467Z</updated>
    
    <content type="html"><![CDATA[<p>Angular Application은 component를 중심으로 구성되는만큼 component는 Angular의 핵심 개념이다.</p><p>Component는 application의 화면을 구성하는 View를 생성하고 관리한다. </p><p>Component는 template의 중첩 관계에 의해서 tree 구조를 갖는다. 여러 component 사이의 통신과 상태 관리를 위해서 Service가 있다.</p><a id="more"></a><h4 id="Compnonent-decorator"><a href="#Compnonent-decorator" class="headerlink" title="@Compnonent : decorator"></a>@Compnonent : decorator</h4><h4 id="Component-Metadata"><a href="#Component-Metadata" class="headerlink" title="Component Metadata"></a>Component Metadata</h4><p><img src="https://user-images.githubusercontent.com/48080762/59491021-0679f900-8ec1-11e9-9db7-31c3af5cce5d.png" alt="component metadata"></p><h4 id="export-class"><a href="#export-class" class="headerlink" title="export class"></a>export class</h4><p><img src="https://user-images.githubusercontent.com/48080762/59491315-6e304400-8ec1-11e9-9e53-ddff4b4861e9.png" alt="export class"></p><h4 id="Add-Component-to-app-module-ts"><a href="#Add-Component-to-app-module-ts" class="headerlink" title="Add Component to app.module.ts"></a>Add Component to app.module.ts</h4><p><img src="https://user-images.githubusercontent.com/48080762/59491403-a172d300-8ec1-11e9-8961-b685478fd3d6.png" alt="component declaration"></p><h4 id="Parent에서-Child로-data-보내는-법-Property-Binding"><a href="#Parent에서-Child로-data-보내는-법-Property-Binding" class="headerlink" title="Parent에서 Child로 data 보내는 법 : Property Binding"></a>Parent에서 Child로 data 보내는 법 : Property Binding</h4><p>parent Component는 자신의 template에 Child Component를 담고 있으므로 Child Component를 알 수 있다. 따라서 data를 쉽게 전송할 수 있다.</p><ol><li><p>Parent Component에서 Child의 Property로 값을 전달한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// app.component.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-root'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;!--The content below is only a placeholder and can be replaced.--&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;app-hello [hi]="greeting"&gt;&lt;/app-hello&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: []</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;</span><br><span class="line">  greeting = <span class="hljs-string">'hello'</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Child에서 @Input decorator로 Proterty value를 전달받는다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// hello.component.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Component, Input &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"@angular/core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  <span class="hljs-comment">// metadata</span></span><br><span class="line">  selector: <span class="hljs-string">'app-hello'</span>,</span><br><span class="line">  template: <span class="hljs-string">`&lt;h1&gt;&#123;&#123;hi&#125;&#125;&lt;/h1&gt;`</span>,</span><br><span class="line">  styles: [<span class="hljs-string">``</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HelloComponent &#123;</span><br><span class="line">  <span class="hljs-comment">// class Field</span></span><br><span class="line">  <span class="hljs-meta">@Input</span>() hi: <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Child-Component에서-Parent-Component로-data-보내는-법-Event-발생"><a href="#Child-Component에서-Parent-Component로-data-보내는-법-Event-발생" class="headerlink" title="Child Component에서 Parent Component로 data 보내는 법 : Event 발생"></a>Child Component에서 Parent Component로 data 보내는 법 : Event 발생</h4><p>Child Component는 Parent Component를 모르므로 Event를 발생시켜 Parent Component에서 Event를 Handling하는 방식으로 data를 전송한다.</p><ol><li><p>@Output, EventEmitter를 이용해서 Child Component에서 Event를 발생시킨다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component, Input, Output, EventEmitter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"@angular/core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  <span class="hljs-comment">// metadata</span></span><br><span class="line">  selector: <span class="hljs-string">'app-hello'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;h1&gt;&#123;&#123;hi&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;button (click)="greeting.emit('Hello')"&gt;greeting&lt;/button&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: [<span class="hljs-string">``</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HelloComponent &#123;</span><br><span class="line">  <span class="hljs-comment">// class Field</span></span><br><span class="line">  <span class="hljs-meta">@Input</span>() hi: <span class="hljs-built_in">string</span>;</span><br><span class="line">  <span class="hljs-meta">@Output</span>() greeting = <span class="hljs-keyword">new</span> EventEmitter&lt;<span class="hljs-built_in">string</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Output으로 선언한 method는 emit으로 argument를 전달할 수 있다.</p></li><li><p>Parent Component에서는 Event Handler를 이용해서 Event를 처리한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-root'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;!--The content below is only a placeholder and can be replaced.--&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;app-hello</span></span><br><span class="line"><span class="hljs-string">      [hi]="greeting"</span></span><br><span class="line"><span class="hljs-string">      (greeting)="changeGreet($event)"</span></span><br><span class="line"><span class="hljs-string">    &gt;&lt;/app-hello&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: []</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;</span><br><span class="line">  greeting = <span class="hljs-string">'Hi~~!!!!'</span>;</span><br><span class="line">  changeGreet(greet: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.greeting = greet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;app-hello&gt;</code> 내부에서 event greeting의 event handler를 등록하고 class 내부에서 정의한다. $event로 parameter에 argument 값을 받아온다.</p></li></ol><h2 id="Content-Projection"><a href="#Content-Projection" class="headerlink" title="Content Projection"></a>Content Projection</h2><p>Child Component의 selector tag 사이에 HTML content를 넣을 수 있다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- parent --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">app-child</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line">    Content from parent</span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">app-child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- child --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Child component의 template에 <code>&lt;ng-content&gt;&lt;/ng-content&gt;</code>가 Parent component에서 전달한 template으로 치환된다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Angular Application은 component를 중심으로 구성되는만큼 component는 Angular의 핵심 개념이다.&lt;/p&gt;
&lt;p&gt;Component는 application의 화면을 구성하는 View를 생성하고 관리한다. &lt;/p&gt;
&lt;p&gt;Component는 template의 중첩 관계에 의해서 tree 구조를 갖는다. 여러 component 사이의 통신과 상태 관리를 위해서 Service가 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular Basics</title>
    <link href="https://sub2n.github.io/2019/06/14/Angular-Basics/"/>
    <id>https://sub2n.github.io/2019/06/14/Angular-Basics/</id>
    <published>2019-06-14T03:59:45.000Z</published>
    <updated>2019-06-14T07:03:39.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>Angular는 SPA(Single Page Application) 개발을 위한 Google의 Open source JavaScript <strong>Framework</strong>.</p><blockquote><h4 id="Framework-and-Library"><a href="#Framework-and-Library" class="headerlink" title="Framework and Library"></a>Framework and Library</h4><p>Library는 관련있는 함수를 모아놓아 개발자가 사용할 수 있는 도구이다. 즉, Library는 개발자에 의해 사용된다.</p><p>Framework는 클래스와 인터페이스의 집합으로 Application의 Flow를 쥐고 있다. 개발자가 Framework 틀 내부에서 작업하는 것이다.</p></blockquote><p>전통적인 웹 개발에서 JavaScript는 HTML/CSS에 의존한다. 의존한다는 것은 HTML/CSS에 접근해서 조작하는 방식으로 JavaScript 코드가 작성되었다는 것을 뜻한다. 이는 HTML/CSS가 변경되면 JavaScript 코드도 영향을 받음을 의미한다.</p><p>Angular는 HTML/CSS가 JavaScript에 의존하도록, 즉 JavaScript 코드의 상태 데이터 (State)에 바인딩해서 상태가 변경될 때마다 Rendering되도록 한다. HTML/CSS를 JavaScript의 Rendering 함수 내부의 문자열로 관리하면 앞서 말한 동작이 가능하다.</p><a id="more"></a><h2 id="Advantages-of-Angular"><a href="#Advantages-of-Angular" class="headerlink" title="Advantages of Angular"></a>Advantages of Angular</h2><ol><li>컴포넌트 기반 개발(CBD: Component Based Development) 로 생산성이 좋다.  Web에서 컴포넌트 기반 개발이 어려운 이유는 CSS가 서로에게 영향을 주기 때문인데,  Component 별로 CSS를 분리해내는 게 중요하다.</li><li>TypeScript 사용으로 정적 타이핑, ES6과 ESNext의 기능을 지원한다.</li><li>Angular는 대부분의 모던 브라우저를 지원한다. IE는 9 이상을 지원한다.</li></ol><h2 id="Angular-Project"><a href="#Angular-Project" class="headerlink" title="Angular Project"></a>Angular Project</h2><h4 id="app-component"><a href="#app-component" class="headerlink" title="app.component"></a>app.component</h4><p>Application의 root Component로, 실행 기본 page. (index.html처럼)</p><p><img src="https://user-images.githubusercontent.com/48080762/59484774-13d9b800-8eae-11e9-9762-ee95824f338f.png" alt="app.component"></p><h5 id="app-component-spec-ts"><a href="#app-component-spec-ts" class="headerlink" title="app.component.spec.ts"></a>app.component.spec.ts</h5><p>test specification</p><h5 id="ng-build-후-map-file"><a href="#ng-build-후-map-file" class="headerlink" title="ng build 후 map file"></a>ng build 후 map file</h5><p>디버깅용</p><h4 id="app-module"><a href="#app-module" class="headerlink" title="app.module"></a>app.module</h4><p>전체 모듈을 관리하므로 component 추가시 module에 추가됨</p><p><img src="https://user-images.githubusercontent.com/48080762/59485300-379dfd80-8eb0-11e9-987c-8154db2b8663.png" alt="app.module"></p><p>Component 생성 후 module file의 declarations에 추가해줘야함</p><h4 id="Generate-Component-Shortcut"><a href="#Generate-Component-Shortcut" class="headerlink" title="Generate Component Shortcut"></a>Generate Component Shortcut</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c service -s -t --skip-tests (-S)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/48080762/59485613-78e2dd00-8eb1-11e9-86da-a3d210def751.png" alt="shortcut"></p><h4 id="ng-generate"><a href="#ng-generate" class="headerlink" title="ng generate"></a>ng generate</h4><table><thead><tr><th>component</th><th>UI를 만들기 위해서 존재</th></tr></thead><tbody><tr><td>sercive</td><td>component와 직접적인 연관이 없는 state 관리</td></tr></tbody></table><p>component가 활성화된다 =&gt; component가 메모리에 올라가면 view가 보임</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="hljs-string">'이거슨 java'</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'이거슨 JavaScript'</span>);</span><br><span class="line">printf(<span class="hljs-string">'이거슨 C'</span>);</span><br><span class="line">cout&lt;&lt;<span class="hljs-string">'이거슨 c++'</span>;</span><br><span class="line">print(<span class="hljs-string">'이거슨 python'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Angular&quot;&gt;&lt;a href=&quot;#Angular&quot; class=&quot;headerlink&quot; title=&quot;Angular&quot;&gt;&lt;/a&gt;Angular&lt;/h2&gt;&lt;p&gt;Angular는 SPA(Single Page Application) 개발을 위한 Google의 Open source JavaScript &lt;strong&gt;Framework&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;Framework-and-Library&quot;&gt;&lt;a href=&quot;#Framework-and-Library&quot; class=&quot;headerlink&quot; title=&quot;Framework and Library&quot;&gt;&lt;/a&gt;Framework and Library&lt;/h4&gt;&lt;p&gt;Library는 관련있는 함수를 모아놓아 개발자가 사용할 수 있는 도구이다. 즉, Library는 개발자에 의해 사용된다.&lt;/p&gt;
&lt;p&gt;Framework는 클래스와 인터페이스의 집합으로 Application의 Flow를 쥐고 있다. 개발자가 Framework 틀 내부에서 작업하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;전통적인 웹 개발에서 JavaScript는 HTML/CSS에 의존한다. 의존한다는 것은 HTML/CSS에 접근해서 조작하는 방식으로 JavaScript 코드가 작성되었다는 것을 뜻한다. 이는 HTML/CSS가 변경되면 JavaScript 코드도 영향을 받음을 의미한다.&lt;/p&gt;
&lt;p&gt;Angular는 HTML/CSS가 JavaScript에 의존하도록, 즉 JavaScript 코드의 상태 데이터 (State)에 바인딩해서 상태가 변경될 때마다 Rendering되도록 한다. HTML/CSS를 JavaScript의 Rendering 함수 내부의 문자열로 관리하면 앞서 말한 동작이 가능하다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>190612-TIL</title>
    <link href="https://sub2n.github.io/2019/06/12/190612-TIL/"/>
    <id>https://sub2n.github.io/2019/06/12/190612-TIL/</id>
    <published>2019-06-12T10:34:40.000Z</published>
    <updated>2019-06-13T01:37:01.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>TypeScript에 대해서 배우고 실습해봤다.</li><li>Angular로 간단한 TodoList 기능을 구현해봤다. 맛보기만 해봤지만 재밌다! 그리고 엄청 편하다.</li><li>TypeScript는 기존에 알고 있던 객체지향개념(Class, Interface 등)이 있어 사용하기 편리할 것 같다. </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TypeScript에 
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript (2)</title>
    <link href="https://sub2n.github.io/2019/06/12/TypeScript-2/"/>
    <id>https://sub2n.github.io/2019/06/12/TypeScript-2/</id>
    <published>2019-06-12T09:16:03.000Z</published>
    <updated>2019-06-13T05:53:12.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TypeScript의-주요-기능"><a href="#TypeScript의-주요-기능" class="headerlink" title="TypeScript의 주요 기능"></a>TypeScript의 주요 기능</h4><ol><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Type-Declaration">타입 선언</a></li><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Class">Class</a></li><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Interface">Interface</a></li><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Generic">Generic</a></li></ol><a id="more"></a><h2 id="Type-Declaration"><a href="#Type-Declaration" class="headerlink" title="Type Declaration"></a>Type Declaration</h2><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 선언과 동시에 할당할 때는 바로 그 type으로 지정됨</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mult</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parameter의 type을 모두 명시해준 경우 Return type은 추론이 가능하므로 생략이 가능하다. Type은 any가 나오지 않게끔만 지정하면 된다.</p><p><code>void</code>: return을 하지 않는다. 사실은 <code>undefined</code>가 return되지만 <code>void</code>라고 한다.</p><h4 id="Types-of-TypeScript"><a href="#Types-of-TypeScript" class="headerlink" title="Types of TypeScript"></a>Types of TypeScript</h4><p><strong>From JavaScript:</strong> boolean,  null, undefined, number, string, symbol, object</p><p><strong>Added in TypeScript:</strong> array, tuple, enum, any, void, never</p><blockquote><h3 id="void와-never-차이"><a href="#void와-never-차이" class="headerlink" title="void와 never 차이"></a>void와 never 차이</h3><p>never는 함수가 종료하지 않아 결코 return하지 않을 때 사용된다. 무한루프 혹은 Error 메시지를 throw할 때 return type이 never이다.</p><p>void는 return 값이 없을 뿐이지 함수는 종료한다.</p></blockquote><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> list1: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> list2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Generic Array Type</span></span><br></pre></td></tr></table></figure><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> tuple: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];</span><br><span class="line">tuple = [<span class="hljs-string">'hello'</span>, <span class="hljs-number">10</span>];</span><br><span class="line">tuple.push(<span class="hljs-string">'good'</span>, <span class="hljs-number">30</span>);</span><br></pre></td></tr></table></figure><p>배열인데 고정된 element의 수만큼 type을 미리 선언한다.</p><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">enum</span> Season &#123;Spring, Summer, Fall, Winter&#125;;</span><br><span class="line"><span class="hljs-keyword">let</span> s1: Season = Season.Spring;</span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>TypeScript가 지원하는 Class는 ES6의 Class와 유사하지만 몇 가지 고유한 확장 기능을 가진다.</p><h3 id="1-Class-Definition"><a href="#1-Class-Definition" class="headerlink" title="1. Class Definition"></a>1. Class Definition</h3><p>ES6 Class와 다르게 constructor 외부, 즉 <strong>Class body에 Class field를 미리 선언해야 한다.</strong> 그렇지 않으면 Error가 발생한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Circle &#123;</span><br><span class="line">    <span class="hljs-comment">// Class field 미리 선언</span></span><br><span class="line">    radius: <span class="hljs-built_in">number</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">radius: <span class="hljs-built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor의 parameter에 Access Identifier를 사용하면 아래와 같이 선언할 수 있다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Circle &#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> radius</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// this.radius = radius;도 안 해줘도 됨</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Access-Identifier"><a href="#2-Access-Identifier" class="headerlink" title="2. Access Identifier"></a>2. Access Identifier</h3><ul><li>public : Class 내부, Child Class 내부, Class Instance에서 접근 가능</li><li>protected: Class 내부, Child Class 내부에서 접근 가능</li><li>private: Class 내부에서만 접근 가능</li></ul><p>Access identifier를 지정해주지 않으면 암묵적으로 public이 된다. 따라서 public으로 지정하고자 하는 Member variable과 method는 access identifier를 생략한다.</p><p>constructor parameter를 선언할 때 public를 붙이면 할당까지 이루어지고 Class 내부의 member variable이 된다. public을 쓰지 않으면 constructor 내부에서만 참조 가능한 지역 변수가 된다.</p><h3 id="3-readonly-Keyword"><a href="#3-readonly-Keyword" class="headerlink" title="3. readonly Keyword"></a>3. readonly Keyword</h3><p><code>readonly</code>가 선언된 클래스 프로퍼티는 선언할 때 또는 생성자 내부에서만 값을 할당할 수 있다. 그 외의 경우에는 값을 할당할 수 없고 오직 읽기만 가능한 상태가 된다. 상수를 선언할 때 사용한다.</p><h3 id="4-static-Keyword"><a href="#4-static-Keyword" class="headerlink" title="4. static Keyword"></a>4. static Keyword</h3><p>메소드 뿐만 아니라 프로퍼티도 static으로 지정할 수 있다.</p><h3 id="5-Abstract-Class"><a href="#5-Abstract-Class" class="headerlink" title="5. Abstract Class"></a>5. Abstract Class</h3><p>Abstract class는 <strong>하나 이상의 abstract method를 포함</strong>하며 일반 method도 가질 수 있다. Abstract method란 구현 없이 method 이름과 type만이 선언된 method를 말한다. 선언시 <code>abstract</code> 키워드를 사용한다.</p><p>Abstract class는 <strong>직접 instance를 생성할 수 없고 상속만을 위해 사용된다.</strong> <strong>Abstract class를 상속한 class는 반드시 abstract class의 abstract method를 구현해야 한다.</strong></p><p>Interface는 모든 method가 abstract이다.</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface는 일반적으로 type check를 위해서 사용된다. 변수, 함수, 클래스에 사용할 수 있다.</p><p>Interface는 여러가지 type을 갖는 property로 이루어진 새로운 type을 정의하는 것과 같다. Interface에 선언된 property와 method의 구현을 강제해서 일관성을 유지할 수 있게 한다.</p><h3 id="1-Variable-and-Interface"><a href="#1-Variable-and-Interface" class="headerlink" title="1. Variable and Interface"></a>1. Variable and Interface</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Definition of interface</span></span><br><span class="line"><span class="hljs-keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="hljs-built_in">number</span>;</span><br><span class="line">  content: <span class="hljs-built_in">string</span>;</span><br><span class="line">  completed: <span class="hljs-built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 변수의 type으로 interface Todo를 선언</span></span><br><span class="line"><span class="hljs-keyword">let</span> todo: Todo;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 변수 todo는 Todo interface를 따라야한다.</span></span><br><span class="line">todo = &#123; id: <span class="hljs-number">1</span>, content: <span class="hljs-string">'typescript'</span>, completed: <span class="hljs-literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수 parameter를 interface Todo로 선언</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span>(<span class="hljs-params">todo: Todo</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>필요에 따라서 새로운 타입을 생성하는 것과 같다. 함수의 parameter 선언시에도 interface를 사용하여 전달되는 argument의 type 형식을 제한할 수 있다.</p><h3 id="2-Function-and-Interface"><a href="#2-Function-and-Interface" class="headerlink" title="2. Function and Interface"></a>2. Function and Interface</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 함수 인터페이스의 정의</span></span><br><span class="line"><span class="hljs-keyword">interface</span> SquareFunc &#123;</span><br><span class="line">  (num: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수 인테페이스를 구현하는 함수는 인터페이스를 따라야 한다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> squareFunc: SquareFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num: <span class="hljs-built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(squareFunc(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 100</span></span><br></pre></td></tr></table></figure><p>잘 안 씀</p><h3 id="3-Class-and-Interface"><a href="#3-Class-and-Interface" class="headerlink" title="3. Class and Interface"></a>3. Class and Interface</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 인터페이스의 정의</span></span><br><span class="line"><span class="hljs-keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>;</span><br><span class="line">  sayHello(): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">인터페이스를 구현하는 클래스는 인터페이스에서 정의한 프로퍼티와 추상 메소드를 반드시 구현하여야 한다.</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-keyword">class</span> Person <span class="hljs-keyword">implements</span> IPerson &#123;</span><br><span class="line">  <span class="hljs-comment">// 인터페이스에서 정의한 프로퍼티의 구현</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 인터페이스에서 정의한 추상 메소드의 구현</span></span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;this.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span>(<span class="hljs-params">person: IPerson</span>): <span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">  person.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> me = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Lee'</span>);</span><br><span class="line">greeter(me); <span class="hljs-comment">// Hello Lee</span></span><br></pre></td></tr></table></figure><h3 id="4-Duck-Typing"><a href="#4-Duck-Typing" class="headerlink" title="4. Duck Typing"></a>4. Duck Typing</h3><p>Interface를 implements해서 구현하지 않아도, 해당 interface 내부의 property나 method를 모두 구현하면 type check에서 통과된다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> IDuck &#123; <span class="hljs-comment">// 1</span></span><br><span class="line">  quack(): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> MallardDuck <span class="hljs-keyword">implements</span> IDuck &#123; <span class="hljs-comment">// 3</span></span><br><span class="line">  quack() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Quack!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> RedheadDuck &#123; <span class="hljs-comment">// 4</span></span><br><span class="line">  quack() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'q~uack!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeNoise</span>(<span class="hljs-params">duck: IDuck</span>): <span class="hljs-title">void</span> </span>&#123; <span class="hljs-comment">// 2</span></span><br><span class="line">  duck.quack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeNoise(<span class="hljs-keyword">new</span> MallardDuck()); <span class="hljs-comment">// Quack!</span></span><br><span class="line">makeNoise(<span class="hljs-keyword">new</span> RedheadDuck()); <span class="hljs-comment">// q~uack! // 5</span></span><br></pre></td></tr></table></figure><p>Interface IDuck을 명시적으로 implements하지 않은 RedheadDuck의 instance도 IDuck 내부를 완벽하게 구현했다면 type이 IDuck으로 인정된다.</p><p>즉, implements 여부가 아니라 interface 구현 여부가 check된다.</p><h3 id="5-Optional-Property-in-Interface"><a href="#5-Optional-Property-in-Interface" class="headerlink" title="5. Optional Property in Interface"></a>5. Optional Property in Interface</h3><p>Interface 내부에서 <code>?</code>가 붙은 property는 구현을 생략해도 된다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> StudentInfo &#123;</span><br><span class="line">name: <span class="hljs-built_in">string</span>;</span><br><span class="line"><span class="hljs-built_in">number</span>: <span class="hljs-built_in">string</span>;</span><br><span class="line">age? : <span class="hljs-built_in">number</span>;</span><br><span class="line">address? : <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p>C나 C++ 등 정적 타입 언어에서는 함수 또는 클래스를 정의할 때 parameter나 return 값의 타입을 선언해야 한다. TypeScript도 정적 타입 언어이므로 정의 시점에 타입을 선언해야하는데, 함수 또는 클래스를 정의할 때 parameter나 return type을 선언하기 어려운 경우가 있다.</p><p>TypeScript는 선언시 타입을 지정하지 않으면 any타입이 되어 type check를 할 수 없게 된다. Stack이나 Queue를 구현하는 경우 배열에 어떤 type을 담을 것인지 정의할 때 확정짓기 어렵다. 이런 경우에 Generic을 사용한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Stack&lt;T&gt; &#123;</span><br><span class="line">  <span class="hljs-keyword">protected</span> data: <span class="hljs-built_in">Array</span>&lt;T&gt; = [];</span><br><span class="line">  push(item: T) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  pop(): T &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 class Stack을 정의할 때 타입을 따로 지정하지 않고 <code>&lt;T&gt;</code>를 사용했다. <code>&lt;T&gt;</code>는 Type Paremeter이며 Type의 약자이다. 어느 type이던 사용할 수 있음을 의미한다. </p><p>Generic은 선언 시점이 아니라 생성 시점에 타이블 명시해서 다양항 타입을 사용할 수 있도록 하는 기법이다. </p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">items: T[]</span>): <span class="hljs-title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> items.sort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위는 함수에서 Generic을 사용한 것이다. 어떤 type으로 이루어지는지는 모르지만 배열을 parameter로 받아서 sorting한 배열을 리턴한다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TypeScript의-주요-기능&quot;&gt;&lt;a href=&quot;#TypeScript의-주요-기능&quot; class=&quot;headerlink&quot; title=&quot;TypeScript의 주요 기능&quot;&gt;&lt;/a&gt;TypeScript의 주요 기능&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Type-Declaration&quot;&gt;타입 선언&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Class&quot;&gt;Class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Interface&quot;&gt;Interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Generic&quot;&gt;Generic&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://sub2n.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://sub2n.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript (1)</title>
    <link href="https://sub2n.github.io/2019/06/12/TypeScript-1/"/>
    <id>https://sub2n.github.io/2019/06/12/TypeScript-1/</id>
    <published>2019-06-12T09:15:55.000Z</published>
    <updated>2019-06-13T05:25:21.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>JavaScript는 모듈 기능을 지원하지 않고, 동적 타입 언어라는 단점 때문에 대형 프로젝트를 진행하기에 불편한 점이 많았다. 따라서 JavaScript의 단점을 보완하고자 하는 AltJS(Alternative) 언어들이 출시되었다. 브라우저는 JavaScript만을 인식하므로 AltJS 를 사용하더라도 JavaScript로 Compile해야한다.</p><p>TypeScript도 AltJS 중 하나로, JavaScript의 Superset(상위 호환)이라는 특징을 가진다. TypeScript는 ES5의 Superset이므로 기존 JavaScript 문법을 그대로 사용할 수 있다. 또한 Babel 등의 Transpiler를 사용하지 않아도 ES6의 새로운 기능을 기존 브라우저에서 실행할 수 있다. TypeScript의 가장 주된 장점은 Static Type을 지원한다는 것이다.</p><p>Angular가 TypeScript를 정식 채용하고 ECMAScript의 업그레이드되는 기능을 지속적으로 추가할 예정으로 많은 주목을 받고 있다.</p><a id="more"></a><h2 id="TypeScript-장점"><a href="#TypeScript-장점" class="headerlink" title="TypeScript 장점"></a>TypeScript 장점</h2><h3 id="1-정적-타입"><a href="#1-정적-타입" class="headerlink" title="1. 정적 타입"></a>1. 정적 타입</h3><p>TypeScript의 가장 큰 장점은 정적 타입을 지원하는 것이다. 변수의 타입이 없고 할당되는 값에 따라 타입이 정해지는 동적 타입 언어인 JavaScript는 type check를 해야하는 불편함이 있다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript는 명시적으로 정적 타입을 지정해 개발자의 의도대로 코드를 작성할 수 있다. 이는 코드의 가독성을 높여 효율적인 디버깅이 가능하다.</p><h3 id="2-도구의-지원"><a href="#2-도구의-지원" class="headerlink" title="2. 도구의 지원"></a>2. 도구의 지원</h3><p>IDE 기능을 사용할 수 있다.</p><h3 id="3-강력한-객체지향-프로그래밍-지원"><a href="#3-강력한-객체지향-프로그래밍-지원" class="headerlink" title="3. 강력한 객체지향 프로그래밍 지원"></a>3. 강력한 객체지향 프로그래밍 지원</h3><h3 id="4-ES6-ES-Next-지원"><a href="#4-ES6-ES-Next-지원" class="headerlink" title="4. ES6 / ES Next 지원"></a>4. ES6 / ES Next 지원</h3><p>Babel 없이도 ES6과 그 이상 버전을 지원하고 Babel보다 신기술에 빠르게 대응한다는 장점이 있다.</p><h3 id="5-Angular"><a href="#5-Angular" class="headerlink" title="5. Angular"></a>5. Angular</h3><p>Angular에서 TypeScript를 강력하게 지원한다.</p><blockquote><h4 id="HTML-code-내부에서-JavaScript를-보는-것과-JavaScript-code-내부에서-HTML을-보는-것의-차이"><a href="#HTML-code-내부에서-JavaScript를-보는-것과-JavaScript-code-내부에서-HTML을-보는-것의-차이" class="headerlink" title="HTML code 내부에서 JavaScript를 보는 것과, JavaScript code 내부에서 HTML을 보는 것의 차이"></a>HTML code 내부에서 JavaScript를 보는 것과, JavaScript code 내부에서 HTML을 보는 것의 차이</h4><p>JavaScript 내부에서 HTML element를 보면, 즉 querySelector를 사용해서 HTML Element에 접근하고 무언가 수행하면 Angular의 기본 원칙에 어긋난다. Angular는 기본적으로 HTML이 JavaScript에 영향을 받는 방식으로 HTML이 수정되어도 JavaScript code가 영항받지 않는다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h2&gt;&lt;p&gt;JavaScript는 모듈 기능을 지원하지 않고, 동적 타입 언어라는 단점 때문에 대형 프로젝트를 진행하기에 불편한 점이 많았다. 따라서 JavaScript의 단점을 보완하고자 하는 AltJS(Alternative) 언어들이 출시되었다. 브라우저는 JavaScript만을 인식하므로 AltJS 를 사용하더라도 JavaScript로 Compile해야한다.&lt;/p&gt;
&lt;p&gt;TypeScript도 AltJS 중 하나로, JavaScript의 Superset(상위 호환)이라는 특징을 가진다. TypeScript는 ES5의 Superset이므로 기존 JavaScript 문법을 그대로 사용할 수 있다. 또한 Babel 등의 Transpiler를 사용하지 않아도 ES6의 새로운 기능을 기존 브라우저에서 실행할 수 있다. TypeScript의 가장 주된 장점은 Static Type을 지원한다는 것이다.&lt;/p&gt;
&lt;p&gt;Angular가 TypeScript를 정식 채용하고 ECMAScript의 업그레이드되는 기능을 지속적으로 추가할 예정으로 많은 주목을 받고 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://sub2n.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://sub2n.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>190611-TIL</title>
    <link href="https://sub2n.github.io/2019/06/11/190611-TIL/"/>
    <id>https://sub2n.github.io/2019/06/11/190611-TIL/</id>
    <published>2019-06-11T08:18:05.000Z</published>
    <updated>2019-06-11T08:18:50.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>SPA (Sigle Page Application)에 대해서 배웠다.</li><li>JavaScript Class를 복습했다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SPA (Sigle P
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190610-TIL</title>
    <link href="https://sub2n.github.io/2019/06/10/190610-TIL/"/>
    <id>https://sub2n.github.io/2019/06/10/190610-TIL/</id>
    <published>2019-06-10T02:15:08.000Z</published>
    <updated>2019-06-11T04:11:44.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Tab UI를 만들었다.</li><li>Accordian UI를 만들었다.</li><li>Range Slider UI를 만들었다.</li><li>셋을 합쳤다.</li><li>jQuery로 구현된 코드를 Vanilla JavaScript로 고쳤다.</li></ul><p><a href="https://github.com/Sub2n/JavaScript-Exercise/blob/master/README.md#ui-exercise" target="_blank" rel="noopener">✨UI Exercise</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Tab UI를 만들었다
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>36. SPA</title>
    <link href="https://sub2n.github.io/2019/06/10/36-SPA/"/>
    <id>https://sub2n.github.io/2019/06/10/36-SPA/</id>
    <published>2019-06-10T01:46:03.000Z</published>
    <updated>2019-06-11T08:26:24.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPA-Single-Page-Application"><a href="#SPA-Single-Page-Application" class="headerlink" title="SPA (Single Page Application)"></a>SPA (Single Page Application)</h2><p>Single Page Application은 모던 웹 패러다임으로, 기본적으로 하나의 페이지로 구성된다. 하나의 페이지라는 것은 html 파일이 하나라는 뜻이다. 기존의 Sever-side 렌더링과 비교할 때 배포가 간단하고 <strong>Native application과 유사한 UX를 제공할 수 있다는 장점</strong>이 있다.</p><a id="more"></a><p>전통적인 웹 방식은 link tag를 사용해서 새로운 페이지를 요청한다. 새로운 페이지(html)를 요청할 때마다 필요한 static resource가 다운로드되고 전체 페이지를 다시 렌더링해야하므로 새로고침이 발생된다.</p><blockquote><h4 id="lt-a-gt-tag"><a href="#lt-a-gt-tag" class="headerlink" title="&lt;a&gt; tag"></a>&lt;a&gt; tag</h4><p>&lt;a&gt; tag 클릭시 href attribute의 url의 page로 이동한다. 즉, 화면 전환이 일어나 새로운 html이 렌더링된다. 화면 전환시 화면이 깜빡거리는 웹의 특성은 Native App과 비교해 단점으로 언급되어왔다.</p></blockquote><p>SPA는 기본적으로 Web Application에 필요한 모든 static resource를 처음 한 번에 다운로드한다. 이후에 새로운 페이지를 요청하면 갱신에 필요한 데이터만 전달받고 변경이 필요한 부분만 렌더링하므로 트래픽이 감소하고 Native application과 유사한 UX를 제공한다.</p><p>특히 모바일 사용이 증가하고 있는 요즘 SPA는 트래픽의 감소와 속도, 사용성, 반응성 등 <strong>사용자 경험(UX) 향상</strong> 면에서 가치를 갖는다. Mobile First 전략에 부합한다.</p><p>그러나 모든 Software Architecture에는 trade-off가 존재하므로 SPA 또한 구조적인 단점을 갖는다.</p><h4 id="초기-구동-속도가-느리다"><a href="#초기-구동-속도가-느리다" class="headerlink" title="초기 구동 속도가 느리다."></a>초기 구동 속도가 느리다.</h4><p>SPA는 Web Application에 필요한 모든 static resource를 최초 한 번에 다운로드 하므로 초기 구동 속도가 상대적으로 느리다. 그러나 한 번 다운로드가 이루어진 이후에는 모든 resource를 가지고 있으므로 속도가 향상된다.</p><h4 id="SEO-Search-Engine-Optimization-Issue"><a href="#SEO-Search-Engine-Optimization-Issue" class="headerlink" title="SEO(Search Engine Optimization) Issue"></a>SEO(Search Engine Optimization) Issue</h4><p>SPA는 Server Rendering 방식이 아닌, 자바스크립트 기반 비동기 모델(Client Rendering 방식)이다. 따라서 SEO가 단점으로 꼽힌다. 그러나 Angular 또는 React 등의 SPA 프레임워크는 Server Side Rendering을 지원하는 SEO 대응 기술이 존재하고 있다.</p><blockquote><h3 id="Web-Page-vs-Web-Application"><a href="#Web-Page-vs-Web-Application" class="headerlink" title="Web Page vs. Web Application"></a>Web Page vs. Web Application</h3><p>일반적인 정보를 제공하는 단순한 웹 사이트는 Web Page</p><p>사용자가 웹 사이트에서 <strong>일 (데이터를 입력, 저장, 수정, 삭제 등등)</strong>을 하면 Web Application</p></blockquote><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>Routing은 source에서 destination까지의 경로를 결정하는 기능이다. <strong>Application의 routing</strong>은 사용자가 task를 수행하기 위해서 어떤 화면(view)에서 다른 화면으로 화면을 전환하는 Navigation을 관리하기 위한 기능을 의미한다.</p><p>일반적으로 <strong>사용자가 요청한 URL 또는 Event를 해석하고 새로운 페이지로 전환하기 위한 데이터를 얻기 위해서 서버에 필요한 데이터를 요청하고 화면을 전환하는 행위</strong>를 말한다.</p><h4 id="브라우저가-화면을-전환하는-경우-3"><a href="#브라우저가-화면을-전환하는-경우-3" class="headerlink" title="브라우저가 화면을 전환하는 경우 3"></a>브라우저가 화면을 전환하는 경우 3</h4><ol><li><p>브라우저 주소창에 URL을 입력해서 해당 페이지로 이동</p></li><li><p>웹 페이지의 링크를 클릭해서 해당 페이지로 이동할 수 있다.</p></li><li><p>브라우저의 뒤로가기, 앞으로가기 버튼으로 사용자가 방문한 웹페이지 history의 뒤, 앞으로 이동</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">window</span>.history.back();</span><br><span class="line"><span class="hljs-built_in">window</span>.history.forward();</span><br><span class="line"><span class="hljs-built_in">window</span>.history.go();</span><br></pre></td></tr></table></figure></li></ol><p>AJAX Request에 의해서 서버로부터 받은 데이터로 화면을 생성하는 경우, 브라우저 주소창의 URL은 변경되지 않는다. URL이 변경되지 않으면 사용자의 history를 관리할 수 없고 이는 SEO 이슈가 된다. <strong>history 관리를 위해서는 각 페이지가 브라우저의 주소창에서 구별할 수 있는 유일한 URL을 소유해야 한다.</strong></p><h2 id="SPA-and-Routing"><a href="#SPA-and-Routing" class="headerlink" title="SPA and Routing"></a>SPA and Routing</h2><h3 id="1-HashBang-Method"><a href="#1-HashBang-Method" class="headerlink" title="1. HashBang Method"></a>1. HashBang Method</h3><p>html 내에서 element의 id 앞에 #를 붙이면 <strong>페이지 리소스를 다시 요청하지 않는다</strong>. 그러나 주소창의 uri는 변경되므로 <strong>페이지마다 고유한 uri를 만들어 history를 이용할 수 있다</strong>.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>SPA<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css/style.css"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/index.js"</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#service"</span>&gt;</span>Service<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#about"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app-root"</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> root = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.app-root'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> json = <span class="hljs-built_in">JSON</span>.parse(data);</span><br><span class="line">    root.innerHTML = <span class="hljs-string">`&lt;h1&gt;<span class="hljs-subst">$&#123;json.title&#125;</span>&lt;/h1&gt;&lt;p&gt;<span class="hljs-subst">$&#123;json.content&#125;</span>&lt;/p&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderHtml</span>(<span class="hljs-params">html</span>) </span>&#123;</span><br><span class="line">    root.innerHTML = html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><br><span class="line">      req.open(<span class="hljs-string">'GET'</span>, url);</span><br><span class="line">      req.send();</span><br><span class="line"></span><br><span class="line">      req.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (req.readyState === XMLHttpRequest.DONE) &#123;</span><br><span class="line">          <span class="hljs-keyword">if</span> (req.status === <span class="hljs-number">200</span>) resolve(req.response);</span><br><span class="line">          <span class="hljs-keyword">else</span> reject(req.statusText);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// switch 문 대신 쓰는 방법</span></span><br><span class="line">  <span class="hljs-keyword">const</span> routes = &#123;</span><br><span class="line">    <span class="hljs-string">''</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">get</span>('/data/home.json').then(render);</span><br><span class="line">    &#125;,</span><br><span class="line">    'service': function () &#123;</span><br><span class="line">      <span class="hljs-keyword">get</span>('/data/service.json').then(render);</span><br><span class="line">    &#125;,</span><br><span class="line">    'about': function () &#123;</span><br><span class="line">      <span class="hljs-keyword">get</span>('/data/about.html').then(renderHtml);</span><br><span class="line">    &#125;,</span><br><span class="line">    otherwise() &#123;</span><br><span class="line">      root.innerHTML = <span class="hljs-string">`<span class="hljs-subst">$&#123;location.hash&#125;</span> Not Found`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">router</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// url의 hash를 취득</span></span><br><span class="line">    <span class="hljs-keyword">const</span> hash = location.hash.replace(<span class="hljs-string">'#'</span>, <span class="hljs-string">''</span>);</span><br><span class="line">    <span class="hljs-comment">// property 참조 방식 1. o.prop 2. o['prop']</span></span><br><span class="line">    (routes[hash] || routes.otherwise)();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 네비게이션을 클릭하면 uri의 hash가 변경된다. 주소창의 uri가 변경되므로 history 관리가 가능하다.</span></span><br><span class="line">  <span class="hljs-comment">// 이때 uri의 hash만 변경되면 서버로 요청을 수행하지 않는다.</span></span><br><span class="line">  <span class="hljs-comment">// 따라서 uri의 hash가 변경하면 발생하는 이벤트인 hashchange 이벤트를 사용하여 hash의 변경을 감지하여 필요한 AJAX 요청을 수행한다.</span></span><br><span class="line">  <span class="hljs-comment">// hash 방식의 단점은 uri에 불필요한 #이 들어간다는 것이다.</span></span><br><span class="line">  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'hashchange'</span>, router);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// DOMContentLoaded은 HTML과 script가 로드된 시점에 발생하는 이벤트로 load 이벤트보다 먼저 발생한다. (IE 9 이상 지원)</span></span><br><span class="line">  <span class="hljs-comment">// 새로고침이 클릭되었을 때, 웹페이지가 처음 로딩되었을 때, 현 페이지(예를들어 loclahost:5003/#service)를 요청하므로 index.html이 재로드되고 DOMContentLoaded 이벤트가 발생하여 router가 호출된다.</span></span><br><span class="line">  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, router);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>결국 HashBang의 목적은 주소창의 uri가 바뀌어도 서버로 해당 uri를 요청하지 않는 것인데, HTML5에서 이를 지원하는 기능을 도입했다.</p><h4 id="DOMContentLoaded-and-load"><a href="#DOMContentLoaded-and-load" class="headerlink" title="DOMContentLoaded and load"></a>DOMContentLoaded and load</h4><p><strong>DOMContentLoaded 이벤트</strong>는 DOM이 만들어지면 발생하는 이벤트로 load 이벤트보다 먼저 발생한다.</p><p><strong>load 이벤트</strong>는 모든 리소스를 다 load했을 때 발생하는 이벤트이다.</p><h3 id="2-PJAX-Method"><a href="#2-PJAX-Method" class="headerlink" title="2. PJAX Method"></a>2. PJAX Method</h3><p>HTML5의 Histroy API인 <a href="https://developer.mozilla.org/ko/docs/Web/API/History_API" target="_blank" rel="noopener">pushState</a>와 <a href="https://developer.mozilla.org/ko/docs/Web/Reference/Events/popstate" target="_blank" rel="noopener">popstate 이벤트</a>를 사용한 PJAX 방식이다. pushState와 popstate은 IE 10 이상에서 동작한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="hljs-string">"viewport"</span> content=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="hljs-string">"X-UA-Compatible"</span> content=<span class="hljs-string">"ie=edge"</span>&gt;</span><br><span class="line">  &lt;title&gt;PJAX&lt;<span class="hljs-regexp">/title&gt;</span></span><br><span class="line"><span class="hljs-regexp">  &lt;link rel="stylesheet" href="css/</span>style.css<span class="hljs-string">"&gt;</span></span><br><span class="line"><span class="hljs-string">  &lt;script src="</span>js/index.js<span class="hljs-string">" defer&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;/head&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;body&gt;</span></span><br><span class="line"><span class="hljs-string">  &lt;nav&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;ul id="</span>navigation<span class="hljs-string">"&gt;</span></span><br><span class="line"><span class="hljs-string">      &lt;li&gt;&lt;a href="</span>/<span class="hljs-string">"&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="hljs-string">      &lt;li&gt;&lt;a href="</span>/service<span class="hljs-string">"&gt;Service&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="hljs-string">      &lt;li&gt;&lt;a href="</span>/about<span class="hljs-string">"&gt;About&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="hljs-string">  &lt;/nav&gt;</span></span><br><span class="line"><span class="hljs-string">  &lt;div class="</span>app-root<span class="hljs-string">"&gt;Loading...&lt;/div&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;/body&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>이는 Server Side Rendering (Server에서 html을 주는 것)방식과 AJAX 방식이 혼합된 것이다. 그러나 브라우저의 새로고침 버튼을 클릭하면 요청이 서버로 전달된다. 따라서 복잡한 처리가 요구된다.</p><p>모던 웹 SPA를 구현하기 위해서는 프레임워크를 사용하는 게 좋을 것 같다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SPA-Single-Page-Application&quot;&gt;&lt;a href=&quot;#SPA-Single-Page-Application&quot; class=&quot;headerlink&quot; title=&quot;SPA (Single Page Application)&quot;&gt;&lt;/a&gt;SPA (Single Page Application)&lt;/h2&gt;&lt;p&gt;Single Page Application은 모던 웹 패러다임으로, 기본적으로 하나의 페이지로 구성된다. 하나의 페이지라는 것은 html 파일이 하나라는 뜻이다. 기존의 Sever-side 렌더링과 비교할 때 배포가 간단하고 &lt;strong&gt;Native application과 유사한 UX를 제공할 수 있다는 장점&lt;/strong&gt;이 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="자바스크립트" scheme="https://sub2n.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="SPA" scheme="https://sub2n.github.io/tags/SPA/"/>
    
      <category term="Single Page Application" scheme="https://sub2n.github.io/tags/Single-Page-Application/"/>
    
      <category term="Routing" scheme="https://sub2n.github.io/tags/Routing/"/>
    
  </entry>
  
  <entry>
    <title>35. Closure</title>
    <link href="https://sub2n.github.io/2019/06/07/35-Closure/"/>
    <id>https://sub2n.github.io/2019/06/07/35-Closure/</id>
    <published>2019-06-07T03:59:09.000Z</published>
    <updated>2019-06-11T08:26:18.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Purpose-of-Closure-Maintain-Status"><a href="#Purpose-of-Closure-Maintain-Status" class="headerlink" title="Purpose of Closure: Maintain Status"></a>Purpose of Closure: Maintain Status</h2><p>클로저의 주된 목적은 <strong>안전한</strong> 상태 유지를 하는 것이다. 다른 객체지향 프로그래밍 언어의 경우 private, public, protect 등의 접근 제한자(Access Specifier)를 제공하지만 자바스크립트에는 그런 기능이 없다. (ES6의 Class에 private이 도입된다고 하지만 아직 완벽하게 적용되지 않음) 자바스크립트의 클로저를 사용하면 상태를 안전하게 유지할 수 있다.</p><a id="more"></a><h2 id="What-is-Closure"><a href="#What-is-Closure" class="headerlink" title="What is Closure?"></a>What is Closure?</h2><blockquote><p>“A closure is the combination of a function and the lexical environment within which that function was declared.”</p><p> 클로저는 함수와 그 함수가 선언된 Lexical Environment의 조합이다.</p></blockquote><h3 id="함수가-선언된-Lexical-Environment"><a href="#함수가-선언된-Lexical-Environment" class="headerlink" title="함수가 선언된 Lexical Environment"></a>함수가 선언된 Lexical Environment</h3><p>함수 내부에서 정의된 함수를 중첩 함수(nested function)라고 한다. 함수 정의는 평가되어 함수 객체가 된다. <strong>함수 객체는 생성되는 시점에 실행중인 실행 컨텍스트(running execution context)의 LexicalEnvironment를 자신의 상위 스코프로 가진다.</strong> 함수 객체의 내부 슬롯 <code>[[Environment]]</code>에 running execution context의 LexicalEnvironment이 저장된다. 즉, 함수는 호출과 무관하게 선언된 위치에서 평가되어 함수 객체가 될 때 자신의 상위 스코프를 <code>[[Environment]]</code>에 저장한다. 이는 함수 객체가 소멸되기 전까지 유지되며 함수가 호출될 때마다 참조하여 상위 스코프로 삼는다. 함수가 호출되어 실행 컨텍스트가 생성될 때 Lexical Environment의 OuterLexicalEnvironmentReference에 그 함수의 <code>[[Environment]]</code>에 저장된 Lexical Environment의 참조값을 저장한다. 이렇게 함수가 어디서 호출되는지에 상관 없이 <strong>정의된 위치로 스코프를 결정하는 것을 Lexical Scope</strong>(또는 Static Scope)라고 한다.</p><p>스코프의 실체는 렉시컬 환경이다.</p><h3 id="함수-객체의-내부-슬롯-Environment"><a href="#함수-객체의-내부-슬롯-Environment" class="headerlink" title="함수 객체의 내부 슬롯 [[Environment]]"></a>함수 객체의 내부 슬롯 <code>[[Environment]]</code></h3><p>모든 함수 객체는 자신의 내부 슬롯 <code>[[Environment]]</code>에 상위 스코프의 참조, 즉 생성될 때 실행중이던 실행 컨텍스트의 Lexical Environment의 참조를 저장한다.</p><p>그리고 함수가 호출되어 평가될 때 생성되는 실행 컨텍스트의 OuterLexicalEnvironmentReference로 <code>[[Environment]]</code> 내부 슬롯에 저장해놓은 Lexical Environment를 바인딩해 스코프 체인을 구성한다.</p><h2 id="Closure-and-Lexical-Environment"><a href="#Closure-and-Lexical-Environment" class="headerlink" title="Closure and Lexical Environment"></a>Closure and Lexical Environment</h2><p>자바스크립트에서 함수는 1급 객체(First-class Object)이므로 값처럼 취급된다. 따라서 함수에서 함수 객체를 argument로 받거나 리턴하는 것이 가능하다. 함수를 argument로 받거나 리턴하는 함수를 고차 함수(Higher Order Function)라고 한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ①</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> x = <span class="hljs-number">10</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(x); &#125;; <span class="hljs-comment">// ②</span></span><br><span class="line">  <span class="hljs-keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수 outer를 호출하면 중첩 함수 inner를 반환한다.</span></span><br><span class="line"><span class="hljs-comment">// 그리고 함수 outer의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop된다. (life cycle 마감)</span></span><br><span class="line"><span class="hljs-keyword">const</span> innerFunc = outer(); <span class="hljs-comment">// ③</span></span><br><span class="line">innerFunc(); <span class="hljs-comment">// ④ 10</span></span><br></pre></td></tr></table></figure><p>③에서 outer 함수는 중첩 함수 inner를 리턴하고 종료한다. 함수가 종료하면 실행 컨텍스트가 실행 컨텍스트 스택에서 pop된다. 소멸되는 것이다. 일반적인 함수의 경우 실행 컨텍스트가 소멸할 때 Lexical Environment도 같이 소멸한다. </p><p>그러나 위의 outer 함수처럼 <strong>자신의 중첩 함수를 리턴하며 종료하는 경우</strong>, outer의 실행 컨텍스트는 소멸하더라도 중첩 함수 inner가 내부 슬롯 <code>[[Environment]]</code>로 outer의 Lexical Environment를 참조하고 있으므로 Reference Count가 남아있는 <strong>outer의 Lexical Environment는 소멸하지 않는다</strong>. </p><p>따라서 inner 함수가 호출되어 inner 실행 컨텍스트를 생성할 때마다 outer의 Lexical Environment를 자신의 상위 스코프로 삼고 outer의 변수를 참조할 수 있는 것이다. outer의 x와 같은 변수를 자유 변수(free variable)라고 한다.</p><p>outer는 종료했으므로 outer의 Lexical Environment에 접근할 수 있는 것은 참조값을 가지고 있는 inner 함수 뿐이다. 따라서 outer 내부의 상태가 안전하게 유지된다.</p><p>이론적으로 모든 함수는 기본적으로 클로저이지만, 모던 브라우저에서는 상위 스코프의 식별자를 참조하지 않는 중첩 함수의 경우 해당 함수의 외부 Lexical Environment를 유지하지 않는다. 또한 외부 함수 내부에서 호출되는 등, 외부 함수와 life cycle을 함께 하는 중첩 함수도 클로저라고 하지 않는다.<br>따라서 일반적으로 <strong>클로저</strong>는 <strong>자신의 외부 함수보다 오래 살아남고</strong>, 자신이 기억하는 <strong>상위 스코프의 식별자를 참조하는 함수</strong>를 말한다.</p><h2 id="Usage-of-Closure"><a href="#Usage-of-Closure" class="headerlink" title="Usage of Closure"></a>Usage of Closure</h2><p>클로저는 상태를 안전하게 유지하기 위해서 사용한다. 즉, 상태가 의도치 않게 변경되지 않도록 정보 은닉(Information hiding)을 통해 캡슐화(Encapsulation) 하는 것이다.</p><p>어떤 상태를 안전하게 유지하기 위해서는 그 상태에 접근할 수 있는 방법을 제한해야한다. 즉, 상태 변경을 위해서 사용하는 메소드를 제외한 다른 외부로부터 상태를 숨겨야 한다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"increase"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"counter"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"decrease"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">const</span> $counter = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.counter'</span>);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">const</span> counter = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 카운트 상태를 유지하기 위한 자유 변수</span></span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 클로저를 메소드로 갖는 객체를 반환한다.</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 객체 리터럴은 스코프를 만들지 않는다.</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 따라서 아래 메소드들의 상위 스코프는 즉시 실행 함수의 스코프이다.</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="line"><span class="hljs-actionscript">        <span class="hljs-comment">// num: 0, // 프로퍼티는 public이므로 정보 은닉이 되지 않는다.</span></span></span><br><span class="line"><span class="hljs-undefined">        increase() &#123;</span></span><br><span class="line"><span class="hljs-actionscript">          $counter.textContent = ++num; <span class="hljs-comment">// 상태 변경</span></span></span><br><span class="line"><span class="hljs-undefined">        &#125;,</span></span><br><span class="line"><span class="hljs-undefined">        decrease() &#123;</span></span><br><span class="line"><span class="hljs-actionscript">          <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;</span></span><br><span class="line"><span class="hljs-actionscript">          $counter.textContent = --num; <span class="hljs-comment">// 상태 변경</span></span></span><br><span class="line"><span class="hljs-undefined">        &#125;</span></span><br><span class="line"><span class="hljs-undefined">      &#125;;</span></span><br><span class="line"><span class="hljs-undefined">    &#125;());</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.increase'</span>).onclick = counter.increase;</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.decrease'</span>).onclick = counter.decrease;</span></span><br><span class="line"><span class="hljs-undefined">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위의 스크립트가 실행되면 IIFE(즉시 실행 함수)가 호출되고 <strong>리턴문이 실행될 때 리턴하는 객체가 생성된다</strong>. <strong>객체가 생성될 때 객체의 메소드인 increase와 decrease 함수 객체 또한 생성된다</strong>. 이 때 increase와 decrease 함수는 자신이 정의될 때의 running execution context인 IIFE 실행 컨텍스트의 Lexical Environment를 <code>[[Environment]]</code>에 기억한다. 그러므로 IIFE는 한 번 호출되고 종료했지만 리턴되어 counter 변수에 저장된 객체의 메소드로서 increase, decrease 함수가 호출될 때마다 IIFE의 Lexical Environment에 등록된 num에 접근하고 상태를 변경할 수 있는 것이다. 다시 말하면 increase, decrease 함수 외에는 num에 접근할 방법이 없으므로 num의 상태가 안전하게 유지된다.</p><p>이를 생성자 함수로 바꾸면 객체의 프로퍼티는 public이므로 다음과 같이 구현해야 한다. </p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"increase"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"counter"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"decrease"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">const</span> $counter = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.counter'</span>);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">const</span> Counter = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// ① 카운트 상태를 유지하기 위한 자유 변수</span></span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span><span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">        <span class="hljs-comment">// this.num = 0; // ② 프로퍼티는 public이므로 정보 은닉이 되지 않는다.</span></span></span><br><span class="line"><span class="hljs-undefined">      &#125;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      Counter.prototype.increase = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-undefined">        $counter.textContent = ++num;</span></span><br><span class="line"><span class="hljs-undefined">      &#125;;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      Counter.prototype.decrease = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">        <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;</span></span><br><span class="line"><span class="hljs-undefined">        $counter.textContent = --num;</span></span><br><span class="line"><span class="hljs-undefined">      &#125;;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-keyword">return</span> Counter; <span class="hljs-comment">// Counter.prototype에 method 정의했으므로 Counter 함수 객체만 리턴</span></span></span><br><span class="line"><span class="hljs-undefined">    &#125;());</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter();</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.increase'</span>).onclick = counter.increase;</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.decrease'</span>).onclick = counter.decrease;</span></span><br><span class="line"><span class="hljs-undefined">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>생성자 함수의 프로퍼티가 아니라 자유 변수로 상태를 안전하게 유지한다. Counter.prototype의 메소드는 IIFE에서 정의되었으므로 IIFE의 변수 num에 접근할 수 있다.</p><h4 id="함수형-프로그래밍"><a href="#함수형-프로그래밍" class="headerlink" title="함수형 프로그래밍"></a>함수형 프로그래밍</h4><p>변수의 사용을 가급적 자제하고, 상태 변화를 최소화 시키는 방법으로 프로그래밍 한다. mutable data를 피하고 <strong>immutable을 지향</strong>하는 함수형 프로그래밍에서 프로그래밍의 안정성을 높이기 위해 클로저는 적극적으로 사용된다. mutable value는 참조값이 전달되므로(Pass by reference) shared data가 되어 상태 변화의 위험성이 높아진다. 또한 외부 상태가 아니라 자신의 지역변수만을 변경시키는 pure function (순수 함수)의 사용을 지향한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 함수를 인자로 전달받고 함수를 반환하는 고차 함수</span></span><br><span class="line"><span class="hljs-comment">// 이 함수가 반환하는 함수는 클로저로서 카운트 상태를 유지하기 위한 자유 변수 counter을 기억한다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span>(<span class="hljs-params">predicate</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 카운트 상태를 유지하기 위한 자유 변수</span></span><br><span class="line">  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 클로저를 반환</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 인자로 전달 받은 보조 함수에 상태 변경을 위임한다.</span></span><br><span class="line">    counter = predicate(counter);</span><br><span class="line">    <span class="hljs-keyword">return</span> counter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 보조 함수</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increase</span>(<span class="hljs-params">n</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 보조 함수</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrease</span>(<span class="hljs-params">n</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> --n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수로 함수를 생성한다.</span></span><br><span class="line"><span class="hljs-comment">// makeCounter 함수는 보조 함수를 인자로 전달받아 함수를 반환한다</span></span><br><span class="line"><span class="hljs-keyword">const</span> increaser = makeCounter(increase); <span class="hljs-comment">// ①</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(increaser()); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(increaser()); <span class="hljs-comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> decreaser = makeCounter(decrease); <span class="hljs-comment">// ②</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(decreaser()); <span class="hljs-comment">// -1</span></span><br></pre></td></tr></table></figure><h2 id="Closure-Mistake"><a href="#Closure-Mistake" class="headerlink" title="Closure Mistake"></a>Closure Mistake</h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = [];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; j++) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(arr[j]()); <span class="hljs-comment">// 5 5 5 5 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제의 실행 결과는 5 5 5 5 5이다. 이유는 <code>var</code> 키워드로 선언한 i는 block-level scope를 지원하지 않기 때문이다. 즉, for문의 block이 scope를 만들지 않아서 arr의 element에 저장된 함수 객체들이 자신의 상위 스코프로 전역 렉시컬 환경을 기억한다.</p><p>이는 for 문 내부의 선언문에 <code>let</code> 키워드를 사용함으로써 보완할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = [];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(arr[i]()); <span class="hljs-comment">// 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 문은 자바스크립트 엔진에 의해 평가될 때 내부 선언문이 <code>let</code>인지, <code>var</code>인지, expression인지에 따라서 다르게 동작한다. <code>let</code> 키워드로 선언된 선언문일 경우 block-level scope를 만들어야하므로 LOOP Lexical Environment를 우선 생성하고 i를 환경 레코드에 등록한다. 그리고 나서 for문의 body를 평가하고 실행하는데 한 반복 당 하나의 per Iteration Lexical Environment를 생성하고, i의 값이 유효한지 검사하고, statement를 실행한 후 다음 반복을 위한 per Iteration Lexical Environment를 생성하고 increment를 진행한다. 이를 반복한다. 따라서 각 Iteration에서 생성된 함수는 각각 다른 Lexical Environment를 자신의 <code>[[Environment]]</code>로 참조하고 있기 때문에 원하는 결과를 얻을 수 있는 것이다.</p><p>비슷하게 Iterable에 사용할 수 있는 for of 문, 객체의 프로퍼티 순회에 사용할 수 있는 for in  문 내부의 선언문에 <code>const</code> 키워드를 사용할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> o) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(o[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> arr = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이는 for of, for in 문의 선언부의 선언문은 for문 body 가장 상단에서 실행되는 것과 같이 동작하기 때문이다. 즉, 반복하는 횟수만큼 선언된다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Purpose-of-Closure-Maintain-Status&quot;&gt;&lt;a href=&quot;#Purpose-of-Closure-Maintain-Status&quot; class=&quot;headerlink&quot; title=&quot;Purpose of Closure: Maintain Status&quot;&gt;&lt;/a&gt;Purpose of Closure: Maintain Status&lt;/h2&gt;&lt;p&gt;클로저의 주된 목적은 &lt;strong&gt;안전한&lt;/strong&gt; 상태 유지를 하는 것이다. 다른 객체지향 프로그래밍 언어의 경우 private, public, protect 등의 접근 제한자(Access Specifier)를 제공하지만 자바스크립트에는 그런 기능이 없다. (ES6의 Class에 private이 도입된다고 하지만 아직 완벽하게 적용되지 않음) 자바스크립트의 클로저를 사용하면 상태를 안전하게 유지할 수 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="자바스크립트" scheme="https://sub2n.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
  </entry>
  
</feed>
