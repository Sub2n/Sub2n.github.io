<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>수빈 개발블로그</title>
  
  <subtitle>Sub2n Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sub2n.github.io/"/>
  <updated>2019-05-15T11:02:33.685Z</updated>
  <id>https://sub2n.github.io/</id>
  
  <author>
    <name>Subin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>21. Number, Math, Date and String Object</title>
    <link href="https://sub2n.github.io/2019/05/15/21-Number-Math-Date-and-String-Object/"/>
    <id>https://sub2n.github.io/2019/05/15/21-Number-Math-Date-and-String-Object/</id>
    <published>2019-05-15T10:23:44.000Z</published>
    <updated>2019-05-15T11:02:33.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Number-wrapper-object"><a href="#1-Number-wrapper-object" class="headerlink" title="1. Number wrapper object"></a>1. Number wrapper object</h1><p>Number 객체 : primitive type number를 다룰 때 유용한 프로퍼티와 메소드를 제공하는 wrapper 객체. 변수 또는 객체의 프로퍼티의 값이 숫자라면 Number 객체를 별도로 생성하지 않고 Number 객체의 프로퍼티와 메소드를 사용할 수 있다.</p><p>Primitive type이 wrapper 객체의 메소드를 사용할 수 있는 이유: primitive type으로 wrapper 객체의 프로퍼티나 메소드를 호출할 때 일시적으로 해당 타입과 연관된 wrapper 객체로 변환해 프로토타입 객체를 공유하기 때문.</p><h2 id="1-1-Number-Constructor"><a href="#1-1-Number-Constructor" class="headerlink" title="1.1 Number Constructor"></a>1.1 Number Constructor</h2><p>Number 객체는 Number() 생성자 함수를 통해 생성한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> y = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-string">'123'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> z = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-string">'string'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 123</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(y); <span class="hljs-comment">// 123</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(z); <span class="hljs-comment">// NaN</span></span><br></pre></td></tr></table></figure><p>new 연산자 없이 Number() 함수를 사용하면 Number 객체가 아니라 primitive type number를 반환한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> x = <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> y = <span class="hljs-built_in">Number</span>(<span class="hljs-string">'123'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> z = <span class="hljs-built_in">Number</span>(<span class="hljs-string">'string'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 123</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(y); <span class="hljs-comment">// 123</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(z); <span class="hljs-comment">// NaN</span></span><br></pre></td></tr></table></figure><p>이를 이용해 형변환을 할 수 있다.</p><h2 id="1-2-Number-Property"><a href="#1-2-Number-Property" class="headerlink" title="1.2. Number Property"></a>1.2. Number Property</h2><p>Number 객체의 프로퍼티는 static property로, Number 객체를 생성할 필요 없이 Number.propertyName의 형태로 사용한다.</p><blockquote><h4 id="Static-Property"><a href="#Static-Property" class="headerlink" title="Static Property"></a>Static Property</h4><p>ES6에서 도입된 <code>static</code> keyword는 클래스 정의 내부에 static method를 정의할 수 있게끔 해준다. Static method는 클래스의 인스턴트 없이 호출 가능하며, 클래스가 인스턴스화되면 호출할 수 없다.</p></blockquote><h3 id="1-2-1-Number-EPSILONES6"><a href="#1-2-1-Number-EPSILONES6" class="headerlink" title="1.2.1. Number.EPSILONES6"></a>1.2.1. Number.EPSILON<sup>ES6</sup></h3><p>Number.EPSILON은 JavaScript에서 표현할 수 있는 가장 작은 수를 나타낸다. EPSILON은 컴퓨터에서 부동소숫점을 표현하는 데에 한계가 있기 때문에 발생하는 오차이다. 컴퓨터가 표현할 수있는 어떤 임의의 수와, 그 바로 다음으로 표현할 수 있는 수와의 차이를 EPSILON이라고 한다. </p><p>컴퓨터에서 부동소숫점 수를 비교할 때는 Number.EPSILON을 사용하여 두 수의 차이가 최소 오차인 Number.EPSILON보다 작으면 같은 수로 인정한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> === <span class="hljs-number">0.3</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-comment">// 0.1 + 0.2 = 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEqual</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(a - b) &lt; <span class="hljs-built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(isEqual(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-Number-MAX-VALUEES1"><a href="#1-2-2-Number-MAX-VALUEES1" class="headerlink" title="1.2.2. Number.MAX_VALUEES1"></a>1.2.2. Number.MAX_VALUE<sup>ES1</sup></h3><p>Number.MAX_VALUE는 JavaScript에서 사용 가능한 가장 큰 숫자를 반환한다. MAX_VALUE보다 큰 숫자는 Infinity이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>.MAX_VALUE; <span class="hljs-comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="hljs-keyword">const</span> num = <span class="hljs-built_in">Number</span>.MAX_VALUE + <span class="hljs-number">1</span>; <span class="hljs-comment">// num = Number.MAX_VALUE</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">Infinity</span> &gt; <span class="hljs-built_in">Number</span>.MAX_VALUE); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-Number-MIN-VALUEES1"><a href="#1-2-3-Number-MIN-VALUEES1" class="headerlink" title="1.2.3. Number.MIN_VALUEES1"></a>1.2.3. Number.MIN_VALUE<sup>ES1</sup></h3><p>Number.MIN_VALUE는 JavaScript에서 사용 가능한 가장 작은 숫자를 반환한다. MIN_VALUE는 0에 가장 가까운 양수 값이다. MIN_VALUE보다 작은 숫자는 0으로 변환된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>.MIN_VALUE; <span class="hljs-comment">// 5e-324</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MinEpsilon</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.MIN_VALUE &gt; <span class="hljs-built_in">Number</span>.EPSILON) &#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'MIN_VALUE &gt; EPSILON'</span>);</span><br><span class="line"> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.MIN_VALUE &lt; <span class="hljs-built_in">Number</span>.EPSILON) &#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'MIN_VALUE &lt; EPSILON'</span>);</span><br><span class="line"> &#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'MIN_VALUE = EPSILON'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinEpsilon(); <span class="hljs-comment">// MIN_VALUE &lt; EPSILON</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Number-wrapper-object&quot;&gt;&lt;a href=&quot;#1-Number-wrapper-object&quot; class=&quot;headerlink&quot; title=&quot;1. Number wrapper object&quot;&gt;&lt;/a&gt;1. Number wrappe
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Number" scheme="https://sub2n.github.io/tags/Number/"/>
    
      <category term="Math" scheme="https://sub2n.github.io/tags/Math/"/>
    
      <category term="Date" scheme="https://sub2n.github.io/tags/Date/"/>
    
      <category term="String" scheme="https://sub2n.github.io/tags/String/"/>
    
      <category term="Wrapper" scheme="https://sub2n.github.io/tags/Wrapper/"/>
    
  </entry>
  
  <entry>
    <title>190515-TIL</title>
    <link href="https://sub2n.github.io/2019/05/15/190515-TIL/"/>
    <id>https://sub2n.github.io/2019/05/15/190515-TIL/</id>
    <published>2019-05-15T07:38:04.000Z</published>
    <updated>2019-05-15T08:51:59.648Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h4><ul><li>자바스크립트의 Strict Mode, 전역 객체 window, this 바인딩에 대해서 배웠다.</li><li>Underscore의 each 메소드를 구현했다.</li><li>자바스크립트 알고리즘 문제 3개를 풀었다.<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// if문 사용</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evenOrOdd</span>(<span class="hljs-params">num</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span>) &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'Odd'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">'Even'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 3항 연산자 사용</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evenOrOdd2</span>(<span class="hljs-params">num</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> num % <span class="hljs-number">2</span> ? <span class="hljs-string">'Odd'</span> : <span class="hljs-string">'Even'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evenOrOdd(<span class="hljs-number">42</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evenOrOdd(<span class="hljs-number">55</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evenOrOdd2(<span class="hljs-number">288</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evenOrOdd2(<span class="hljs-number">25</span>));</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// #2. 1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기 (Google)</span></span><br><span class="line"><span class="hljs-comment">// 1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 단, 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. 예를 들어 8808은 3, 8888은 4로 카운팅 해야 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// (hint) 문자열 중 n번째에 있는 문자 : str.charAt(n) or str[n]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCount8</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">let</span> concatString = <span class="hljs-string">''</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10001</span>; i++) &#123;</span><br><span class="line">  concatString += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; concatString.length; j++) &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (concatString[j] === <span class="hljs-string">'8'</span>) &#123;</span><br><span class="line">    count += <span class="hljs-number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(getCount8()); <span class="hljs-comment">// 4000</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 3. 문자열 다루기</span></span><br><span class="line"><span class="hljs-comment">// alphaString46 함수는 문자열 s를 매개변수로 입력받는다. s의 길이가 4 ~ 6이고, 숫자로만 구성되어 있는지 확인하는 alphaString46 함수를 완성하라.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 예를 들어 s가 'a234'이면 false를 리턴하고 '1234'라면 true를 리턴한다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alphaString46</span>(<span class="hljs-params">s</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (s === <span class="hljs-literal">undefined</span> || s.length &lt; <span class="hljs-number">4</span> || s.length &gt; <span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="hljs-comment">// eslint-disable-next-line no-restricted-globals</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(s[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46(<span class="hljs-string">'1234'</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46(<span class="hljs-string">'9014'</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46(<span class="hljs-string">'723'</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46(<span class="hljs-string">'a234'</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46(<span class="hljs-string">''</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46());</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트의 Stri
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Underscore: each</title>
    <link href="https://sub2n.github.io/2019/05/15/Underscore-each/"/>
    <id>https://sub2n.github.io/2019/05/15/Underscore-each/</id>
    <published>2019-05-15T04:08:16.000Z</published>
    <updated>2019-05-15T10:22:40.073Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/48080762/57747874-59ba2980-7712-11e9-8a09-b7f1825254e4.png" alt="each pass"></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_.each = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection, iterator</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(collection)) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; collection.length; index++) &#123;</span><br><span class="line">      iterator(collection[index], <span class="hljs-built_in">Number</span>(index), collection);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> collection) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (key !== <span class="hljs-string">'someProperty'</span>)</span><br><span class="line">        iterator(collection[key], key, collection);</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/48080762/57747874-59ba2980-7712-11e9-8a09-b7f1825254e4.png&quot; alt=&quot;each pass&quot;&gt;&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://sub2n.github.io/categories/Algorithm/"/>
    
      <category term="UnderScore" scheme="https://sub2n.github.io/categories/Algorithm/UnderScore/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Algorithm" scheme="https://sub2n.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>20. this</title>
    <link href="https://sub2n.github.io/2019/05/15/20-this/"/>
    <id>https://sub2n.github.io/2019/05/15/20-this/</id>
    <published>2019-05-15T03:45:06.000Z</published>
    <updated>2019-05-15T10:20:40.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-this-Keyword"><a href="#1-this-Keyword" class="headerlink" title="1. this Keyword"></a>1. this Keyword</h1><p>this는 객체가 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다. 함수 호출시 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. arguments 객체와 this는 함수 내부에서 지역 변수처럼 사용할 수 있다. this가 가리키는 값은 <strong>함수 호출 방식에 의해 동적으로 결정</strong>된다.</p><p>C++, Java와 같은 클래스 기반 언어에서 this는 항상 클래스로부터 생성되는 인스턴스를 가리킨다. 그러나 자바스크립트의 this는 함수가 호출되는 방식에 따라서 this에 바인딩될 객체가 동적으로 결정된다.</p><blockquote><h4 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h4><p>바인딩이란 식별자와 값을 연결하는 과정을 의미한다.</p></blockquote><p>객체 리터럴은 할당 단계에 평가되므로 객체의 식별자를 this 대신 사용할 수 있지만, 일반적이지 않다. 생성자를 이용해서 객체를 생성할 때는 인스턴트를 가리킬 식별자를 미리 알 수 없기 때문이다.</p><p>this는 객체의 프로퍼티나 메소드를 참조하기 위한 변수이므로 객체의 메소드 또는 생성자 함수에서만 의미가 있다. strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩 된다. 적용되지 않을 경우 일반 함수 내부에서 this는 전역 객체 window를 가리킨다.</p><blockquote><h4 id="strict-mode"><a href="#strict-mode" class="headerlink" title="strict mode"></a>strict mode</h4><p>‘use strict’;  strict mode는 자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.</p></blockquote><h1 id="2-Function-call-types-and-this-Binding"><a href="#2-Function-call-types-and-this-Binding" class="headerlink" title="2. Function call types and this Binding"></a>2. Function call types and this Binding</h1><p><strong>스코프</strong>의 경우 렉시컬 스코프(Lexical Scope)는 <strong>함수 정의가 평가되어 함수 객체가 생성되는 시점</strong>에 상위 스코프가 결정된다. <strong>this</strong>에 바인딩될 객체는 <strong>함수 호출 시점</strong>에 결정된다.</p><p>함수 호출 방식은 다음과 같다.</p><ol><li>일반 함수 호출 : this는 window</li><li>메소드 호출 : this는 메소드를 호출한 객체</li><li>생성자 함수 호출 : this는 생성할 instance</li><li>Function.prototype.apply/call/bind 메소드에 의한 간접 호출 (??)</li></ol><h2 id="2-1-General-Function-Call"><a href="#2-1-General-Function-Call" class="headerlink" title="2.1. General Function Call"></a>2.1. General Function Call</h2><p><strong>일반 함수로 호출된 함수 내부의 this</strong>에는 <strong>전역 객체(Global Object)</strong>가 바인딩된다.</p><p>전역 함수는 물론 <strong>중첩 함수를 일반 함수로 호출했을 때에도 함수 내부의 this에는 전역 객체가 바인딩</strong>된다. 일반 함수에서는 this로 객체의 프로퍼티나 메소드를 참조할 일이 없으므로 this에 의미가 없다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo this: '</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">// window</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar this: '</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>메소드 내에서 정의한 중첩 함수일지라도 <strong>일반 함수로 호출되면 중첩 함수의 this는 전역 객체</strong>이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo this: '</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">// &#123;foo: f&#125;</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar this: '</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 메소드 내부에서 정의한 중첩 함수라도 일반 함수로 호출하면 this에 전역 객체가 바인딩된다.</span></span><br><span class="line">    bar();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure><p>마찬가지로 콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 정리하면 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.</p><p>메소드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메소드의 this 바인딩과 일치시키기 위한 방법은 다음과 같다.</p><ol><li><p>this를 변수에 저장하고 콜백 함수의 this를 변수로 대체 </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="hljs-number">100</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    cosnt that = <span class="hljs-keyword">this</span>;</span><br><span class="line">    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(that.value); <span class="hljs-comment">// 100</span></span><br><span class="line">    &#125;, <span class="hljs-number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메소드 이용</p> <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="hljs-number">100</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="hljs-comment">// bind method의 argument를 콜백 함수의 this로 바인딩한다.</span></span><br><span class="line">    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.value); <span class="hljs-comment">// 100</span></span><br><span class="line">    &#125;.bind(<span class="hljs-keyword">this</span>), <span class="hljs-number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-Method-Call"><a href="#2-2-Method-Call" class="headerlink" title="2.2. Method Call"></a>2.2. Method Call</h2><p><strong>메소드 내부의 this는 메소드를 호출한 객체</strong>, 즉 메소드 호출시 (.) 연산자 앞의 객체에 바인딩된다.</p><p>메소드를 소유한 객체가 아닌, 메소드를 호출한 객체에 바인딩된다는 것이 주의해야할 점이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> me = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Park'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> you = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Kim'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">you.getName = me.getName;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(me.getName()); <span class="hljs-comment">// "Park"</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(you.getName()); <span class="hljs-comment">// "Kim"</span></span><br></pre></td></tr></table></figure><h2 id="2-3-Constructor-Function-Call"><a href="#2-3-Constructor-Function-Call" class="headerlink" title="2.3. Constructor Function Call"></a>2.3. Constructor Function Call</h2><h2 id="2-4-Indirect-Call-by-Function-prototype-apply-call-bind-method"><a href="#2-4-Indirect-Call-by-Function-prototype-apply-call-bind-method" class="headerlink" title="2.4. Indirect Call by Function.prototype.apply / call / bind method"></a>2.4. Indirect Call by Function.prototype.apply / call / bind method</h2><h3 id="apply-call"><a href="#apply-call" class="headerlink" title="apply, call"></a>apply, call</h3><p>Function.prototype의 메소드 apply와 call은 argument로 this와 arguments list를 전달받아 함수를 호출한다. Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 Function.prototype.apply와 call을 상속받아 사용할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출한다.</span></span><br><span class="line"><span class="hljs-comment"> * @param thisArg - this로 사용될 객체</span></span><br><span class="line"><span class="hljs-comment"> * @param argsArray - 함수에게 전달할 인수 리스트 배열</span></span><br><span class="line"><span class="hljs-comment"> * @returns 호출된 함수의 반환값</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-built_in">Function</span>.prototype.apply(thisArg, [argsArray]))</span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 주어진 this 바인딩과 인수 리스트를 사용하여 함수를 호출한다.</span></span><br><span class="line"><span class="hljs-comment"> * @param thisArg - this로 사용될 객체</span></span><br><span class="line"><span class="hljs-comment"> * @param arg1, arg2, ... - 함수에게 전달할 인수 리스트</span></span><br><span class="line"><span class="hljs-comment"> * @returns 호출된 함수의 반환값</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-built_in">Function</span>.prototype.call(thisArg, arg1, arg2, ...))</span><br></pre></td></tr></table></figure><p>두 메소드의 차이는,</p><ul><li>apply 메소드는 호출할 함수의 arguments를 배열로 묶어 전달한다.</li><li>call 메소드는 호출할 함수의 arguments를 쉼표로 구분한 리스트 형식으로 전달한다.</li></ul><p>apply와 call은 호출할 함수에 argument를 전달하는 방식만 다를 뿐, this로 사용할 객체와 argument를 전달하며 함수를 호출한다.</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.callName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;</span><br><span class="line">    callback.bind(<span class="hljs-keyword">this</span>)();</span><br><span class="line">    <span class="hljs-comment">// callback.apply(this);</span></span><br><span class="line">    <span class="hljs-comment">// callback.apply(this);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind로 this를 전달한 callback을 실행할 수도 있고, apply나 call로 this를 전달하며 동시에 호출할 수도 있다.</p><p>정리하면 this 바인딩은 다음과 같이 실행된다.</p><table><thead><tr><th style="text-align:center">함수 호출 방식</th><th style="text-align:center">this 바인딩</th></tr></thead><tbody><tr><td style="text-align:center">일반 함수 호출</td><td style="text-align:center">전역 객체</td></tr><tr><td style="text-align:center">메소드 호출</td><td style="text-align:center">메소드를 호출한 객체</td></tr><tr><td style="text-align:center">생성자 함수 호출</td><td style="text-align:center">생성자 함수가 생성할 instance</td></tr><tr><td style="text-align:center">Function.prototype.apply/call/bind 메소드에 의한 간접 호출</td><td style="text-align:center">Function.prototype.apply/call/bind 메소드에 argument로 전달한 객체</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-this-Keyword&quot;&gt;&lt;a href=&quot;#1-this-Keyword&quot; class=&quot;headerlink&quot; title=&quot;1. this Keyword&quot;&gt;&lt;/a&gt;1. this Keyword&lt;/h1&gt;&lt;p&gt;this는 객체가 자신의 프로퍼티나 
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="this" scheme="https://sub2n.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>19. Global Object</title>
    <link href="https://sub2n.github.io/2019/05/15/19-Global-Object/"/>
    <id>https://sub2n.github.io/2019/05/15/19-Global-Object/</id>
    <published>2019-05-15T03:43:39.000Z</published>
    <updated>2019-05-15T06:03:04.310Z</updated>
    
    <content type="html"><![CDATA[<p>전역 객체는 어떤 객체보다도 먼저 생성하고 어느 객체에도 속하지 않는 최상위 객체.</p><ul><li><p>client side 환경(브라우저)에서는 window</p></li><li><p>server side 환경에서는 global 객체</p></li></ul><p>전역 객체는</p><ul><li>개발자가 의도적으로 생성할 수 없다.</li><li>전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.</li><li>전역 객체는 Object, String, Number,Boolean, Function, Array RegExp, Date, Math, Promise 등 모든 built-in 객체를 프로퍼티로 가지고 있다.</li><li>브라우저의 window 객체는 DOM, BOM, Canvas, XMLHttpRequest, Fetch, SVG, Web Storage 등 Client side Web API를 프로퍼티로 소유한다.</li><li>var 키워드로 선언한 전역 변수와 암묵적 전역 변수, 전역 함수는 전역 객체의 프로퍼티가 된다. (단, let이나 const 키워드로 선언한 전역 변수는 전역 객체  window의 프로퍼티가 아니다.)</li><li>전역 객체의 프로퍼티와 메소드는 window를 생략하고 참조/호출 할 수 있으므로 전역 함수처럼 사용할 수 있다.</li></ul><h1 id="1-Global-Property"><a href="#1-Global-Property" class="headerlink" title="1. Global Property"></a>1. Global Property</h1><p>전역 프로퍼티는 전역 객체의 프로퍼티이다.</p><h2 id="1-1-Infinity"><a href="#1-1-Infinity" class="headerlink" title="1.1. Infinity"></a>1.1. Infinity</h2><p>Infinity 프로퍼티는 양/음의 무한대를 나타내는 Number Infinity를 갖는다. 숫자를 0으로 나누면 NaN이 될 것 같지만 무한대를 나타낸다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>/<span class="hljs-number">0</span>);<span class="hljs-comment">// Infinity</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>/<span class="hljs-number">-0</span>);<span class="hljs-comment">// -Infinity</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">Infinity</span>);<span class="hljs-comment">// number</span></span><br></pre></td></tr></table></figure><h2 id="1-2-NaN"><a href="#1-2-NaN" class="headerlink" title="1.2. NaN"></a>1.2. NaN</h2><p>NaN(Not-a-Number) 프로퍼티는 숫자가 아님을 나타내는 Number NaN을 갖는다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">'string'</span>));<span class="hljs-comment">// NaN</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> * <span class="hljs-string">'string'</span>); <span class="hljs-comment">// NaN</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>);<span class="hljs-comment">// number</span></span><br></pre></td></tr></table></figure><h2 id="1-3-undefined"><a href="#1-3-undefined" class="headerlink" title="1.3. undefined"></a>1.3. undefined</h2><p>undefined 프로퍼티는 primitive type undefined를 값으로 갖는다.</p><h1 id="2-Global-Function"><a href="#2-Global-Function" class="headerlink" title="2. Global Function"></a>2. Global Function</h1><p>전역 함수는 전역 객체의 메소드이다. 애플리케이션 전역에서 호출할 수 있다.</p><h2 id="2-1-eval"><a href="#2-1-eval" class="headerlink" title="2.1. eval"></a>2.1. eval</h2><p>문자열로 코드를 주면 그 코드를 실행하는데, 평가시 자신의 스코프를 만들고 상위 스코프로 변형시켜 비용이 많이 든다.</p><h2 id="2-2-isFinite"><a href="#2-2-isFinite" class="headerlink" title="2.2. isFinite"></a>2.2. isFinite</h2><p>parameter에 전달된 값이 정상적인 유한수인지 검사해서 Boolean을 리턴한다. 숫자가 아닌 값 전달받으면 숫자 타입으로 변환 후 검사를 수행한다.</p><h2 id="2-3-isNaN"><a href="#2-3-isNaN" class="headerlink" title="2.3. isNaN"></a>2.3. isNaN</h2><p>parameter에 전달된 값이 NaN인지 검사해서 Boolean을 리턴한다. 숫자가 아닌 값 전달받으면 숫자 타입으로 변환 후 검사를 수행한다.</p><h2 id="2-4-parseFloat"><a href="#2-4-parseFloat" class="headerlink" title="2.4. parseFloat"></a>2.4. parseFloat</h2><p>parameter에 전달된 <strong>String을 부동소숫점 숫자(floating point number)로</strong> 변환하여 반환한다.</p><h2 id="2-5-parseInt"><a href="#2-5-parseInt" class="headerlink" title="2.5. parseInt"></a>2.5. parseInt</h2><p>parameter에 전달된 <strong>String을 정수형 숫자(Integer)로</strong> parsing하여 리턴한다. 리턴값은 10진수이다.</p><p>10진수 숫자를 10진수가 아닌 수의 문자열로 변환하고 싶을 때는 Number.prototype.toString 메소드를 사용한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> x = <span class="hljs-number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x.toString(<span class="hljs-number">2</span>));<span class="hljs-comment">// '1010'</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x.toString(<span class="hljs-number">8</span>));<span class="hljs-comment">// '12'</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x.toString(<span class="hljs-number">16</span>));<span class="hljs-comment">// 'a'</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x.toString());<span class="hljs-comment">// '10'</span></span><br></pre></td></tr></table></figure><h2 id="2-6-encodeURI-decodeURI"><a href="#2-6-encodeURI-decodeURI" class="headerlink" title="2.6. encodeURI / decodeURI"></a>2.6. encodeURI / decodeURI</h2><p>encodeURI 함수는 paremeter로 전달된 URI(Uniform Resource Identifier)를 인코딩한다.</p><blockquote><h4 id="URI-Uniform-Resource-Identifier"><a href="#URI-Uniform-Resource-Identifier" class="headerlink" title="URI (Uniform Resource Identifier)"></a>URI (Uniform Resource Identifier)</h4><p>인터넷에 있는 자원을 나타내는 유일한 주소. URI의 하위 개념으로 URL, URN이 있다.</p><ul><li>Scheme(protocol) : 통신 방식</li><li>Host : 찾아갈 server의 주소<ul><li>localhost : 컴퓨터 한 대에서 client와 server를 동시에 돌릴 때 server를 의미. Port 번호로 server에 고유 번호를 매김</li></ul></li><li>Port : port 번호</li><li>Path : file 경로<ul><li>REST API : 서버와 통신시 메소드 호출방식처럼 사용</li></ul></li><li>Query Parameter : ?key=value&amp;key=value&amp;key=value</li><li>Fragment : # page 내 이동에서 씀</li></ul></blockquote><p>인코딩이랑 URI의 문자들을 Escape 처리 하는 것을 의미한다. Escape 처리는 네트워크를 통해 정보를 공유할 때 ASCII Character-set으로 변환하는 것이다. 한글은 %EC%9E%90 등과 같이 인코딩 된다.</p><p>decodeURI 함수는 paremeter로 전달된 encoded URI을 전달받아 escape 처리 되기 전으로 디코딩한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;전역 객체는 어떤 객체보다도 먼저 생성하고 어느 객체에도 속하지 않는 최상위 객체.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;client side 환경(브라우저)에서는 window&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;server side 환경에서는 global 객
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="window" scheme="https://sub2n.github.io/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>18. JavaScript Prototype</title>
    <link href="https://sub2n.github.io/2019/05/12/18-JavaScript-Prototype/"/>
    <id>https://sub2n.github.io/2019/05/12/18-JavaScript-Prototype/</id>
    <published>2019-05-12T01:42:10.000Z</published>
    <updated>2019-05-16T01:34:57.886Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript는</p><ul><li>명령형 (Imperative)</li><li>함수형 (Functional)</li><li>프로토타입 기반 (Prototype-based) 객체지향 프로그래밍</li></ul><p>을 지원하는 멀티 패러다임 프로그래밍 언어.</p><p>프로토타입은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 방식이다.</p><p>자바스크립트는 객체 기반 프로그래밍 언어로, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다.</p><h1 id="1-Object-Oriented-Programming"><a href="#1-Object-Oriented-Programming" class="headerlink" title="1. Object-Oriented Programming"></a>1. Object-Oriented Programming</h1><p>이전에 포스팅한 객체 지향 프로그래밍 포스팅을 참고</p><p><a href="https://sub2n.github.io/2019/04/24/4-Fundamental-of-Object-Oriented-Programming/">4 Fundamental of Object Oriented Programming</a></p><p>객체지향 프로그래밍은 프로그래밍을 명령어 또는 함수의 목록으로 보는 명령형 프로그래밍의 절차지향적 관점에서 벗어나 <strong>프로그램을 여러개의 독립적 객체들의 집합으로 표현</strong>하려는 프로그래밍 패러다임을 말한다.</p><p>객체지향 프로그래밍에는 몇 가지 원칙이 있다.</p><ul><li>추상화 (abstraction) : 다양한 속성 중에서 프로그램에 필요한 속성만을 간추려내어 표현하는 것을 추상화라고 한다. 불필요한 정보는 숨기고 필요한 정보만을 표현함으로써 공토</li><li>캡슐화 (encapsulation) : 모든 객체가 자신의 상태(state, private variavles)를 클래스 내부에 private으로 보유함으로써 지켜진다. 내부 상태를 내부 메소드로만 접근할 수 있게 한다.</li><li><strong>상속 (inheritance)</strong> : 객체지향 프로그래밍의 핵심 개념으로 부모 객체의 프로퍼티를 자식 개체가 상속받아 그대로 사용할 수 있는 것을 말한다.</li><li>다형성 (polymorpism) : 부모 객체가 선언한 interface 메소드를 자식 객체가 재정의(overiding) 함으로써 하나의 interface로 상황에 따라 기능을 달리 하는 것을 말한다.</li></ul><h1 id="2-Inheritance-and-Prototype"><a href="#2-Inheritance-and-Prototype" class="headerlink" title="2. Inheritance and Prototype"></a>2. Inheritance and Prototype</h1><p>자바스크립트의 상속은 프로토타입(prototype)을 기반으로 구현된다.</p><p>상속을 사용해야 하는 이유는,</p><ol><li>동일한 프로퍼티 구조를 갖는 객체를 여러개 만들 때 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리적 관점에서 비효율적이기 때문이다. 상속을 사용하면 하나의 프로토타입을 생성해 모든 인스턴스가 공유할 수 있다.</li><li>인스턴스를 생성할 때마다 메소드를 생성하므로 퍼포먼스적으로도 비효율적이다. 상속은 코드의 재사용이란 관점에서 유용하다. 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해놓으면 생성되는 인스턴스는 메소드 생성 없이 미리 구현된 프로토타입의 프로퍼티를 사용할 수 있다.</li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Add getGeometer method to Circle's prototype object(prototype).</span></span><br><span class="line"><span class="hljs-comment">// The prototype is bound to the prototype property of the Circle constructor function.</span></span><br><span class="line">Circle.prototype.getGeometer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">this</span>.radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> circle1 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">2</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> circle2 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// All instances of Circle constuctor have same prototype(Circle constuctor function's prototype proeprety).</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(circle1) === <span class="hljs-built_in">Object</span>.getPrototypeOf(circle2)) <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(circle1) === Circle.prototype) <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="3-prototype-Object"><a href="#3-prototype-Object" class="headerlink" title="3. prototype Object"></a>3. prototype Object</h1><p><strong>Prototype Object(prototype)는 Object간의 상속을 구현하기 위해 사용된다</strong>. 프로토타입은 어떤 object의 Parent obect 역할을 하는 객체로, 다른 객체에 Shared property를 제공한다.  Prototype을 상속받은 Child object는 Parent object의 프로퍼티를 자신의 프로퍼티처럼 사용할 수 있다.</p><p>모든 객체는 <code>[[Prototype]]</code> 내부 슬롯을 가지며, 내부 슬롯의 값으로 프로토타입 객체의 참조를 저장한다. 프로토타입은 객체의 생성 방식에 의해 결정된다.</p><p>객체 리터럴로 생성된 객체의 프로토타입은 <strong>Object.prototype</strong>이고, 생성자 함수에 의해 생성된 객체의 프로토타입은 <strong>자신을 생성한 함수의 prototype 프로퍼티</strong>이다.</p><p><strong>모든 객체는 하나의 프로토타입을 가지며 모든 프로토타입은 생성자 함수와 연결되어 있다.</strong> 이는 객체와 프로토타입, 생성자 사이를 연결한다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57820069-2042f600-77c6-11e9-8292-68c91244925a.png" alt="Prototype Connection"></p><ul><li>Constructor Function : prototype property가 prototype object를 가리킴</li><li>Constructor Function.prototype Object : constructor property가 constructor function를 가리킴</li><li>Obejct : <strong> proto </strong> Accessor property로 자신을 생성한 함수의 prototype Obect에 접근할 수 있음 (내부 슬롯 <code>[[Prototype]]</code>이 가리키고 있음)</li></ul><h2 id="3-1-Object’s-proto-Accessor-Property"><a href="#3-1-Object’s-proto-Accessor-Property" class="headerlink" title="3.1. Object’s __proto__ Accessor Property"></a>3.1. Object’s __proto__ Accessor Property</h2><p>모든 객체는 <strong> proto </strong> 접근자 프로퍼티를 통해 자신의 프로토타입 (<code>[[Prototype]]</code> 내부 슬롯)에 접근할 수 있다.</p><h4 id="proto-is-an-Accessor-Property"><a href="#proto-is-an-Accessor-Property" class="headerlink" title="__proto__ is an Accessor Property"></a>__proto__ is an Accessor Property</h4><p>내부 슬롯은 프로퍼티가 아니므로 직접 접근할 수 없고 제공하는 접근자 프로퍼티를 통해서 접근할 수 있다. 접근자 프로퍼티는 접근자 함수로 구성된 프로터티다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57598149-05397180-758d-11e9-88f0-6b24cffc4ef4.png" alt="__proto__"></p><p>Object.prototype의 <strong> proto </strong> 접근자 프로퍼티는 자신의 getter, settter 함수(get, set <strong> proto </strong>)를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 가져오거나 저장한다. </p><blockquote><h4 id="Internal-Method-GetPrototypeOf-amp-SetPrototypeOf"><a href="#Internal-Method-GetPrototypeOf-amp-SetPrototypeOf" class="headerlink" title="Internal Method [[GetPrototypeOf]] &amp; [[SetPrototypeOf]]"></a>Internal Method [[GetPrototypeOf]] &amp; [[SetPrototypeOf]]</h4><p>get <strong> proto </strong>는 자신의 프로토타입 취득시 [[GetPrototypeOf]] 내부 메소드를 호출</p><p>set <strong> proto </strong>는 새로운 프로토타입 할당시 [[SetPrototypeOf]] 내부 메소드를 호출</p></blockquote><h4 id="코드-내에서-proto-접근자-프로퍼티-직접-사용-자제"><a href="#코드-내에서-proto-접근자-프로퍼티-직접-사용-자제" class="headerlink" title="코드 내에서 __proto__ 접근자 프로퍼티 직접 사용 자제"></a>코드 내에서 __proto__ 접근자 프로퍼티 직접 사용 자제</h4><p>코드 내에서 __proto__ 직접 사용하는 것 대신 Object.getPrototypeOf, Object.setPrototypeOf 메소드 사용 권장</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(Person) === Person.__proto__);<span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="proto-접근자-프로퍼티는-상속을-통해-사용됨"><a href="#proto-접근자-프로퍼티는-상속을-통해-사용됨" class="headerlink" title="__proto__ 접근자 프로퍼티는 상속을 통해 사용됨"></a>__proto__ 접근자 프로퍼티는 상속을 통해 사용됨</h4><p>__proto__ 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아닌, Object.prototype으로부터 상속받은 프로퍼티이다. 모든 객체는 상속을 통해서 Object.prototype.<strong> proto </strong> 접근자 프로퍼티를 사용할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57592782-75d39480-7573-11e9-887c-c49eef672893.png" alt="Object.prototype"></p><blockquote><h4 id="Prototype-Chain"><a href="#Prototype-Chain" class="headerlink" title="Prototype Chain"></a>Prototype Chain</h4><p>모든 객체는 프로토타입 계층 구조인 프로토타입 체인에 엮여있다. 자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 <strong> proto </strong> 접근자 프로퍼티가 가리키는 링크를 따라서 부모 프로토타입의 프로퍼티를 검색한다. 프로토타입 체인의 최상위 객체는 Object.prototype이다. 모든 객체가 Object.prototype 객체를 상속한다.</p></blockquote><h4 id="proto-접근자-프로퍼티를-통해서-프로토타입에-접근하는-이유"><a href="#proto-접근자-프로퍼티를-통해서-프로토타입에-접근하는-이유" class="headerlink" title="__proto__ 접근자 프로퍼티를 통해서 프로토타입에 접근하는 이유"></a>__proto__ 접근자 프로퍼티를 통해서 프로토타입에 접근하는 이유</h4><p>서로가 서로의 프로토타입이 되어, 프로토타입 체인이 무한 루프에 빠지지 않게 하기 위해서 __proto__ 접근자 프로퍼티를 통해 접근할 수 있도록 한다.</p><p>즉, Object.prototype의 set __proto__() (setter function)이 객체가 프로토타입을 상호참조할 때 에러를 발생시킨다.</p><h2 id="3-2-Function-Object’s-prototype-Property"><a href="#3-2-Function-Object’s-prototype-Property" class="headerlink" title="3.2. Function Object’s prototype Property"></a>3.2. Function Object’s prototype Property</h2><p>함수 객체는 __proto__ 접근자 프로퍼티 외에 prototype 프로퍼티도 소유한다.</p><table><thead><tr><th style="text-align:center">구분</th><th style="text-align:center">prototype 프로퍼티</th><th style="text-align:center">__proto__ 접근자 프로퍼티</th></tr></thead><tbody><tr><td style="text-align:center">소유</td><td style="text-align:center">함수 객체</td><td style="text-align:center">모든 객체</td></tr><tr><td style="text-align:center">값</td><td style="text-align:center">프로토타입의 참조값</td><td style="text-align:center">프로토타입의 참조값</td></tr><tr><td style="text-align:center">사용 주체</td><td style="text-align:center">생성자 함수</td><td style="text-align:center">모든 객체</td></tr><tr><td style="text-align:center">사용 목적</td><td style="text-align:center">자신이 생성할 객체의 프로토타입을 할당하기 위해 사용</td><td style="text-align:center">자신의 프로토타입에 접근하기 위해서 사용</td></tr></tbody></table><h1 id="4-Constructor-Functions-and-Prototypes-of-Objects-Created-by-Literal-Notation"><a href="#4-Constructor-Functions-and-Prototypes-of-Objects-Created-by-Literal-Notation" class="headerlink" title="4. Constructor Functions and Prototypes of Objects Created by Literal Notation"></a>4. Constructor Functions and Prototypes of Objects Created by Literal Notation</h1><p>생성자 함수로 만들지 않은 객체도 Object.prototype을 상속받아야하므로 Object constructor function과도 연결된다.</p><p>웹 애플리케이션 실행시 window 객체가 만들어지고, built-in 생성자 함수들이 만들어짐과 동시에 prototype property도 정의된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;명령형 (Imperative)&lt;/li&gt;
&lt;li&gt;함수형 (Functional)&lt;/li&gt;
&lt;li&gt;프로토타입 기반 (Prototype-based) 객체지향 프로그래밍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;을 지원하는 멀
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Prototype" scheme="https://sub2n.github.io/tags/Prototype/"/>
    
  </entry>
  
  <entry>
    <title>17. Function and First-class Object</title>
    <link href="https://sub2n.github.io/2019/05/12/17-Function-and-First-class-Object/"/>
    <id>https://sub2n.github.io/2019/05/12/17-Function-and-First-class-Object/</id>
    <published>2019-05-12T01:40:32.000Z</published>
    <updated>2019-05-13T06:27:34.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-First-class-Object"><a href="#1-First-class-Object" class="headerlink" title="1. First-class Object"></a>1. First-class Object</h1><p>자바스크립트에서 함수는 객체이며 값처럼 사용할 수 있다. 값처럼 사용할 수 있는 객체를 일급 객체라고 한다. 자바스크립트의 함수는 일급 객체(first-class object)이다.</p><h3 id="First-class-Object"><a href="#First-class-Object" class="headerlink" title="First-class Object"></a>First-class Object</h3><ul><li>런타임에 무명의 리터럴로 생성할 수 있다.</li><li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li><li>함수의 매개변수로 전달될 수 있다.</li><li>함수의 반환값으로 사용될 수 있다.</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 무명의 리터럴로 생성할 수 있다.</span></span><br><span class="line"><span class="hljs-comment">// 2. 변수나 자료 구조에 저장할 수 있다.</span></span><br><span class="line"><span class="hljs-comment">// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> increase = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> ++num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> decrease = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> --num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수 객체를 객체에 저장할 수 있다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> predicates = &#123; increase, decrease &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span>(<span class="hljs-params">predicate</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 4. 함수의 반환값으로 사용할 수 있다.</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    num = predicate(num);</span><br><span class="line">    <span class="hljs-keyword">return</span> num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 3. 함수의 매개변수에게 전달할 수 있다.</span></span><br><span class="line"><span class="hljs-comment">// makeCounter의 매개변수에게 함수 객체를 전달</span></span><br><span class="line"><span class="hljs-keyword">const</span> increaser = makeCounter(predicates.increase);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(increaser()); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(increaser()); <span class="hljs-comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// makeCounter의 매개변수에게 함수 객체를 전달</span></span><br><span class="line"><span class="hljs-keyword">const</span> decreaser = makeCounter(predicates.decrease);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(decreaser()); <span class="hljs-comment">// -1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(decreaser()); <span class="hljs-comment">// -2</span></span><br></pre></td></tr></table></figure><p>자바스크립트의 함수는 일급객체의 조건을 모두 만족하는 일급 객체이다. 따라서 함수는,</p><ul><li>무명의 리터럴로 생성할 수 있으므로 어디에서나 정의할 수 있다.</li><li>함수를 변수나 자료구조의 값으로 할당할 수 있다.</li><li>함수를 값처럼 매개변수로 전달할 수 있다.</li><li>함수에서 함수를 반환할 수 있다.</li></ul><p>자바스크립트의 함수가 일급 객체이므로 함수형 프로그래밍을 할 수 있다.</p><blockquote><h3 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a>Functional Programming</h3><p>함수형 프로그래밍이랑 Pure function과 보조 함수의 조합을 통해 외부 상태를 변경하는 side-effect를 최소화하여 immutability를 지향하는 프로그래밍 패러다임이다.</p><p>함수형 프로그래밍 패러다임에서 함수를 매개변수에 전달하거나 반환하는 함수를 Hign Order Function이라고 한다.</p></blockquote><p>함수는 객체이지만 일반 객체와 달리 호출할 수 있다. 함수 객체는 일반 객체에는 없는 함수 고유의 프로퍼티를 소유한다.</p><h1 id="2-Property-of-Function-Object"><a href="#2-Property-of-Function-Object" class="headerlink" title="2. Property of Function Object"></a>2. Property of Function Object</h1><p><img src="https://user-images.githubusercontent.com/48080762/57577077-034ab200-74aa-11e9-9242-6def63879626.png" alt="Function Object Properties"></p><p><img src="https://user-images.githubusercontent.com/48080762/57577086-4573f380-74aa-11e9-9a26-734acab4b018.png" alt="Object Property"></p><p>함수 객체와 일반 객체를 각각 콘솔에 찍어보면 함수 객체에는 일반 객체에 없는 프로퍼티들이 있다. 함수 객체 내에는 arguments, caller, length, name, prototype 프로퍼티가 존재한다. <strong> proto </strong> 프로퍼티는 함수 객체, 일반 객체에 모두 존재한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// function object의 Data property들</span></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'arguments'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: null, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'caller'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: null, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'length'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: 0, writable: false, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'name'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: "add", writable: false, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'prototype'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// __proto__는 function object가 아닌, Object.prototype으로부터 상속받은 Accessor property이다.</span></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'__proto__'</span>);</span><br><span class="line"><span class="hljs-comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-built_in">Object</span>.prototype, <span class="hljs-string">'__proto__'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li>함수 객체의 데이터 프로퍼티 : argunemts, caller, length, name, prototype </li><li><strong> proto </strong>는 접근자 프로퍼티로, Object.prototype객체의 프로퍼티를 상속받은 것.</li></ul><h2 id="2-1-arguments-Property"><a href="#2-1-arguments-Property" class="headerlink" title="2.1 arguments Property"></a>2.1 arguments Property</h2><p>arguments 프로퍼티의 value는 arguments 객체이다. arguments 객체는 함수 호출 시 전달된 argument들의 정보를 담고 있는 iterable array-like object이며, 함수 내부에서만 참조 가능하다.</p><blockquote><h4 id="arguments-Property"><a href="#arguments-Property" class="headerlink" title="arguments Property"></a>arguments Property</h4><p>함수 객체의 arguments property는 일부 브라우저에서 지원하고 있으나 ES3부터 표준에서 페지되었다. arguments 프로퍼티를 통해서가 아니라 함수 내부에서 지역 변수처럼 사용할 수 있는 <strong>arguments 객체를 직접 참조</strong>하는 것이 좋다.</p></blockquote><h4 id="arguments-Object"><a href="#arguments-Object" class="headerlink" title="arguments Object"></a>arguments Object</h4><p><img src="https://user-images.githubusercontent.com/48080762/57577250-ef08b400-74ad-11e9-820a-d6bf77e6ae79.png" alt="arguments object"></p><ul><li>argument들을 value로 가진다. 0, 1, 2 등 key는 argumet의 전달 순서를 나타낸다.</li><li>callee:  호출된 함수, 즉 arguments 객체를 생성한 함수를 가리킨다.</li><li>length: argument의 개수</li><li>Symbol(Symbol.iteraor): arguments object를 순회 가능한 iterable 자료 구조로 만들기 위한 프로퍼티.</li></ul><p>arguments object는 parameter의 개수를 확정할 수 없는 <strong>가변 인자 함수 (Variable Argument Function)</strong>를 구현할 때 유용하게 사용한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// arguments 객체는 length property를 가진 array-like object이므로 iterable하다.</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)</span><br><span class="line">        result += <span class="hljs-built_in">arguments</span>[i];</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Array-like Object</strong>란 length property를 가진 객체로, 실제 배열이 아니지만 for 문 등으로 순회할 수 있는 객체를 말한다. 배열이 아니므로 배열 메소드를 사용하면 에러가 발생한다.</p><p>arguments object에 reduce, for…each 등 고차 함수를 사용하기 위해 배열로 변환한 후 사용하기도 한다.</p><p>ES6에서는 argument를 배열로 사용하기 위해 Rest parameter를 도입했다.</p><h2 id="2-2-caller-Property"><a href="#2-2-caller-Property" class="headerlink" title="2.2. caller Property"></a>2.2. caller Property</h2><p>caller property는 ECMAScript spec에 포함되지 않은 비표준 프로퍼티이다. 함수 객체의 caller property는 함수 자신을 호출한 함수를 가리킨다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">func</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'caller : '</span> + bar.caller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 브라우저에서의 실행 결과</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo(bar)); <span class="hljs-comment">// caller : function foo(func) &#123;...&#125;</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar());    <span class="hljs-comment">// caller : null</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Node.js에서의 실행 결과</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo(bar)); <span class="hljs-comment">// caller : function foo(func) &#123;...&#125;</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar());    <span class="hljs-comment">// caller : function (exports, require, module, __filename, __dirname) &#123;전역 코드 전체&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-length-Property"><a href="#2-3-length-Property" class="headerlink" title="2.3 length Property"></a>2.3 length Property</h2><p>함수 객체의 length property는 함수 정의 시 선언한 매개변수의 개수를 가리킨다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a + b +c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(add.length)<span class="hljs-comment">//3</span></span><br></pre></td></tr></table></figure><p>arguments Object의 length property와 Function Object의 length property의 값은 다름을 알고 넘어가자.</p><ul><li><p>arguments Object’s length property : 넘겨받은 argument의 개수</p></li><li><p>Function Object’s length property : 함수에 정의된 parameter의 개수</p></li></ul><h2 id="2-4-name-Property"><a href="#2-4-name-Property" class="headerlink" title="2.4. name Property"></a>2.4. name Property</h2><p>함수 객체의 name property는 함수명을 나타낸다. ES6에서 정식 표준이 되었다.</p><p>익명 함수의 경우 ES5에서 name property는 빈 문자열이지만 ES6에서는 함수 객체를 가리키는 변수명을 값으로 갖는다. (함수 선언문일 경우 함수명과 동일한 변수명, 익명 함수 표현식일 경우 함수 표현식을 할당한 변수명)</p><h2 id="2-5-proto-Accessor-Property"><a href="#2-5-proto-Accessor-Property" class="headerlink" title="2.5. __proto__ Accessor Property"></a>2.5. __proto__ Accessor Property</h2><p>모든 객체는 <code>[[Prototype]]</code>이라는 내부 슬롯을 갖는다. [[Prototype]] 내부 슬롯은 프로토타입 객체를 가리킨다.</p><p>__proto__ property는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">'value'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj.__proto__ === <span class="hljs-built_in">Object</span>.prototype);<span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj.hasOwnProperty(<span class="hljs-string">'key'</span>));<span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj.hasOwnProperty(<span class="hljs-string">'__proto__'</span>));<span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="2-6-prototype-Property"><a href="#2-6-prototype-Property" class="headerlink" title="2.6. prototype Property"></a>2.6. prototype Property</h2><p>prototype Property는 함수 객체만이 소유하는 프로퍼티이다.</p><p>prototype Property는 함수가 객체를 생성하는 생성자 함수로 사용될 때 생성자 함수가 생성할 객체의 프로토타입 객체를 가리킨다.</p><p>즉, </p><ul><li><strong>prototype</strong> Data Property는 <strong>함수가 생성자로 동작하여 생성할 instatnce의 prototype 객체</strong>를 가리키고</li><li><strong>__proto__</strong> Accessor Property는 <strong>자신을 생성한 생성자 함수의 prototype 객체</strong>, 즉 <strong>자신이 상속받은 prototype 객체</strong>를 가리킨다.</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> circle2 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Circle.prototype === circle2.__proto__); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Person.__proto__ === Circle.__proto__);<span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-First-class-Object&quot;&gt;&lt;a href=&quot;#1-First-class-Object&quot; class=&quot;headerlink&quot; title=&quot;1. First-class Object&quot;&gt;&lt;/a&gt;1. First-class Object&lt;/h1
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="First-class object" scheme="https://sub2n.github.io/tags/First-class-object/"/>
    
      <category term="일급 객체" scheme="https://sub2n.github.io/tags/%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4/"/>
    
  </entry>
  
  <entry>
    <title>16. Creating an Object with a Constructor Function</title>
    <link href="https://sub2n.github.io/2019/05/10/16-Creating-an-Object-with-a-Constructor-Function/"/>
    <id>https://sub2n.github.io/2019/05/10/16-Creating-an-Object-with-a-Constructor-Function/</id>
    <published>2019-05-10T06:43:45.000Z</published>
    <updated>2019-05-13T05:25:48.969Z</updated>
    
    <content type="html"><![CDATA[<p>객체 리터럴 표기법은 가장 일반적이고 간단한 객체 생성 방법이다. 객체는 객체 리터럴 표기법 외에도 다양한 방법으로 생성할 수 있다. </p><p>객체를 생성하기 위한 용도로 사용되는 함수를 생성자 함수라고 한다.</p><h1 id="1-Object-Constructor-Function"><a href="#1-Object-Constructor-Function" class="headerlink" title="1. Object Constructor Function"></a>1. Object Constructor Function</h1><p>객체 리터럴 표기법은 분명 간단한 방법이지만, 같은 구조를 가진 객체를 <strong>여러 개</strong> 만들어야할 경우가 있다.</p><p>new 연선자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 생성한 빈 객체에 프로퍼티와 메소드를 추가한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> student = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">student.name = <span class="hljs-string">'Park'</span>;</span><br><span class="line">student.sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hi! I am '</span> + <span class="hljs-keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object 생성자 함수는 함수 <strong>객체</strong>이므로 프로퍼티와 메소드를 갖는다. 앞서 살펴본 <code>Object.getOwnPropertyDescriptor()</code> 또한 Object 생성자 함수의 메소드이다.</p><p>Constructor 함수는 new 연산자와 함께 호출해서 Object(instance)를 생성하는 함수이다. 생성자 함수에 의해 생성된 객체는 instance라고 한다.</p><blockquote><h3 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h3><p>생성자 함수도 객체이므로 생성자 함수나 클래스가 생성한 객체를 다른 객체와 구분하기 위해 실체라는 의미로 인스턴스라고 한다.</p></blockquote><h2 id="1-1-Built-in-Constructor-Function-Wrapper-Object"><a href="#1-1-Built-in-Constructor-Function-Wrapper-Object" class="headerlink" title="1.1. Built-in Constructor Function (Wrapper Object)"></a>1.1. Built-in Constructor Function (Wrapper Object)</h2><p>자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의 built-in(intrinsic) 생성자 함수를 제공한다. 이들은 전역객체(window)의 메소드이다. 자바스크립트에서 <strong>함수는 객체</strong>이므로 Built-in 생성자 함수는 객체로서 메소드도 가진다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-string">'str'</span>);<span class="hljs-comment">//가능하지만 잘 안 씀</span></span><br><span class="line"><span class="hljs-keyword">const</span> strObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'str'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> numObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);</span><br></pre></td></tr></table></figure><p>String, Number 생성자 함수로 형변환도 가능하지만 잘 안 쓴다.</p><blockquote><h3 id="Wrapper-Object"><a href="#Wrapper-Object" class="headerlink" title="Wrapper Object"></a>Wrapper Object</h3><p>원시 값을 객체처럼 쓰면 자바스크립트 엔진이 <strong>원시값 타입의 객체로 순간 바꾸고 평가한 후 다시 원시 값으로 되돌린다</strong>. 이 때 원시값 타입의 객체를 wrapper object라고 부른다.</p></blockquote><h1 id="2-Constructor-Function"><a href="#2-Constructor-Function" class="headerlink" title="2. Constructor Function"></a>2. Constructor Function</h1><p>객체 리터럴로 객체를 생성하는 경우 프로퍼티 구조가 동일해도 매번 같은 프로퍼티와 메소드를 작성해야하는 문제가 있다. 객체 리터럴은 한 번 평가되어 값을 만드므로 재사용할 수 없으며 동일한 코드의 중복 또한 문제가 된다.</p><h2 id="2-1-Advantages-of-object-creation-by-constructor-function"><a href="#2-1-Advantages-of-object-creation-by-constructor-function" class="headerlink" title="2.1 Advantages of object creation by constructor function"></a>2.1 Advantages of object creation by constructor function</h2><p>생성자 함수로 객체를 생성하면 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</p><p>생성자 함수는 일반 함수와 동일한 방법으로 <strong>미리 정의한 후</strong>에, <strong>new 연산자와 함께 호출했을 때만 생성자 함수로 동작한다</strong>.</p><p>생성자 함수는 보통 Pascal case로 naming 한다. (ex. Object, Circle, String 등)</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Constructor Function</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// this indicates the instance that the constructor function will create.</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="hljs-keyword">this</span>.getDiameter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">this</span>.radius;  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// instance creation</span></span><br><span class="line"><span class="hljs-keyword">const</span> circle1 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> circle2 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">10</span>);</span><br></pre></td></tr></table></figure><p>new 연산자 없이 함수를 호출하면, 일반 함수로 호출되는 것이므로 this는 전역 객체(window)가 된다.</p><blockquote><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><code>this</code>는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 Self-regerencing variable이다. <code>this</code>가 가리키는 객체는 함수 호출 방식에 따라 동적으로 결정된다.</p><table><thead><tr><th style="text-align:center">Function call</th><th style="text-align:center">Object <code>this</code> points to</th></tr></thead><tbody><tr><td style="text-align:center">As a normal function</td><td style="text-align:center">Global object (window)</td></tr><tr><td style="text-align:center">As a method</td><td style="text-align:center"><strong>Object</strong> that called a method</td></tr><tr><td style="text-align:center">As a constructor function</td><td style="text-align:center"><strong>Instance</strong> that a constructor function will create in the future.</td></tr></tbody></table></blockquote><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Called as a general function</span></span><br><span class="line">foo ();<span class="hljs-comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Called as a method</span></span><br><span class="line"><span class="hljs-keyword">const</span> obj = &#123; foo &#125;;<span class="hljs-comment">// ES6 property shorthand</span></span><br><span class="line">obj.foo();<span class="hljs-comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Called as a constructor function</span></span><br><span class="line"><span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> foo();<span class="hljs-comment">// inst</span></span><br></pre></td></tr></table></figure><h2 id="2-3-Internal-method-Call-and-Constructor"><a href="#2-3-Internal-method-Call-and-Constructor" class="headerlink" title="2.3. Internal method [[Call]] and [[Constructor]]"></a>2.3. Internal method [[Call]] and [[Constructor]]</h2><p>함수 객체는 일반 객체와 달리 내부 메소드로 [[Call]]과 [[Constructor]]를 가진다.</p><p>내부 메소드 [[Call]]은 함수가 일반 함수로 호출되었을 때 실행되고, 내부 메소드 [[Constructor]]는 함수가 생성자 함수로 호출되었을 때 실행된다.</p><p>내부 메소드 [[Call]]이 구현되어 있는 객체를 callable, [[Constuctor]]가 구현되어 있는 객체는 constructor, [[Constructor]]가 구현되어 있지 않은 객체는 non-constructor라고 부른다.</p><p>단, arrow function은 constructor function으로 생성할 수 없다. ES6의 메소드 축약 표현으로 선언한 메소드 또한 non-constructor이다. 따라서 모든 함수는 callable이지만 모두 constructor인 것은 아니다.</p><h2 id="2-4-constructors-and-non-constructors"><a href="#2-4-constructors-and-non-constructors" class="headerlink" title="2.4. constructors and non-constructors"></a>2.4. constructors and non-constructors</h2><p>자바스크립트 엔진은 함수 생성시 FunctionCreate라는 abstract operation을 사용한다.</p><p>Abstract operation FunctionCreate는 함수 정의가 평가될 때 호출된다. 함수 정의 방식에 따라서 FunctionCreate의 kind parameter에 함수의 종류를 나타내는 문자열이 전달된다.</p><table><thead><tr><th style="text-align:center">Kinds</th><th style="text-align:center">Strings</th></tr></thead><tbody><tr><td style="text-align:center">일반 함수 정의(함수 선언문, 함수 표현식) 평가</td><td style="text-align:center">Normal</td></tr><tr><td style="text-align:center">화살표 함수 정의 평가</td><td style="text-align:center">Arrow</td></tr><tr><td style="text-align:center">메소드 정의 평가</td><td style="text-align:center">Method</td></tr></tbody></table><p>일반 함수로 정의된 함수만 constructor, Arrow나 Method는 con-constructor이다.</p><p>이 때 주의해야할 점은 ES6의 메소드 축약 표현만을 메소드 정의로 인정한다는 것이다.</p><h2 id="2-5-How-the-Constructor-Function-Works"><a href="#2-5-How-the-Constructor-Function-Works" class="headerlink" title="2.5. How the Constructor Function Works"></a>2.5. How the Constructor Function Works</h2><p>생성자 함수의 역할은 인스턴스를 생성하는 것과 생성된 인스턴스의 프로퍼티 값을 초기화하는 것이다.</p><p>생성자 함수가 호출되면,</p><ol><li>자바스크립트 내부에서 빈 객체를 만들고 <code>this</code>에 할당한다. (this binding)</li><li>내부 코드를 실행한 후 <code>this</code>를 return한다. 즉, <code>this</code>는 생성자 함수로 생성하는 instance가 된다.</li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 1. create empty object and bind it to this. this = &#123;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 2. run internal codes (create property)</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 3. return this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Park'</span>));<span class="hljs-comment">// Person &#123;name: 'Park'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-6-new-Operator"><a href="#2-6-new-Operator" class="headerlink" title="2.6. new Operator"></a>2.6. new Operator</h2><p>new 연산자와 함께 constructor인 함수를 호출하면 함수는 생성자 함수로 동작한다. 이 때 함수 객체의 내부 메소드 [[Constructor]]가 호출된다. 함수 내부의 this는 생성자 함수가 생성할 instance를 가리킨다.</p><p>new 연산자 없이 함수를 호출하면 함수 객체의 내부 메소드 [[Call]]이 호출된다. 이 때 함수 내부의 this는 전역 객체 window를 가리킨다.</p><h2 id="2-7-new-target"><a href="#2-7-new-target" class="headerlink" title="2.7. new.target"></a>2.7. new.target</h2><p>new 연산자 없이 생성자 함수를 호출하는 것을 방지하기 위해서 ES6에서 new.target을 지원한다.</p><p>new.target은 함수 내부에서 지역 변수와 같이 사용되는 meta property이다. (IE는 new.target을 지원하지 않음!)</p><p>함수가 new 연산자와 함께 호출되면 new.target은 함수 자신을 가리키고, new 연산자 없이 호출된 함수 내부의 new.target은 undefined이다.</p><p>new 연산자와 함께 호출된 생성자 함수로부터 생성된 instance는 프로토타입에 의해 생성자 함수와 연결된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;객체 리터럴 표기법은 가장 일반적이고 간단한 객체 생성 방법이다. 객체는 객체 리터럴 표기법 외에도 다양한 방법으로 생성할 수 있다. &lt;/p&gt;
&lt;p&gt;객체를 생성하기 위한 용도로 사용되는 함수를 생성자 함수라고 한다.&lt;/p&gt;
&lt;h1 id=&quot;1-Ob
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Object" scheme="https://sub2n.github.io/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>CodeWars 6kyu. Build a pile of Cubes</title>
    <link href="https://sub2n.github.io/2019/05/09/CodeWars-6kyu-Build-a-pile-of-Cubes/"/>
    <id>https://sub2n.github.io/2019/05/09/CodeWars-6kyu-Build-a-pile-of-Cubes/</id>
    <published>2019-05-09T07:19:09.000Z</published>
    <updated>2019-05-09T08:17:34.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CodeWars-6kyu-Build-a-pile-of-Cubes"><a href="#CodeWars-6kyu-Build-a-pile-of-Cubes" class="headerlink" title="CodeWars 6kyu. Build a pile of Cubes"></a><a href="https://www.codewars.com/kata/build-a-pile-of-cubes/javascript" target="_blank" rel="noopener">CodeWars 6kyu. Build a pile of Cubes</a></h2><p>Find the largest number of cubes can be piled.</p><a id="more"></a><blockquote><p>Your task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume of n^3, the cube above will have volume of (n-1)^3 and so on until the top which will have a volume of 1^3.</p><p>You are given the total volume m of the building. Being given m can you find the number n of cubes you will have to build?</p><p>The parameter of the function findNb (find_nb, find-nb, findNb) will be an integer m and you have to return the integer n such as n^3 + (n-1)^3 + … + 1^3 = m if such a n exists or -1 if there is no such n.</p></blockquote><blockquote><p>Examples:</p><p>findNb(1071225) –&gt; 45<br>findNb(91716553919377) –&gt; -1<br>mov rdi, 1071225<br>call find_nb            ; rax &lt;– 45</p><p>mov rdi, 91716553919377<br>call find_nb            ; rax &lt;– -1</p></blockquote><h2 id="접근법"><a href="#접근법" class="headerlink" title="접근법"></a>접근법</h2><p>Σ k<sup>3</sup> (k = 1~n) == ((n * (n+1))/2))**2 가 m보다 작아야 한다.</p><p>따라서 n == Math.sqrt(2 * Math.sqrt(m)) 에 근사한 값으로 설정한 후 m보다 커질 때까지 반복한다.</p><h2 id="JavaScript-Solution"><a href="#JavaScript-Solution" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h2><p><img src="https://user-images.githubusercontent.com/48080762/57434636-5c320480-7276-11e9-9045-4b17910f48f8.png" alt="Solution Submit"></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNb</span>(<span class="hljs-params">m</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">2</span> * (<span class="hljs-built_in">Math</span>.sqrt(m)))) - <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> ( ((n * (n+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>) ** <span class="hljs-number">2</span> &lt; m ) &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ((n * (n+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>) ** <span class="hljs-number">2</span> &gt; m ? <span class="hljs-number">-1</span> : n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CodeWars-6kyu-Build-a-pile-of-Cubes&quot;&gt;&lt;a href=&quot;#CodeWars-6kyu-Build-a-pile-of-Cubes&quot; class=&quot;headerlink&quot; title=&quot;CodeWars 6kyu. Build a pile of Cubes&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.codewars.com/kata/build-a-pile-of-cubes/javascript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CodeWars 6kyu. Build a pile of Cubes&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Find the largest number of cubes can be piled.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://sub2n.github.io/categories/Algorithm/"/>
    
      <category term="CodeWars" scheme="https://sub2n.github.io/categories/Algorithm/CodeWars/"/>
    
    
      <category term="Algorithm" scheme="https://sub2n.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>190509-TIL</title>
    <link href="https://sub2n.github.io/2019/05/09/190509-TIL/"/>
    <id>https://sub2n.github.io/2019/05/09/190509-TIL/</id>
    <published>2019-05-09T07:15:52.000Z</published>
    <updated>2019-05-09T07:18:13.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li><p>Implemented underscore libray’s last function</p><p><img src="https://user-images.githubusercontent.com/48080762/57434410-e332ad00-7275-11e9-9c6f-2c85032b12d2.png" alt="Condition complete"></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Like first, but for the last elements. If n is undefined, return just the</span></span><br><span class="line"><span class="hljs-comment">// last element.</span></span><br><span class="line">_.last = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">array, n</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> n === <span class="hljs-literal">undefined</span> ? array[array.length<span class="hljs-number">-1</span>] : n &gt; array.length ? array : array.slice(array.length-n, array.length);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Studied about JavaScript global variable and let, const keyword variables.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Implement
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>15. Property Definition</title>
    <link href="https://sub2n.github.io/2019/05/09/15-Property-Definition/"/>
    <id>https://sub2n.github.io/2019/05/09/15-Property-Definition/</id>
    <published>2019-05-09T06:11:04.000Z</published>
    <updated>2019-05-10T06:42:59.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-What-is-Property-Definition"><a href="#1-What-is-Property-Definition" class="headerlink" title="1. What is Property Definition?"></a>1. What is Property Definition?</h1><p>프로퍼티 정의란 프로퍼티 어트리뷰트의 값을 정의하여 프로퍼티의 상태를 관리하는 것이다. 예를 들면 프로퍼티 값을 갱신 가능하도록 할 것인지(writable), 프로퍼티를 열거 가능하도록 할 것인지(enumarable), 재정의 가능하도록 할 것인지(configurable)를 정의할 수 있다.</p><p>객체 리터럴이 평가되거나 프로퍼티가 동적 생성될 때 프로퍼티가 생성된다. 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//Dynamic creation of properties. The JavaScript engine creates the property and defines the property's attributes as the default.</span></span><br><span class="line">obj.prop = <span class="hljs-number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">'prop'</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="hljs-comment">// &#123;value: 10, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><p>프로퍼티 동적 생성은 프로퍼티가 존재하지 않을 때 프로퍼티를 생성하여 추가하는 것이다.</p><p>프로퍼티 정의는 프로퍼티 어트리뷰트를 정의하는 것을 말한다. 프로퍼티 어트리뷰트는 프로퍼티의 상태를 나타낸다.</p><p>프로퍼티의 상태란 프로퍼티의,</p><ul><li>value</li><li>writable</li><li>enumerable</li><li>configurable</li></ul><p>프로퍼티 어트리뷰트는 <code>Object.getOwnPropertyDescriptor</code> 메소드를 사용해 참조할 수 있다. 이 메소드는 프로퍼티 어트리뷰트를 객체로 표현한 PropertyDescriptor 객체를 반환한다. 존재하지 않는 프로퍼티나, 상속받은 프로퍼티에 대한 PropertyDescriptor를 요구하면 undefined가 반환된다.</p><p>프로퍼티가 동적 생성될 때 자바스크립트 엔진은 프로퍼티 어트리뷰트를 기본값으로 정의한다. 이미 정의된 프로퍼티 어트리뷰트를 재정의할 수도 있다.</p><h1 id="2-Internal-Slot-Method"><a href="#2-Internal-Slot-Method" class="headerlink" title="2. Internal Slot / Method"></a>2. Internal Slot / Method</h1><p>Internal slot and internal method는 ECMAScript 스펙에서 요구하는 객체 관련 내부 상태와 내부 동작을 정의한 것이다. ECMAScript 스펙에서 <code>[[...]]</code>로 감싼 이름들이 내부 슬롯과 내부 메소드이다.</p><p>Internal slot과 method는 자바스크립트 엔진의 내부 구현 사양을 정의한 것이므로 외부에 노출되지 않는다. </p><p>객체의 프로퍼티 키로 프로퍼티 값에 접근할 때 <code>[[Get]]</code> 내부 메소드가 내부적으로 호출된다. <code>[[Get]]</code> 내부 메소드는 다음과 같이 동작한다.</p><ol><li>프로퍼티 키가 유효한지 확인한다. (문자열 또는 심볼)</li><li>프로토타입 체인에서 프로퍼티를 검색한다.</li></ol><blockquote><h3 id="Prototype-and-Prototype-Chain"><a href="#Prototype-and-Prototype-Chain" class="headerlink" title="Prototype and Prototype Chain"></a>Prototype and Prototype Chain</h3><p>프로토타입은 어떤 객체의 parent 객체 역할을 하는 객체이다. 프로토타입은 Child 객체에게 자신의 프로퍼티와 메소드를 상속한다. Prototype객체의 프로퍼티나 메소드를 상속받은 child 객체는 parent 객체의 프로퍼티나 메소드를 자유롭게 사용한다.</p><p>프로토타입 체인은 프로토타입 객체가 연결되어있는 상속 구조이다. 어떤 객체의 프로퍼티나 메소드에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티나 메소드가 없다면 프로토타입 체인을 따라 상위(부모) 객체의 프로퍼티나 메소드를 차례대로 검색한다.</p></blockquote><ol start="3"><li>검색된 프로퍼티가 Data property라면 프로퍼티 값(데이터 프로퍼티의 프로퍼티 어트리뷰트 [[Value]])의 값을 그대로 반환한다.</li><li>만약 검색된 프로퍼티가 Accessor property라면 접근자 프로퍼티의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하고 그 결과를 반환한다.</li></ol><p>함수 객체에는 [[Call]]이라는 고유한 internal method가 있다. [[Call]]은 함수를 호출하면 내부적으로 호출된다. 이는 일반 객체에는 없는 함수 객체만의 고유한 internal method이다.</p><blockquote><h3 id="Abstract-Operation"><a href="#Abstract-Operation" class="headerlink" title="Abstract Operation"></a>Abstract Operation</h3><p>ECMAScript 스펙에서 Abstract operation으로 구현 방향을 제시한다. ECMAScript의 내부 동작을 이해하기 위해서 읽으면 좋음..</p></blockquote><h1 id="3-Accessor-Property"><a href="#3-Accessor-Property" class="headerlink" title="3. Accessor Property"></a>3. Accessor Property</h1><p>프로퍼티는 Data property와 Accessor property로 구분할 수 있다.</p><ul><li>Data property<ul><li>키와 값으로 구성된 일반 프로퍼티. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티이다.</li></ul></li><li>Accessor property<ul><li>자체적으로는 값을 갖지 않고 다른 data property의 값을 읽거나 저장할 때 사용되는 Accessor function으로 구성된 프로퍼티</li></ul></li></ul><p>Accessor function은 getter / setter 함수라고도 부른다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> student = &#123;</span><br><span class="line">    <span class="hljs-comment">// Data property</span></span><br><span class="line">    name: <span class="hljs-string">'Park'</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// Accessor property</span></span><br><span class="line">    <span class="hljs-keyword">get</span> infoName() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-keyword">set</span> infoName(newName) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// A reference to a property value through a data property.</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(student);<span class="hljs-comment">// &#123;name: "Park", age: 25&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Setting Property Values with Accessor Properties</span></span><br><span class="line"><span class="hljs-comment">// If store the value in the accessor property infoName, the setter function is called.</span></span><br><span class="line">student.infoName = <span class="hljs-string">'Kim'</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(student);<span class="hljs-comment">// &#123;name: "Kim", age: 25&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Getting Property Values with Accessor Properties</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(student.infoName);<span class="hljs-comment">// Kim</span></span><br></pre></td></tr></table></figure><p>student 객체의 name은 일반적인 데이터 프로퍼티이다.</p><p>get infoName은 getter 함수, set infoName은 setter 함수이고 함수의 이름인 infoName이 바로 접근자 프로퍼티이다. 접근자 프로터티는 값([[Value]] attribute)을 가지지 않고 데이터 프로퍼티의 값을 읽거나(get) 저장(set)할 때 동작한다.</p><p>Accessor property infoName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] internal method가 호출되어 다음과 같이 동작한다.</p><ol><li>프로퍼티 키가 유효한지 확인한다. (문자열 또는 숫자인지)</li><li>프로토타입 체인에서 프로퍼티를 검색한다.</li><li>검색된 infoName 프로퍼티가 data property인지 accessor property인지 확인한다. infoName은 Accessor property이다.</li><li>Accessor property infoName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출해 결과를 반환한다. 프로퍼티 infoName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDescriptor 메소드가 반환하는 프로퍼티 디스크립터(PropertyDescriptor) 객체의 get 프로퍼티 값과 같다.</li></ol><p>Accessor property와 data property의 구별 방법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// The __proto__ of a generic object is an accessor property.</span></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-built_in">Object</span>.prototype, <span class="hljs-string">'__proto__'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// The prototype of a function object is a data property.</span></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;, <span class="hljs-string">'prototype'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><p>Accessor property와 data property의 property descriptor object의 프로퍼티가 다르다.</p><h1 id="4-Property-Attribute"><a href="#4-Property-Attribute" class="headerlink" title="4. Property Attribute"></a>4. Property Attribute</h1><p>모든 프로퍼티는 자신의 상태와 동작을 정의한 내부 슬롯 / 메소드를 가진다. 이것들을 property attribute라고 한다. Property attribute는 자바스크립트 엔진이 프로퍼티를 생성할 때 default로 자동 정의된다.</p><ul><li><p>Data Property Attributes</p><p>| Property Attribute |                         Description                          | Property of Property Descriptor Object |<br>| :—————-: | :———————————————————-: | :————————————: |<br>|     [[Value]]      | - 프로퍼티 키로 프로퍼티 값에 접근하면 내부 메소드 [[Get]]에 의해 반환되는 값<br>-    프로퍼티 키로 프로퍼티 값을 저장하면 [[Value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다. |                 value                  |<br>|    [[Writable]]    | - 프로퍼티 값의 변경 가능 여부. Boolean<br>- [[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다. |                writable                |<br>|   [[Enumarable]]   | - 프로퍼티의 열거 가능 여부. Boolean<br>- [[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다. |               enumerable               |<br>|  [[Configurable]]  | - 프로퍼티의 재정의 가능 여부. Boolean<br>- [[Configurable]]의 값이 false인 경우, 해당 프로퍼티의 삭제와 프로퍼티 어트리뷰트 값의 변경이 금지된다.<br> - 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. |              configurable              |</p></li></ul><ul><li><p>Accessor Property Attributes</p><p>| Property Attribute |                         Description                          | Property of Property Descriptor Object |<br>| :—————-: | :———————————————————-: | :————————————: |<br>|      [[Get]]       | - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수 <br>- 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값인 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환 |                  get                   |<br>|      [[Set]]       | - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수 <br>- 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값인 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환 |                  set                   |<br>|   [[Enumerable]]   |            Same as Data Property’s [[Enumerable]]            |               enumerable               |<br>|  [[Configurable]]  |           Same as Data Property’s [[Configurable]]           |              configurable              |</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-What-is-Property-Definition&quot;&gt;&lt;a href=&quot;#1-What-is-Property-Definition&quot; class=&quot;headerlink&quot; title=&quot;1. What is Property Definition?&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>14. let, const and a Block-level Scope</title>
    <link href="https://sub2n.github.io/2019/05/09/14-let-const-and-a-Block-level-Scope/"/>
    <id>https://sub2n.github.io/2019/05/09/14-let-const-and-a-Block-level-Scope/</id>
    <published>2019-05-09T04:58:23.000Z</published>
    <updated>2019-05-10T06:03:31.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Problems-with-Variables-declared-with-the-var-keyword"><a href="#1-Problems-with-Variables-declared-with-the-var-keyword" class="headerlink" title="1. Problems with Variables declared with the var keyword"></a>1. Problems with Variables declared with the <code>var</code> keyword</h1><p>ES5까지 변수를 선언할 수 있는 유일한 키워드는 <code>var</code> 하나였다. <code>var</code> 키워드로 선언된 변수는 다른 언어와는 구별되는 특징을 가진다.</p><h2 id="1-1-Allow-Duplicate-Variable-Declaration"><a href="#1-1-Allow-Duplicate-Variable-Declaration" class="headerlink" title="1.1. Allow Duplicate Variable Declaration"></a>1.1. Allow Duplicate Variable Declaration</h2><p><code>var</code> 키워드로 선언한 변수는 중복 선언이 가능하다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-comment">// No Error</span></span><br><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">//10</span></span><br></pre></td></tr></table></figure><p>같은 스코프 내에서 변수를 중복 선언하면 나중에 선언된 변수는 선언문이 아닌 할당문처럼 동작한다. 이 때 에러가 발생하지 않기 때문에 중복 선언을 인지하기 힘들다. 이로 인해 의도치 않게 변수값이 변경될 수 있다.</p><h2 id="1-2-Function-level-Scope"><a href="#1-2-Function-level-Scope" class="headerlink" title="1.2. Function-level Scope"></a>1.2. Function-level Scope</h2><p><code>var</code> 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서, if문이나 for문 등에서 선언한 <code>var</code> 변수는 모두 전역 변수가 된다.</p><p>대부분의 프로그래밍 언어는 block-level scope이기 때문에 function-level scope를 이용하는 것은 전역 변수를 남발할 가능성을 높인다.</p><h2 id="1-3-Variable-Hoisting"><a href="#1-3-Variable-Hoisting" class="headerlink" title="1.3. Variable Hoisting"></a>1.3. Variable Hoisting</h2><p><code>var</code>키워드로 선언한 변수는 변수 호이스팅에 의해 변수 선언문이 스코프의 가장 위로 끌어 올려진 것처럼 동작한다. 즉, 선언 이전에 <code>var</code> 변수를 참조해도 에러가 나지 않는다. 이는 프로그램의 흐름을 해치고 가독성을 떨어뜨린다.</p><h1 id="2-let-keyword"><a href="#2-let-keyword" class="headerlink" title="2. let keyword"></a>2. <code>let</code> keyword</h1><p><code>var</code> 키워드의 단점들을 보완하기 위해 ES6에서 <code>var</code>와 <code>const</code> 키워드가 추가되었다. 이들은 <code>var</code> 키워드와 같이 변수를 선언할 때 사용된다.</p><h2 id="2-1-Ban-Duplicate-Variable-Declaration"><a href="#2-1-Ban-Duplicate-Variable-Declaration" class="headerlink" title="2.1. Ban Duplicate Variable Declaration"></a>2.1. Ban Duplicate Variable Declaration</h2><p><code>let</code> 키워드로 선언한 변수를 중복 선언하면 <code>var</code>와 달리 SyntaxError가 발생한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<span class="hljs-comment">// SyntaxError: Identifier 'x' has already been declared</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Block-level-Scope"><a href="#2-2-Block-level-Scope" class="headerlink" title="2.2. Block-level Scope"></a>2.2. Block-level Scope</h2><p><code>var</code> 키워드로 선언한 변수는 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따른다. 그러나 <code>let</code> 키워드로 선언한 변수는 모든 코드 블록 <code>{}</code>을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> foo = <span class="hljs-number">1</span>;<span class="hljs-comment">// global variable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> foo = <span class="hljs-number">3</span>;<span class="hljs-comment">// local variable</span></span><br><span class="line">    <span class="hljs-keyword">let</span> bar = <span class="hljs-number">4</span>;<span class="hljs-comment">// local variable</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 3</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar);<span class="hljs-comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar);<span class="hljs-comment">// ReferenceError: bar is not defined</span></span><br></pre></td></tr></table></figure><h2 id="2-3-Variable-Hoisting"><a href="#2-3-Variable-Hoisting" class="headerlink" title="2.3. Variable Hoisting"></a>2.3. Variable Hoisting</h2><p><code>let</code> 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(foo);<span class="hljs-comment">// ReferenceError: foo is not defined</span></span><br><span class="line"><span class="hljs-keyword">let</span> foo;</span><br></pre></td></tr></table></figure><p>그렇다면 <code>let</code> 키워드로 선언한 선언문은는 런타임 이전에 실행되지 않는 것일까? </p><p>일반적으로 <code>var</code> 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 declaration phase와 initialization phase가 <strong>한 번에</strong> 진행된다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57504827-02424500-7331-11e9-960b-75e673a99ae3.png" alt="var declaration"></p><ol><li>Declaration phase : Execution context의 lexical environment에 있는 스코프에 변수 식별자를 등록하여 변수의 존재를 알린다.</li><li>Initialization phase : declaration phase가 끝나는 즉시 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined로 변수를 할당해 초기화한다.</li></ol><p><code>let</code> 키워드로 선언한 변수는 “Declaration phase”와 “Initialization Phase”가 <strong>분리되어 진행</strong>된다.  즉, 런타임 이전에 암묵적으로 declaration phase가 먼저 실행되지만 <strong>initialization phase는 런타임에 변수 선언문에 도달했을 때 실행</strong>된다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57430144-acef3080-7269-11e9-987d-75b1881b029a.png" alt="let declaration"></p><p>initialization phase가 실행되기 이전에 변수에 접근하려고 하면 reference error가 발생한다. 아직 변수를 위한 메모리 공간이 확보되지 않았기 때문이다. 따라서 스코프의 시작 지점부터 변수 선언문을 만나서 initialization phase가 시작되기 전까지는 변수를 참조할 수 없다.</p><blockquote><h3 id="TDZ-Temporal-Dead-Zone"><a href="#TDZ-Temporal-Dead-Zone" class="headerlink" title="TDZ (Temporal Dead Zone)"></a>TDZ (Temporal Dead Zone)</h3><p>스코프의 시작 지점부터 Initialization phase 시작 지점까지의 구간 </p></blockquote><p><code>let</code> 키워드로 선언한 변수는 hoisting이 되지 않는 게 아니라, 선언문을 만났을 때 initialization phase를 진행하는 것이다.</p><h2 id="2-4-Global-Object-and-let"><a href="#2-4-Global-Object-and-let" class="headerlink" title="2.4. Global Object and let"></a>2.4. Global Object and <code>let</code></h2><p><strong>전역 객체(Global Object)</strong>는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 브라우저 환경에서는 window 객체, Node.js 환경에서는 global 객체를 말한다.</p><p><strong><code>var</code> 키워드로 선언한 전역 변수와, 키워드 없이 선언하고 값을 할당한 암묵적 전역변수, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;</span><br><span class="line">y = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.x === x);<span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.y === y);<span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.foo === foo);<span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><p>전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.</p><p>그러나 <code>let</code> 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다. <code>let</code> 전역 변수는 전역 렉시컬 환경의 선언적 환경 레코드 내에 존재하게 된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.x);<span class="hljs-comment">// undefined</span></span><br></pre></td></tr></table></figure><h1 id="3-const-Keyword"><a href="#3-const-Keyword" class="headerlink" title="3. const Keyword"></a>3. <code>const</code> Keyword</h1><p><code>const</code> 키워드는 상수(변하지 않는 고정된 값)를 선언하기 위해 사용한다. <code>let</code> 과 <code>const</code> 는 동일한 특징이 많다. 차이점을 살펴보자.</p><h2 id="3-1-Declaration-and-Initialization"><a href="#3-1-Declaration-and-Initialization" class="headerlink" title="3.1. Declaration and Initialization"></a>3.1. Declaration and Initialization</h2><p><code>let</code> 키워드로 선언한 변수와 달리 <code>const</code> 키워드로 선언한 변수는 재할당이 금지된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.14</span>;</span><br><span class="line"></span><br><span class="line">PI = <span class="hljs-number">3.141492</span>;<span class="hljs-comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p><code>const</code> 키워드로 선언한 변수는 반드시 선언과 할당이 동시에 이루어져야 한다. 이후로는 재할당을 할 수 없다.</p><p><code>const</code> 키워드로 선언한 변수 또한 block-level scope를 갖는다.</p><h2 id="3-2-Constant"><a href="#3-2-Constant" class="headerlink" title="3.2. Constant"></a>3.2. Constant</h2><p>변수를 만들고 재할당을 하지 않을 거라면 상수를 적극적으로 쓰는 게 좋다. 고정된 값을 상수로 만들어 쓰면 코드의 가독성을 높일 수 있다. 상수는 프로그램 전체에서 사용하므로, 유지보수에 효율적이다.</p><h2 id="3-3-const-Keyword-and-Object"><a href="#3-3-const-Keyword-and-Object" class="headerlink" title="3.3. const Keyword and Object"></a>3.3. <code>const</code> Keyword and Object</h2><p><code>const</code> 키워드로 선언한 변수에 primitive value를 할당한 경우, primitive value는 immutable value이고 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법이 없다.</p><p><code>const</code> 키워드로 선언한 변수에 객체를 할당한 경우, 재할당이 금지되는 것은 마찬가지이다. 그러나 객체는 mutable value이므로 <code>const</code> 키워드로 선언된 변수에 할당된 객체는 변경이 가능하다.</p><p>즉, <code>const</code> 키워드는 재할당을 금지할 뿐 immutable을 의미하지 않는다. immutable과 mutable은 상수와 변수의 개념이 아닌, 값의 변경에 대한 개념이다.</p><h1 id="4-var-vs-let-vs-const"><a href="#4-var-vs-let-vs-const" class="headerlink" title="4. var vs. let vs. const"></a>4. <code>var</code> vs. <code>let</code> vs. <code>const</code></h1><p>변수 선언에는 기본적으로 <code>const</code>를 사용하고 <code>let</code>은 재할당이 필요한 경우에 사용하는 것이 좋다. </p><ul><li>ES6 사용시 <code>var</code> 키워드 사용하지 않는다.</li><li>재할당이 필요한 경우에만 <code>let</code> 키워드를 사용하고, 변수의 스코프를 최소화 한다.</li><li>객체와 변경을 하지 않을 원시 값에는 <code>const</code> 키워드를 사용한다.</li><li><code>var</code> 와 <code>let</code>/<code>const</code>를 함께 쓰지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Problems-with-Variables-declared-with-the-var-keyword&quot;&gt;&lt;a href=&quot;#1-Problems-with-Variables-declared-with-the-var-keyword&quot; class=&quot;h
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>13. Problems with Global Variables</title>
    <link href="https://sub2n.github.io/2019/05/09/13-Problems-with-global-variables/"/>
    <id>https://sub2n.github.io/2019/05/09/13-Problems-with-global-variables/</id>
    <published>2019-05-09T02:26:46.000Z</published>
    <updated>2019-05-10T05:25:54.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Life-Cycle-of-a-Variable"><a href="#1-Life-Cycle-of-a-Variable" class="headerlink" title="1. Life Cycle of a Variable"></a>1. Life Cycle of a Variable</h1><p>변수는 선언에 의해 생성되고 할당을 통해 값을 가진다. 생성된 변수는 언젠가는 소멸한다. 변수가 생성되고 소멸되는 주기를 변수의 생명 주기라고 한다.</p><p>변수가 생성된다는 것은 메모리 공간을 차지하는 것이고, 소멸됨은 차지하던 메모리가 해제되는 것이다.</p><p>조금 더 정확히 말하면 변수가 소멸된다는 것은 등록된 식별자가 소멸한다는 것이다. 이때 식별자와 값의 바인딩이 해제된다. 어떤 지역 스코프가 사라질 때 그 스코프에 등록된 식별자들이 소멸된다.</p><p>함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다. 즉, 지역 변수의 생명주기는 함수와 생명 주기와 같다. 그래서 지역 변수의 생명주기는 비교적 짧다. 그러나 전역 변수는 다르다.</p><p>함수는 함수 몸체의 문이 끝나거나, return 문이 실행되면 종료한다. 하지만 전역 코드는 마지막 문이 끝나서 더 이상 실행할 문이 없어도 함수처럼 종료하지 않는다. 전역변수는 브라우저를 종료해서 애플리케이션을 종료할 때까지 유효하다. 즉, 전역 변수의 생명주기는 애플리케이션의 생명 주기와 일치한다. 이는 다음과 같은 문제점을 가진다.</p><h1 id="2-Problem-of-Global-Variable"><a href="#2-Problem-of-Global-Variable" class="headerlink" title="2. Problem of Global Variable"></a>2. Problem of Global Variable</h1><h2 id="2-1-Implicit-Coupling"><a href="#2-1-Implicit-Coupling" class="headerlink" title="2.1. Implicit Coupling"></a>2.1. Implicit Coupling</h2><p>전역 변수는 코드의 전체 영역에서 사용할 수 있다. 이는 <strong>모든 코드에서 전역 변수를 참조하고 변경할 수 있는 암묵적 결합</strong>을 허용한다. 문제는 변수의 유효 범위가 크면 클수록 코드의 가독성이 나빠지고 의도치 않은 상태 변경이 일어난다는 것이다.</p><h2 id="2-2-Long-Life-Cycle"><a href="#2-2-Long-Life-Cycle" class="headerlink" title="2.2. Long Life Cycle"></a>2.2. Long Life Cycle</h2><p>전역 변수는 생명 주기가 길다. 이는 다음과 같이 몇 가지 문제점을 가진다.</p><ul><li>전역 변수의 상태를 변경할 수 있는 시간이 길다.</li><li>모든 함수가 참조할 수 있으므로 상태가 변경될 위험이 크다.</li><li>메모리 리소스를 오랜기간 차지한다.</li><li><code>var</code> 키워드는 변수의 중복 선언을 허용하므로 중간에 변수명이 중복되어 의도치 않은 재할당이 일어날 수 있다.</li></ul><h2 id="2-3-Exist-at-the-End-of-the-Scope-Chain"><a href="#2-3-Exist-at-the-End-of-the-Scope-Chain" class="headerlink" title="2.3. Exist at the End of the Scope Chain"></a>2.3. Exist at the End of the Scope Chain</h2><p>전역 변수의 또다른 문제점은 스코프 체인 가장 상위에 존재한다는 것이다. 이는 자바스크립트 엔진이 전역 변수를 찾을 때 가장 마지막 스코프까지 검색해야함을 의미한다. 즉, 전역 변수의 검색 속도가 가장 느리다.</p><h2 id="2-4-Namespace-Pollution"><a href="#2-4-Namespace-Pollution" class="headerlink" title="2.4. Namespace Pollution"></a>2.4. Namespace Pollution</h2><p>자바스크립트의 특성으로, 분리되어있는 파일을 함께 import할 경우 하나의 전역 스코프를 공유한다. 따라서 다른 파일 내에서 동일한 이름으로 명명한 변수나 함수가 겹칠 경우 예상치 못한 결과를 가져올 수 있다.</p><h1 id="3-How-to-Suppress-Using-Global-Variables"><a href="#3-How-to-Suppress-Using-Global-Variables" class="headerlink" title="3. How to Suppress Using Global Variables"></a>3. How to Suppress Using Global Variables</h1><p>위에서 살펴본 바와 같이 전역 변수의 사용은 위험하다. 반드시 사용해야할 때가 아니라면 지역 변수를 사용해야 한다. </p><h2 id="3-1-Immediately-Invoke-Function-Expression"><a href="#3-1-Immediately-Invoke-Function-Expression" class="headerlink" title="3.1. Immediately Invoke Function Expression"></a>3.1. Immediately Invoke Function Expression</h2><p>즉시 실행 함수는 함수의 정의와 동시에 한 번만 호출되는 함수로, 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 함수는 스코프를 만들고, 함수 내에 선언된 변수는 지역 변수가 된다는 것을 이용한 방법이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> foo = <span class="hljs-number">10</span>;<span class="hljs-comment">//local variable of IIF</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>가장 간단하고 일반적인 방식이다.</p><h2 id="3-2-Namespace-Object"><a href="#3-2-Namespace-Object" class="headerlink" title="3.2. Namespace Object"></a>3.2. Namespace Object</h2><p>전역 네임 스페이스 역할을 담당할 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다. 즉, 전역 변수를 네임 스페이스 객체의 프로퍼티로 등록하고 사용하는 방법이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> GLOBAL = &#123;&#125;;<span class="hljs-comment">// global namespace object</span></span><br><span class="line">GLOBAL.name = <span class="hljs-string">'Lee'</span>;</span><br></pre></td></tr></table></figure><p>현재는 잘 안 쓰는 방식.</p><h2 id="3-3-Module-Pattern"><a href="#3-3-Module-Pattern" class="headerlink" title="3.3. Module Pattern"></a>3.3. Module Pattern</h2><p>모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아서 즉시 실행함수로 감싸 하나의 모듈로 만든다. 모듈 패턴은 자바스크립트의 <strong>클로저</strong>를 기반으로 동작한다.</p><p><strong>캡슐화란 보호하고자 하는 내부 구현을 외부로부터 감추는 것</strong>을 말한다. 캡슐화의 목적은 상태 유지로, 외부에서 객체 내부의 상태를 변경하는 것을 제한한다. C++이나 Java의 class는 기본적으로 Access modifier를 제공하여 공개 범위를 한정할 수 있게 한다.</p><p>자바스크립트는 Access modifier를 제공하지 않는다. 모듈 패턴은 전역 네임 스페이스의 오염을 막는 기능에 더해서, 한정적이기는 하지만 캡슐화를 구현하기 위해 사용한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Account = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// private variable</span></span><br><span class="line">  <span class="hljs-keyword">var</span> balance = <span class="hljs-number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">      deposit(money) &#123;</span><br><span class="line">        balance += money;</span><br><span class="line">          <span class="hljs-keyword">return</span> balance;</span><br><span class="line">      &#125;,</span><br><span class="line">      withdraw(money) &#123;</span><br><span class="line">          balance -= money;</span><br><span class="line">          <span class="hljs-keyword">return</span> balance;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Account.balance);        <span class="hljs-comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Account.deposit(<span class="hljs-number">3000</span>));<span class="hljs-comment">//3000</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Account.withdraw(<span class="hljs-number">1000</span>));<span class="hljs-comment">//2000</span></span><br></pre></td></tr></table></figure><p>위 코드의 즉시 실행 함수는 외부에 노출할 메소드를 객체에 담아 반환한다. 이 때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버이다. 반환되는 객체에 추가되지 않은 변수나 함수는 모두 외부에서 접근할 수 없는 프라이빗 멤버가 된다.</p><blockquote><h4 id="Closure"><a href="#Closure" class="headerlink" title="Closure?"></a>Closure?</h4><p>그런데 즉시 실행 함수는 선언과 동시에 실행되고 종료되는데 deposit()과 withdraw() 메소드가 어떻게 num을 참조할 수 있을까? </p><p>deposit()과 withdraw()는 즉시 실행 함수의 중첩 함수로, 중첩 함수가 외부 함수보다 더 오래 살아남아 있을 경우 이를 <strong>클로저</strong>라고 부른다. </p><p>자바스크립트의 함수 객체는 생성될 때, 프로퍼티 어트리뷰트로 [[Environment]]라는 내부 슬롯을 가진다. 이 곳에 자신이 생성될 때의 외부 스코프(Lexical scope)를 담는다. 이는 함수 객체가 소멸하기 전까지 유지된다. 위의 num같은 변수를 자유변수라고 한다.</p><p>deposit()과 withdraw()는 같은 lexical scope object를 참조하고 있다. 모던 자바스크립트 프로그래밍에서는 클로저의 사용을 적극 권장한다.</p></blockquote><h2 id="3-4-ES6-Module"><a href="#3-4-ES6-Module" class="headerlink" title="3.4 ES6 Module"></a>3.4 ES6 Module</h2><ul><li>import</li><li>export</li></ul><p>ES6가 구체적인 구현 스펙을 제안하지 않아 대부분의 브라우저가 완전히 지원하지는 않는다. 그러나 Webpack 등의 모듈 번들러를 사용해서 ES6 모듈을 사용할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Life-Cycle-of-a-Variable&quot;&gt;&lt;a href=&quot;#1-Life-Cycle-of-a-Variable&quot; class=&quot;headerlink&quot; title=&quot;1. Life Cycle of a Variable&quot;&gt;&lt;/a&gt;1. Life
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>190508-TIL</title>
    <link href="https://sub2n.github.io/2019/05/08/190508-TIL/"/>
    <id>https://sub2n.github.io/2019/05/08/190508-TIL/</id>
    <published>2019-05-08T12:19:28.000Z</published>
    <updated>2019-05-08T12:23:59.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learend"><a href="#Today-I-Learend" class="headerlink" title="Today I Learend"></a>Today I Learend</h2><p>Studied JavaScript function and scope of JavaScript.</p><p>✨ <a href="https://sub2n.github.io/2019/05/08/11-Function/">Function posting</a> ✨</p><p>✨ <a href="https://sub2n.github.io/2019/05/08/12-Scope/">Scope posting</a> ✨</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learend&quot;&gt;&lt;a href=&quot;#Today-I-Learend&quot; class=&quot;headerlink&quot; title=&quot;Today I Learend&quot;&gt;&lt;/a&gt;Today I Learend&lt;/h2&gt;&lt;p&gt;Studied JavaScript
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>12. Scope</title>
    <link href="https://sub2n.github.io/2019/05/08/12-Scope/"/>
    <id>https://sub2n.github.io/2019/05/08/12-Scope/</id>
    <published>2019-05-08T06:23:34.000Z</published>
    <updated>2019-05-08T08:56:00.084Z</updated>
    
    <content type="html"><![CDATA[<p>The scope determines the extent to which the identifier can be referenced. A scope is a data structure that keeps the binding of identifiers and values, and is managed by the JavaScript engine.</p><h1 id="What-is-Scope"><a href="#What-is-Scope" class="headerlink" title="What is Scope?"></a>What is Scope?</h1><p>The range in which the variable is valid. That is, the extent to which other code can refer to the variable itself. The scope is created by the location <strong>where the variable is declared</strong>.</p><p>When there are variables with the same name in different scopes, JavaScript engine must decide which variable to reference at runtime. JavaScript uses the scope to determine which variables to reference. That is, <strong>the scope is the rule that the JavaScript engine uses to search for variables to reference.</strong></p><p>By default, JavaScript supports function-level scopes rather than block-level scopes. Variables declared with <code>var</code> form a function-level scope. However, variables declared with <code>let</code> or <code>const</code> form a block-level scopes.</p><p>If there is no scope, the name of the variable in the program should be unique.</p><blockquote><h4 id="Duplicate-declaration-of-var-keyword-variable"><a href="#Duplicate-declaration-of-var-keyword-variable" class="headerlink" title="Duplicate declaration of var keyword variable"></a>Duplicate declaration of <code>var</code> keyword variable</h4><p>Variables declared with the <code>var</code> keyword allow duplicate declarations within the same scope.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">&gt;     <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="hljs-comment">// This statement operates like x = 2;</span></span><br><span class="line">&gt;     <span class="hljs-comment">// So reassignment occurs.</span></span><br><span class="line">&gt;     <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;<span class="hljs-comment">//2</span></span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">//2</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; foo();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Variables declared as <code>let</code> or <code>const</code> do not allow duplicate declarations, so it is better to use them.</p></blockquote><h1 id="Types-of-scope"><a href="#Types-of-scope" class="headerlink" title="Types of scope"></a>Types of scope</h1><p>Code can be distinguished as global and local.</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">Global</th><th style="text-align:center">Local</th></tr></thead><tbody><tr><td style="text-align:left">Explanation</td><td style="text-align:center">Outermost area of code</td><td style="text-align:center">Inside of function body</td></tr><tr><td style="text-align:left">Scope</td><td style="text-align:center">Global scope</td><td style="text-align:center">Local scope</td></tr><tr><td style="text-align:left">Vaiable</td><td style="text-align:center">Global variable</td><td style="text-align:center">Local variable</td></tr></tbody></table><p>The variable is determined by its declared location (global or local) to the scope in which it is valid. </p><ul><li>A variable declared in global is a global variable having a global scope</li><li>A variable declared in local is a local variable having a local scope.</li></ul><p>Declaring a variable in global is a global variable with a global scope. Global variables can be referenced anywhere. In other words, global variables are valid in the global scope.</p><p>Local variables can be referenced only in the declared region and sub-region (nested function). In other words, local variables are valid in their local and subregional scopes.</p><h1 id="Scope-Chain"><a href="#Scope-Chain" class="headerlink" title="Scope Chain"></a>Scope Chain</h1><p>Scopes are created by functions. Functions can be nested, so the local scope of a function can also be nested. This means that <strong>the scope has a hierarchical structure by nesting of functions</strong>.</p><p>The local scope of the outer function is the top scope of the nested function.</p><p><strong>The scope chain</strong> refers to a structure in which the scopes from the deepest local scope to the global scope of the overlap are hierarchically connected.</p><p>When referring to a variable, the JavaScript engine starts at the scope of the code that references the variable, moves to the top scope, and searches for the declared variable.</p><h1 id="Function-level-Scope"><a href="#Function-level-Scope" class="headerlink" title="Function-level Scope"></a>Function-level Scope</h1><ul><li>Most programming language like C, Java <ul><li>Block-level scope</li><li>All code blocks (if, for, while, try / catch, etc.), not just the function body, create the local scope.</li></ul></li><li>Variables declared with the <code>var</code> keyword <ul><li><strong>Function-level scope</strong></li><li>Accept only the code block of the <strong>function</strong> as the local scope.</li></ul></li></ul><p>The <code>let</code> and <code>const</code> keywords introduced in ES6 support block level scopes.</p><h1 id="Lexical-Scope"><a href="#Lexical-Scope" class="headerlink" title="Lexical Scope"></a>Lexical Scope</h1><ul><li>Dynamic Scope<ul><li>The function’s top scope is determined by <strong>where the function is called.</strong></li></ul></li><li><strong>Lexical Scope</strong> / Static Scope<ul><li>The function’s top scope is determined by <strong>where the function is defined.</strong></li><li>Most programming languages follow the lexical scope.</li></ul></li></ul><p>JavaScript follows a lexical scope. So it determines the top scope depending on where it is defined.</p><h1 id="Implicit-Global-Variable"><a href="#Implicit-Global-Variable" class="headerlink" title="Implicit Global Variable"></a>Implicit Global Variable</h1><p>If declare a variable without <code>var</code> keyword, it becomes a global variable.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    i = <span class="hljs-number">0</span>;<span class="hljs-comment">//implicit global variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// var i = 0 is a duplicate declaration</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(i);</span><br><span class="line">&#125;<span class="hljs-comment">// infinite loop</span></span><br></pre></td></tr></table></figure><p>Global variables are so dangerous!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;The scope determines the extent to which the identifier can be referenced. A scope is a data structure that keeps the binding of identifi
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Scope" scheme="https://sub2n.github.io/tags/Scope/"/>
    
  </entry>
  
  <entry>
    <title>11. Function</title>
    <link href="https://sub2n.github.io/2019/05/08/11-Function/"/>
    <id>https://sub2n.github.io/2019/05/08/11-Function/</id>
    <published>2019-05-08T00:47:35.000Z</published>
    <updated>2019-05-08T09:03:15.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-a-Function"><a href="#What-is-a-Function" class="headerlink" title="What is a Function?"></a>What is a Function?</h1><p>In mathematics, a function defines the process of receiving an input and outputting it.</p><p>In programming language, a function is defined as a unit of execution by implementing a series of processes as statements and wrapping them in code blocks. This function also receive input and outputting it.</p><p>In function,</p><ul><li>parameter : variable that receiving input</li><li>argument : input</li><li>return value : output</li></ul><p>And function has a name as identifier. </p><p>A function is created by a <strong>function definition</strong>. You must call the function to execute the generated function. This is called a <strong>function call</strong>.</p><h1 id="Why-use-a-function"><a href="#Why-use-a-function" class="headerlink" title="Why use a function?"></a>Why use a function?</h1><ul><li>To <strong>reuse</strong> the same code repeated in many parts.</li><li>To remove redundant code to improve <strong>maintenance</strong> efficiency.</li><li>To improve the <strong>readability</strong> of your code using function names that specify functions.</li></ul><h1 id="Function-Literal"><a href="#Function-Literal" class="headerlink" title="Function Literal"></a>Function Literal</h1><p>Just as objects are created as object literals, functions can also be created as function literals. Function literal consists of function keyword, function name, list of parameters and function body. A <strong>function literal is evaluated to create a function object</strong>.</p><ul><li>Function name<ul><li>Since the function name is an identifier, it must conform to the identifier naming rules.</li><li>A function name is an identifier that can be referenced <strong>only within a function body</strong>.</li><li>The function name can be omitted. A function with a function name is called a <strong><em>named function</em></strong>, and a function without a function name is called an <strong><em>anonymous function</em></strong>.</li></ul></li><li>List of parameters<ul><li>Wrap 0 or more parameters in parentheses and separate them with commas.</li><li>Parameters are assigned arguments.</li><li>Parameters are treated the same as variables in the function body.</li></ul></li><li>Function body<ul><li>It is a block of code that defines the statements to be executed in batches as a unit of execution when the function is called.</li><li>The function body is executed by a function call.</li></ul></li></ul><p>A function literal is evaluated to produce a value, which is an object. In other words, <strong>the function of JavaScript is an object.</strong></p><p>Unlike regular objects, functions can be called and have unique properties. All function objects have <code>[[Call]]</code>.</p><h1 id="Definition-of-Function"><a href="#Definition-of-Function" class="headerlink" title="Definition of Function"></a>Definition of Function</h1><p>There are 4 ways to define a function.</p><ul><li><p>Function Declaration / Function Statement</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Function Expression</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Function Constructor</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'return x + y'</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Arrow Function (ES6)</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure></li></ul><p>Each method defines a function, but there is an important difference.</p><h2 id="Function-Declaration"><a href="#Function-Declaration" class="headerlink" title="Function Declaration"></a>Function Declaration</h2><p>The function declaration has the same format as the function literal, but <strong>the function name can not be omitted.</strong> This is because the JavaScript engine needs to create variables with function names.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Function Declaration</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//Function Call</span></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//5</span></span><br></pre></td></tr></table></figure><p>The function name is an identifier that can be referenced only within the function body.</p><p>However, when you call a function outside a function, you use the function name.</p><p>When a function declaration is executed to create a function object, a variable is needed to assign the function object. This is because the function object can not be stored in memory unless it is allocated anywhere. </p><p>Therefore, the JavaScript engine</p><ol><li>Implicitly declares an identifier of the same name as the function name</li><li>Assigns the created function object to the identifier.</li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// This is the pseudo code when the above function add statement is executed.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// variable add is an identifier created by the JavaScript engine with the same name as the function name implicitly. </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><p>Function name can only be referenced within a function, and implicitly created <strong>variable</strong> name can be referenced <strong>in the scope where the function is defined</strong>.</p><p><img src="https://user-images.githubusercontent.com/48080762/57363047-21b76180-71bb-11e9-9fa1-d67593e265e4.png" alt="Pseudo Code"></p><p>This pseudo code is the following function expression. That is, the JavaScript engine converts function declarations into function expressions to create function objects.</p><h2 id="Function-Expression"><a href="#Function-Expression" class="headerlink" title="Function Expression"></a>Function Expression</h2><h3 id="First-class-object"><a href="#First-class-object" class="headerlink" title="First-class object"></a>First-class object</h3><p>An object that can be assigned to a variable, such as a value, which can be the value of a property or an element of an array.</p><p>Function in JavaScript is a first-class object. It means that a function can be freely used as a value. </p><p>A function object created with a function literal can be assigned to a variable. This way of defining a function is called a <strong>function expression</strong>.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Function Expression</span></span><br><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><p>Unlike function declarations, function literals can omit function names. It is common to use anonymous functions in function expressions.</p><p>Since a function name is an identifier that can be referenced only by a function body, even if a named function is used, the function must be called with the variable name to which the function object is assigned.</p><h2 id="Function-Creation-time-and-Function-Hoisting"><a href="#Function-Creation-time-and-Function-Hoisting" class="headerlink" title="Function Creation time and Function Hoisting"></a>Function Creation time and Function Hoisting</h2><p>Function declarations and function expressions seem to behave similarly, because the JavaScript engine implicitly declares the variable as a function name in the function declaration statement and allocates the created object.<br>However, function declaration is non-expression statement, and function expression is an expression statement. Therefore, there is an important difference.</p><p>The point at which the function is created is when the JavaScript engine evaluates the function declaration to create the function object.</p><ul><li><p><strong>Function declaration statements are executed before runtime</strong> because they are declarations themselves. </p></li><li><p>However, <strong>function expressions are executed at run-time</strong> because they are assignment statements that assign function literals to variables. </p></li></ul><p>That is, the function created by the function declaration statement and the function generated by the function expression are created at different times.</p><p>Functions created with function declarations are executed and hoisted before runtime, but functions created with function expressions are not hoisted.</p><p>Unlike variable hoisting, in the case of function hoisting, a function object is referenced instead of undefined.</p><h2 id="Function-Constructor"><a href="#Function-Constructor" class="headerlink" title="Function Constructor"></a>Function Constructor</h2><blockquote><h2 id="Constructor-Function"><a href="#Constructor-Function" class="headerlink" title="Constructor Function"></a>Constructor Function</h2><p>A constructor function is a function that creates an object.</p></blockquote><p>The <code>function</code> constructor function, which is a built-in function provided by JavaScript, receives a parameter list and a function body as a string. It is called with the <code>new</code> operator and returns the created function object.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Function Constructor</span></span><br><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'return x + y'</span>);</span><br><span class="line"></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><p>However, creating a function as a function constructor is not common. These functions behave differently from function declarations or function expressions.</p><p>Do not use it!</p><h2 id="Arrow-Function"><a href="#Arrow-Function" class="headerlink" title="Arrow Function"></a>Arrow Function</h2><p>An arrow function introduced in ES6 can make a function simply without a <code>function</code> keyword. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Arrow Function</span></span><br><span class="line"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><p>The arrow function is not available in all situations.</p><h1 id="Function-Call"><a href="#Function-Call" class="headerlink" title="Function Call"></a>Function Call</h1><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Function Call</span></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><ul><li><code>add</code> : Variable name referring to function object, not function name</li><li><code>( )</code> : Function call operator</li><li><code>2, 3</code> : Arguments to be assigned to the parameter</li></ul><p>Calling a function stops the current execution flow and passes control to the called function. At this point, arguments are assigned to the parameters and the statements in the function body begin to execute.</p><h1 id="Parameter-and-Argument"><a href="#Parameter-and-Argument" class="headerlink" title="Parameter and Argument"></a>Parameter and Argument</h1><ul><li>Parameter<ul><li>Declare when defining a function</li><li>Treated as variables in the function body</li><li>When a function is called, the parameter is implicitly created in the function body, initialized to undefined, and then an argument is assigned.</li><li>The scope of the parameter is inside the function.</li></ul></li><li>Argument<ul><li>If the argument is passed less than the parameter, the missing parameter has the value undefined. (No error)</li><li>If the argument is passed in more than the parameter, the excess argument is ignored and kept in the arguments object.</li></ul></li></ul><h1 id="Argument-Check"><a href="#Argument-Check" class="headerlink" title="Argument Check"></a>Argument Check</h1><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">'number'</span> || <span class="hljs-keyword">typeof</span> y !== <span class="hljs-string">'number'</span>)</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Non-number type value has assigned to parameter.'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="hljs-number">2</span>);<span class="hljs-comment">// TypeError: Non-number type value has assigned to parameter.</span></span><br><span class="line">add(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);<span class="hljs-comment">// TypeError: Non-number type value has assigned to parameter.</span></span><br></pre></td></tr></table></figure><p>It is necessary to check whether the argument is passed properly in the JavaScript function. Because..</p><ul><li>JavaScript functions do not check that the number of parameters and arguments match.</li><li>Because JavaScript is a dynamic type language, functions do not specify the type of parameters in advance.</li></ul><h1 id="Number-of-parameters"><a href="#Number-of-parameters" class="headerlink" title="Number of parameters"></a>Number of parameters</h1><p>The smaller the number of parameters, the better. A function with 0 parameters is ideal. The more parameters, the more things to consider when using the function, which leads to errors.</p><p>Also, if the number or sequence of parameters changes, all the code that calls the function must be modified.</p><p>The ideal function should only do one thing and make it as small as possible. In addition to functions, classes and other functional units must be as clear and small as possible too.</p><h1 id="External-State-Changes-and-Functional-Programming"><a href="#External-State-Changes-and-Functional-Programming" class="headerlink" title="External State Changes and Functional Programming"></a>External State Changes and Functional Programming</h1><p>Since functions are objects, they follow pass by reference. Passing a value to a function’s parameters is called as <strong>Call by value</strong> and <strong>Call by reference</strong>, but the behavior is the same as <strong>Pass by value</strong> and <strong>Pass by reference</strong>.</p><p>As we saw in <a href="https://sub2n.github.io/2019/05/07/10-Comparing-primitive-and-objects/">10. Comparing primitive and objects</a>, there is a side effect in which the original object is changed by reference values passed from inside the function body to outside of the function. This is called change of external state.</p><ul><li>Pure function : functions that do not change any external state (No side effect)</li><li>Impure function : functions that change the external state inside a function (Side effect)</li></ul><p><img src="https://user-images.githubusercontent.com/48080762/57363055-2714ac00-71bb-11e9-9810-7770c44966c8.png" alt="External State Change"></p><p>Functional programming is a programming paradigm that avoids state changes by suppressing the use of variables and solves complexity by eliminating conditional statements and loops in the logic through the combination of pure and auxiliary functions. Variable values can be changed by someone at any time, and conditional statements or loop statements can make the flow of logic difficult to understand, which can impair readability and become a root cause of errors.</p><p>Functional programming is a way to avoid errors and increase the stability of programs by minimizing side effects through pure functions.</p><h2 id="Return-Statement"><a href="#Return-Statement" class="headerlink" title="Return Statement"></a>Return Statement</h2><p>The function returns the execution result through a return statement consisting of the <code>retur</code>n keyword and the return value.</p><p>When the return statement is executed, execution of the function is aborted and the function body is exited.</p><p>If do not write anything after the <code>return</code> keyword or write a return statement, <code>undefined</code> is returned implicitly.</p><h2 id="Types-of-various-Functions"><a href="#Types-of-various-Functions" class="headerlink" title="Types of various Functions"></a>Types of various Functions</h2><h3 id="IIFE-Immediately-Invoke-Function-Expression"><a href="#IIFE-Immediately-Invoke-Function-Expression" class="headerlink" title="IIFE ( Immediately Invoke Function Expression)"></a>IIFE ( Immediately Invoke Function Expression)</h3><p>A function that <em>executes concurrently with the definition</em> of a function. It is common to use anonymous functions and can not be called again once.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Anonymous immediately invoke function</span></span><br><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-keyword">var</span> b = <span class="hljs-number">3</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>Even if a named function is used, the function name can not be referenced outside of the function and can not be called again.</p><p>An immediate function must be enclosed in the group operator <code>()</code>. Otherwise, it will not be identified and an error will occur.</p><p>If put the code in the immediate function, collision of the variable name or the function name can be prevented. An immediate execution function is used for this purpose.</p><h3 id="Recursive-Function"><a href="#Recursive-Function" class="headerlink" title="Recursive Function"></a>Recursive Function</h3><p>A recursive call is to call itself. A function that calls itself is called a recursive function.</p><p>When creating a recursive function, a base case with an escape condition must be included. Stack overflow occurs when a function is called without escaping.</p><p>Most of what can be implemented as recursive functions can be implemented as loops.</p><h3 id="Nested-Function-Inner-Function"><a href="#Nested-Function-Inner-Function" class="headerlink" title="Nested Function / Inner Function"></a>Nested Function / Inner Function</h3><p>A function defined inside a function is called a nested function (or inner function). A nested function acts as a helper function of an outer function that contains itself.</p><p>A nested function can access variables of an outer function, but an outer function can not access variables of a nested function. The nesting of functions means the nesting of the scope.</p><h3 id="Callback-Function"><a href="#Callback-Function" class="headerlink" title="Callback Function"></a>Callback Function</h3><p>Because JavaScript functions are first-class objects, can pass functions as arguments to functions.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Function that recieves calback function</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">f</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> string = <span class="hljs-string">'Good'</span>;</span><br><span class="line">    <span class="hljs-comment">// Determine when to call the callback function passed in parameter and call the function</span></span><br><span class="line">    <span class="hljs-keyword">return</span> f(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// It calls the print function and passes the callback function</span></span><br><span class="line"><span class="hljs-keyword">var</span> upper = print(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> str.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// It calls the print function and passes the callback function</span></span><br><span class="line"><span class="hljs-keyword">var</span> lower = print(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> str.toLowerCase();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(upper, lower);<span class="hljs-comment">//GOOD good</span></span><br></pre></td></tr></table></figure><p>The function passed to the print function as an argument is called a <strong>callback function</strong>. The callback function calls the function that receives the callback function as an argument by determining the point of call.</p><p>Using a callback function is like pushing a nested function depending on your needs and circumstances.</p><p>Just as a nested function acts as a helper function to help an outer function, the callback function is passed to the function to serve as a helper function. However, since the nested function is fixed and can not be replaced, the callback function can be freely replaced because it is injected as an argument outside the function.</p><p>When you pass a callback function from the outside, you can create a function that performs various actions depending on the callback function.</p><p>That is, it is useful to use the callback function in situations where it is changed instead of being fixed like a nested function.</p><p>Callback functions are mainly used for <strong>event handling</strong>, Ajax communication, and higher-order functions.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What-is-a-Function&quot;&gt;&lt;a href=&quot;#What-is-a-Function&quot; class=&quot;headerlink&quot; title=&quot;What is a Function?&quot;&gt;&lt;/a&gt;What is a Function?&lt;/h1&gt;&lt;p&gt;In m
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CodeWars 6kyu. Consecutive strings</title>
    <link href="https://sub2n.github.io/2019/05/07/CodeWars-6kyu-Consecutive-strings/"/>
    <id>https://sub2n.github.io/2019/05/07/CodeWars-6kyu-Consecutive-strings/</id>
    <published>2019-05-07T12:46:33.000Z</published>
    <updated>2019-05-08T10:07:35.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CodeWars-6kyu-Consecutive-strings"><a href="#CodeWars-6kyu-Consecutive-strings" class="headerlink" title="CodeWars 6kyu. Consecutive strings"></a><a href="https://www.codewars.com/kata/consecutive-strings/javascript" target="_blank" rel="noopener">CodeWars 6kyu. Consecutive strings</a></h2><p>Find longest k consecutive strings</p><a id="more"></a><blockquote><p>You are given an array strarr of strings and an integer k. Your task is to return the first longest string consisting of k consecutive strings taken in the array.</p></blockquote><blockquote><p>Example:</p><p>longest_consec([“zone”, “abigail”, “theta”, “form”, “libe”, “zas”, “theta”, “abigail”], 2) –&gt; “abigailtheta”</p></blockquote><blockquote><p>n being the length of the string array, if n = 0 or k &gt; n or k &lt;= 0 return “”.</p></blockquote><blockquote><p>Note</p><p>consecutive strings : follow one after another without an interruption</p></blockquote><h2 id="JavaScript-Solution"><a href="#JavaScript-Solution" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longestConsec</span>(<span class="hljs-params">strarr, k</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (strarr.length == <span class="hljs-number">0</span> || k &gt; strarr.length || k &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">let</span> longStr = <span class="hljs-string">''</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">let</span> newStr = <span class="hljs-string">''</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strarr.length; i++)&#123;</span><br><span class="line">      newStr = strarr.slice(i, i+k);</span><br><span class="line">      <span class="hljs-keyword">if</span> (newStr.join(<span class="hljs-string">''</span>).length &gt; longStr.length )&#123;</span><br><span class="line">        longStr = newStr.join(<span class="hljs-string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> longStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CodeWars-6kyu-Consecutive-strings&quot;&gt;&lt;a href=&quot;#CodeWars-6kyu-Consecutive-strings&quot; class=&quot;headerlink&quot; title=&quot;CodeWars 6kyu. Consecutive strings&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.codewars.com/kata/consecutive-strings/javascript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CodeWars 6kyu. Consecutive strings&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Find longest k consecutive strings&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://sub2n.github.io/categories/Algorithm/"/>
    
      <category term="CodeWars" scheme="https://sub2n.github.io/categories/Algorithm/CodeWars/"/>
    
    
      <category term="Algorithm" scheme="https://sub2n.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>10. Comparing primitive and objects</title>
    <link href="https://sub2n.github.io/2019/05/07/10-Comparing-primitive-and-objects/"/>
    <id>https://sub2n.github.io/2019/05/07/10-Comparing-primitive-and-objects/</id>
    <published>2019-05-07T11:24:49.000Z</published>
    <updated>2019-05-08T06:23:53.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Difference-between-primitive-type-and-object-type"><a href="#Difference-between-primitive-type-and-object-type" class="headerlink" title="Difference between primitive type and object type"></a>Difference between primitive type and object type</h2><table><thead><tr><th style="text-align:center">Primitive Type</th><th style="text-align:center">Object Type</th></tr></thead><tbody><tr><td style="text-align:center">immutable value</td><td style="text-align:center">mutable value</td></tr><tr><td style="text-align:center">stored as value itself</td><td style="text-align:center">stored as reference value (memory address of an object)</td></tr><tr><td style="text-align:center">Pass by value</td><td style="text-align:center">Pass by reference</td></tr></tbody></table><h1 id="Primitive-Value"><a href="#Primitive-Value" class="headerlink" title="Primitive Value"></a>Primitive Value</h1><h2 id="Immutable-Value"><a href="#Immutable-Value" class="headerlink" title="Immutable Value"></a>Immutable Value</h2><ul><li>The value of primitive type is an <strong>immutable value</strong>. (Read only, can not change)</li><li>Can not change value doesn’t mean can not reassign value.</li><li>Variable can be reassigned a new value, but the value can not be changed.</li><li>When reassigning a new value to a variable, instead of changing the value stored in the memory space pointed to by the variable, assign a value to the new memory space and make the variable refer to the new memory space. This is because the primitive value is immutable.</li><li>If the primitive value is a mutable value, the memory address referenced by the variable will not change when reassigning the variable.</li><li>immutability : Since the primitive value is an immutable value, when the value of the variable is changed, the new value is stored in the new memory space, and the memory space is referred to. This property is called the <strong>immutability</strong> of the primitive value.</li></ul><blockquote><h2 id="Immutable-constant"><a href="#Immutable-constant" class="headerlink" title="Immutable? constant?"></a>Immutable? constant?</h2><p>In programming language, variable is a mechanism that store and refer data values. So, constant is also variable but can not assign more than once.</p><p>Variables, and constants are memory spaces that can hold values, and the concept of mutable, immutable is about whether the value can change.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-comment">//Constants declared with the const keyword are not reassigned.</span></span><br><span class="line">&gt; <span class="hljs-keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; obj.a = <span class="hljs-number">1</span>;</span><br><span class="line">&gt; <span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// &#123;a: 1&#125;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Objects declared as <code>const</code> can be changed. This is because you are not reassigning a new object to <code>const</code>. That is, the constant is only a variable for which reassignment is prohibited.</p></blockquote><h2 id="String-and-Immutability"><a href="#String-and-Immutability" class="headerlink" title="String and Immutability"></a>String and Immutability</h2><ul><li><p>String is immutable because it’s also primitive type of JavaScript.</p></li><li><p>String is an array-like object.</p><blockquote><h3 id="Array-like-Object"><a href="#Array-like-Object" class="headerlink" title="Array-like Object"></a>Array-like Object</h3><p>An array-like object is an object that is not an array, but can be treated like an array. A string can access each character through an index like an array, or it can be traversed by a for statement. This means that the string can be an object with a length property.</p></blockquote></li><li><p>You can not change <code>str[0]</code>, but error doesn’t occur. Just ignore it.</p></li></ul><p><img src="https://user-images.githubusercontent.com/48080762/57296797-dba1c580-7108-11e9-83bd-86e735652c18.png" alt="String is immutable value"></p><ul><li>But, it is of course possible to reassign the new string. Because it is not a change to the existing string but a new assignment of the new string.</li><li>The string gives the confidence that the value does not change without reassignment.</li></ul><h2 id="Pass-by-value"><a href="#Pass-by-value" class="headerlink" title="Pass by value"></a>Pass by value</h2><p>What happens when a variable is assigned to a variable? </p><p>If assigned variable is primitive type, the assigned variable value is copied and passed. It’s <strong>pass by value</strong>.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> score = <span class="hljs-number">80</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> mine = score;</span><br></pre></td></tr></table></figure><p>Variable <code>score</code> and <code>mine</code> have a value 80, but it’s a separate value in memory. The value 80 in <code>mine</code> is not same as 80 in <code>score</code>. This is because the memory space of the variables <code>mine</code> and <code>score</code> is different and each contains a value.</p><p><img src="https://user-images.githubusercontent.com/48080762/57297341-57e8d880-710a-11e9-9007-36ec715ebcf7.png" alt="Pass by Value"></p><p>Thus, reassigning another value to the variable <code>score</code> does not affect the value of the variable <code>mine</code>.</p><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><ul><li>An object is a collection of properties consisting of key and value. A property whose value is a function is called a method.</li><li>Since the number of properties is not fixed and the object can be added and deleted dynamically, the size of the memory space can not be preset in advance like the primitive value.</li></ul><blockquote><h2 id="How-JavaScript-manages-objects"><a href="#How-JavaScript-manages-objects" class="headerlink" title="How JavaScript manages objects"></a>How JavaScript manages objects</h2><p>Unlike with an class-based object-oriented language, JavaScript can create an object without class and dynamically add a property and method even after an object have been created.</p><p>For this reason, almost modern JavaScript engine uses a function-based dictionary-like structure to score a location of object property in memory.</p><p>This is theoretically more costly and inefficient than object management in class-based object-oriented programming languages such as Java. So V8 JavaScript engine uses hidden class method. A hidden class operates like class in Java.</p></blockquote><h2 id="Mutable-Value"><a href="#Mutable-Value" class="headerlink" title="Mutable Value"></a>Mutable Value</h2><p>The value of an object (reference) type, that is, an object is a mutable value.</p><p>A variable that has been assigned a primitive value has its primitive value as its value. </p><p>But, the variable that the object is assigned has a <strong>reference value</strong> as a value. The reference value is <strong>the address of the memory space</strong> in which the created object is stored, itself.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Park'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/48080762/57298300-d181c600-710c-11e9-96ba-119ba0ffc866.png" alt="Assignment of an object"></p><ul><li><p><code>student</code> variable has a <strong>address of the memory space</strong> where a created object is stored. This is a <strong>reference value</strong>. A variable can access the object by this reference value.</p></li><li><p>When evaluating a variable that assigns an object, it returns the object by accessing the actual object through the reference value rather than returning the reference value stored in memory.</p></li><li><p>An object pointed by a variable can be added dynamically after it has been created, updated, or deleted. In other words, an object is a <strong>mutable value</strong>.</p></li><li><p>Objects can be very large and change fluidly, so instead of reallocating each time as a primitive value and changing the memory address, it changes the object itself to be referenced directly.</p></li><li><p>In other words, copying an object as a primitive value (a deep copy) is <strong>expensive and inefficient</strong>, so it copies the reference value.</p><blockquote><h3 id="Shallow-copy-and-Deep-copy"><a href="#Shallow-copy-and-Deep-copy" class="headerlink" title="Shallow copy and Deep copy"></a>Shallow copy and Deep copy</h3><ul><li>Shallow copy : copying reference values</li><li>Deep copy : copying and recreating the object itself as a primitive value. The larger the object, the higher the cost.</li></ul></blockquote></li></ul><ul><li><p>A side effect of storing an object’s reference value is that an object can be referenced by multiple identifiers.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Park'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> teacher = student;</span><br><span class="line"></span><br><span class="line">teacher.age = <span class="hljs-number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(teacher);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(student);</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/48080762/57299503-b06ea480-710f-11e9-8dd4-19c322cbf727.png" alt="Referenced by multiple identifiers"></p><ul><li>The property is added only to the object of the teacher variable, but the changes are shared because the objects referenced by the student and teacher are the same.</li></ul></li></ul><h2 id="Pass-by-Reference"><a href="#Pass-by-Reference" class="headerlink" title="Pass by Reference"></a>Pass by Reference</h2><p>If you assign a variable that points to an object to another variable, the original reference value is copied and passed. This is called <strong>pass by reference.</strong></p><p><img src="https://user-images.githubusercontent.com/48080762/57299971-d34d8880-7110-11e9-8fc7-1ee9d64a5f13.png" alt="Pass by Reference"></p><p>As shown in the figure above, since the memory address of the same object is referenced, <code>student</code> and <code>teacher</code> refer to the same object and change it.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Difference-between-primitive-type-and-object-type&quot;&gt;&lt;a href=&quot;#Difference-between-primitive-type-and-object-type&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="immutable" scheme="https://sub2n.github.io/tags/immutable/"/>
    
      <category term="mutable" scheme="https://sub2n.github.io/tags/mutable/"/>
    
      <category term="primitive" scheme="https://sub2n.github.io/tags/primitive/"/>
    
      <category term="object" scheme="https://sub2n.github.io/tags/object/"/>
    
      <category term="pass by reference" scheme="https://sub2n.github.io/tags/pass-by-reference/"/>
    
      <category term="pass by value" scheme="https://sub2n.github.io/tags/pass-by-value/"/>
    
  </entry>
  
  <entry>
    <title>190507-TIL</title>
    <link href="https://sub2n.github.io/2019/05/07/190503-TIL/"/>
    <id>https://sub2n.github.io/2019/05/07/190503-TIL/</id>
    <published>2019-05-07T10:51:17.000Z</published>
    <updated>2019-05-07T11:21:52.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><p>Studied JavaScript operator, contitional statement, type coercion and short-circuit evaluation, object literal.</p><p>Algorithm study - CodeWars [6kyu] Consecutive strings. We will start to implement underscore library functions like map, reduce.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;p&gt;Studied JavaScript
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>9. Object Literal</title>
    <link href="https://sub2n.github.io/2019/05/05/9-Object-Literal/"/>
    <id>https://sub2n.github.io/2019/05/05/9-Object-Literal/</id>
    <published>2019-05-05T11:16:54.000Z</published>
    <updated>2019-05-08T12:16:17.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-Object"><a href="#What-is-Object" class="headerlink" title="What is Object?"></a>What is Object?</h1><p>JavaScript is an object-based programming language and almost “everything” that makes up JavaScript is an object. The rest of the values (functions, arrays, regular expressions, etc.) are all objects except primitive types.</p><p>Object / reference type is a complex data structure that consists of several types of values (primitive type values or other objects) in a single unit.</p><table><thead><tr><th style="text-align:center">Primitive value</th><th style="text-align:center">Object</th></tr></thead><tbody><tr><td style="text-align:center">immutable value</td><td style="text-align:center">mutable value</td></tr><tr><td style="text-align:center">pass by value</td><td style="text-align:center">pass by reference</td></tr></tbody></table><p><strong>Object</strong> is a set of properties that consist of keys and values.</p><p>Any value that is available in JavaScript can be used as the value of the property. Functions in JavaScript are first-class objects, so they can be treated as values.</p><p>JavaScript functions are first-class objects, so they can be used as property values. If the property value is a function, it is called a <strong>method</strong> to distinguish it from a normal function.</p><ul><li>Attributes are refer to additional information of an object. </li><li>Properties are describing the characteristics of an object.</li></ul><p>An object is a set of methods, which means properties that refer to data and behavior that can refer to and manipulate data.</p><h1 id="Create-Object-by-Object-Literal"><a href="#Create-Object-by-Object-Literal" class="headerlink" title="Create Object by Object Literal"></a>Create Object by Object Literal</h1><p>Class-based object-oriented languages such as C ++ and Java pre-define classes and create objects by calling the constructor with the new operator at the point in time. However, JavaScript is a prototype-based object-oriented language that creates objects differently.</p><p>Then how JavaScript creates object?</p><ul><li>Object literal</li><li>Object constructor function</li><li>Constructor function</li><li>Object.create method</li><li>Class (ES6)</li></ul><p>The most basic and general method is using object literal.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// empty object</span></span><br><span class="line"><span class="hljs-keyword">var</span> empty = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// At the time of assignment, the object literal is interpreted and the resulting object is created.</span></span><br><span class="line"><span class="hljs-keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Park'</span>,</span><br><span class="line">    hello: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        Console.log(<span class="hljs-string">'Hello. I'</span>m $&#123;<span class="hljs-keyword">this</span>.name&#125;.<span class="hljs-string">');</span></span><br><span class="line"><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">&#125;;</span></span><br></pre></td></tr></table></figure><p>The <code>{}</code> used to create the object is not a block of code. It is an object literal because it ends with a <code>;</code>.</p><p>You can create a property as soon as you create the object by including the property in an object literal, or you can dynamically add a property after you create the object.</p><h1 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h1><p>An object is a set of properties. A property consists of a key and a value.</p><p>The values that can be used for property key and property values are as follows.</p><ul><li>Property key : all strings include empty string or symbol value</li><li>Property value : all values in JavaScript</li></ul><p>Quotes can be omitted if the property key is a name that conforms to the identifier naming convention, that is, a valid name that can be used in JavaScript.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Park'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Dynamically add property key</span></span><br><span class="line">student[<span class="hljs-string">'age'</span>] = <span class="hljs-number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(student); <span class="hljs-comment">// &#123;name: "Park", age: 25&#125;</span></span><br></pre></td></tr></table></figure><p>Property keys are allowed to be duplicated, and in the event of duplication, the last declared key is valid.</p><h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><p>If the property value is a function, it is called a method to distinguish it from a normal function. In other words, a method means a function restricted to an object.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> circle = &#123;</span><br><span class="line">  radius: <span class="hljs-number">5</span>, <span class="hljs-comment">// ← property</span></span><br><span class="line">  getDiameter: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// ← method</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">this</span>.radius; <span class="hljs-comment">// this pointing circle</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(circle.getDiameter());  <span class="hljs-comment">// 10</span></span><br></pre></td></tr></table></figure><p><code>this</code> is a reference variable that points to the object that called it.</p><h1 id="Access-of-Property"><a href="#Access-of-Property" class="headerlink" title="Access of Property"></a>Access of Property</h1><p>You can access the properties in such a way,</p><ul><li>Dot notation </li><li>Bracket notation</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> student = &#123;</span><br><span class="line">name: <span class="hljs-string">'Park'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(student.name);<span class="hljs-comment">// Access by dot notaion</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(student[<span class="hljs-string">'name'</span>];<span class="hljs-comment">// Access by bracket notation</span></span><br></pre></td></tr></table></figure><p>If the property key follows the identifier naming convention, 2 notations are both available. If not, only bracket notation is available.</p><p>If the property key is not a name that does conform to the identifier naming convention, that is, not a valid name that can be used in JavaScript,  must use square bracket notation. However, the quotation marks <code>&#39;&#39;</code> can be omitted if the property key is a string of numbers.</p><h1 id="Update-Property-Value"><a href="#Update-Property-Value" class="headerlink" title="Update Property Value"></a>Update Property Value</h1><p>If assign a value to an existing property, the property value is updated.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Park'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">student.name = <span class="hljs-string">'Kim'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(student);<span class="hljs-comment">// &#123;name: "Kim"&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Dynamic-property-creation"><a href="#Dynamic-property-creation" class="headerlink" title="Dynamic property creation"></a>Dynamic property creation</h1><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> student = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Park'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">student.age = <span class="hljs-string">'22'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(student); <span class="hljs-comment">// &#123;name: "Park", age: "22"&#125;</span></span><br></pre></td></tr></table></figure><p>Can add, modify, and delete properties after object creation is complete.</p><h1 id="New-ES6-Object-Literal-Functions"><a href="#New-ES6-Object-Literal-Functions" class="headerlink" title="New ES6 Object Literal Functions"></a>New ES6 Object Literal Functions</h1><h2 id="Property-shorthand"><a href="#Property-shorthand" class="headerlink" title="Property shorthand"></a>Property shorthand</h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> obj = &#123; x, y &#125;;   <span class="hljs-comment">// &#123; x:1, y: 2 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Property-key-dynamic-creation"><a href="#Property-key-dynamic-creation" class="headerlink" title="Property key dynamic creation"></a>Property key dynamic creation</h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// ES6</span></span><br><span class="line"><span class="hljs-keyword">const</span> prefix = <span class="hljs-string">'prop'</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 객체 리터럴 내부에서 프로퍼티 키 동적 생성</span></span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123;</span><br><span class="line">    [<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>-<span class="hljs-subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">    [<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>-<span class="hljs-subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">    [<span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>-<span class="hljs-subst">$&#123;++i&#125;</span>`</span>]: i</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Method-shorthand"><a href="#Method-shorthand" class="headerlink" title="Method shorthand"></a>Method shorthand</h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// ES6</span></span><br><span class="line"><span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Park'</span>,</span><br><span class="line">    <span class="hljs-comment">// 메소드 축약 표현</span></span><br><span class="line">    sayHi(other) &#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi, <span class="hljs-subst">$&#123;other&#125;</span>! I'm <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayHi(<span class="hljs-string">'Sam'</span>); <span class="hljs-comment">// Hi, Sam! I'm Park</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What-is-Object&quot;&gt;&lt;a href=&quot;#What-is-Object&quot; class=&quot;headerlink&quot; title=&quot;What is Object?&quot;&gt;&lt;/a&gt;What is Object?&lt;/h1&gt;&lt;p&gt;JavaScript is an obj
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
