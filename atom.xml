<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>수빈 개발블로그</title>
  
  <subtitle>Sub2n Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sub2n.github.io/"/>
  <updated>2019-06-05T08:54:37.906Z</updated>
  <id>https://sub2n.github.io/</id>
  
  <author>
    <name>Subin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>190605-TIL</title>
    <link href="https://sub2n.github.io/2019/06/05/190605-TIL/"/>
    <id>https://sub2n.github.io/2019/06/05/190605-TIL/</id>
    <published>2019-06-05T08:53:10.000Z</published>
    <updated>2019-06-05T08:54:37.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>오늘은 실행 컨텍스트를 배웠다.</li><li>엄청 어렵다..</li><li>변수 선언문을 배울 때부터 의문점이었던 실행 컨텍스트의 렉시컬 환경의 정체에 대해서 알게 되어서 속이 시원한 것 같다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;오늘은 실행 컨텍스트를
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>34. Execution Context</title>
    <link href="https://sub2n.github.io/2019/06/05/34-Execution-Context/"/>
    <id>https://sub2n.github.io/2019/06/05/34-Execution-Context/</id>
    <published>2019-06-05T01:43:07.000Z</published>
    <updated>2019-06-06T04:55:08.868Z</updated>
    
    <content type="html"><![CDATA[<p><strong>실행 컨텍스트(Execution Context)</strong>는 <strong>실행 가능한 코드를 평가</strong>하고 <strong>실행하기 위해 필요한 환경을 제공</strong>하고 <strong>코드의 실행 결과를 실제로 관리</strong>하는 영역이다.</p><p>Context는 문맥, 맥락이라는 뜻이다. 프로그램에도 맥락이 있다. 예를 들면 식별자가 어느 스코프에서 사용되었는지에 따라서 다른 값을 참조한다.</p><h2 id="1-Executable-Code"><a href="#1-Executable-Code" class="headerlink" title="1. Executable Code"></a>1. Executable Code</h2><p>실행 가능한 코드(Executable Code)를 4가지 유형으로 구분한다.</p><table><thead><tr><th>Executable Code</th><th style="text-align:left">Explaination</th></tr></thead><tbody><tr><td>Global code</td><td style="text-align:left">전역에 존재하는 Text code. 전역에 정의된 함수나 클래스의 내부 코드는 포함되지 않음</td></tr><tr><td>Function code</td><td style="text-align:left">함수 내부에 존재하는 Text code. 함수 내부에 중첩된 함수나 클래스의 내부 코드는 포함되지 않음</td></tr><tr><td>Eval code</td><td style="text-align:left">Built-in 전역 함수인 eval 함수에 argument로 전달된 Text code</td></tr><tr><td>Module code</td><td style="text-align:left">모듈 내부에 존재하는 Text code. 모듈 내부의 함수나 클래스의 내부 코드는 포함되지 않음</td></tr></tbody></table><h4 id="전역-코드-Global-Code"><a href="#전역-코드-Global-Code" class="headerlink" title="전역 코드 Global Code"></a>전역 코드 Global Code</h4><p>전역 코드는 전역 스코프를 생성해야하며 전역 객체와 연결되어야 한다. 이를 위해서 <strong>전역 코드가 평가되면 전역 실행 컨텍스트가 생성</strong>된다. </p><p><code>var</code> 키워드로 선언한 전역 변수는 전역 객체(window)의 프로퍼티가 된다.  그러나 전역 스코프를 통해서도 검색이 가능해야한다. <code>let</code>과 <code>const</code> 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되는 것이 아니라 전역 스코프에 등록된다.</p><h4 id="함수-코드-Function-Code"><a href="#함수-코드-Function-Code" class="headerlink" title="함수 코드 Function Code"></a>함수 코드 Function Code</h4><p>함수 코드는 지역 스코프를 생성해야하며 생성된 지역 스코프는 스코프 체인의 최상위인 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결되어야 한다. 이를 위해서 <strong>함수 코드가 평가되면 함수 실행 컨텍스트가 생성</strong>된다.</p><h2 id="2-Evaluation-and-Execution-of-Executable-Code"><a href="#2-Evaluation-and-Execution-of-Executable-Code" class="headerlink" title="2. Evaluation and Execution of Executable Code"></a>2. Evaluation and Execution of Executable Code</h2><p>모든 Executable code는 실행하기 전에 평가 과정을 거친다. </p><h4 id="1-코드의-평가-과정"><a href="#1-코드의-평가-과정" class="headerlink" title="1. 코드의 평가 과정"></a>1. 코드의 평가 과정</h4><p>코드의 평가 과정에서 <strong>실행 컨텍스트가 생성</strong>된다.</p><p>변수, 함수, 클래스 등의 <strong>선언문이 우선 평가되고 그 결과가 실행 컨텍스트에 등록</strong>된다. </p><blockquote><h4 id="Evaluation-and-Hoisting"><a href="#Evaluation-and-Hoisting" class="headerlink" title="Evaluation and Hoisting"></a>Evaluation and Hoisting</h4><p><code>var</code> 키워드로 선언한 변수 선언문은 평가되어 변수명(식별자)이 실행 컨텍스트에 등록된다. 이 때 1. 선언 단계(Declaration Phase)로 변수명을 등록하고 2. 초기화 단계(Initialazation Phase)로 변수명에 <code>undefined</code>를 할당한다. 이는 자바스크립트 엔진에 변수의 존재를 알려 변수를 관리하도록 한다.</p><p><code>let</code>이나 <code>const</code> 키워드로 선언한 변수 선언문은 평가되어 실행 컨텍스트에 등록될 때 1. 선언 단계만 거친다. 2. 초기화 단계로 <code>undefined</code>를 할당하는 것이 아니라 자바스크립트 엔진이 알고 있는 특별한 값을 할당하여 초기화 이전에 해당 값을 참조하면 <code>ReferenceError: Cannot access &#39;x&#39; before initialization</code>을 발생시킨다. <code>let</code>이나 <code>const</code> 키워드로 선언한 변수의 <strong>2. 초기화 단계는 코드의 실행 중 선언문을 실행시킬 때 이루어진다.</strong></p><p>함수 선언문의 경우 함수명과 동일한 변수명을 실행 컨텍스트에 등록하고, 즉시 함수 객체를 생성해서 변수명에 할당한다. </p><p>함수 호출시 진행되는 함수 코드의 평가에서는 parameter와 내부 코드의 선언문을 평가한다. 이 때 parameter는 <code>var</code> 키워드로 선언한 변수로 취급되어 <code>undefined</code>로 초기화된다. 또한 함수 내부에서 지역 변수처럼 사용할 수 있는  arguments 객체도 생성되어 지역 스코프에 등록된다. arguments 객체는 유사배열객체(Array-like Object)로, spread 연산자를 사용해서 배열로 만들어 사용할 수 있다.</p></blockquote><h4 id="2-코드의-실행"><a href="#2-코드의-실행" class="headerlink" title="2. 코드의 실행"></a>2. 코드의 실행</h4><p>코드의 평가 과정이 끝나면 선언문을 제외한 코드가 순차적으로 실행된다. 이 때 할당문 등 코드 실행에 필요한 정보를 실행 컨텍스트에서 가져온다. 코드의 실행 결과는 실행 컨텍스트에서 관리된다.</p><p>코드 실행 중 식별자를 만나면 우선 해당 실행 컨텍스트의 스코프에서 검색하고, 없으면 전역 스코프까지 올라간다. console 같은 식별자의 경우 전역 스코프에 등록되지 않았다. 그러나 ReferenceError가 나지 않는다. 이는 전역 스코프에서 식별자를 못 찾을 시 전역 객체의 프로퍼티를 검색하기 때문이다. 전역 객체의 프로퍼티는 마치 전역 스코프에 등록된 식별자처럼 동작한다.</p><h2 id="3-Role-of-Execution-Context"><a href="#3-Role-of-Execution-Context" class="headerlink" title="3. Role of Execution Context"></a>3. Role of Execution Context</h2><h4 id="1-전역-코드-평가"><a href="#1-전역-코드-평가" class="headerlink" title="1. 전역 코드 평가"></a>1. 전역 코드 평가</h4><p>전역 코드를 한 줄씩 실행하기 이전에 전역 코드가 평가된다. 평가 과정에서 변수 선언문과 함수 선언문이 평가된다. 그 결과로 전역 변수와 전역 함수가 전역 스코프에 등록된다. <code>var</code> 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티가 된다. <code>let</code>이나 <code>const</code> 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 아니라 전역 스코프의 식별자로 등록된다.</p><h4 id="2-전역-코드-실행"><a href="#2-전역-코드-실행" class="headerlink" title="2. 전역 코드 실행"></a>2. 전역 코드 실행</h4><p>전역 코드 평가가 끝나면 전역 코드를 순차적으로 실행한다. 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 전역 코드의 실행이 멈추고 호출된 함수 내부로 진입한다. </p><h4 id="3-함수-코드-평가"><a href="#3-함수-코드-평가" class="headerlink" title="3. 함수 코드 평가"></a>3. 함수 코드 평가</h4><p>함수 내부로 진입하면 함수 내부 코드를 실행하기 이전에 함수 코드가 평가된다. 이 때 parameter와 지역 변수 선언문이 평가된다. 그 결과로 parameter와 지역 변수는 지역 스코프에 등록된다. arguments 객체도 생성되어 스코프에 등록된다.</p><h4 id="4-함수-코드-실행"><a href="#4-함수-코드-실행" class="headerlink" title="4. 함수 코드 실행"></a>4. 함수 코드 실행</h4><p>함수 코드가 순차적으로 실행되고 종료되면 함수를 빠져나와 함수 호출 다음의 전역 코드를 실행한다.</p><p>결국 실행 컨텍스트가 해야하는 역할은 다음과 같다.</p><ol><li>선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분해서 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리해야 한다.</li><li>스코프 중첩 관계에 의해서 스코프 체인을 형성해야 한다. 스코프 체인을 통해서 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.</li><li>함수 호출 등으로 현재 실행중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수 있어야 한다.</li></ol><p><strong>실행 컨텍스트(Execution Context)는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.</strong></p><p>다시 말해, 실행 컨텍스트는 식별자(변수, 함수, 클래스, this 등)를 등록하고 관리하기 위한 <strong>스코프와 실행 순서 관리를 구현한 내부 매커니즘</strong>으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.</p><h2 id="4-Execution-Context-Stack"><a href="#4-Execution-Context-Stack" class="headerlink" title="4. Execution Context Stack"></a>4. Execution Context Stack</h2><p>Stack은 LIFO(Last In First Out) 방식의 자료구조이다. Stack의 가장 윗부분을 Top이라고 하고,  데이터를 넣는 것을 push, 꺼내는 것을 pop이라고 한다.</p><p>함수 호출 등에 따라서 생성되는 실행 컨텍스트는 Stack 자료구조로 관리된다. 이를 실행 컨텍스트 스택이라고 한다. 우리가 익히 알고 있는 Call Stack이 Execution context stack이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cosnt x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">funtcion foo() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> y = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> z = <span class="hljs-number">3</span>;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(x + y + z);</span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h4 id="1-전역-코드의-평가와-실행"><a href="#1-전역-코드의-평가와-실행" class="headerlink" title="1. 전역 코드의 평가와 실행"></a><strong>1. 전역 코드의 평가와 실행</strong></h4><p>자바스크립트 엔진은 자바스크립트 파일을 로드하고 실행하기 이전에 평가 과정을 거치며 전역 실행 컨텍스트를 생성한다. 전역 객체는 전역 실행 컨텍스트 이전에 생성되어있다.  그러므로 전역 코드를 평가할 때 <code>var</code> 키워드 등으로 선언한 변수를 전역 객체의 프로퍼티로 추가할 수 있는 것이다.  전역 실행 컨텍스트는 생성되는 즉시 Execution Context Stack에 push된다. 이 때 전역 변수  x와 전역 함수 foo는 전역 실행 컨텍스트에 등록된다. 이후에 전역 코드가 실행되며 x에 값이 할당되고 foo가 호출된다.</p><h4 id="2-foo-함수의-평가와-실행"><a href="#2-foo-함수의-평가와-실행" class="headerlink" title="2. foo 함수의 평가와 실행"></a>2. foo 함수의 평가와 실행</h4><p>전역 함수 foo가 호출되면 전역 코드의 실행이 멈추고 control이 foo 함수 내부로 이동한다. 자바스크립트 엔진은 foo 함수 내부의 함수 코드를 평가해서 foo 함수 실행 컨텍스트를 생성하고 Execution Context Stack에 push한다. foo 함수 평가가 끝나고 실행을 하다가 중첩 함수 bar를 만나면 bar를 호출한다.</p><h4 id="3-bar-함수의-평가와-실행"><a href="#3-bar-함수의-평가와-실행" class="headerlink" title="3. bar 함수의 평가와 실행"></a>3. bar 함수의 평가와 실행</h4><p>중첩 함수 bar가 호출되면 foo 코드의 실행이 멈추고 control이 bar 함수 내부로 이동한다. 자바스크립트 엔진은 bar 함수 내부의 함수 코드를 평가해서 bar 함수 실행 컨텍스트를 생성하고 Execution Context Stack에 push한다. bar 함수는 실행을 마치고 종료한다.</p><h4 id="4-foo-함수-코드로-복귀"><a href="#4-foo-함수-코드로-복귀" class="headerlink" title="4. foo 함수 코드로 복귀"></a>4. foo 함수 코드로 복귀</h4><h4 id="5-전역-코드로-복귀"><a href="#5-전역-코드로-복귀" class="headerlink" title="5. 전역 코드로 복귀"></a>5. 전역 코드로 복귀</h4><h2 id="5-Lexical-Environment"><a href="#5-Lexical-Environment" class="headerlink" title="5. Lexical Environment"></a>5. Lexical Environment</h2><p><strong>Lexical Environment는 식별자가 선언되는 환경,</strong> 즉 <strong>렉시컬 스코프</strong>를 의미한다. 렉시컬 환경은 스코프와 식별자를 관리한다.</p><p>실행 컨텍스트는 LexicalEnvorinment 컴포넌트와 VariableEnvironment 컴포넌트로 구성된다. 생성 초기에 두 컴포넌트는 하나의 동일한 렉시컬 환경을 참조한다. with 문을 사용하지 않으면 둘은 언제나 동일한 렉시컬 환경을 참조한다.</p><p><img src="https://poiemaweb.com/assets/fs-images/22-7.png" alt="img"></p><p><img src="https://poiemaweb.com/assets/fs-images/22-8.png" alt="img"></p><ol><li>EnvironmentRecord : 환경 레코드. 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소. 환경 레코드는 Executable Code의 종류에 따라 내용이 다르다. 예를 들어 전역 코드의 경우 전역 객체와 연결되어야하고 함수 코드는 그렇지 않다.</li><li>Outer Lexical Enciromnent Reference : 외부 렉시컬 환경을 가리키는 참조를 저장. 해당 실행 컨텍스트를 생성한 Executable code를 포함하는 상위 코드의 렉시컬 환경을 말한다. 이를 통해서 One-way linked list인 스코프 체인을 구현한다.</li><li>ThisBinding : this 바인딩. 렉시컬 환경의 this에 바인딩된 객체(ThisBinding)를 나타낸다. this 바인딩은 Abstract operation ResolveThisBinding을 통해 결정할 수 있다.</li></ol><p>결국 스코프 체인은 각 실행 컨텍스트의 Lexical Environment의 link로 구성된 Linked List이다.</p><h2 id="6-Creation-of-Executable-Context-and-Identifier-Search-Process"><a href="#6-Creation-of-Executable-Context-and-Identifier-Search-Process" class="headerlink" title="6. Creation of Executable Context and Identifier Search Process"></a>6. Creation of Executable Context and Identifier Search Process</h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> y = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">a</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> y = <span class="hljs-number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span> (<span class="hljs-params">b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> z = <span class="hljs-number">5</span>;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a + b + x + y + z);</span><br><span class="line">&#125;</span><br><span class="line">  bar(<span class="hljs-number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="hljs-number">20</span>); <span class="hljs-comment">// 42</span></span><br></pre></td></tr></table></figure><h4 id="1-전역-객체-생성"><a href="#1-전역-객체-생성" class="headerlink" title="1. 전역 객체 생성"></a>1. 전역 객체 생성</h4><p>전역 객체는 생성자 함수를 제공하지 않으므로 의도적으로 생성할 수 없다. 전역 객체는 애플리케이션 로딩시 전역 코드가 평가되기 이전에 생성된다. 전역 객체에는 전역 프로퍼티와 전역 함수, builtin 객체가 추가되며 Client Side인 경우 CIient-side Web API를 포함한다.</p><h4 id="2-전역-코드-평가"><a href="#2-전역-코드-평가" class="headerlink" title="2. 전역 코드 평가"></a>2. 전역 코드 평가</h4><h5 id="1-전역-실행-컨텍스트-생성"><a href="#1-전역-실행-컨텍스트-생성" class="headerlink" title="1. 전역 실행 컨텍스트 생성"></a>1. 전역 실행 컨텍스트 생성</h5><p>전역 실행 컨텍스트를 생성하고 즉시 실행 컨텍스트 스택에 생성된 전역 실행 컨텍스트를 push한다.</p><h5 id="2-전역-렉시컬-환경-생성"><a href="#2-전역-렉시컬-환경-생성" class="headerlink" title="2. 전역 렉시컬 환경 생성"></a>2. 전역 렉시컬 환경 생성</h5><p>전역 Lexical Environment를 생성하고 전역 실행 컨텍스트의 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트에 바인딩한다. Lexical Environment는 EnvironmentRecord, OuterLexicalEnvironmentReference, ThisBinding의 3가지 컴포넌트로 구성된다.</p><h5 id="2-1-전역-환경-레코드-생성-Global-Environment-Record"><a href="#2-1-전역-환경-레코드-생성-Global-Environment-Record" class="headerlink" title="2.1. 전역 환경 레코드 생성 Global Environment Record"></a>2.1. 전역 환경 레코드 생성 Global Environment Record</h5><p>전역 환경 레코드(Global Environment Record)는 함수 환경 레코드와는 다르게, 객체 환경 레코드(Object Environment Record)와 선언적 환경 레코드(Declarative Environment Record)로 구성되어 있다. Object Environment Record와 Declarative Environment Record는 서로 협력해 전역 스코프와 전역 객체를 관리한다.</p><h6 id="2-1-1-객체-환경-레코드-생성-Object-Environment-Record"><a href="#2-1-1-객체-환경-레코드-생성-Object-Environment-Record" class="headerlink" title="2.1.1. 객체 환경 레코드 생성 Object Environment Record"></a>2.1.1. 객체 환경 레코드 생성 Object Environment Record</h6><p><code>var</code> 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 Object Environment Record에 등록되고 관리된다.</p><p>정확히 말하면 Object Environment Record는 bindingObject라는 객체와 연결되는데, Object Environment Record에 등록한 식별자는 bindingObject의 프로퍼티가 된다. Global Environment Record의 경우 Object Environment Record의 bindingObject는 전역 객체(window)이다.</p><p>따라서 <code>var</code> 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티가 된다. 등록된 식별자를 Global Environment Record의 Object Environment Record에서 검색하면 전역 객체의 프로퍼티를 검색해서 반환한다. 따라서 <code>var x = 1</code>과 같이 선언한 변수는 <code>x</code> 또는 <code>window.x</code>로 검색할 수 있는 것이다. 전역 함수 또한 마찬가지이다.</p><h6 id="변수-호이스팅과-함수-호이스팅"><a href="#변수-호이스팅과-함수-호이스팅" class="headerlink" title="변수 호이스팅과 함수 호이스팅"></a>변수 호이스팅과 함수 호이스팅</h6><p><code>var</code> 키워드로 선언한 변수는 Object Environment Record에 바인딩된 bindingObject에 변수 식별자를 등록(1. 선언 단계)한 다음, 암묵적으로 undefined로 초기화(2. 초기화 단계)한다.</p><p>함수 선언문으로 정의한 함수는 평가되면 함수명과 동일한 이름의 식별자를 Object Environment Record에 등록하고, 함수 객체를 생성해서 즉시 할당한다. 그래서 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있는 것이다.</p><h6 id="2-1-2-선언적-환경-레코드-생성-Declarative-Environment-Record"><a href="#2-1-2-선언적-환경-레코드-생성-Declarative-Environment-Record" class="headerlink" title="2.1.2. 선언적 환경 레코드 생성 Declarative Environment Record"></a>2.1.2. 선언적 환경 레코드 생성 Declarative Environment Record</h6><p><code>let</code>, <code>const</code> 키워드로 선언된전역 변수는 Declarative Environment Record에 등록되고 관리된다. <code>let</code>, <code>const</code> 키워드로 선언한 변수는 1. 선언 단계와 2. 초기화 단계가 분리되어 진행된다. 평가 단계에서는 선언 단계만 진행되어 식별자가 등록이 되고, 초기화 단계는 실행 시간에 선언문을 실행할 때 진행되므로 선언문 실행 이전까지를 TDZ(Temporal Dead Zone)라고 한다. 이들은 전역 객체의 프로퍼티가 아니라 Global Lexical Environment의 Declarative Environment Record에 등록되어 관리된다.</p><h5 id="2-2-외부-렉시컬-환경에-대한-참조-할당-Outer-Lexical-Envronment-Reference"><a href="#2-2-외부-렉시컬-환경에-대한-참조-할당-Outer-Lexical-Envronment-Reference" class="headerlink" title="2.2. 외부 렉시컬 환경에 대한 참조 할당 Outer Lexical Envronment Reference"></a>2.2. 외부 렉시컬 환경에 대한 참조 할당 Outer Lexical Envronment Reference</h5><h5 id="2-3-this-바인딩-ThisBinding"><a href="#2-3-this-바인딩-ThisBinding" class="headerlink" title="2.3. this 바인딩 ThisBinding"></a>2.3. this 바인딩 ThisBinding</h5><h4 id="3-전역-코드-실행"><a href="#3-전역-코드-실행" class="headerlink" title="3. 전역 코드 실행"></a>3. 전역 코드 실행</h4><h4 id="4-함수-코드-평가"><a href="#4-함수-코드-평가" class="headerlink" title="4. 함수 코드 평가"></a>4. 함수 코드 평가</h4><h5 id="1-함수-실행-컨텍스트-생성"><a href="#1-함수-실행-컨텍스트-생성" class="headerlink" title="1. 함수 실행 컨텍스트 생성"></a>1. 함수 실행 컨텍스트 생성</h5><h5 id="2-함수-Lexical-Environment-생성"><a href="#2-함수-Lexical-Environment-생성" class="headerlink" title="2. 함수 Lexical Environment 생성"></a>2. 함수 Lexical Environment 생성</h5><h5 id="2-1-함수-Environment-Record-생성"><a href="#2-1-함수-Environment-Record-생성" class="headerlink" title="2-1. 함수 Environment Record 생성"></a>2-1. 함수 Environment Record 생성</h5><h5 id="2-1-Outer-Lexical-Environment-Reference-할당"><a href="#2-1-Outer-Lexical-Environment-Reference-할당" class="headerlink" title="2-1. Outer Lexical Environment Reference 할당"></a>2-1. Outer Lexical Environment Reference 할당</h5><p>함수는 함수 정의가 평가되어 함수 객체가 생성될 때, 현재 실행 중인 실행 컨텍스트의 Lexical Environment를 함수 객체의 내부 슬롯 <code>[[Environment]]</code>에 저장한다. </p><p>즉, 생성된 함수 객체가 호출되어 평가될 때 생성되는 함수 실행 컨텍스트의 Lexical Environment의 OuterLexicalEnvironmentReference 컴포넌트의 참조는 해당 함수 객체의 내부 슬롯 <code>[[Environment]]</code>에 저장된 Lexical Environment와 같다.</p><h5 id="2-3-this-바인딩"><a href="#2-3-this-바인딩" class="headerlink" title="2-3. this 바인딩"></a>2-3. this 바인딩</h5><p>일반적으로 this는 호출되는 방식에 따라서 다르게 바인딩된다.</p><p>this를 참조하는 순간 추상 연산 ResolveThisBinding 메소드가 도는데, 화살표 함수의 경우 선언된 코드가 실행중인 실행 컨텍스트의 Lexical Environment의 this, 즉 Lexical this를 자신의 this로 바인딩한다.</p><h4 id="5-함수-코드-실행"><a href="#5-함수-코드-실행" class="headerlink" title="5. 함수 코드 실행"></a>5. 함수 코드 실행</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;실행 컨텍스트(Execution Context)&lt;/strong&gt;는 &lt;strong&gt;실행 가능한 코드를 평가&lt;/strong&gt;하고 &lt;strong&gt;실행하기 위해 필요한 환경을 제공&lt;/strong&gt;하고 &lt;strong&gt;코드의 실행 결과를 실제
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="실행 컨텍스트" scheme="https://sub2n.github.io/tags/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sub2n.github.io/2019/06/04/hello-world/"/>
    <id>https://sub2n.github.io/2019/06/04/hello-world/</id>
    <published>2019-06-04T04:55:03.028Z</published>
    <updated>2019-03-13T06:32:43.607Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="hljs-string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>190604-TIL</title>
    <link href="https://sub2n.github.io/2019/06/04/190604-TIL/"/>
    <id>https://sub2n.github.io/2019/06/04/190604-TIL/</id>
    <published>2019-06-04T04:11:33.000Z</published>
    <updated>2019-06-04T07:51:44.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>MongoDB는 Document-Oriented NoSQL Database이다. RDBMS의 Table을 Collection, Tuple를 Document라고 부른다.<br>RDBMS처럼 고정된 Schema가 존재하지 않고 하나의 Collection 내의 DOcument가 각각 다른 Schema를 가질 수 있다.</p><h3 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h3><p>Sass(Syntactically Awesome StyleSheets)는 CSS pre-processor로 CSS의 단점을 보완하고 코드 재사용에 유리한 CSS를 생성하기 위한 CSS의 extension이다.</p><ul><li>변수의 사용</li><li>조건문과 반복문</li><li>Import</li><li>Nesting</li><li>Mixin</li><li>Extend/Inheritance</li></ul><p>등의 도구들을 제공한다.</p><h3 id="한-일"><a href="#한-일" class="headerlink" title="한 일"></a>한 일</h3><ul><li>Todos version 3을 만들었다.</li><li>MongoDB 서버를 연동</li><li>복습하는 겸 네트워크 공부를 조금 했다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;h3 id=&quot;MongoDB&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190603-TIL</title>
    <link href="https://sub2n.github.io/2019/06/03/190603-TIL/"/>
    <id>https://sub2n.github.io/2019/06/03/190603-TIL/</id>
    <published>2019-06-03T08:42:08.000Z</published>
    <updated>2019-06-03T08:46:19.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>오후에 3분간 나가서 자바스크립트 키워드에 대해서 설명하는 시험을 봤다. 자바스크립트 원시타입과 객체타입의 차이에 대해서 발표했다. <a href="https://sub2n.github.io/2019/05/31/자바스크립트-키워드-정리/">💛 키워드 정리</a></li><li>Todo List Server가 있는 환경에서 실습하기 위해서 작업환경을 세팅했다.</li><li>Webpack과 Babel, Sass를 위한 작업 환경을 구성했다.</li><li>호스팅 서비스를 이용해서 MongoDB를 설치했다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;오후에 3분간 나가서 
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Development Environment Setting</title>
    <link href="https://sub2n.github.io/2019/06/03/npm/"/>
    <id>https://sub2n.github.io/2019/06/03/npm/</id>
    <published>2019-06-03T05:22:17.000Z</published>
    <updated>2019-06-03T11:22:53.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-node-package-manager-and-Modularization"><a href="#npm-node-package-manager-and-Modularization" class="headerlink" title="npm (node package manager) and Modularization"></a>npm (node package manager) and Modularization</h2><p>자바스크립트는 웹페이지의 보조적인 기능을 수행하기 위해 만들어진 언어로, 다른 범용 프로그래밍 언어와는 달리 모듈 기능이 없다.</p><p>모듈이란 애플리케이션을 구성하는 개별적인 요소를 말한다. 일반적으로 파일 단위로 분리된다. 모듈을 기능별로 분리해서 개발의 효율성과 유지보수성이 좋아진다.</p><p>그러나 자바스크립트는 파일을 나누었다고 해도 모듈을 로드했을 때 하나의 전역 스코프로 합쳐진다. 즉, 파일 스코프를 지원하지 않는다. 모듈은 그리고 모듈 내부에서 외부로 선택적으로 노출할 수 있는 기능이 있어야 하는데 자바스크립트는 그런 기능이 없었다.</p><p>ES6에서 자바스크립트에서도 <code>&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</code>와 같이 모듈을 지원하지만,  2019년 6월 현재까지는 최신브라우저에서만 지원을 하므로 사용할 수 없다.</p><p>또한 대형 애플리케이션을 만들 때 모듈의 개수가 백 단위를 넘어갈 때 하나하나를 순서에 맞춰서 import하기 어렵다. 이런 문제를 Webpack과 같은 module bundler를 사용해서 하나의 파일로 만들어(module bundling) 해결할 수 있다.</p><p>Babel은 크로스브라우징을 위한 다운그레이드 작업 등의 전처리를 해준다.</p><p>Node.js에서는 CommonJS spec을 받아들여 RequireJS 로 모듈화를 구현하고 있다.</p><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>npm은 자바스크립트 패키지 매니저로, Node.js에서 사용할 수 있는 모듈을 패키지화 해서 모아둔 <strong>저장소 역할</strong>과 패키지 설치 및 관리를 위한 <strong>CLI를 제공</strong>한다. 여기서 패키지란 여러 모듈의 구조를 가지고 모여있는 것을 의미한다. 누구나 자신의 패키지를 공개할 수 있으므로 install할 때는 신뢰성 있는 패키지인지 확인해야 한다.</p><h4 id="node-emoji-설치"><a href="#node-emoji-설치" class="headerlink" title="node-emoji 설치"></a>node-emoji 설치</h4><p><img src="https://user-images.githubusercontent.com/48080762/58779464-ff293480-8610-11e9-8a00-ae1ae039983a.png" alt="npm emoji install"></p><p>package.json이 없어서 안 깔림</p><p><img src="https://user-images.githubusercontent.com/48080762/58779663-95f5f100-8611-11e9-8f76-36b0280b4cb9.png" alt="Again"></p><p>깔림</p><p><a href="https://poiemaweb.com/es6-babel-webpack-1" target="_blank" rel="noopener">Babel Webpack 개발 환경 구축 1</a></p><p><a href="https://poiemaweb.com/es6-babel-webpack-2" target="_blank" rel="noopener">Babel Webpack 개발 환경 구축 2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;npm-node-package-manager-and-Modularization&quot;&gt;&lt;a href=&quot;#npm-node-package-manager-and-Modularization&quot; class=&quot;headerlink&quot; title=&quot;npm (n
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="Node.js" scheme="https://sub2n.github.io/tags/Node-js/"/>
    
      <category term="npm" scheme="https://sub2n.github.io/tags/npm/"/>
    
      <category term="Babel" scheme="https://sub2n.github.io/tags/Babel/"/>
    
      <category term="Webpack" scheme="https://sub2n.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>190531-TIL</title>
    <link href="https://sub2n.github.io/2019/05/31/190531-TIL/"/>
    <id>https://sub2n.github.io/2019/05/31/190531-TIL/</id>
    <published>2019-05-31T09:35:26.000Z</published>
    <updated>2019-05-31T09:39:31.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Ajax, Promise로 CRUD 구현</li><li>fetch, async 와 await도 사용해봤다</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Ajax, Promis
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트 키워드 정리</title>
    <link href="https://sub2n.github.io/2019/05/31/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/"/>
    <id>https://sub2n.github.io/2019/05/31/자바스크립트-키워드-정리/</id>
    <published>2019-05-31T08:44:37.000Z</published>
    <updated>2019-06-03T04:34:39.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Data-Type"><a href="#1-Data-Type" class="headerlink" title="1. Data Type"></a>1. Data Type</h2><p>Data type은 값의 종류를 말한다. 대부분의 프로그래밍 언어는 데이터 타입을 지원한다. 왜일까? 값을 구분할 필요가 있기 때문이다. 메모리 공간은 연속된 메모리 주소로 구분한다. 값을 메모리에 저장할 때는 데이터의 형태가 다르더라도 모두 2진수로 저장된다.</p><ol><li>값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해서,</li><li>메모리에 저장해둔 값을 참조할 때 한 번에 읽어들일 메모리 공간의 크기를 결정하기 위해서,</li><li>메모리에서 읽어들인 2진수를 어떻게 변환할 지 결정하기 위해서 데이터 타입이 필요하다.</li></ol><p>자바스크립트의 데이터 타입은 크게 원시 타입(Primitive Type)과 객체 타입(Object Type)으로 나뉜다. 원시 타입을 제외한 데이터는 모두 객체 타입이다. 그러므로 원시 타입을 우선 살펴보겠다. </p><h3 id="Primitive-Type"><a href="#Primitive-Type" class="headerlink" title="Primitive Type"></a>Primitive Type</h3><p>자바스크립트의 원시 타입은 6종류가 있다.</p><ol><li><p>Number</p><p>자바스크립트는 정수와 실수를 구분하지 않고 모든 수를 실수로 표현한다. 배정밀도 64비트 부동소수점 형식을 따른다. -(2<sup>53</sup> -1) ~ 2<sup>53</sup> -1 사이의 숫자 값을 표현할 수 있다.</p><ul><li>Infinity</li><li>-Infinity</li><li>NaN</li></ul></li><li><p>String</p><p>문자열은 0개 이상의 16bit (2byte) 유니코드 문자 (UTF-16)들의 집합으로 전세계 대부분의 문자를 표현할 수 있다. 자바스크립트에서는 일반적으로 작은 따옴표(‘’)를 사용해서 문자열을 표현한다.</p><p>C나 Java와 달리 자바스크립트의 문자열은 원시타입이고 immutable value다. 한 번 생성된 문자열은 재할당하지 않고서는 변경할 수 없다.</p><ul><li><p>Template Literal</p><p>템플릿 리터럴은 backtick(``)을 사용하며 다음과 같은 특징을 가진다.</p><ul><li>Template literal 내의 모든 공백은 그대로 적용된다. (줄바꿈 포함)</li><li>String interpolation을 사용해서 간단하게 새로운 문자열을 삽입할 수 있다. <code>${ expression }</code>으로 표현식을 감싸면 표현식의 평과 결과가 문자열로 강제 타입 변환 된다.</li></ul></li></ul></li><li><p>Boolean</p><p>true, false</p></li><li><p>undefined</p><p>undefined 타입의 값은 <code>undefined</code>뿐이다. 선언만 하고 명시적으로 값을 할당하지 않은 변수에는 <code>undefiend</code>가 들어있다.</p><p>C 에서는 변수를 선언하고 초기화해주지 않으면 선언만 한 변수에는 garbage value가 들어가있지만, 자바스크립트는 선언문을 평가할 때 암묵적으로 변수를 undefined로 초기화한다.</p></li><li><p>null</p><p>null 타입의 값은 <code>null</code>이 유일하다. null은 변수에 값이 없음을 의도적으로 명시할 때 사용한다. 함수가 유효한 값을 반환할 수 없을 때 명시적으로 null을 반환하기도 한다.</p></li><li><p>Symbol</p><p>symbol은 ES6에서 추가된 타입으로 이름이 충돌하면 안되는 객체의 유일한 Property key를 만들기 위해서 사용한다.</p></li></ol><h3 id="Object-Reference-Type"><a href="#Object-Reference-Type" class="headerlink" title="Object (Reference) Type"></a>Object (Reference) Type</h3><p>객체, 함수, 배열 등 원시타입을 제외한 모든 것이 객체이다.</p><p>typeof undefined는 undefined인데 typeof null은 object임</p><p>자바스크립트는 동적 타입(Dynamic Type) 언어로, 선언할 때가 아니라 할당할 때 타입이 결정된다. 그러므로 재할당에 의해서 변수의 타입이 동적으로 변한다.</p><h2 id="2-Literal"><a href="#2-Literal" class="headerlink" title="2. Literal"></a>2. Literal</h2><p>Literal은 <strong>소스 코드 안에서 직접 만들어낸 고정된 값 그 자체</strong>를 말한다. 리터럴은 자바스크립트 엔진에 의해 해석되어 값으로 평가된다. Literal은 Literal Notation으로 생성한다.</p><h3 id="Literal-Notation"><a href="#Literal-Notation" class="headerlink" title="Literal Notation"></a>Literal Notation</h3><p>리터럴 표기법은 값을 생성하는 방법. 리터럴은 사람이 이해할 수 있는 표기법으로 자바스크립트 엔진에게 값의 생성을 명령하는 것이다.</p><p>리터럴 표기법으로 작성한 리터럴은 자바스크립트 엔진에 의해 해석되어 값으로 평가된다. 리터럴은 결국 값이 되므로 리터럴을 값 자체라고 할 때가 많다. 리터럴은 그 자체로 표현식이며 표현식의 일부로 다른 값을 생성할 때 사용된다.</p><ul><li><p>숫자 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 정수 리터럴</span></span><br><span class="line"><span class="hljs-number">100</span></span><br><span class="line"><span class="hljs-comment">// 부동 소숫점 리터럴</span></span><br><span class="line"><span class="hljs-number">10.5</span></span><br><span class="line"><span class="hljs-comment">// 2진수 리터럴(0b로 시작)</span></span><br><span class="line"><span class="hljs-number">0b01000001</span></span><br><span class="line"><span class="hljs-comment">// 8진수 리터럴(ES6에서 도입. 0o로 시작)</span></span><br><span class="line"><span class="hljs-number">0o101</span></span><br><span class="line"><span class="hljs-comment">// 16진수 리터럴(ES6에서 도입. 0x로 시작)</span></span><br><span class="line"><span class="hljs-number">0x41</span></span><br></pre></td></tr></table></figure></li><li><p>문자열 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 문자열 리터럴</span></span><br><span class="line"><span class="hljs-string">'Hello'</span></span><br><span class="line"><span class="hljs-string">"World"</span></span><br></pre></td></tr></table></figure></li><li><p>불리언 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 불리언 리터럴</span></span><br><span class="line"><span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// null 리터럴</span></span><br><span class="line"><span class="hljs-literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// undefined 리터럴</span></span><br><span class="line"><span class="hljs-literal">undefined</span></span><br></pre></td></tr></table></figure></li><li><p>객체 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 객체 리터럴</span></span><br><span class="line">&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'Lee'</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">'male'</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>배열 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 배열 리터럴</span></span><br><span class="line">[ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]</span><br></pre></td></tr></table></figure></li><li><p>함수 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 함수 리터럴</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>정규표현식 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 정규표현식 리터럴</span></span><br><span class="line">/ab+c/</span><br></pre></td></tr></table></figure></li></ul><p>등을 사용해서 리터럴을 생성하고, 리터럴은 평가되어 값이 된다.</p><h2 id="3-Expression"><a href="#3-Expression" class="headerlink" title="3. Expression"></a>3. Expression</h2><p>표현식은 </p><ul><li>리터럴</li><li>식별자(변수명, 함수명)</li><li>연산자</li><li>함수 호출 </li></ul><p>등의 조합을 말한다. 표현식은 평가되어 하나의 값을 만든다.</p><p><strong>표현식은 하나의 값으로 평가될 수 있는 문(statement)</strong>이다. 표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식으로 나뉜다.</p><p><strong>문(statement)은 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령</strong>이다. 문의 집합으로 이루어진 게 프로그램이다. 문은 선언문, 표현식 문, 조건문, 반복문으로 구분한다.</p><p>표현식인 문과 표현식이 아닌 문을 구분하기 위해서는 변수에 할당하는 것이 가장 빠른 방법이다. 아니면 크롬 개발자 도구에 찍어볼 수도 있다.</p><p><img src="https://user-images.githubusercontent.com/48080762/58757742-806ac380-854c-11e9-855f-158deaf88968.png" alt="Completed Value"></p><blockquote><h3 id="Completion-Value"><a href="#Completion-Value" class="headerlink" title="Completion Value"></a>Completion Value</h3><p>크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력한다. 이를 완료 값(Completion value)이라고 한다.</p></blockquote><h2 id="4-Primitive-type-vs-Object-type"><a href="#4-Primitive-type-vs-Object-type" class="headerlink" title="4. Primitive type vs. Object type"></a>4. Primitive type vs. Object type</h2><p>자바스크립트에서는 데이터 타입을 원시 타입과 객체 타입으로 구분한다. 둘은 그만큼 구분되는 성질을 가진다.</p><ol><li>원시 타입 값은 immutable value이고 객체 타입 값은 mutable value이다.</li><li>원시 값을 변수에 할당하면 변수의 메모리 공간에는 실제 값이 저장되고 객체를 변수에 할당하면 메모리 공간에 참조 값이 저장된다.</li><li>Pass by value 원시 값을 가지는 변수를 다른 변수에 할당하면 원본 원시 값이 복사되어 전달된다. Pass by reference 객체를 가리키는 변수를 다른 변수에 할당하면 원본 참조 값이 복사되어 전달된다.</li></ol><p>그렇다면 immutable value란 무엇일까? 변경 불가능한 값. 즉, read only한 값이다. 값을 변경할 수 없다는 것은 변수가 참조하는 메모리 공간에 저장된 값을 수정할 수 없음을 의미한다. 원시 값이 저장된 변수의 값을 바꾸기 위해서는 새로운 원시 값을 재할당하는 수밖에 없다. 원시 값을 재할당하면 원래 참조하던 메모리 공간에 새로운 원시 값을 뒤집어 쓰는게 아니라 새로운 메모리 공간에 새로운 값을 저장하고 변수가 그 메모리를 참조하게 된다.</p><p>나는 처음 immutable 개념을 공부할 때 변경할 수 없다는 말 때문에 immutable value와 const로 선언한 변수(constant 상수)를 혼동했었는데, constant는 그저 선언과 동시에 할당한 값을 재할당할 수 없는 변수일 뿐이고, constant에 저장되는 값의 종류가 immutable과 mutable인 것이다. 그러므로 그 둘은 개념이 다르다.</p><p>Pass by value란 값에 의한 전달이다. 변수에 변수를 할당했을 때, 변수가 원시 값을 참조하고 있다면 저장되어있는 <strong>값 자체가 복사되어 전달</strong>된다. 반면 변수가 객체 값을 참조하고 있다면 저장된 참조값이 복사되어 <strong>전달된다</strong>. 이처럼 참조값이 전달되는 것을 Pass by reference라고 한다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57297341-57e8d880-710a-11e9-9007-36ec715ebcf7.png" alt="Pass by Value"></p><p><img src="https://user-images.githubusercontent.com/48080762/57299971-d34d8880-7110-11e9-8fc7-1ee9d64a5f13.png" alt="Pass by Reference"></p><h2 id="5-Function-Definition"><a href="#5-Function-Definition" class="headerlink" title="5. Function Definition"></a>5. Function Definition</h2><p>함수 정의를 통해서 함수를 생성할 수 있다. 자바스크립트에서 함수는</p><ul><li>함수 선언문</li><li>함수 표현식</li><li>Function 생성자 함수</li><li>화살표 함수</li></ul><p>로 정의할 수 있다.  그러나 Function 생성자 함수를 통한 함수 정의는 잘 하지 않는다.</p><ol><li><p>함수 선언문</p><p>함수 선언문은 <strong>표현식이아닌 문</strong>으로 해석된다. 함수 선언문은 실행되어 함수 객체를 생성한다. 함수 선언문을 작성할 때는 함수의 이름을 생략할 수가 없다. 자바스크립트 엔진이 선언문을 실행해서 함수 객체를 생성할 때 함수 객체를 저장할 변수를 암묵적으로 함수명과 동일한 이름으로 선언하기 때문이다. 결국 우리가 선언한 함수를 호출할 때 부르는 함수명은 함수 객체를 참조하는 변수명이다. 실제 함수명은 함수 내부에서만 참조할 수 있는 식별자이다. 주로 재귀함수에서 사용한다.</p></li><li><p>함수 표현식</p><p>함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이렇게 변수에 함수를 할당하는 함수 정의 방식을 함수 표현식이라고 한다. 주의해야할 점은, 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수는 호이스팅할 때 다르게 동작한다는 것이다. <strong>함수 선언문</strong>은 선언문이므로 자바스크립트 엔진이 <strong>런타임 이전에 먼저 실행</strong>시켜 함수 객체를 생성하지만, <strong>함수 표현식</strong>은 런타임 도중에 <strong>할당문이 실행되는 시점</strong>에 평가되어 함수 객체가 생성된다. 즉, 함수 표현식으로 생성한 함수는 호이스팅 되지 않는다.</p></li><li><p>화살표 함수</p><p>ES6에서 도입되었으나 모든 함수를 대체하기 위한 것은 아니다. 기존 함수와 다르게 호출 시점이 아니라 선언될 때 상위 lexical scope의 this와 바인딩되고, prototype 프로퍼티가 없고 argument 객체를 생성하지 않는다.</p></li></ol><h2 id="6-Scope"><a href="#6-Scope" class="headerlink" title="6. Scope"></a>6. Scope</h2><p>변수의 유효 범위를 scope라고 한다. 변수는 자신이 <strong>선언된 위치</strong>에 의해서 scope가 결정된다. 유효 범위, <strong>scope란 다른 코드가 변수 자신을 참조할 수 있는 범위를 말한다.</strong></p><p>scope는 전역과 지역으로 나눌 수 있는데, 함수 가장 바깥을 전역이라고 하고 전역에서 선언된 변수를 전역 변수라고 한다. 전역 변수는 코드 상 어디에서나 참조할 수 있다. 지역은 함수 몸체 내부(또는 블록 내부)를 의미하며 지역 스코프에서 선언된 변수를 지역 변수라고 한다. 지역 변수는 자신의 지역 스코프와 그 하위 지역 스코프에서 유효하다.</p><p>scope는 중첩될 수 있으며 scope는 중첩 관계를 바탕으로 scope chain을 만든다. scope는 자바스크립트 엔진이 참조할 변수를 검색할 때 사용되는 규칙이라고 할 수 있다.</p><p>변수를 참조할 때 자바스크립트 엔진은 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하면서 변수를 검색한다. 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 연결한 것으로, 함수의 렉시컬 환경은 함수가 호출되며 생성된다.</p><p>스코프 체인 내의 식별자 검색은 상위 방향으로만 이루어지므로 하위 스코프의 식별자를 상위 스코프에서 참조할 수 없다.</p><p>자바스크립트의 스코프는 Lexical Scope (Static Scope)로 <strong>함수를 어디서 정의했는지에 따라서 함수의 상위 스코프를 결정</strong>한다.</p><h2 id="7-Lexical-Scope"><a href="#7-Lexical-Scope" class="headerlink" title="7. Lexical Scope"></a>7. Lexical Scope</h2><p>자바스크립트의 스코프는 Lexical Scope (Static Scope)로 함수를 어디서 정의했는지에 따라서 함수의 상위 스코프를 결정한다고 했다. 함수가 호출된 위치에 따라서 스코프가 결정되는 것은 Dynamic Scope이다.</p><p>자바스크립트는 렉시컬 스코프를 따르므로 모든 함수 정의가 평가되어 함수 객체를 생성할 때, 자신이 정의된 스코프를 기억한다. 함수가 기억하는 것은 Lexical Enviromnent인데, 함수 객체의 내부 슬롯 <code>[[Environment]]</code>에 저장한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="hljs-comment">// 1</span></span><br><span class="line">bar(); <span class="hljs-comment">// 1</span></span><br></pre></td></tr></table></figure><p>bar() 함수는 foo() 함수 내부에서 호출되었으나, 전역에서 선언되었기 때문에 전역 스코프의 x =1을 우선 찾는다.</p><h2 id="8-전역-변수의-문제점"><a href="#8-전역-변수의-문제점" class="headerlink" title="8. 전역 변수의 문제점"></a>8. 전역 변수의 문제점</h2><ul><li><p><strong>암묵적 결합</strong></p><p>모든 코드가 전역 변수를 참조하고 변경할 수 있기 때문에 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있어 위험하다.</p></li><li><p>긴 생명 주기</p><p>생명 주기가 길다는 것은 리소스가 변경될 수 있는 시간이 길어진다는 것을 의미한다. 또한 브라우저가 종료하기 전까지 소멸되지 않아 메모리 상에 남아있다는 문제가 있다.</p></li><li><p>스코프 체인 상에서 종점에 존재</p><p>변수를 검색할 때 전역 변수가 가장 마지막에 검색되기 때문에 검색 속도가 가장 느리다.</p></li><li><p><strong>네임 스페이스 오염</strong></p><p>파일이 분리되어 있다고 해도 결국 하나의 전역을 갖게 된다. 따라서 각각 다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.</p></li></ul><h2 id="9-var-키워드로-선언한-변수의-문제점"><a href="#9-var-키워드로-선언한-변수의-문제점" class="headerlink" title="9. var 키워드로 선언한 변수의 문제점"></a>9. var 키워드로 선언한 변수의 문제점</h2><p><code>var</code> 키워드로 선언한 변수는 크게 세가지의 문제점을 가진다.</p><ul><li><p>같은 스코프 내에서 중복 선언이 허용된다.</p><p>나중에 작성된 변수 선언문은 마치 var키워드가 없는 것처럼 동작한다. 즉, 오류를 내지 않고 재할당한다. 의도치 않게 재할당되어 먼저 선언된 값이 변경되는 결과를 초래할 수 있다.</p></li><li><p>block-level scope 를 지원하지 않는다. (function-level scope)</p><p>제어문(if문, for문)의 평가식에 선언한 변수는 전역 변수가 된다. 전역 변수를 남발할 가능성이 높아진다.</p><p>for문에서 반복을 위해 사용된 변수 i는 for문 외부에서 사용할 일이 없지만  var 키워드로 선언하면 전역 변수가 된다. 이는 예상치 못한 결과를 가져올 수 있다.</p></li><li><p>변수 호이스팅</p><p>변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.</p><p>변수 선언문 이전에 참조할 수 있다. 이는 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.</p></li></ul><p>이를 보완하기 위해서 ES6에서 let과 const keyword를 도입했다.</p><p><code>let</code>과 <code>const</code>의 특징은 다음과 같다.</p><ul><li>같은 스코프 내에서 중복 선언을 할 수 없다.</li><li>block-level scope를 지원한다.</li><li>hoisting 되지 않는 것처럼 동작한다.</li></ul><h2 id="10-Constructor-Function"><a href="#10-Constructor-Function" class="headerlink" title="10. Constructor Function"></a>10. Constructor Function</h2><p><strong>생성자 함수란?</strong></p><ul><li>new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다.</li><li>자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의 빌트인(intrinsic 내장) 생성자 함수를 제공한다.</li><li>생성자 함수는 다른 함수와 구별하기 위해 함수명의 맨 앞 글자를 대문자로 사용한다.</li><li>생성자 함수는 어떤 특별한 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 정의하고 <strong>new연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.</strong></li></ul><h5 id="생성자-함수에-의한-객체-생성-방식의-장점"><a href="#생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="생성자 함수에 의한 객체 생성 방식의 장점"></a>생성자 함수에 의한 객체 생성 방식의 장점</h5><ul><li>생성자 함수로 객체를 생성하면 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</li></ul><h5 id="내부메소드"><a href="#내부메소드" class="headerlink" title="내부메소드"></a>내부메소드</h5><ul><li><strong>constructor는 생성자 함수로서 호출할 수 있는 객체를 의미</strong>한다. 생성자 함수로서 호출할 수 있다</li><li>new 연산자(또는 super 연산자)와 함께 생성자 함수로서 호출되면 내부 메소드 [[Constructor]]가 호출된다</li><li><strong>모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다.</strong><ul><li>화살표 함수와  ES6의 메소드 축약 표현으로 정의된 함수는 생성자 함수로 호출할 수 없다.</li></ul></li></ul><h5 id="생성자-함수의-동작-방식"><a href="#생성자-함수의-동작-방식" class="headerlink" title="생성자 함수의 동작 방식"></a>생성자 함수의 동작 방식</h5><ul><li>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 <strong>인스턴스를 생성</strong> 하는 것과 <strong>생성된 인스턴스의 프로퍼티 값을 초기화</strong>하는 것이다.</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 1. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다.</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 2. 생성된 빈 객체를 가리키는 this를 사용하여 프로퍼티나 메소드를 추가하고 초기화한다.</span></span><br><span class="line">  <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="hljs-keyword">this</span>.getDiameter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 3. 암묵적으로 this를 반환한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환한다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(circle); <span class="hljs-comment">// Circle &#123;radius: 1, getDiameter: ƒ&#125;</span></span><br></pre></td></tr></table></figure><ul><li>생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손한다. 따라서 <strong>생성자 함수 내부에서 return 문을 반드시 생략해야 한다.</strong></li></ul><h2 id="11-this"><a href="#11-this" class="headerlink" title="11. this"></a>11. this</h2><p>this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 <strong>자기 참조 변수</strong>이다.</p><p>this가 가리키는 객체는 <strong>함수 호출 방식</strong>에 따라 <strong>동적으로 결정</strong>된다.</p><table><thead><tr><th>함수 호출 방식</th><th>this가 가리키는 객체</th></tr></thead><tbody><tr><td>일반 함수로서 호출</td><td>전역 객체</td></tr><tr><td>메소드로서 호출</td><td>메소드를 호출한 객체</td></tr><tr><td>생성자 함수로서 호출</td><td>생성자 함수가(미래에) 생성할 인스턴스</td></tr></tbody></table><ul><li><p>화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다. </p></li><li><p>이벤트 핸들러 내부의 this는 이벤트가 발생한 요소 객체를 가리킨다.</p></li><li><p>Function.prototype.apply/call/bind 메소드에 의한 간접 호출 =&gt; this는 메소드에 argument로 전달한 객체를 가리킨다.</p></li><li><p>바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수는 할당에 의해 값이 바인딩된다.</p></li></ul><h2 id="12-DOM"><a href="#12-DOM" class="headerlink" title="12. DOM"></a>12. DOM</h2><h5 id="DOM이란"><a href="#DOM이란" class="headerlink" title="DOM이란?"></a>DOM이란?</h5><ul><li>브라우저의 렌더링 엔진은  웹 문서를 로드한 후, 파싱하여 <strong>웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재</strong>하는데 이를 DOM이라 한다.</li><li>모든 요소와 요소의 어트리뷰트, 텍스트를 <strong>각각의 객체</strong>로 만들고 이들 객체를 <strong>부자 관계</strong>를 표현할 수 있는 <strong>트리 구조로 구성</strong>한 것이 DOM이다.</li><li><strong>DOM은 자바스크립트를 통해 동적으로 변경</strong>할 수 있으며 변경된 DOM은 렌더링에 반영된다.</li><li>동적 변경을 위해 DOM은 프로그래밍 언어가 자신에게 접근하고 수정할 수 있는 방법을 제공하는데 일반적으로 프로퍼티와 메소드를 갖는 자바스크립트 객체로 제공된다. 이를 DOM API라고 부른다.</li><li>DOM은 ECMAScript에서 정의한 표준이 아닌 별개의 W3C의 공식 표준이다.</li><li><strong>DOM에서 모든 요소, 어트리뷰트, 텍스트는 하나의 객체이며 Document 객체의 자식이다</strong></li></ul><h5 id="DOM의-두-가지-기능"><a href="#DOM의-두-가지-기능" class="headerlink" title="DOM의 두 가지 기능"></a>DOM의 두 가지 기능</h5><ul><li><p><strong>HTML 문서에 대한 모델 구성</strong></p><ul><li>브라우저는 HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성한다. 이때 모델은 객체의 트리로 구성되는데 이것을 <strong>DOM tree</strong>라 한다.</li></ul></li><li><p><strong>HTML 문서 내의 각 요소에 접근 / 수정</strong></p><ul><li>DOM은 모델 내의 각 객체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공한다. DOM이 수정되면 브라우저를 통해 사용자가 보게 될 내용 또한 변경된다.</li></ul></li><li><h5 id="DOM-tree의-네-종류-노드"><a href="#DOM-tree의-네-종류-노드" class="headerlink" title="DOM tree의 네 종류 노드"></a>DOM tree의 네 종류 노드</h5><ul><li><p>문서 노드</p><p>트리의 최상위에 존재</p><p>DOM tree에 접근하기 위한 시작점</p></li><li><p>요소 노드</p><p><strong>HTML 요소를 표현</strong>(div, h1, ul 등)</p><p><strong>중첩에 의해 부자 관계를 가진다.</strong></p><p>어트리뷰트, 텍스트 노드에 접근하려면 먼저 요소 노드를 찾아 접근해야 한다.</p><p>HTMLElement 객체를 상속한 객체로 구성된다</p></li><li><p>어트리뷰트 노드</p><p>HTML 요소의 어트리뷰트를 표현</p><p>해당 어트리뷰트가 지정된 <strong>요소의 자식이 아니라</strong> 해당 요소의 일부로 표현</p></li><li><p>텍스트 노드</p><p>HTML 요소의 텍스트를 표현</p><p><strong>요소 노드의 자식</strong>이며 자신의 자식 노드를 가질 수 없다. 즉, 텍스트 노드는 DOM tree의 최종단이다.</p></li></ul></li></ul><h2 id="13-브라우저-동작"><a href="#13-브라우저-동작" class="headerlink" title="13. 브라우저 동작"></a>13. 브라우저 동작</h2><ul><li>브라우저는 <strong>동기(Synchronous)적</strong>으로 HTML, CSS, 자바스크립트를 처리한다. 이것은 <strong>script 태그의 위치</strong>에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 <strong>script 태그의 위치는 중요한 의미를 갖는다.</strong></li><li>body 요소의 가장 아래에 script 태그를 위치시키면 <strong>이미 HTML 파서가 HTML 요소를 모두 파싱하여 DOM 객체를 생성</strong>하였기 때문에 자바스크립트가 <strong>DOM 조작 시 에러가 발생하지 않는다.</strong> 또한, HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 <strong>페이지 로딩 시간이 단축</strong>된다.</li></ul><h5 id="웹-브라우저의-동작-순서"><a href="#웹-브라우저의-동작-순서" class="headerlink" title="웹 브라우저의 동작 순서"></a>웹 브라우저의 동작 순서</h5><ol><li>클라이언트가 서버에게 <strong>Request(요청)</strong>을 보낸다.</li><li>서버가 <strong>Response(응답)</strong>을 보낸다.</li><li>클라이언트가 서버의 응답을 받아서 HTML, CSS, JavaScript, 이미지 등의 파일을 <strong>Load</strong>한다.</li><li>렌더링 엔진의 HTML 파서와 CSS 파서가 HTML, CSS 파일을 <strong>파싱(Parsing)</strong>한다.<ul><li>자바스크립트는 렌더링 엔진이 아닌 <strong>자바스크립트 엔진</strong>이 처리한다.</li><li>HTML 파서는 <strong>script 태그</strong>를 만나면 자바스크립트 코드를 실행하기 위해 <strong>DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다.</strong></li><li>자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 <strong>브라우저가 중지했던 시점</strong>부터 DOM 생성을 재개한다.</li></ul></li><li>파싱된 결과를 바탕으로 HTML은 <strong>DOM tree</strong>, CSS는 <strong>CSSOM tree</strong>, JavaScript는 <strong>syntax tree</strong>로 변환한다.</li><li>자바스크립트가 DOM tree와 CSSOM tree를 제어한다.</li><li>DOM tree와 CSSOM tree가 <strong>렌더 트리로 결합</strong>된다.</li><li>생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 표시한다.</li></ol><h2 id="14-Event-Delegation"><a href="#14-Event-Delegation" class="headerlink" title="14. Event Delegation"></a>14. Event Delegation</h2><h5 id="이벤트-위임이란"><a href="#이벤트-위임이란" class="headerlink" title="이벤트 위임이란?"></a>이벤트 위임이란?</h5><ul><li><p>다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 <strong>하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법</strong></p></li><li><p>이벤트가 <a href="https://poiemaweb.com/js-event#7-event-flow-이벤트의-흐름" target="_blank" rel="noopener">이벤트 흐름</a>에 의해 <strong>이벤트를 발생시킨 요소의 부모 요소에도 영향**</strong>(버블링)**을 미치기 때문에 가능한 것</p></li></ul><h5 id="이벤트-위임이-효과적인-경우"><a href="#이벤트-위임이-효과적인-경우" class="headerlink" title="이벤트 위임이 효과적인 경우"></a>이벤트 위임이 효과적인 경우</h5><ul><li><p>모든 li 요소가 클릭 이벤트에 반응하는 처리를 구현하고 싶은 경우 =&gt; 부모요소인 ul요소에 클릭 이벤트 핸들러를 바인딩하는 것이 효율적이다.</p></li><li><p><strong>동적으로 li 요소가 추가되는 경우, 아직 추가되지 않은 요소는 DOM에 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다.</strong></p></li></ul><h2 id="15-Event-Capturing-vs-Event-Bubbling"><a href="#15-Event-Capturing-vs-Event-Bubbling" class="headerlink" title="15. Event Capturing vs. Event Bubbling"></a>15. Event Capturing vs. Event Bubbling</h2><h4 id="Capturing"><a href="#Capturing" class="headerlink" title="Capturing"></a>Capturing</h4><ul><li>이벤트가 window 객체에서 출발해서 DOM 트리를 통해서 이벤트 타깃까지 전파되는 것.</li><li>이벤트 타깃이 이벤트를 수신하기 전에 이벤트를 빼돌리는 단계라는 뜻에서 캡처링 단계라는 이름이 붙음</li></ul><h4 id="Bubbling"><a href="#Bubbling" class="headerlink" title="Bubbling"></a>Bubbling</h4><ul><li>이벤트가 이벤트 타깃에서 출발해서 DOM 트리를 타고 window 객체까지 전파되는 것.</li><li>이벤트가 마치 거품이 올라오는 것처럼 DOM트리 아래에서부터 위로 올라온다는 뜻에서 버블링 단계라는 이름이 붙음</li></ul><h2 id="16-Class"><a href="#16-Class" class="headerlink" title="16. Class"></a>16. Class</h2><p>대부분의 객체 지향 언어가 클래스 기반인 점을 고려하여 ES6에서 클래스를 도입했다. 그러나 그 <strong>클래스도 사실은 함수</strong>이고 기존의 프로토타입 기반 객체지향 패턴으로 동작한다.</p><p>클래스는 상속을 빼놓고 말할 수 없다. 상속이란 객체지향의 핵심적인 기능으로, 클래스는 상속을 지원한다.</p><p>클래스의 기본적인 문법은 아래와 같다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// constructor</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// default method definition: class's prototype method</span></span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi! <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>._name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> mimi = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">'Mimi'</span>);</span><br><span class="line">mimi.sayHello(); <span class="hljs-comment">// Hi! Mimi</span></span><br></pre></td></tr></table></figure><p>클래스 정의 내부에는 최대 한 개의 constructor가 필요하며 constructor를 생략할 경우에 default connstructir() {}가 실행되어 인스턴스 생성시 빈 객체가 생성된다. constructor는 인스턴스를 생성하고 클래스 필드를 초기화하는 특수한 메소드이다.</p><h4 id="Class-Field"><a href="#Class-Field" class="headerlink" title="Class Field"></a>Class Field</h4><p>클래스 내부에는 메소드만 선언한다. 모든 프로퍼티(인스턴스의 멤버 변수)는 constructor 내부에 선언한다. contstructor는 생성자 함수와 같이 this로 빈 객체를 생성해서 프로퍼티를 추가하고 this를 리턴한다.</p><h4 id="Class-Hoisting"><a href="#Class-Hoisting" class="headerlink" title="Class Hoisting"></a>Class Hoisting</h4><p>Class는 <code>let</code>이나 <code>const</code>와 같이 <strong>호이스팅 되지 않는 것처럼</strong> 동작한다. 선언 이전에 참조하면 ReferenceError가 발생한다.</p><blockquote><h4 id="호이스팅되지-않는-것처럼-동작한다는-것"><a href="#호이스팅되지-않는-것처럼-동작한다는-것" class="headerlink" title="호이스팅되지 않는 것처럼 동작한다는 것"></a>호이스팅되지 않는 것처럼 동작한다는 것</h4><p><code>var</code> 키워드와 다르게 <code>let</code>, <code>const</code> 키워드는 런타임 이전에 자바스크립트 엔진이 선언문을 미리 실행할 때, 1. 선언 단계(Declaration Phase)와 2. 초기화 단계(Initialization Phase)가 함께 진행되지 않는다. </p><p><code>let</code>, <code>const</code> 키워드로 선언한 변수는 1. 선언 단계만 미리 실행되어 스코프에 변수 명이 등록되지만 2. 초기화 단계는 런타임에 <strong>선언문이 실행될 때</strong> 실행된다. 2. 초기화 단계는 변수의 값을 위한 메모리 공간을 할당하고 undefined라는 값을 암묵적으로 넣어주는 것이다. 이런 초기화 단계를 진행하지 않았으니 참조 에러가 나는 것이다. </p><p>ES6의  class도 사실은 함수이지만, function 키워드로 선언한 함수 선언식은 호이스팅 되는 반면 class로 선언한 함수는 호이스팅 되지 않는다. 즉, 선언만 해놓고 초기화를 하지 않아 호이스팅되지 않는 것처럼 동작한다.</p><p><code>let</code>이나 <code>const</code> 나 class 등의 선언문 이전을 TDZ(Temporal Dead Zone)이라고 한다. 선언만 되고 초기화되지 않아 참조할 수 없는 구간을 말한다.</p></blockquote><h2 id="17-super"><a href="#17-super" class="headerlink" title="17. super"></a>17. super</h2><h4 id="1-extends-Keyword"><a href="#1-extends-Keyword" class="headerlink" title="1. extends Keyword"></a>1. <code>extends</code> Keyword</h4><p><code>extends</code> 키워드는 parent 클래스를 생속받는 child 클래스를 정의할 때 사용한다.</p><h4 id="2-super-Keyword"><a href="#2-super-Keyword" class="headerlink" title="2. super Keyword"></a>2. <code>super</code> Keyword</h4><p><code>super</code> 키워드는 <strong>parent 클래스를 참조</strong>하거나  <strong>parent 클래스의 constructor를 호출</strong>할 때 사용한다.</p><ol><li><p>super 클래스가 메소드로 사용될 때는 parent 클래스의 constructor를 호출한다. <strong>child 클래스의 constructor에서 super()를 호출하지 않으면 this에 대한 ReferenceError가 발생한다.</strong></p><p>child 클래스의 인스턴스를 만들 때 parent 클래스의 인스턴스를 우선 만들고 상속한다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// parent 클래스의 constructor를 호출한다.</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cylinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(radius, height) &#123;</span><br><span class="line">    <span class="hljs-comment">// super가 parent class의 constructor처럼 사용됨</span></span><br><span class="line">    <span class="hljs-keyword">super</span>(radius);</span><br><span class="line">    <span class="hljs-keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/48080762/58225537-6c111480-7d5d-11e9-9cbb-45fc8d66a2ff.png" alt="super"></p><p>ECMAScript의 스펙을 살펴보면 super가 argument를 전달받으며 호출될 때</p><ol><li>내부적으로 자신의 parent 클래스의 constructor를 호출하고</li><li>constructor가 리턴한 this 객체를 child 클래스 constructor의 this(child 클래스가 생성할 인스턴스)에 바인딩한다.</li></ol></li><li><p>super 클래스가 객체로 사용될 때는 parent 클래스를 참조한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// super가 parent class Circle처럼 사용됨</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// parent class Circle의 getArea overriding</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">super</span>.getPerimeter()) + (<span class="hljs-number">2</span> * <span class="hljs-keyword">super</span>.getArea());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 자신의 메소드 정의</span></span><br><span class="line">  getVolume() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getArea() * <span class="hljs-keyword">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="18-Prototype"><a href="#18-Prototype" class="headerlink" title="18. Prototype"></a>18. Prototype</h2><p><strong>상속 (inheritance)</strong> : 객체지향 프로그래밍의 핵심 개념으로 부모 객체의 프로퍼티를 자식 개체가 상속받아 그대로 사용할 수 있는 것을 말한다.</p><p>자바스크립트의 상속은 프로토타입(prototype)을 기반으로 구현된다.</p><p>상속을 사용해야 하는 이유는,</p><ol><li>동일한 프로퍼티 구조를 갖는 객체를 여러개 만들 때 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 <strong>메모리적 관점에서 비효율적</strong>이기 때문이다. 상속을 사용하면 하나의 프로토타입을 생성해 모든 인스턴스가 공유할 수 있다.</li><li>인스턴스를 생성할 때마다 메소드를 생성하므로 <strong>퍼포먼스적으로 비효율적</strong>이다. 상속은 코드의 재사용이란 관점에서 유용하다. 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해놓으면 생성되는 인스턴스는 메소드 생성 없이 미리 구현된 프로토타입의 프로퍼티를 사용할 수 있다.</li></ol><h4 id="proto-amp-prototype-property"><a href="#proto-amp-prototype-property" class="headerlink" title="__proto__ &amp; prototype property"></a>__proto__ &amp; prototype property</h4><p>모든 객체는 <code>[[Prototype]]</code> 내부슬롯에 자신의 프로토타입을 가지고, 접근하기 위해서 __proto__ 접근자 프로퍼티를 사용한다. </p><p>함수 객체는 __proto__ 접근자 프로퍼티 외에 prorotype 프로퍼티도 소유하는데, 이 둘을 헷갈리면 안된다.</p><p>__proto__는 모든 객체가 가지는 자신의 프로토타입 접근자 프로퍼티이고, prototype 프로퍼티는 함수 객체가 자신이 생성할 인스턴스에 할당하는 프로토타입이다.</p><table><thead><tr><th style="text-align:center">구분</th><th style="text-align:center">prototype 프로퍼티</th><th style="text-align:center">__proto__ 접근자 프로퍼티</th></tr></thead><tbody><tr><td style="text-align:center">소유</td><td style="text-align:center">함수 객체</td><td style="text-align:center">모든 객체</td></tr><tr><td style="text-align:center">값</td><td style="text-align:center">프로토타입의 참조값</td><td style="text-align:center">프로토타입의 참조값</td></tr><tr><td style="text-align:center">사용 주체</td><td style="text-align:center">생성자 함수</td><td style="text-align:center">모든 객체</td></tr><tr><td style="text-align:center">사용 목적</td><td style="text-align:center">자신이 생성할 객체의 프로토타입을 할당하기 위해 사용</td><td style="text-align:center">자신의 프로토타입에 접근하기 위해서 사용</td></tr></tbody></table><p>프로토타입은 생성자 함수가 생성되는 시점에 함께 생성된다.</p><h4 id="Prototype-Chain"><a href="#Prototype-Chain" class="headerlink" title="Prototype Chain"></a>Prototype Chain</h4><p><img src="https://user-images.githubusercontent.com/48080762/57827738-7f633380-77e3-11e9-92b8-ccf1ba0c77ab.png" alt="Prototype Chain"></p><p>자바스크립트 엔진은 객체의 프로퍼티에 접근하려고 할 때 해당 객체에서 우선 프로퍼티를 검색하고, 없으면 __proto__ 접근자 프로퍼티가 가리키는 프로토타입 객체의 프로퍼티를 순차적으로 검색한다. </p><p>이렇게 연결된 프로토타입들을 프로토타입 체인이라고 한다. <strong>프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘</strong>이다.</p><p>프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. Object.prototype을 프로토 타입 체인의 종점(End ofprototype chain)이라고 한다. </p><p>프로퍼티 체인의 끝까지 올라가 검색했는데도 프로퍼티를 찾지 못 할 경우 에러가 아니라 <code>undefined</code>를 리턴한다.</p><p>식별자의 검색은 함수의 중첩 관계로 이루어진 스코프의 계층적인 구조에서 이루어지고, 프로퍼티의 검색은 객체 간의 상속 관계로 이루어진 프로토타입의 계층적인 구조에서 이루어진다.</p><h2 id="19-Promise"><a href="#19-Promise" class="headerlink" title="19. Promise"></a>19. Promise</h2><p>자바스크립트는 비동기 처리를 위해서 callback 함수 패턴을 사용한다. 그러나 callback 패턴은 가독성이 나쁘고 <strong>에러의 예외 처리가 곤란</strong>하다. ES6에서 Asynchronous processing을 위한 패턴으로 Promise를 도입했다. </p><p>Promise는 비동기 처리를 하고 Response가 오면 해야할 일을 약속하는 것이다.</p><h4 id="콜백-패턴의-단점"><a href="#콜백-패턴의-단점" class="headerlink" title="콜백 패턴의 단점"></a>콜백 패턴의 단점</h4><ol><li><p>콜백 헬</p><p>콜백 패턴을 사용할 때 처리 순서를 위해서 여러 개의 콜백 함수가 중첩되어 프로그래밍의 복잡도가 높아진다. 그래서 콜백 헬이 발생한다.</p></li><li><p>에러 처리의 한계</p><p>Exception(예외)는 Caller 방향으로 전파되는데, 콜백 함수의 경우 Caller를 찾을 수 없으므로 try catch로 에러를 캐치할 수 없다.</p></li></ol><p>이러한 콜백의 단점을 보완하기 위해서 ES6에서 Promise를 도입했다.</p><h4 id="Promise-생성"><a href="#Promise-생성" class="headerlink" title="Promise 생성"></a>Promise 생성</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Asynchronous process</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-comment">/* Asynchronous process Fulilled */</span>) &#123;</span><br><span class="line">        resolve(<span class="hljs-string">'result'</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">/* Asynchronous process Rejected */</span></span><br><span class="line">        reject(<span class="hljs-string">'failure reason'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise constructor function은 비동기 작업을 수행할 callback 함수를 argument로 전달받는다. 이 callback 함수는 resolve, reject 함수를 argument로 전달받는다.</p><p>resolve 함수는 argument로 실행 결과를 전달하며 호출, reject 함수는 argument로 에러 메시지를 전달하며 호출한다.</p><h4 id="Promise-후속-처리"><a href="#Promise-후속-처리" class="headerlink" title="Promise 후속 처리"></a>Promise 후속 처리</h4><p>비동기 함수는 Promise 객체를 리턴해야 한다. 그러면 Promise 객체의 메소드인 then과 catch를 사용해서 후속 처리를 한다.</p><blockquote><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then 메소드는 두 개의 콜백 함수를 argument로 전달받는다. <strong>첫 번째 callback 함수는 성공</strong>(fulfilled, resolve 함수가 호출된 상태) 시 호출되고 <strong>두 번째 callback은 실패</strong>(rejected, reject 함수가 호출된 상태) 시 호출된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; p.then(onFulfilled, onRejected);</span><br><span class="line">&gt; p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;</span><br><span class="line">&gt; <span class="hljs-comment">// fulfilled</span></span><br><span class="line">&gt; &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>&#123;</span><br><span class="line">&gt; <span class="hljs-comment">// rejected</span></span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>onFulfilled</code></p><p>​    Promise가 성공했을 때 호출되는 function. <strong>Fulfillment value</strong> (수행 결과)  (Promise의  resolve argument에 넘겨준 response) 하나를 argument로 받는다. Promise를 리턴한다.</p><p><code>onRejected</code></p><p>​    Promise가 거부되었을 때 호출되는 function. <strong>Rejected reason</strong> (에러 이유) (Promise의  regect argument에 넘겨준 error mesagge) 하나를 argument로 받는다. Promise를 리턴한다.</p></blockquote><blockquote><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p><strong>예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출</strong>된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; p.catch(onRejected);</span><br><span class="line">&gt; </span><br><span class="line">&gt; p.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>&#123;</span><br><span class="line">&gt; <span class="hljs-comment">// rejected</span></span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>onRejected</code></p><p>​    Promise가 거부되었을 때 호출되는 function. Rejected reason을 argument로 받는다.</p></blockquote><p>then과 catch 메소드도 Promise 객체를 리턴하므로 Promise Chaining이 가능하다. 콜백을 중첩시키지 않고서도 처리 순서를 지킬 수 있다.</p><h2 id="20-동기식-처리-모델-vs-비동기식-처리-모델"><a href="#20-동기식-처리-모델-vs-비동기식-처리-모델" class="headerlink" title="20. 동기식 처리 모델 vs. 비동기식 처리 모델"></a>20. 동기식 처리 모델 vs. 비동기식 처리 모델</h2><p>동기식 처리 모델(Synchronous Processing Model)은 Blocking model이라고도 불리며, 어떤 작업 도중에 클라이언트가 서버에 데이터를 요청하는 것과 같이 시간이 오래 걸리는 일이 발생하면 다른 작업을 Blocking 시켜놓고 해당 작업이 끝날 때까지 기다리는 것과 같이 동작한다.</p><p>반면 비동기식 처리 모델(Asynchronous Processing Model)은 작업 도중 서버로의 요청 등 시간이 오래 걸리는 일이 발생하면 기다리지 않고 (non-blocking) 바로 다음 작업을 실행한다.</p><p>자바스크립트의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기식 처리 모델로 동작한다.</p><p><img src="https://poiemaweb.com/img/event-loop.gif" alt="event-loop"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Data-Type&quot;&gt;&lt;a href=&quot;#1-Data-Type&quot; class=&quot;headerlink&quot; title=&quot;1. Data Type&quot;&gt;&lt;/a&gt;1. Data Type&lt;/h2&gt;&lt;p&gt;Data type은 값의 종류를 말한다. 대부분의 프로그래
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>190529-TIL</title>
    <link href="https://sub2n.github.io/2019/05/29/190529-TIL/"/>
    <id>https://sub2n.github.io/2019/05/29/190529-TIL/</id>
    <published>2019-05-29T09:32:29.000Z</published>
    <updated>2019-05-31T09:36:55.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>JavaScript Ajax, RESPful API, Promise에 대해서 배웠다.</li><li>알고리즘 문제 해결 전략 책을 샀다. 틈틈히 알고리즘 공부를 해야겠다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JavaScript A
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190527-TIL</title>
    <link href="https://sub2n.github.io/2019/05/27/190527-TIL/"/>
    <id>https://sub2n.github.io/2019/05/27/190527-TIL/</id>
    <published>2019-05-27T09:37:55.000Z</published>
    <updated>2019-05-27T09:47:27.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h3><ul><li>JavaScript Event를 연습하기위해서 TodoList를 여러가지로 구현했다.</li><li>Class를 이용해서 구현하는 방법도 알았다.</li><li>Event Listener를 Class의 method로 만들었을 때 해당 메소드의 this는 class의 instance가 아니라 event를 바인딩한 DOM객체가 되는 문제<ul><li>bind로 event listener method에 this를 binding</li><li>this가 없는 Arrow function을 사용해서 상위 lexical scope, 즉 class의 this를 바인딩하게 하는 방법</li></ul></li></ul><hr><p><a href="https://github.com/Sub2n/Todos-1.0" target="_blank" rel="noopener">Todos 1.0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JavaScript E
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>33. Promise</title>
    <link href="https://sub2n.github.io/2019/05/27/33-Promise/"/>
    <id>https://sub2n.github.io/2019/05/27/33-Promise/</id>
    <published>2019-05-27T03:53:37.000Z</published>
    <updated>2019-05-31T07:11:57.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-Promise"><a href="#What-is-Promise" class="headerlink" title="What is Promise?"></a>What is Promise?</h2><p>자바스크립트는 비동기 처리를 위해서 callback 함수 패턴을 사용한다. 그러나 callback 패턴은 가독성이 나쁘고 <strong>에러의 예외 처리가 곤란</strong>하다. ES6에서 Asynchronous processing을 위한 패턴으로 Promise를 도입했다. </p><p>Promise는 비동기 처리를 하고 Response가 오면 해야할 일을 약속하는 것이다.</p><h2 id="1-Disadvantages-of-Callback-Pattern"><a href="#1-Disadvantages-of-Callback-Pattern" class="headerlink" title="1. Disadvantages of Callback Pattern"></a>1. Disadvantages of Callback Pattern</h2><h3 id="1-1-Callback-Hell"><a href="#1-1-Callback-Hell" class="headerlink" title="1.1. Callback Hell"></a>1.1. Callback Hell</h3><p>자바스크립트의 Asynchronous Processing Model(non-blocking)은 task를 parallel 처리해서 다른 task가 blocking되지 않는다는 장점이 있다.</p><p>그러나 callback 패턴을 사용하면 processing 순서를 위해서 여러 개의 callback 함수가 nesting되어 프로그래밍의 복잡도가 높아진다. 그래서 Callback Hell이 발생한다.</p><p>비동기 함수(asynchronous function)의 경우 언제 Request에 대한 Response가 올지 알 수 없으므로 비동기 함수의 처리 결과를 가지고 무언가를 해야할 경우 해당 함수의 callback 함수 내에서 처리해야한다. 이로 인해서 중첩이 계속되어 callback hell이 발생한다.</p><h3 id="1-2-Error-Handling-Limits"><a href="#1-2-Error-Handling-Limits" class="headerlink" title="1.2. Error Handling Limits"></a>1.2. Error Handling Limits</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-string">'Error!'</span>; &#125;, <span class="hljs-number">1000</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'에러를 캐치하지 못한다..'</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setTimeout의 argument로 넘겨주는 callback 함수는 setTimeout이 아닌 다른 곳에서 실행된다. setTimeout은 비동기 함수이므로 호출되는 즉시 종료되어 Call Stack에서 제거된다.</p><p>Exception(예외)는 Caller 방향으로 전파되는데, setTimeout의 callback 함수의 Caller는 setTimeout 함수가 아니므로  catch block에서 exception이 캐치되지 않는다.</p><p>이러한 문제를 보완하기 위해서 ES6에서 Promise를 도입했다. IE를 제외한 대부분의 브라우저가 Promise를 지원한다.</p><h2 id="2-Creation-of-Promise"><a href="#2-Creation-of-Promise" class="headerlink" title="2. Creation of Promise"></a>2. Creation of Promise</h2><p>Promise constructor function은 비동기 작업을 수행할 callback 함수를 argument로 전달받는다. 이 callback 함수는 resolve, reject 함수를 argument로 전달받는다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Asynchronous process</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-comment">/* Asynchronous process Fulilled */</span>) &#123;</span><br><span class="line">        resolve(<span class="hljs-string">'result'</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">/* Asynchronous process Rejected */</span></span><br><span class="line">        reject(<span class="hljs-string">'failure reason'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise는 비동기 처리의 state 정보를 가진다.</p><table><thead><tr><th>State</th><th>Meaning</th><th>Implementation</th></tr></thead><tbody><tr><td>pending</td><td>비동기 처리 수행 전</td><td>resolve / reject 함수 호출 전</td></tr><tr><td>fulfilled</td><td>비동기 처리 수행됨 (성공)</td><td>resolve 함수 호출된 상태</td></tr><tr><td>rejected</td><td>비동기 처리 수행됨 (실패)</td><td>reject 함수 호출된 상태</td></tr><tr><td>settled</td><td>literally 비동기처리 수행됨 (성공 또는 실패)</td><td>resolve 또는 reject 함수 호출된 상태</td></tr></tbody></table><h2 id="4-Post-processing-Method-of-the-Promise"><a href="#4-Post-processing-Method-of-the-Promise" class="headerlink" title="4. Post-processing Method of the Promise"></a>4. Post-processing Method of the Promise</h2><p>Promise로 구현된 비동기 함수는 Promise object를 리턴해야한다. Promise로 구현된 비동기 함수를 호출하는 promise consumer는 Promise object의 후속 처리 메소드(then, catch)를 통해서 해당 비동기 함수의 결과 또는 에러메시지를 받아서 처리한다. Promise object의  state에 따라서 후속 처리 메소드를 chaining 방식으로 호출한다.</p><blockquote><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then 메소드는 두 개의 콜백 함수를 argument로 전달받는다. <strong>첫 번째 callback 함수는 성공</strong>(fulfilled, resolve 함수가 호출된 상태) 시 호출되고 <strong>두 번째 callback은 실패</strong>(rejected, reject 함수가 호출된 상태) 시 호출된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; p.then(onFulfilled, onRejected);</span><br><span class="line">&gt; p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;</span><br><span class="line">&gt;   <span class="hljs-comment">// fulfilled</span></span><br><span class="line">&gt;   &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>&#123;</span><br><span class="line">&gt;   <span class="hljs-comment">// rejected</span></span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>onFulfilled</code></p><p>​    Promise가 성공했을 때 호출되는 function. <strong>Fulfillment value</strong> (수행 결과)  (Promise의  resolve argument에 넘겨준 response) 하나를 argument로 받는다. Promise를 리턴한다.</p><p><code>onRejected</code></p><p>​    Promise가 거부되었을 때 호출되는 function. <strong>Rejected reason</strong> (에러 이유) (Promise의  regect argument에 넘겨준 error mesagge) 하나를 argument로 받는다. Promise를 리턴한다.</p></blockquote><blockquote><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p><strong>예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출</strong>된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; p.catch(onRejected);</span><br><span class="line">&gt; </span><br><span class="line">&gt; p.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>&#123;</span><br><span class="line">&gt;    <span class="hljs-comment">// rejected</span></span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>onRejected</code></p><p>​    Promise가 거부되었을 때 호출되는 function. Rejected reason을 argument로 받는다.</p></blockquote><h3 id="5-Error-Handling-of-Promise"><a href="#5-Error-Handling-of-Promise" class="headerlink" title="5. Error Handling of Promise"></a>5. Error Handling of Promise</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> $result = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.result'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> render = <span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> &#123; $result.innerHTML = <span class="hljs-built_in">JSON</span>.stringify(content, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> promiseAjax = <span class="hljs-function">(<span class="hljs-params">method, url, callback, payload</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">        xhr.setRequestHeader(<span class="hljs-string">'Content-type'</span>, <span class="hljs-string">'application/json'</span>);</span><br><span class="line">        xhr.send(<span class="hljs-built_in">JSON</span>.stringify(payload));  <span class="hljs-comment">// undefined를 strungify하면 undefined (string 아님)</span></span><br><span class="line">        xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (xhr.readyState !== XMLHttpRequest.DONE) <span class="hljs-keyword">return</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span> (xhr.status &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.status &lt; <span class="hljs-number">400</span>) &#123; <span class="hljs-comment">// 200: GET ok, 201: POST ok</span></span><br><span class="line">                <span class="hljs-comment">// 성공 =&gt; resolve</span></span><br><span class="line">                resolve(<span class="hljs-built_in">JSON</span>.parse(xhr.response));</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 실패 =&gt; reject</span></span><br><span class="line">                reject(<span class="hljs-string">`<span class="hljs-subst">$&#123;xhr.status&#125;</span> <span class="hljs-subst">$&#123;xhr.statusText&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">promiseAjax(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'http://localhost:3000/todos'</span>)</span><br><span class="line">      .then(render)</span><br><span class="line">      .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`ERROR!: <span class="hljs-subst">$&#123;error&#125;</span>`</span>));</span><br></pre></td></tr></table></figure><p>비동기 함수 promiseAjax 내부의 비동기 처리시 발생한 에러 메시지는 promiseAjax이 리턴하는 Promise object의 then 메소드의 두번째 argument callback 함수나 catch 메소드로 처리한다.</p><p>catch 메소드는 then의 두번째 argument callback 함수와 똑같이 에러를 처리하지만, then 뒤에 호출되어 then 내부에서 발생한 에러도 캐치할 수 있다. 따라서 <strong>에러 처리는 catch 메소드를 사용하는 게 효율적</strong>이다.</p><blockquote><h4 id="Async-amp-Await-이용"><a href="#Async-amp-Await-이용" class="headerlink" title="Async &amp; Await 이용"></a>Async &amp; Await 이용</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">&gt;     <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">&gt;         <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> promiseAjax(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'http://localhost:3000/todos'</span>);</span><br><span class="line">&gt;         render(res);</span><br><span class="line">&gt;     &#125; <span class="hljs-keyword">catch</span>(e) &#123;</span><br><span class="line">&gt;         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`ERROR!: <span class="hljs-subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Promise에 async와 await를 이용하면 try, catch로 에러처리를 할 수 있다.</p></blockquote><h2 id="6-Promise-Chaining"><a href="#6-Promise-Chaining" class="headerlink" title="6. Promise Chaining"></a>6. Promise Chaining</h2><p>Promise는 후속 처리 메소드를 Chainning해서 여러 개의 Promise를 연결하여 사용할 수 있다.  Callback Hell을 해결한다.</p><p>여러 개의 Promise를 연결한다는 것은, Promise object의 후속 처리 메소드인 then이나 catch가 또 다른 Promise object를 리턴하도록 하는 것이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// promiseAjax 함수가 리턴하는 Promise callback에서 JSON.parse 안 하고 리턴할 경우</span></span><br><span class="line">promiseAjax(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'http://localhost:3000/todos'</span>)</span><br><span class="line">    .then(<span class="hljs-built_in">JSON</span>.parse)</span><br><span class="line">.then(render)</span><br><span class="line">    .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`ERROR!: <span class="hljs-subst">$&#123;error&#125;</span>`</span>));</span><br></pre></td></tr></table></figure><h3 id="7-Static-Methods-of-Promise"><a href="#7-Static-Methods-of-Promise" class="headerlink" title="7. Static Methods of Promise"></a>7. Static Methods of Promise</h3><p>Promise는 주로 생성자로 사용되지만 4가지 Static method를 갖는다.</p><h3 id="7-1-Promise-resolve-Promise-reject"><a href="#7-1-Promise-resolve-Promise-reject" class="headerlink" title="7.1. Promise.resolve / Promise.reject"></a>7.1. Promise.resolve / Promise.reject</h3><p>Promise.resolve와 Promise.reject 메소드는 존재하는 값을 <strong>Promise로 wrapping</strong>하기 위해 사용</p><p>Static method resolve는 argument로 전달된 값을 resolve하는 Promise를 생성</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> resolvedPromise = <span class="hljs-built_in">Promise</span>.resolve([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);</span><br><span class="line">resolvedPromise.then(<span class="hljs-built_in">console</span>.log); <span class="hljs-comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Static method reject는 argument로 전달된 값을 reject하는 Promise를 생성</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> rejectedPromise = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Error!'</span>));</span><br><span class="line">rejectedPromise.catch(<span class="hljs-built_in">console</span>.log);<span class="hljs-comment">// Error: Error!</span></span><br></pre></td></tr></table></figure><h3 id="7-2-Promise-all"><a href="#7-2-Promise-all" class="headerlink" title="7.2. Promise.all"></a>7.2. Promise.all</h3><p>Promise.all 메소드는 argument로 Promise가 담겨 있는 Iterable을 받는다. 그리고 전달 받은 Promise들을 parallel로 처리하고 결과를 전달받은 순서대로 resolve하는 새로운 Promise를 리턴한다. Promise.all은 Promise가 순서대로 처리되지 않아도 모든 Promise 처리가 완료될 때가지 기다려 순서대로 resolve한다. 즉, <strong>처리 순서를 보장</strong>한다.</p><p>Promise 처리가 하나라도 실패하면 <strong>가장 먼저 실패한 Promise가 reject한 에러를 reject하는 Promise를 즉시 리턴</strong>한다.</p><h3 id="7-3-Promise-race"><a href="#7-3-Promise-race" class="headerlink" title="7.3. Promise.race"></a>7.3. Promise.race</h3><p>Promise.race 메소드는 Promise.all 메소드와 비슷게 argument로 Promise가 담겨있는 Iterable을 전달받지만, Promise.all과 다르게 <strong>가장 먼저 처리된 Promise가 resolve한 결과를 resolve하는 새로운 Promise를 리턴</strong>한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;What-is-Promise&quot;&gt;&lt;a href=&quot;#What-is-Promise&quot; class=&quot;headerlink&quot; title=&quot;What is Promise?&quot;&gt;&lt;/a&gt;What is Promise?&lt;/h2&gt;&lt;p&gt;자바스크립트는 비동기 처리를 
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Promise" scheme="https://sub2n.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>32. REST API</title>
    <link href="https://sub2n.github.io/2019/05/27/32-REST-API/"/>
    <id>https://sub2n.github.io/2019/05/27/32-REST-API/</id>
    <published>2019-05-27T02:20:18.000Z</published>
    <updated>2019-05-30T01:41:17.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="REST-Representational-State-Transfer-API"><a href="#REST-Representational-State-Transfer-API" class="headerlink" title="REST(Representational State Transfer) API"></a>REST(Representational State Transfer) API</h2><p>open API를 이용하기 위해서 문서를 찾아다닐 때 가장 많이 본 단어가 RESTful API이다. REST는 웹의 장점을 최대한 활용할 수 있는 architecture로 처음 소개되었으며 HTTP 프로토콜을 의도에 맞게 디자인하도록 유도하는 방법론이다. REST의 기본 원칙에 충실한 서비스 디자인을 RESTful이라고 한다.</p><h3 id="1-REST-API-중심-규칙"><a href="#1-REST-API-중심-규칙" class="headerlink" title="1. REST API 중심 규칙"></a>1. REST API 중심 규칙</h3><h4 id="1-URI는-정보의-자원을-표현해야-한다"><a href="#1-URI는-정보의-자원을-표현해야-한다" class="headerlink" title="1) URI는 정보의 자원을 표현해야 한다."></a>1) URI는 정보의 자원을 표현해야 한다.</h4><p>리소스명으로 동사보다는 명사를 사용</p><p>URI는 자원을 표현하는 데 중점 두어야 함</p><h4 id="2-자원에-대한-행위는-HTTP-Method-GET-POST-PUT-DELETE-등-로-표현한다"><a href="#2-자원에-대한-행위는-HTTP-Method-GET-POST-PUT-DELETE-등-로-표현한다" class="headerlink" title="2) 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)로 표현한다."></a>2) 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)로 표현한다.</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># bad</span><br><span class="line">GET /books/delete/1</span><br><span class="line"></span><br><span class="line"># good</span><br><span class="line">DELETE /books/1</span><br></pre></td></tr></table></figure><h3 id="2-HTTP-Method"><a href="#2-HTTP-Method" class="headerlink" title="2. HTTP Method"></a>2. HTTP Method</h3><p>주로 5자리 Method를 사용해서 <strong>CRUD</strong> (Create, Read, Update, Delete) 구현</p><table><thead><tr><th style="text-align:left">Method</th><th>Action</th><th>역할</th></tr></thead><tbody><tr><td style="text-align:left">GET</td><td>index/retireve</td><td>모든/특정 리소스 조회</td></tr><tr><td style="text-align:left">POST</td><td>create</td><td>리소스 생성</td></tr><tr><td style="text-align:left">PUT</td><td>update all</td><td>모든 리소스 갱신</td></tr><tr><td style="text-align:left">PATCH</td><td>update</td><td>리소스 갱신</td></tr><tr><td style="text-align:left">DELETE</td><td>delete</td><td>리소스 삭제</td></tr></tbody></table><h3 id="3-Configuring-the-REST-API"><a href="#3-Configuring-the-REST-API" class="headerlink" title="3. Configuring the REST API"></a>3. Configuring the REST API</h3><h4 id="REST의-3요소"><a href="#REST의-3요소" class="headerlink" title="REST의 3요소"></a>REST의 3요소</h4><table><thead><tr><th>구성 요소</th><th>내용</th><th>표현 방법</th></tr></thead><tbody><tr><td>Resource</td><td>Resource</td><td>HTTP URI</td></tr><tr><td>Verb</td><td>Actions on Resources</td><td>HTTP Method</td></tr><tr><td>Representations</td><td>Details of actions on resources</td><td>HTTP Message <strong>Pay Load</strong></td></tr></tbody></table><p>REST는 Self-descriptiveness(자체 표현 구조)로 구성되어  REST API만으로 Request를 이해할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;REST-Representational-State-Transfer-API&quot;&gt;&lt;a href=&quot;#REST-Representational-State-Transfer-API&quot; class=&quot;headerlink&quot; title=&quot;REST(Represe
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="REST API" scheme="https://sub2n.github.io/tags/REST-API/"/>
    
  </entry>
  
  <entry>
    <title>31. Ajax</title>
    <link href="https://sub2n.github.io/2019/05/26/31-Ajax/"/>
    <id>https://sub2n.github.io/2019/05/26/31-Ajax/</id>
    <published>2019-05-26T02:33:41.000Z</published>
    <updated>2019-05-29T07:10:17.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Ajax-Asynchronous-JavaScript-and-XML"><a href="#1-Ajax-Asynchronous-JavaScript-and-XML" class="headerlink" title="1. Ajax (Asynchronous JavaScript and XML)"></a>1. Ajax (Asynchronous JavaScript and XML)</h3><p>브라우저에서 웹페이지를 요청하거나 링크를 클릭하면 서버에서 요청받은 페이지(HTML)을 반환한다. 이 때 HTML에서 로드하는 CSS나 JavaScript 파일도 함께 반환한다. 서버에서 웹페이지를 받으면 브라우저는 파일을 렌더링해서 화면에 표시한다. <strong>URI이 바뀌면 전체 화면 렌더링을 다시해야해</strong>서 화면이 깜빡하는 문제가 있다.</p><h4 id="Ajax-Asynchronous-JavaScript-and-XML"><a href="#Ajax-Asynchronous-JavaScript-and-XML" class="headerlink" title="Ajax(Asynchronous JavaScript and XML)"></a>Ajax(Asynchronous JavaScript and XML)</h4><ul><li>XML : JSON이 나오기 이전에 서버와 Data를 주고받기 위해 사용됨</li></ul><p>자바스크립트를 이용해서 Asynchronous하게 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식</p><p>Ajax는 서버로부터 웹페이지를 받아서 <strong>화면 전체를 다시 그리는 것이 아니라, 페이지 일부만 갱신</strong>할 수 있게 한다.</p><p>페이지 전체를 로드해서 렌더링할 필요가 없으므로 퍼포먼스가 빨라지고 화면 표시 효과가 부드러워진다.</p><h3 id="2-JSON-JavaScript-Object-Notation"><a href="#2-JSON-JavaScript-Object-Notation" class="headerlink" title="2. JSON (JavaScript Object Notation)"></a>2. JSON (JavaScript Object Notation)</h3><p><strong>JSON</strong>은 클라이언트와 서버 간 데이터 교환을 위한 규칙. 즉, <strong>데이터 포맷</strong>이다.</p><p>JSON은 일반 텍스트 포맷보다 효과적으로 데이터를 구조화할 수 있다.</p><p>XML 포맷보다 가볍고 사용하기 간편하고 가독성이 우수하다.</p><p>자바스크립트의 객체 리터럴과 비슷하지만 <strong>JSON은 순수한 텍스트</strong>로 구성된 규칙이 있는 Data Structure이다. JSON은 String이다.</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>,</span><br><span class="line">    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Park"</span>,</span><br><span class="line">    <span class="hljs-attr">"checked"</span>: <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JSON에서 Key는 반드시 <code>&quot; &quot;</code>로 둘러싸야 한다.</strong> (‘ ‘ 사용 불가)</p><h4 id="2-1-JSON-stiringify"><a href="#2-1-JSON-stiringify" class="headerlink" title="2.1. JSON.stiringify"></a>2.1. JSON.stiringify</h4><p>JSON.stringify 메소드는 객체를 JSON 형식 string으로 변환한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> hospitalKey = <span class="hljs-string">'hospital'</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> partskey = <span class="hljs-string">'parts'</span>;</span><br><span class="line">    ...</span><br><span class="line">  localStorage.setItem(hospitalkey,<span class="hljs-built_in">JSON</span>.stringify(hospital));</span><br><span class="line">  localStorage.setItem(partskey, <span class="hljs-built_in">JSON</span>.stringify(parts));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-JSON-parse"><a href="#2-1-JSON-parse" class="headerlink" title="2.1. JSON.parse"></a>2.1. JSON.parse</h4><p>JSON.parse 메소드는 JSON 형식 data string을 객체로 변환한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkSelectedPart</span>(<span class="hljs-params">part</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> parts = <span class="hljs-built_in">JSON</span>.parse(localStorage.getItem(partskey));</span><br><span class="line">    <span class="hljs-keyword">let</span> checkedPart;</span><br><span class="line">    parts.forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (element.id === part) &#123;</span><br><span class="line">            element.checked = <span class="hljs-literal">true</span>;</span><br><span class="line">            checkedPart = element;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            element.checked = <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    localStorage.setItem(partskey, <span class="hljs-built_in">JSON</span>.stringify(parts));</span><br><span class="line">    showParts(checkedPart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서버에서 브라우저로 전송하는 JSON 데이터는 모두 string이다. 이 string을 자바스크립트의 객체로 사용하기 위해서는 Internal Object인 JSON의 static 메소드 JSON.parse를 사용한다.</p><p>JSON.stringify가 encoding / serialization이면 JSON.parse는 decoding / deserialization이다.</p><h3 id="3-XMLHttpRequest"><a href="#3-XMLHttpRequest" class="headerlink" title="3. XMLHttpRequest"></a>3. XMLHttpRequest</h3><p>브라우저는 <strong>XMLHttpRequest 객체를 이용해 Ajax Request를 생성하고 전송</strong>한다. 서버가 브라우저의 Request에 Response하면 Ajax Request를 생성했던 XMLHttpRequest 객체가 결과를 처리한다.</p><h3 id="3-1-Ajax-Request"><a href="#3-1-Ajax-Request" class="headerlink" title="3.1. Ajax Request"></a>3.1. Ajax Request</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// XMLHttpRequest 객체의 생성</span></span><br><span class="line"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="hljs-comment">// 비동기 방식으로 Request를 open. open하며 method와 action 지정</span></span><br><span class="line"><span class="hljs-comment">// 상대주소는 html 출처 server 기준. 다른 출처로 요청하면 동일출처원칙에 어긋담</span></span><br><span class="line">xhr.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'/users'</span>);</span><br><span class="line"><span class="hljs-comment">// Request를 전송한다</span></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h4 id="XMLHttpRequest-open"><a href="#XMLHttpRequest-open" class="headerlink" title="XMLHttpRequest.open"></a>XMLHttpRequest.open</h4><p>new 연산자로 XMLHttpRequest 객체의 인스턴스를 생성 후, XMLHttpRequest.open 메소드를 사용해서 서버로 보낼 Request를 오픈한다.</p><p><strong>XMLHttpRequest.open(method, url[, async])</strong></p><ul><li>method<ul><li>HTTP method </li><li>“GET”, “POST”, “PUT”, “DELETE”</li></ul></li><li>url<ul><li>Request를 보낼 URL</li></ul></li><li>async<ul><li>default true로 asynchronous 동작</li><li>false면 synchronous =&gt; blocking 발생</li></ul></li></ul><h4 id="XMLHttpRequest-send"><a href="#XMLHttpRequest-send" class="headerlink" title="XMLHttpRequest.send"></a>XMLHttpRequest.send</h4><p>XMLHttpRequest.send 메소드로 준비된 Request를 서버에 전달한다.</p><p>Request의 method가,</p><ul><li>GET일 때 : 데이터를 URL의 일부인 <strong>query string으로</strong> 서버로 전송. Pay Load 없고 URL에 넣어 보내므로 send(null)</li><li>POST일 때 : <strong>데이터(Pay Load)</strong>를 <strong>Request Body에 담아서</strong> 서버로 전송</li></ul><p>XMLHttpRequest.send 메소드에는 Request Body에 담아서 서버로 전송할 arguments를 전달할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(<span class="hljs-literal">null</span>);</span><br><span class="line"><span class="hljs-comment">// xhr.send('string');</span></span><br><span class="line"><span class="hljs-comment">// xhr.send(new Blob()); // file 등 binary contents 보내는 방법</span></span><br><span class="line"><span class="hljs-comment">// xhr.send(&#123; form: 'data' &#125;);</span></span><br><span class="line"><span class="hljs-comment">// xhr.send(document);</span></span><br></pre></td></tr></table></figure><p>Request Method가 POST가 아니라 GET일 때는 send 메소드의 argument는 무시되고 request body는 null로 설정됨</p><h4 id="XMLHttpRequest-setRequestHeader"><a href="#XMLHttpRequest-setRequestHeader" class="headerlink" title="XMLHttpRequest.setRequestHeader"></a>XMLHttpRequest.setRequestHeader</h4><p>XMLHttpRequest.setRequestHeader 메소드는 HTTP Request Header의 값을 설정한다. 헤더 설정 전에 <strong>반드시 XMLHttpRequest.open 메소드로 Request를 오픈</strong>한 상태여야 한다.</p><h4 id="Content-type"><a href="#Content-type" class="headerlink" title="Content-type"></a>Content-type</h4><p>Request Body에 담아 전송할 데이터의  MIME-type 정보 표현 (contents type)</p><blockquote><h4 id="MIME-type-Multipurpose-Internet-Mail-Extensions"><a href="#MIME-type-Multipurpose-Internet-Mail-Extensions" class="headerlink" title="MIME-type(Multipurpose Internet Mail Extensions)"></a>MIME-type(Multipurpose Internet Mail Extensions)</h4><p>클라이언트에 전송된 문서의 다양성을 알려주기 위한 매커니즘. 웹에서 파일의 확장자는 별 의미가 없으므로 각 문서와 함께 올바른 MIME-type을 전송하도록 서버가 정한다. 브라우저는 MIME-type을 사용해서 리소스를 내려받은 후 해야 할 기본 동작을 결정한다.</p></blockquote><p>자주 사용되는 MIME-type</p><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">Subtype</th></tr></thead><tbody><tr><td style="text-align:center">text Type</td><td style="text-align:center">text/plain, text/html, text/css, text/javascript</td></tr><tr><td style="text-align:center">Application Type</td><td style="text-align:center">application/json, application/x-www-form-urlencode</td></tr><tr><td style="text-align:center">Type to upload a File</td><td style="text-align:center">multipart/formed-data</td></tr></tbody></table><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// json으로 전송</span></span><br><span class="line">xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'/users'</span>);</span><br><span class="line"><span class="hljs-comment">// 서버로 전송할 데이터의 MIME-type 지정</span></span><br><span class="line">xhr.setRequestHeader(<span class="hljs-string">'Content-type'</span>, <span class="hljs-string">'application/json'</span>);</span><br></pre></td></tr></table></figure><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>HTTP 클라이언트가 서버에 요청할 때 서버로부터 <strong>받을 데이터의  MIME-type을 Accept로 지정</strong> 가능.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 클라이언트가 Request시 서버가 Send back할 데이터의 MIME-type 지정</span></span><br><span class="line">xhr.setRequestHeader(<span class="hljs-string">'Accept'</span>, <span class="hljs-string">'application/json'</span>);</span><br></pre></td></tr></table></figure><h3 id="3-2-Ajax-Response"><a href="#3-2-Ajax-Response" class="headerlink" title="3.2. Ajax Response"></a>3.2. Ajax Response</h3><p>XMLHttpRequest.onreadystatechange는 요청한 Request에 대해서 서버가 보낸 Response를 감지하고 callback 함수를 실행한다. XHLHttpRequest.readyState 프로퍼티가 변경될 때마다 onreadystatechange 이벤트 핸들러가 호출된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// XMLHttpRequest 객체 생성</span></span><br><span class="line"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="hljs-comment">// Asynchronous Request open</span></span><br><span class="line">xhr.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'data/test.json'</span>);</span><br><span class="line"><span class="hljs-comment">// send Request</span></span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 이벤트 핸들러 호출</span></span><br><span class="line">xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 이 함수는 Response가 클라이언트에 도달하면 호출된다.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>XMLHttpRequest.readyState</strong>로 서버가 보낸 Response가 클라이언트에 도착했는지 알 수 있다. </p><p>XMLHttpRequest.readyState의 값은 아래와 같다.</p><table><thead><tr><th style="text-align:center">Value</th><th style="text-align:center">State</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">UNSENT</td><td style="text-align:center">XMLHttpRequest.open() 메소드 호출 이전</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">OPENED</td><td style="text-align:center">XMLHttpRequest.open() 메소드 호출 완료</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">HEADERS_RECEIVED</td><td style="text-align:center">XMLHttpRequest.send() 메소드 호출 완료</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">LOADING</td><td style="text-align:center">서버 응답 중(XMLHttpRequest.responseText 미완성 상태)</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">DONE</td><td style="text-align:center">서버 응답 완료</td></tr></tbody></table><p><strong>XMLHttpRequest.status</strong>로 Response를 분석할 수 있다.</p><h3 id="4-Web-Server"><a href="#4-Web-Server" class="headerlink" title="4.  Web Server"></a>4.  Web Server</h3><blockquote><h4 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h4><p>HTML, CSS, JavaScript, img, XML 등 client가 요청하는 Static file(resource)를 제공</p><h4 id="Application-Server"><a href="#Application-Server" class="headerlink" title="Application Server"></a>Application Server</h4><p>Static resource를 제공할 수 있는 기능은 물론 REST API를 처리할 수 있다.</p></blockquote><p>웹서버(Web Server)는 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고 HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램이다.</p><p>Node.js로 간단한 웹서버를 생성해서 Ajax 실습을 해보자.</p><p><img src="https://user-images.githubusercontent.com/48080762/58472479-4a5ec580-8181-11e9-81b9-ec94d9c68ccd.png" alt="Express Server"></p><p><a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000</a>에서 Hello World!를 표시하면 성공</p><h3 id="5-Ajax-Example"><a href="#5-Ajax-Example" class="headerlink" title="5. Ajax Example"></a>5. Ajax Example</h3><h4 id="5-1-Load-HTML"><a href="#5-1-Load-HTML" class="headerlink" title="5.1. Load HTML"></a>5.1. Load HTML</h4><p>위에서 만든 webserver-express의 루트인 public 폴더에 data/data.html 파일을 준비한 후, 아래 html 파일을 만들고 실행해본다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://poiemaweb.com/assets/css/ajax.css"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// XMLHttpRequest 객체의 생성</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 비동기 방식으로 Request를 오픈</span></span></span><br><span class="line"><span class="hljs-actionscript">      xhr.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'data/data.html'</span>);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// Request를 전송한다</span></span></span><br><span class="line"><span class="hljs-undefined">      xhr.send();</span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-built_in">console</span>.dir(xhr);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// Event Handler</span></span></span><br><span class="line"><span class="hljs-actionscript">      xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">        <span class="hljs-comment">// 서버 응답 완료</span></span></span><br><span class="line"><span class="hljs-actionscript">        <span class="hljs-keyword">if</span> (xhr.readyState === XMLHttpRequest.DONE) &#123;</span></span><br><span class="line"><span class="hljs-actionscript">          <span class="hljs-comment">// 정상 응답</span></span></span><br><span class="line"><span class="hljs-actionscript">          <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span>) &#123;</span></span><br><span class="line"><span class="hljs-javascript">            <span class="hljs-built_in">console</span>.log(xhr.responseText);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content'</span>).innerHTML = xhr.responseText;</span></span><br><span class="line"><span class="hljs-actionscript">          &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="line"><span class="hljs-javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[<span class="hljs-subst">$&#123;xhr.status&#125;</span>] : <span class="hljs-subst">$&#123;xhr.statusText&#125;</span>`</span>);</span></span><br><span class="line"><span class="hljs-undefined">          &#125;</span></span><br><span class="line"><span class="hljs-undefined">        &#125;</span></span><br><span class="line"><span class="hljs-undefined">      &#125;;</span></span><br><span class="line"><span class="hljs-undefined">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>정상 실행 되었을 때의 log이다. 서버에 요청해서 응답받은 data/data.html을 xhr.responseText로 취득한다.</p><p><img src="https://user-images.githubusercontent.com/48080762/58473668-251f8680-8184-11e9-9c0a-59110cbc12af.png" alt="Success"></p><p>xhr.open(‘GET’, ‘data/data2.html’)로 코드를 수정해서 없는 file을 요청하면 Request의 status는 404, statusText는 Not Found이다.</p><p><img src="https://user-images.githubusercontent.com/48080762/58473745-5b5d0600-8184-11e9-90c6-354839bec8e9.png" alt="Fail"></p><h4 id="5-2-Load-JSON"><a href="#5-2-Load-JSON" class="headerlink" title="5.2. Load JSON"></a>5.2. Load JSON</h4><p>다음은 위에서처럼 html을 통째로 받아오는 것이 아니라 JSON 객체를 전달받아 parsing하고 필요한 정보를 뽑아서 렌더링하는 예제이다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://poiemaweb.com/assets/css/ajax.css"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// XMLHttpRequest 객체의 생성</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 비동기 방식으로 Request를 오픈</span></span></span><br><span class="line"><span class="hljs-actionscript">      xhr.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'data/data.json'</span>);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// Request를 전송</span></span></span><br><span class="line"><span class="hljs-undefined">      xhr.send();</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">        <span class="hljs-comment">// 서버 응답 완료</span></span></span><br><span class="line"><span class="hljs-actionscript">        <span class="hljs-keyword">if</span> (xhr.readyState === XMLHttpRequest.DONE) &#123;</span></span><br><span class="line"><span class="hljs-actionscript">          <span class="hljs-comment">// 정상 응답</span></span></span><br><span class="line"><span class="hljs-actionscript">          <span class="hljs-keyword">if</span> (xhr.status === <span class="hljs-number">200</span>) &#123;</span></span><br><span class="line"><span class="hljs-javascript">            <span class="hljs-built_in">console</span>.log(xhr.responseText);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">            <span class="hljs-comment">// Deserializing (String → Object)</span></span></span><br><span class="line"><span class="hljs-javascript">            responseObject = <span class="hljs-built_in">JSON</span>.parse(xhr.responseText);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">            <span class="hljs-comment">// JSON → HTML String</span></span></span><br><span class="line"><span class="hljs-handlebars"><span class="hljs-xml">            let newContent = '<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"tours"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Guided Tours<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>';</span></span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">            responseObject.tours.forEach(<span class="hljs-function"><span class="hljs-params">tour</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="hljs-actionscript">              newContent += `&lt;li <span class="hljs-class"><span class="hljs-keyword">class</span>="$</span>&#123;tour.region&#125; tour<span class="hljs-string">"&gt;</span></span></span><br><span class="line"><span class="hljs-handlebars"><span class="hljs-xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>$&#123;tour.location&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="hljs-javascript">                  &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"details"</span>&gt;$&#123;tour.details&#125;&lt;<span class="hljs-regexp">/span&gt;</span></span></span><br><span class="line"><span class="hljs-javascript">                  &lt;button <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"book"</span>&gt;Book Now&lt;<span class="hljs-regexp">/button&gt;</span></span></span><br><span class="line"><span class="hljs-handlebars"><span class="hljs-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>`;</span></span></span><br><span class="line"><span class="hljs-undefined">            &#125;);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-handlebars"><span class="hljs-xml">            newContent += '<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>';</span></span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content'</span>).innerHTML = newContent;</span></span><br><span class="line"><span class="hljs-actionscript">          &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="line"><span class="hljs-javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[<span class="hljs-subst">$&#123;xhr.status&#125;</span>] : <span class="hljs-subst">$&#123;xhr.statusText&#125;</span>`</span>);</span></span><br><span class="line"><span class="hljs-undefined">          &#125;</span></span><br><span class="line"><span class="hljs-undefined">        &#125;</span></span><br><span class="line"><span class="hljs-undefined">      &#125;;</span></span><br><span class="line"><span class="hljs-undefined">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-Load-JSONP"><a href="#5-3-Load-JSONP" class="headerlink" title="5.3. Load JSONP"></a>5.3. Load JSONP</h4><blockquote><h4 id="Same-origin-Policy-동일출처원칙"><a href="#Same-origin-Policy-동일출처원칙" class="headerlink" title="Same-origin Policy (동일출처원칙)"></a>Same-origin Policy (동일출처원칙)</h4><p>보안상의 이유로 다른 도메인(http, https / 다른 port)로 요청하는 Cross-domain Request는 제한된다.</p></blockquote><p>동일출처원칙을 우회하는 방법 세가지</p><ol><li><p>웹서버의 프록시파일</p><p>Proxy (원격 서버로부터 데이터를 수집하는 별도 기능)를 서버에 추가</p></li><li><p>JSONP</p><p>이해 안 감</p></li><li><p><strong>Cross-Origin Resource Sharing (CORS)</strong><br>서버에서 처리하니까 백엔드에 요청하면 됨</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Ajax-Asynchronous-JavaScript-and-XML&quot;&gt;&lt;a href=&quot;#1-Ajax-Asynchronous-JavaScript-and-XML&quot; class=&quot;headerlink&quot; title=&quot;1. Ajax (Asynchr
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Ajax" scheme="https://sub2n.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>190524-TIL</title>
    <link href="https://sub2n.github.io/2019/05/24/190524-TIL/"/>
    <id>https://sub2n.github.io/2019/05/24/190524-TIL/</id>
    <published>2019-05-24T12:23:39.000Z</published>
    <updated>2019-05-24T13:00:10.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FDS12-Pair-Hackaton"><a href="#FDS12-Pair-Hackaton" class="headerlink" title="FDS12 Pair Hackaton"></a>FDS12 Pair Hackaton</h2><p>오늘 약 5일간 기획하고 준비한 페어 해커톤을 마쳤다. 오전 10시부터 오후 5시까지 약 7시간동안 하나의 결과물을 내는 것이다. <strong>내 생애 첫 해커톤에서 1등을 했다.</strong> 오늘은 이론을 공부하지는 않았으나 그것보다 훨씬 더 많은 것을 배웠다.</p><p>우선 나는 프로젝트 경험이 적어 개발 능력에 자신감이 없는 편이었는데 이번 해커톤으로 자신감을 많이 얻었다. 그리고 무엇보다 내가 생각한대로 기능을 구현하는 것이 너무나 재미있었다.<br>삐그덕거리던 프로그램을 차근차근 고쳐서 모든 게 맞아 돌아가게끔 할 때의 쾌감이란! 확실히 개발은 재미있다. 고통 속에서 느끼는 희열이 있다. 그리고 기획이 얼마나 중요한 것인지도 알았다. 비지니스적인 시야가 넓은 팀원의 주제 제안과 꼼꼼한 기획 덕에 완성도 있고 의미 있는 프로젝트를 할 수 있었다. 또한 디자인적인 감각을 키우는 것도 내가 해야할 공부 중 하나라는 것을 깨달았다.</p><p>두번째로 아직 내가 가야할 길이 멀다는 것을 배웠다. <strong>무언가 엄청나게 멋있(어 보이는)는 것</strong>을 만들기에 시간은 한없이 모자랐다. 마음이 조급해지니 중간에 혼잣말로 징징거리기도 많이 했다. 결국 프로젝트는 원하던 것의 80%정도밖에 구현하지 못했다. 아쉽지만 분명히 미래의 나에게 좋은 밑거름이 될거라 믿는다.</p><p>마지막으로, 나는 발표를 할 때 긴장을 참 많이 한다. 막상 앞에 나가서 무슨 정신인지 여유로운 척 농담을 하고 발표를 했지만 끝나고 돌아와 앉는 순간까지 손과 다리가 떨리는 게 느껴졌다. 오늘도 발표를 하고 들어왔는데 어떻게 한 건지 정신이 하나 없었다. 그런데 같은 스쿨 분들이 안 떤 것처럼 느껴졌다고, 잘 했다고 말해줘서 많이 안심했다. 내가 막연하게 무서워하는 것들. 막연하게 내가 못 할 거라고 단정지었던 것들은 사실 내가 충분히 해낼 수 있는 거였다. 오늘의 경험을 잊지 않고 앞으로 나아가기 위해 기록한다.</p><hr><p>✨<a href="https://devpost.com/software/team-doctor" target="_blank" rel="noopener">Team Doctor on Devpost</a></p><p>✨<a href="https://github.com/Sub2n/Team-Doctor" target="_blank" rel="noopener">Team Doctor Github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FDS12-Pair-Hackaton&quot;&gt;&lt;a href=&quot;#FDS12-Pair-Hackaton&quot; class=&quot;headerlink&quot; title=&quot;FDS12 Pair Hackaton&quot;&gt;&lt;/a&gt;FDS12 Pair Hackaton&lt;/h2&gt;&lt;p&gt;오늘
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
      <category term="FDS12" scheme="https://sub2n.github.io/tags/FDS12/"/>
    
      <category term="Hackaton" scheme="https://sub2n.github.io/tags/Hackaton/"/>
    
  </entry>
  
  <entry>
    <title>30. Event</title>
    <link href="https://sub2n.github.io/2019/05/22/30-Event/"/>
    <id>https://sub2n.github.io/2019/05/22/30-Event/</id>
    <published>2019-05-22T12:01:02.000Z</published>
    <updated>2019-06-03T04:48:32.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Event"><a href="#1-Event" class="headerlink" title="1. Event"></a>1. Event</h3><p>브라우저의 이벤트는 사용자의 동작에 따라 어느 시점에 발생할 지 미리 알 수 없고 순서 또한 예측할 수 없다. 브라우저에서는 이벤트를 감지할 수 있고 이벤트 발생 시 통지를 해서 사용자와 웹 페이지의 Interaction이 가능케 한다.</p><p>이벤트 발생시 실행될 함수를 등록할 수 있다. 이벤트와 함수를 연결하면 함수는 이벤트 발생 전에는 실행되지 않닥 이벤트가 발생하면 실행된다. 이런 함수를 Event Handler 또는 Event Listener라고 한다.</p><blockquote><h4 id="Synchronous-amp-Asynchronous-Processing-Model"><a href="#Synchronous-amp-Asynchronous-Processing-Model" class="headerlink" title="Synchronous &amp; Asynchronous Processing Model"></a>Synchronous &amp; Asynchronous Processing Model</h4><ul><li>Synchronous<ul><li>프로세스가 직렬적, 즉 순차적으로 task를 처리하는 처리 모델</li><li>따라서 중간에 시간이 오래 걸리는 작업이 있으면 다음 작업은 대기한다.</li><li>서버에서 데이터를 요청받아야할 I/O 작업이 실행될 경우에 이후의 작업들은 Block되어 대기한다. 이를 I/O Blocking이라고 한다.</li></ul></li><li>Asynchronous<ul><li>Non-Blocking Process Model이라고도 하는 Asyncoronous 처리 모델</li><li>어떤 task가 종료되지 않은 상태라고 해도 대기하지 않고(Non-Blocking) 즉시 다음 task로 넘어간다.</li><li>대부분의 Event를 Asncronous하게 처리한다.</li></ul></li></ul></blockquote><h3 id="2-Event-Loop-and-Concurrency"><a href="#2-Event-Loop-and-Concurrency" class="headerlink" title="2. Event Loop and Concurrency"></a>2. Event Loop and Concurrency</h3><p>브라우저는 Single-thread에서 Event-driven 방식으로 동작한다.</p><h4 id="Single-thread"><a href="#Single-thread" class="headerlink" title="Single-thread"></a>Single-thread</h4><p>Single thread는 하나의 thread만을 사용하기 때문에 어느 한 순간에 하나의  task만을 처리할 수 있다는 것을 의미한다. 그러나 브라우저를 사용하는 사용자는 동시에 여러 웹 애플리케이션을 실행하고 있는 것처럼 느낄 것이다. <strong>Event Loop</strong>가 자바스크립트의 동시성(Concurrency)을 지원하기 때문이다.</p><h4 id="Call-Stack"><a href="#Call-Stack" class="headerlink" title="Call Stack"></a>Call Stack</h4><p>스택은 LIFO(Last In First Out)으로 마지막에 들어온 task가 먼저 실행된다. 자바스크립트는 하나의 Call Stack을 사용한다. 이는 어떤 task가 종료하기 전에 다른 task는 수행될 수 없음을 의미한다.</p><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><p>Dynamic하게 생성된 Object Instance가 할당되는 영역</p><h4 id="Event-Queue-Task-Queue"><a href="#Event-Queue-Task-Queue" class="headerlink" title="Event Queue(Task Queue)"></a>Event Queue(Task Queue)</h4><p>Asynchronous process function의 callback 함수, asynchronous event handler, Timer 함수의 callback 함수가 보관되는 영역.</p><p>Event Loop에 의해 Call Stack이 비었을 때 순차적으로 Call Stack으로 이동해서 실행된다. </p><p>이벤트 발생시 이벤트 핸들러는 Event Queue에 들어갔다가 Call Stack이 비면 Event Loop에 의해서 Call Stack에 진입해 실행된다.</p><h4 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h4><p>Event Loop는 Call Stack의 task와 Event Queue의 task를 주기적으로 확인한다. Call Stack이 비어있는 시점에 Event Queue 내의 Task를 Call Stcak으로 이동시켜 실행하게 한다. </p><p>Event Loop가 빠르게 돌며 task를 순간순간 전환하기 때문에 사용자는 여러개의 task를 동시에 실행하고 있다고 느끼는 것이다. 이렇게 한 번에 하나의 task을 처리하면서 마치 동시에 처리하는 것처럼 동작시키는 방법을 Pseudo Parallel이라고 한다.</p><h3 id="3-Type-of-Events"><a href="#3-Type-of-Events" class="headerlink" title="3. Type of Events"></a>3. Type of Events</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener">Event Reference</a></p><h3 id="4-Register-Event-Handler"><a href="#4-Register-Event-Handler" class="headerlink" title="4. Register Event Handler"></a>4. Register Event Handler</h3><ul><li>인라인 이벤트 핸들러</li><li>이벤트 팬들러 프로퍼티</li><li>addEventListener 메소드</li></ul><h4 id="4-1-Inline-Event-Handler"><a href="#4-1-Inline-Event-Handler" class="headerlink" title="4.1. Inline Event Handler"></a>4.1. Inline Event Handler</h4><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"foo()"</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">  <span class="hljs-keyword">const</span> $button = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.btn'</span>);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Clicked!'</span>);</span></span><br><span class="line"><span class="hljs-undefined">  &#125;</span></span><br><span class="line"><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML element의 이벤트 핸들러 attribute에 inline으로 핸들러를 등록</p><h4 id="4-2-Event-Handler-Property"><a href="#4-2-Event-Handler-Property" class="headerlink" title="4.2. Event Handler Property"></a>4.2. Event Handler Property</h4><p><img src="https://user-images.githubusercontent.com/48080762/58231568-4c381b80-7d72-11e9-8e07-7d111af4fe39.png" alt="EventHandler Property"></p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn"</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">  <span class="hljs-keyword">const</span> $button = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.btn'</span>);</span></span><br><span class="line"><span class="hljs-actionscript">  $button.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Clicked!'</span>);</span></span><br><span class="line"><span class="hljs-undefined">  &#125;;</span></span><br><span class="line"><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML과 JavaScript 코드가 섞이지 않지만 한 개의 Event Handler 프로퍼티에 하나의 Event Handler만을 바인딩할 수 있다.</p><h4 id="4-3-addEventListener-Method"><a href="#4-3-addEventListener-Method" class="headerlink" title="4.3. addEventListener Method"></a>4.3. addEventListener Method</h4><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn"</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">  <span class="hljs-keyword">const</span> $button = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.btn'</span>);</span></span><br><span class="line"><span class="hljs-actionscript">  $button.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Clicked!'</span>);</span></span><br><span class="line"><span class="hljs-undefined">  &#125;);</span></span><br><span class="line"><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>EventTarget.addEventListener(eventType, functionName[, useCapture])</p><ul><li>EventTarget : 대상 element</li><li><code>eventTarget</code>: 대상 element에 바인딩될 이벤트 (String)</li><li><code>fuinctionName</code>: 이벤트 발생 시 호출될 함수 명, 또는 함수 정의</li><li><code>useCapture</code>(option): capture 사용 여부<ul><li>Dafault: false (Bubbling)</li><li>true: capturing</li></ul></li></ul><p>addEventListener의 장점</p><ol><li>하나의 이벤트에 여러 개의 이벤트 핸들러를 추가할 수 있다.</li><li>캡처링을 사용할 수 있다.</li><li>HTML element 뿐만 아니라 DOM 요소(HTML, XML, SVG)에도 동작한다.</li></ol><p>IE9 이상에서 동작하므로 IE8 이하에서는 attachEvent 메소드를 사용한다.</p><h3 id="5-this-in-Event-Handler"><a href="#5-this-in-Event-Handler" class="headerlink" title="5. this in Event Handler"></a>5. <code>this</code> in Event Handler</h3><ol><li><p><strong>Inline Event Handler</strong></p><p>이벤트 핸들러가 일반 함수로 호출되므로 내부의 this는 <strong>전역 객체 window</strong>이다.</p></li><li><p><strong>Event Handler Property</strong></p><p>이벤트 핸들러가 메소드이므로 내부의 this는 <strong>이벤트에 바인딩된 element</strong>를 가리킨다. event 객체의 currentTarget 프로퍼티 값과 같다.</p></li><li><p><strong>addEventListener Method</strong></p><p>이벤트 핸들러 내의 this는 addEventListener 메소드를 호출한 element, 즉 <strong>이벤트 리스너에 바인딩된 element</strong>를 가리킨다. <strong>event 객체의 currentTarget 프로퍼티 값</strong>과 같다.</p></li></ol><p>이벤트 핸들러 property와 addEventListener method로 등록한 이벤트 핸들러 내부의 this = 이벤트 리스너에 <strong>바인딩된 element</strong> = event.currentTarget</p><h3 id="6-Event-Flow"><a href="#6-Event-Flow" class="headerlink" title="6. Event Flow"></a>6. Event Flow</h3><h4 id="Event-Propagation"><a href="#Event-Propagation" class="headerlink" title="Event Propagation"></a>Event Propagation</h4><p>HTML element에 이벤트가 발생할 경우 속한 계층을 따라서 이벤트가 전파(Event Propagation)된다.</p><ul><li>Event Capturing : child element에서 발생한 이벤트가 parent element부터 시작해서 이벤트를 발생시킨 child element까지 도달하는 것</li><li>Event Bubbling : child element에서 발생한 이벤트가 parent element까지 전이되는 것</li></ul><p>버블링과 캡처링은 둘 중 하나만 발생하는 것이 아니라 <strong>캡처링으로 시작해 버블링으로 끝난다.</strong></p><p>addEventListener 메소드의 세번째 argument를 true로 주면 캡처링으로 이동하는 이벤트를 캐치하고, flase 또는 주지 않으면 default로 버블링으로 이동하는 이벤트를 캐치한다.</p><h3 id="7-Event-Object"><a href="#7-Event-Object" class="headerlink" title="7. Event Object"></a>7. Event Object</h3><p>이벤트 발생시 event 객체가 동적으로 생성되어 이벤트를 처리할 핸들러에 argument로 전달된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventHandler</span>(<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(e.clientX, e.clientY);</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(<span class="hljs-string">'click'</span>, eventHandler);</span><br></pre></td></tr></table></figure><h4 id="Event-target"><a href="#Event-target" class="headerlink" title="Event.target"></a>Event.target</h4><p>e.target은 <strong>실제로 이벤트를 발생시킨 element</strong>를 가리킨다. Event.target은 this와 반드시 일치하지 않는다.</p><h4 id="Event-currentTarget"><a href="#Event-currentTarget" class="headerlink" title="Event.currentTarget"></a>Event.currentTarget</h4><p><strong>이벤트에 바인딩된 DOM element</strong>를 가리킨다. addEventListener로 지정한 이벤트 핸들러 내부의 this와 일치한다.</p><h4 id="Event-type"><a href="#Event-type" class="headerlink" title="Event.type"></a>Event.type</h4><p>발생한 이벤트의 종류를 나타내는 문자열을 리턴한다.</p><h4 id="Event-cancelable"><a href="#Event-cancelable" class="headerlink" title="Event.cancelable"></a>Event.cancelable</h4><p>element의 기본 동작을 취소시킬 수 있는지를 나타낸다. =&gt; Boolean</p><h4 id="Event-eventPhase"><a href="#Event-eventPhase" class="headerlink" title="Event.eventPhase"></a>Event.eventPhase</h4><p>이벤트가 event flow 상에서 어떤 event phase에 있는지 리턴한다.</p><table><thead><tr><th>Return</th><th>Meaning</th></tr></thead><tbody><tr><td>0</td><td>No Event</td></tr><tr><td>1</td><td>Capturing Phase</td></tr><tr><td>2</td><td>Target</td></tr><tr><td>3</td><td>Bubbling Phase</td></tr></tbody></table><h3 id="8-Event-Elegation"><a href="#8-Event-Elegation" class="headerlink" title="8. Event Elegation"></a>8. Event Elegation</h3><p>여러 child element의 이벤트를 캐치하고 싶을 때 이벤트 위임을 이용해서 parent element에 이벤트 핸들러를 바인딩한다. </p><p>또한 어떤 ul element에 동적으로 child li element들이 추가되는 경우, 동적으로 추가되는 element는 DOM에 아직 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다. 이런 경우에도 parent element인 ul에 이벤트 핸들러를 바인딩해 event elegation을 사용한다.</p><p>이벤트 위임(Event Delegation)은 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법이다.</p><p>Event Delegation은 이벤트가 Event flow에 의해서 bubbling이 되기 때문에 가능한 것이다.</p><p>실제로 이벤트를 발생시킨 element는 event.target으로 찾는다.</p><h3 id="9-Change-Default-Operation"><a href="#9-Change-Default-Operation" class="headerlink" title="9. Change Default Operation"></a>9. Change Default Operation</h3><p>Event object는 element의 default 동작을 가지며 element의 parent element들이 이벤트에 대응하는 방법을 변경할 수 있도록하는 메소드를 가진다.</p><h4 id="Event-preventDefault"><a href="#Event-preventDefault" class="headerlink" title="Event.preventDefault()"></a>Event.preventDefault()</h4><p>form을 submit하거나 link를 클릭하면 default로 다른 페이지로 이동하는데, 이처럼 element가 가진 default 동작을 막는 메소드가 preventDefault()이다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.google.com"</span>&gt;</span>go<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'a'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">console</span>.log(e.target, e.target.nodeName);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-comment">// a 요소의 기본 동작을 중단한다.</span></span></span><br><span class="line"><span class="hljs-undefined">    e.preventDefault();</span></span><br><span class="line"><span class="hljs-undefined">  &#125;);</span></span><br><span class="line"><span class="hljs-undefined">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Event-stopPropagation"><a href="#Event-stopPropagation" class="headerlink" title="Event.stopPropagation()"></a>Event.stopPropagation()</h4><p>Event flow 상의 어떤 한 element에서 이벤트를 처리한 후에,  더이상 이벤트가 전파되는 것을 중단하게끔 하는 메소드이다. 주로 child와 parent에 동일한 event에 대한 핸들러가 각각 다르게 등록되어있는 경우에 사용한다. child에서 일어난 event에서 op1을 동작해야 하는데 parent로 이벤트가 전파되어 op2가 동작되면 안되기 때문이다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-css">    <span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;&#125;</span></span><br><span class="line"><span class="hljs-undefined">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>버튼을 클릭하면 이벤트 전파를 중단한다. <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>버튼<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">const</span> body = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'body'</span>);</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">const</span> para = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'p'</span>);</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">const</span> button = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'button'</span>);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-comment">// default: 버블링</span></span></span><br><span class="line"><span class="hljs-actionscript">    body.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Handler for body.'</span>);</span></span><br><span class="line"><span class="hljs-undefined">    &#125;);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-comment">// default: 버블링</span></span></span><br><span class="line"><span class="hljs-actionscript">    para.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Handler for paragraph.'</span>);</span></span><br><span class="line"><span class="hljs-undefined">    &#125;);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-comment">// default: 버블링</span></span></span><br><span class="line"><span class="hljs-actionscript">    button.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Handler for button.'</span>);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 이벤트 전파를 중단</span></span></span><br><span class="line"><span class="hljs-undefined">      event.stopPropagation();</span></span><br><span class="line"><span class="hljs-undefined">    &#125;);</span></span><br><span class="line"><span class="hljs-undefined">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="preventDefault-amp-stopPropagation"><a href="#preventDefault-amp-stopPropagation" class="headerlink" title="preventDefault &amp; stopPropagation"></a>preventDefault &amp; stopPropagation</h3><p>default 동작과 bubbling/capturing을 동시에 중단시킬 수 있는 방법이 있다.</p><p>이벤트 핸들러 내에서 <code>return false;</code>를 하면 되는데, 이 방법은 jQuery를 사용하거나 inline event handler로 이벤트 핸들러를 return할 때만 동작한다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.google.com"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">'return handleEvent()'</span>&gt;</span>go<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEvent</span><span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span></span><br><span class="line"><span class="hljs-undefined">  &#125;</span></span><br><span class="line"><span class="hljs-undefined">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.google.com"</span>&gt;</span>go<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">  <span class="hljs-comment">// within jQuery</span></span></span><br><span class="line"><span class="hljs-javascript">  $(<span class="hljs-string">'a'</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">    e.preventDefault(); <span class="hljs-comment">// OK</span></span></span><br><span class="line"><span class="hljs-undefined">  &#125;);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">  $(<span class="hljs-string">'a'</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// OK --&gt; e.preventDefault() &amp; e.stopPropagation().</span></span></span><br><span class="line"><span class="hljs-undefined">  &#125;);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">  <span class="hljs-comment">// pure js</span></span></span><br><span class="line"><span class="hljs-javascript">  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'a'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-comment">// e.preventDefault(); // OK</span></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;       <span class="hljs-comment">// NG!!!!!</span></span></span><br><span class="line"><span class="hljs-undefined">  &#125;);</span></span><br><span class="line"><span class="hljs-undefined">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Event&quot;&gt;&lt;a href=&quot;#1-Event&quot; class=&quot;headerlink&quot; title=&quot;1. Event&quot;&gt;&lt;/a&gt;1. Event&lt;/h3&gt;&lt;p&gt;브라우저의 이벤트는 사용자의 동작에 따라 어느 시점에 발생할 지 미리 알 수 없고 순서
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Event" scheme="https://sub2n.github.io/tags/Event/"/>
    
  </entry>
  
  <entry>
    <title>190522-TIL</title>
    <link href="https://sub2n.github.io/2019/05/22/190522-TIL/"/>
    <id>https://sub2n.github.io/2019/05/22/190522-TIL/</id>
    <published>2019-05-22T10:52:13.000Z</published>
    <updated>2019-05-22T12:39:56.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h3><ul><li>JavaScript의 Class, super 키워드에 대해서 공부했다.</li><li>해커톤 자료구조를 설계하고 사용할 카카오맵 API를 테스트했다.</li><li>JavaScript Event에 대해서 읽어보았다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JavaScript의 
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>29. DOM</title>
    <link href="https://sub2n.github.io/2019/05/22/29.%20DOM/"/>
    <id>https://sub2n.github.io/2019/05/22/29. DOM/</id>
    <published>2019-05-22T07:58:06.000Z</published>
    <updated>2019-05-28T05:11:53.418Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-DOM-Document-Object-Model"><a href="#1-DOM-Document-Object-Model" class="headerlink" title="1. DOM (Document Object Model)"></a>1. DOM (Document Object Model)</h3><ul><li><p>DOM : DOM Tree + DOM API</p><ul><li><p>브라우저의 렌더링 엔진이 웹 문서를 파싱해서 메모리에 저장한 결과물</p></li><li><p>즉, DOM이란 모든  element와 element의 attribute, text를 각각의 객체로 만들고 이 객체들을 부모-자식 관계를 나타낼 수 있는 트리 구조로 구성한 것</p></li><li>DOM은 자바스크립트를 통해 동적으로 변경할 수 있고 변경된 DOM은 브라우저 렌더링에 반영된다.</li><li>DOM API(Application Programming Interface) : 웹 문서의 동적 변경을 위해서 DOM에 접근할 수 있도록 제공하는 자바스크립트 객체의 프로퍼티와 메소드의 집합. DOM API를 통해서 DOM에 접근하고 변경해서 웹 페이지를 동적으로 변경할 수 있다.</li></ul><blockquote><h4 id="DOM-tree-HTML-문서에-대한-모델-구성"><a href="#DOM-tree-HTML-문서에-대한-모델-구성" class="headerlink" title="DOM tree | HTML 문서에 대한 모델 구성"></a>DOM tree | HTML 문서에 대한 모델 구성</h4><p>브라우저가 HTML 문서를 로드한 후 해당 문서에 대한 모델을 트리 구조로 메모리에 생성한 것</p><h4 id="DOM-API-ㅣ-HTML-문서-내의-각-요소에-접근-수정"><a href="#DOM-API-ㅣ-HTML-문서-내의-각-요소에-접근-수정" class="headerlink" title="DOM API ㅣ HTML 문서 내의 각 요소에 접근, 수정"></a>DOM API ㅣ HTML 문서 내의 각 요소에 접근, 수정</h4><p>모델 내의 각 객체에 접근하고 수정할 수 있도록 DOM이 제공하는 프로퍼티와 메소드. DOM이 수정되면 브라우저를 통해 웹페이지의 내용이 변경된다.</p></blockquote></li><li><p>jQuery</p><ul><li>DOM 객체를 보다 직관적으로 조작</li><li>SPA에는 안 맞음</li></ul></li><li><p>SPA(Single Page Application) </p><ul><li>SPA Framework : Angular, React</li><li>html 문서를 하나를 계속 씀</li><li>JavaScript로 html 다시 그림</li></ul></li></ul><h3 id="2-DOM-tree"><a href="#2-DOM-tree" class="headerlink" title="2. DOM tree"></a>2. DOM tree</h3><p>HTML 문서 내부에서 element의 중첩 관계는 트리에서 부모-자식 관계로 표현된다.</p><p>HTML Element 별로 다른 속성을 표현하기 위해서 브라우저에서는 DOM Parsing시 Element의 정보를 DOM 객체의 상속관계로 표현한다.</p><p><img src="https://user-images.githubusercontent.com/48080762/58159094-c30fde80-7cb6-11e9-998d-85c3a3c791b9.png" alt="Proprties"></p><p>DOM Element(node)는 HTML Element의 상태를 보관한다.</p><p>DOM tree는 4 종류의 노드로 구성된다.</p><h4 id="Document-Node"><a href="#Document-Node" class="headerlink" title="Document Node"></a>Document Node</h4><p>트리의 최상위 루트(root). 각 Element, Attribute, Text node에 접근하기 위해서는 트리의 루트인 Document Node를 시작으로 검색해야 한다.</p><h4 id="Element-Node"><a href="#Element-Node" class="headerlink" title="Element Node"></a>Element Node</h4><p>Element node는 HTML element를 표현한다. HTML element는 nesting(중첩)에 의해서 부모-자식 관계를 가지며 이를 통해서 정보를 구조화한다. 따라서 Element Node는 문서의 구조를 표현한다. Attribute, Text node에 접근하기 위해서는 우선 Element node에 접근해야 한다. </p><p>각 Element의 특성을 표현하기 위해서 객체의 상속을 이용한다. 이 때 모든 Element node는 HTMLElement 객체를 상속한다.</p><h4 id="Attribute-Node"><a href="#Attribute-Node" class="headerlink" title="Attribute Node"></a>Attribute Node</h4><p>Attribute Node는 HTML element의 attribute를 표현. Attribute Node는 자신을 가지는 <strong>Element의 자식이 아니라 형제(sibling)</strong>로 표현된다.</p><h4 id="Text-Node"><a href="#Text-Node" class="headerlink" title="Text Node"></a>Text Node</h4><p>Text Node는 HTML element의 텍스트를 표현한다. <strong>Text Node는 Element node의 자식</strong>이며 자신의 자식을 가질 수 없다. 즉 DOM tree의 단말 노드이다.</p><h3 id="3-DOM-Query"><a href="#3-DOM-Query" class="headerlink" title="3. DOM Query"></a>3. DOM Query</h3><p>DOM을 통해 웹페이지를 조작하기 위해서는 우선 DOM 객체(element)에 접근할 수 있어야 한다.</p><p>DOM API를 이용해서 DOM Element에 접근할 수 있다.  document 객체에 DOM API가 정의되어있다.</p><blockquote><h4 id="HTML-element에-id-사용을-자제해야하는-이유"><a href="#HTML-element에-id-사용을-자제해야하는-이유" class="headerlink" title="HTML element에 id 사용을 자제해야하는 이유"></a>HTML element에 id 사용을 자제해야하는 이유</h4><ol><li>중복되면 안되지만 중복되어도 에러가 나지 않는다.</li><li>HTML element의 id는 전역변수이다.</li></ol><p>되도록 class를 사용하는 것이 좋다.</p></blockquote><h4 id="document-getElementById-id"><a href="#document-getElementById-id" class="headerlink" title="document.getElementById(id)"></a>document.getElementById(id)</h4><ul><li><p><code>id</code> attribute 값으로  Element Node 하나를 선택한다. id가 중복될 경우 첫번째 element만 리턴한다.</p></li><li><p>Return: HTMLElement를 상속받은 객체</p></li><li><p>모든 브라우저에서 동작한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .red  &#123; <span class="hljs-attr">color</span>: red; &#125;</span><br><span class="line">      .blue &#123; <span class="hljs-attr">color</span>: blue; &#125;</span><br><span class="line">      .yellow &#123; <span class="hljs-attr">color</span>: yellow; &#125;</span><br><span class="line">    &lt;<span class="hljs-regexp">/style&gt;</span></span><br><span class="line"><span class="hljs-regexp">  &lt;/</span>head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Cities&lt;<span class="hljs-regexp">/h1&gt;</span></span><br><span class="line"><span class="hljs-regexp">      &lt;ul&gt;</span></span><br><span class="line"><span class="hljs-regexp">        &lt;li id="one" class="red"&gt;Seoul&lt;/</span>li&gt;</span><br><span class="line">        &lt;li id=<span class="hljs-string">"two"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"blue"</span>&gt;London&lt;<span class="hljs-regexp">/li&gt;</span></span><br><span class="line"><span class="hljs-regexp">        &lt;li id="three" class="red"&gt;Newyork&lt;/</span>li&gt;</span><br><span class="line">        &lt;li id=<span class="hljs-string">"four"</span>&gt;Tokyo&lt;<span class="hljs-regexp">/li&gt;</span></span><br><span class="line"><span class="hljs-regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">    &lt;script type="text/</span>javascript<span class="hljs-string">"&gt;</span></span><br><span class="line"><span class="hljs-string">      const elem = document.getElementById('one');</span></span><br><span class="line"><span class="hljs-string">      elem.className = 'yellow';</span></span><br><span class="line"><span class="hljs-string">      </span></span><br><span class="line"><span class="hljs-string">console.log(elem); // &lt;li id="</span>one<span class="hljs-string">" class="</span>blue<span class="hljs-string">"&gt;Seoul&lt;/li&gt;</span></span><br><span class="line"><span class="hljs-string">console.log(elem.__proto__);           // HTMLLIElement</span></span><br><span class="line"><span class="hljs-string">console.log(elem.__proto__.__proto__); // HTMLElement</span></span><br><span class="line"><span class="hljs-string">console.log(elem.__proto__.__proto__.__proto__);           // Element</span></span><br><span class="line"><span class="hljs-string">console.log(elem.__proto__.__proto__.__proto__.__proto__); // Node</span></span><br><span class="line"><span class="hljs-string">    &lt;/script&gt;</span></span><br><span class="line"><span class="hljs-string">  &lt;/body&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>  <img src="https://user-images.githubusercontent.com/48080762/58170933-c19ee000-7ccf-11e9-8b2b-f1f05fbd35c3.png" alt="Proto Chain"></p><h4 id="document-querySelector-cssSelector"><a href="#document-querySelector-cssSelector" class="headerlink" title="document.querySelector(cssSelector)"></a>document.querySelector(cssSelector)</h4><ul><li><strong>CSS Selector를 사용</strong>해서 Element Node를 한 개 선택한다. 여러 개가 선택되면 첫번째 element만 리턴한다.</li><li>Return: HTMLElement를 상속받은 객체</li><li>IE8 이상 브라우저에서 동작 <a href="https://caniuse.com/#search=document.querySelector" target="_blank" rel="noopener">Can I use document.querySelector ?</a></li><li>getElement계열보다 querySelector를 쓰자.</li><li>조건에 부합하는 대상이 없을 경우 null 리턴</li></ul><h4 id="document-getElementByClassName-class"><a href="#document-getElementByClassName-class" class="headerlink" title="document.getElementByClassName(class)"></a>document.getElementByClassName(class)</h4><ul><li><p><code>class</code> attribute 값으로  Element Node를 모두 선택. id가 중복될 경우 첫번째 element만 리턴</p></li><li><p>Return: (live)HTMLCollection</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Cities&lt;<span class="hljs-regexp">/h1&gt;</span></span><br><span class="line"><span class="hljs-regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="hljs-regexp">      &lt;li id="one" class="red"&gt;Seoul&lt;/</span>li&gt;</span><br><span class="line">      &lt;li id=<span class="hljs-string">"two"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"red"</span>&gt;London&lt;<span class="hljs-regexp">/li&gt;</span></span><br><span class="line"><span class="hljs-regexp">      &lt;li id="three" class="red"&gt;Newyork&lt;/</span>li&gt;</span><br><span class="line">      &lt;li id=<span class="hljs-string">"four"</span>&gt;Tokyo&lt;<span class="hljs-regexp">/li&gt;</span></span><br><span class="line"><span class="hljs-regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">  &lt;script type="text/</span>javascript<span class="hljs-string">"&gt;</span></span><br><span class="line"><span class="hljs-string">   const elems = document.getElementsByClassName('red');</span></span><br><span class="line"><span class="hljs-string">   console.log(elems);</span></span><br><span class="line"><span class="hljs-string">   for (let i = 0; i &lt; elems.length; i++) &#123;</span></span><br><span class="line"><span class="hljs-string">     elems[i].className = 'yellow';</span></span><br><span class="line"><span class="hljs-string">   &#125;</span></span><br><span class="line"><span class="hljs-string">  &lt;/script&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure><p>HTMLCollection이란, 배열이 아닌 유사배열 객체(array-like object)이다. HTMLCollection은 실시간으로 Node의 상태가 변경될 때마다 Collection에 반영하기 때문에 liveHTMLCollection이라고도 한다.</p><p><img src="https://user-images.githubusercontent.com/48080762/58171787-ba78d180-7cd1-11e9-8a92-e9a745831533.png" alt="Result Page"></p><p>위 코드의 실행 결과로 두번째와 네번째 Element의 색이 바뀌지 않은 것은  elems가 참조하는 HTMLCollection이 실시간으로 변경되어 누락되었기 때문이다.</p><ol><li>for 문을 역방향으로 돌리기</li><li>while 문 사용</li><li>HTMLCollection을 배열로 변경</li><li><code>querySelectorAll</code> 메소드를 사용해서 non-live NodeList를 리턴하게 함</li></ol><p>등으로 이런 현상을 방지할 수 있다.</p></li><li><p>IE9 이상의 브라우저에서 동작</p></li></ul><h4 id="document-getElementsByTagName-tagName"><a href="#document-getElementsByTagName-tagName" class="headerlink" title="document.getElementsByTagName(tagName)"></a>document.getElementsByTagName(tagName)</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script type=<span class="hljs-string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="hljs-keyword">const</span> elems = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'li'</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(elems); <span class="hljs-comment">// HTMLCollection(4) [li#one.red, li#two.red, li#three.red, li#four, one: li#one.red, two: li#two.red, three: li#three.red, four: li#four]</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; elems.length; i++) &#123;</span><br><span class="line">        elems[i].className = <span class="hljs-string">'blue'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="hljs-regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><code>getElementsByTagName</code> 메소드도 HTMLCollection을 리턴한다고 명세에 써있으나 Webkit에서는 NodeList를 리턴한다. 크롬에서는 NodeList를 리턴한다.</p><p><img src="https://user-images.githubusercontent.com/48080762/58172154-b5685200-7cd2-11e9-9bc1-802293274981.png" alt="Result Page"></p><h3 id="document-querySelectorAll-selector"><a href="#document-querySelectorAll-selector" class="headerlink" title="document.querySelectorAll(selector)"></a>document.querySelectorAll(selector)</h3><ul><li><strong>CSS Selector를 사용</strong>하여 Element Node를 모두 선택.</li><li>Return: <a href="https://developer.mozilla.org/ko/docs/Web/API/NodeList" target="_blank" rel="noopener">NodeList</a> (non-live)</li><li>IE8 이상 브라우저에서 동작</li><li>여러개 선택할 때는 getElements 대신 querySelectorAll을 쓰자.</li><li>조건에 부합하는 대상이 없을 경우 빈 NodeList [] 리턴</li></ul><h4 id="element-className"><a href="#element-className" class="headerlink" title="element.className"></a>element.className</h4><p><code>class=&quot;red blue&quot;</code>에서 ‘red blue’를 의미. class를 한 번에 전부 수정하는 데에 좋다. 하나를 추가하고 싶을 때는 아래와 같이 쓴다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> elem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#one'</span>);</span><br><span class="line">elem.className += <span class="hljs-string">'yellow'</span>;</span><br></pre></td></tr></table></figure><p>추가나 삭제에는 classList의 method를 사용하는 것이 편리하다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> elem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#one'</span>);</span><br><span class="line">elem.classList.add(<span class="hljs-string">'blue'</span>);</span><br><span class="line">elem.classList.remove(<span class="hljs-string">'blue'</span>);</span><br></pre></td></tr></table></figure><h3 id="DOM-Traversal"><a href="#DOM-Traversal" class="headerlink" title="DOM Traversal"></a>DOM Traversal</h3><h3 id="parentNode"><a href="#parentNode" class="headerlink" title="parentNode"></a>parentNode</h3><p>자신의 parent 노드를 탐색. HTMLElement를 상속받은 객체를 리턴하며 모든 브라우저에서 동작한다.</p><h4 id="firstChild-lastChild"><a href="#firstChild-lastChild" class="headerlink" title="firstChild, lastChild"></a>firstChild, lastChild</h4><p>자신의 첫번째 child, 마지막 child 노드를 탐색. HTMLELement를 상속받은 객체를 리턴하며 IE9 이상의 브라우저에서 동작한다.</p><p>IE를 제외한 대부분의 브라우저에서는 element 사이의 공백과 줄바꿈을 Text Node로 취급하기 때문에 주의해야 한다.</p><h4 id="hasChildNodes"><a href="#hasChildNodes" class="headerlink" title="hasChildNodes()"></a>hasChildNodes()</h4><p>child 노트가 있는지 확인하고 Boolean을 리턴. 모든 브라우저에서 동작</p><h4 id="childNodes"><a href="#childNodes" class="headerlink" title="childNodes"></a>childNodes</h4><p>child 노드의 Collection을 리턴. NodeList(non-live)가 리턴됨. 모든 브라우저에서 동작</p><h4 id="children"><a href="#children" class="headerlink" title="children"></a>children</h4><p>child 노드의 Collection을 리턴. <strong>HTMLCollection(live)가 리턴</strong>됨. IE9 이상 브라우저에서 동작.  childNodes 대신 children을 쓰자</p><h4 id="previousSibling-nextSibling"><a href="#previousSibling-nextSibling" class="headerlink" title="previousSibling, nextSibling"></a>previousSibling, nextSibling</h4><p>Text Node를 포함한 모든 형제 노드를 탐색. HTMLElement를 상속받은 객체가 리턴됨. 모든 브라우저에서 동작</p><h4 id="previosElementSibling-nextElementSibling"><a href="#previosElementSibling-nextElementSibling" class="headerlink" title="previosElementSibling, nextElementSibling,"></a>previosElementSibling, nextElementSibling,</h4><p>Element type의 형제 노드만을 탐색. HTMLElement를 상속받은 객체가 리턴됨. IE9 이상 브라우저에서 동작</p><h2 id="4-DOM-Manipulation"><a href="#4-DOM-Manipulation" class="headerlink" title="4. DOM Manipulation"></a>4. DOM Manipulation</h2><h3 id="1-Text-Node-Access-and-Manipulation"><a href="#1-Text-Node-Access-and-Manipulation" class="headerlink" title="1. Text Node Access and Manipulation"></a>1. Text Node Access and Manipulation</h3><ol><li>Text Node의 parent인  Element Node를 선택한다.</li><li>firstChild 프로퍼티로 Text Node를 탐색한다.</li><li>Text Node의 프로퍼티 <code>nodeValue</code>를 이용해서 텍스트에 접근하고 수정한다.</li></ol><blockquote><h4 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue"></a>nodeValue</h4><ul><li>노드의 값을 반환</li><li>Return: 텍스트 노드의 경우는 문자열, 요소 노드의 경우 null 반환</li><li>IE6 이상의 브라우저에서 동작</li></ul></blockquote><h3 id="2-Attribute-Node-Access-and-Manipulation"><a href="#2-Attribute-Node-Access-and-Manipulation" class="headerlink" title="2. Attribute Node Access and Manipulation"></a>2. Attribute Node Access and Manipulation</h3><p>Attribute Node 조작을 위해서 다음 프로퍼티 또는 메소드를 사용할 수 있다.</p><h4 id="className"><a href="#className" class="headerlink" title="className"></a>className</h4><ul><li>class attribute 값에 접근하고 할당할 수 있다. class attribute가 없는데 className을 할당하면 class atrribute를 생성하고 설정한다. className이 여러개일 경우 <code>&#39; &#39;</code>(공백)으로 구분된  string이 반환되므로 String.split(‘ ‘)를 사용해서 변경한다.</li><li>모든 브라우저에서 동작</li></ul><h4 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h4><ul><li>add, remove, item, toggle, contains, replace method 제공</li><li>어떤 element의 class attribute를 추가, 삭제, 검사할 때 유용하다.</li><li>IE10 이상 브라우저에서 동작한다.</li></ul><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><ul><li>id attribute의 값에 접근하고 변경할 수 있다. className과 마찬가지로 없는데 할당시 생성하고 설정한다.</li><li>모든 브라우저에서 동작</li></ul><h4 id="hasAttribute-attribute"><a href="#hasAttribute-attribute" class="headerlink" title="hasAttribute(attribute)"></a>hasAttribute(attribute)</h4><ul><li>지정한 어트리뷰트를 가지고 있는지 검사.</li><li>Return : Boolean</li><li>IE8 이상의 브라우저에서 동작.</li></ul><h4 id="getAttribute-attribute"><a href="#getAttribute-attribute" class="headerlink" title="getAttribute(attribute)"></a>getAttribute(attribute)</h4><ul><li>어트리뷰트의 값을 취득.</li><li>Return : 문자열</li><li>모든 브라우저에서 동작.</li></ul><h4 id="setAttribute-attribute-value"><a href="#setAttribute-attribute-value" class="headerlink" title="setAttribute(attribute, value)"></a>setAttribute(attribute, value)</h4><ul><li>어트리뷰트와 어트리뷰트 값을 설정.</li><li>Return : undefined</li><li>모든 브라우저에서 동작.</li></ul><h4 id="removeAttribute-attribute"><a href="#removeAttribute-attribute" class="headerlink" title="removeAttribute(attribute)"></a>removeAttribute(attribute)</h4><ul><li>지정한 어트리뷰트를 제거.</li><li>Return : undefined</li><li>모든 브라우저에서 동작.</li></ul><blockquote><h3 id="Difference-between-Attribute-and-Property"><a href="#Difference-between-Attribute-and-Property" class="headerlink" title="Difference between Attribute and Property"></a>Difference between Attribute and Property</h3><p>checkbox input element의 상태를 변경하는 방법 2가지 attribute이용, property 이용</p><ol><li><p><strong>Attribute 이용</strong></p><p>element.setAttribute(‘chekced’, true);</p><p>setting 전에는 <strong>변하지 않는 것</strong>. <strong>element의 초기값</strong></p></li><li><p><strong>Property 이용</strong></p><p>element.checked = true;</p><p><strong>실시간으로 값이 변함</strong>. <strong>element의 현재값(최신 상태)</strong></p></li></ol></blockquote><h3 id="4-3-HTML-Contents-Manipulation"><a href="#4-3-HTML-Contents-Manipulation" class="headerlink" title="4.3.  HTML Contents Manipulation"></a>4.3.  HTML Contents Manipulation</h3><p>HTML contents를 조작하기 위해 아래와 같은 프로퍼티와 메소드를 사용할 수 있으나 Markup이 포함된 content를 추가하는 것은 XSS(Cross-Site Scripting Attacks)에 취약하므로 조심해야 한다.</p><h4 id="textContent"><a href="#textContent" class="headerlink" title="textContent"></a>textContent</h4><ul><li>Element의 text content에 접근하고 변경할 수 있다. 이 때 입력 문자열에 Markup이 포함되더라도 그냥 텍스트로 출력된다.</li><li>IE9 이상 브라우저에서 동작</li></ul><h4 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h4><ul><li>textContent와 같이 element의 text content에만 접근할 수 있지만 비표준이며 CSS를 고려한다.</li><li>사용하지 않는 것이 좋음</li></ul><h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><ul><li>해당 element 내부의 모든 html contents를 하나의 string으로 취득하고 변경할 수 있다.</li><li>Markup을 포함한다.</li><li>그러나 Markup이 포함된 contents를 추가하는 것은 Cross-Site Scripting Attack에 취약하다.</li></ul><h3 id="4-4-DOM-Manipulation-Method"><a href="#4-4-DOM-Manipulation-Method" class="headerlink" title="4.4 DOM Manipulation Method"></a>4.4 DOM Manipulation Method</h3><p>보안상 취약한 innerHTML 프로퍼티를 사용하지 않고 새로운 content를 추가할 수 있는 방법은 DOM을 직접 조작하는 것이다. 주로 하나의 element를 추가하는 경우 사용한다.</p><ol><li>createElement() method로 새로운 Element Node를 생성. Argument로 tag이름 전달.</li><li>createTextNode() method로 새로운 Text Node를 생성. 1에서 만든 Element Node에 TextNode를 추가하지 않으면 content가 비어있는 element가 된다.</li><li>appendChild() method로 생성된 element를 DOM에 추가한다. removeChild() method로는 DOM tree에서  node를 삭제할 수 있다.</li></ol><h4 id="createElement-tagName"><a href="#createElement-tagName" class="headerlink" title="createElement(tagName)"></a>createElement(tagName)</h4><ul><li>노드의 값을 리턴</li><li>Return: 텍스트 노드의 경우는 문자열, 요소 노드의 경우 null 리턴</li><li>IE6 이상의 브라우저에서 동작</li></ul><h4 id="createTextNode-text"><a href="#createTextNode-text" class="headerlink" title="createTextNode(text)"></a>createTextNode(text)</h4><ul><li>텍스트를 인자로 전달하여 텍스트 노드를 생성</li><li>Return: Text 객체</li><li>모든 브라우저에서 동작</li></ul><h4 id="appendChild-Node"><a href="#appendChild-Node" class="headerlink" title="appendChild(Node)"></a>appendChild(Node)</h4><ul><li>argument로 전달한 노드를 마지막 자식 요소로 DOM 트리에 추가</li><li>Return: 추가한 노드</li><li>모든 브라우저에서 동작</li></ul><h4 id="removeChild-Node"><a href="#removeChild-Node" class="headerlink" title="removeChild(Node)"></a>removeChild(Node)</h4><ul><li>argument로 전달한 노드를 DOM 트리에 제거</li><li>Return: 추가한 노드</li><li>모든 브라우저에서 동작</li></ul><h3 id="4-5-insertAdjacentHTML"><a href="#4-5-insertAdjacentHTML" class="headerlink" title="4.5 insertAdjacentHTML()"></a>4.5 insertAdjacentHTML()</h3><h4 id="insertAdjacentHTML-position-string"><a href="#insertAdjacentHTML-position-string" class="headerlink" title="insertAdjacentHTML(position, string)"></a>insertAdjacentHTML(position, string)</h4><ul><li>인자로 전달한 텍스트를 HTML로 파싱하고 그 결과로 생성된 노드를 DOM 트리의 지정된 위치에 삽입한다.</li><li>position : insert position<ul><li>‘beforebegin’</li><li>‘afterbegin’</li><li>‘beforeend’</li><li>‘afterend’</li></ul></li><li>string: 삽입할 element string</li></ul><ul><li>모든 브라우저에서 동작</li></ul><h4 id="4-6-innerHTML-vs-DOM-manipulation-vs-insertAdjacentHTML"><a href="#4-6-innerHTML-vs-DOM-manipulation-vs-insertAdjacentHTML" class="headerlink" title="4.6. innerHTML vs. DOM manipulation vs. insertAdjacentHTML()"></a>4.6. innerHTML vs. DOM manipulation vs. insertAdjacentHTML()</h4><table><thead><tr><th>장단점</th><th>innerHTML</th><th>DOM manipulation</th><th>insertAdjacentHTML()</th></tr></thead><tbody><tr><td>장점</td><td>DOM 조작 방식에 비해 빠르고 간편<br>간편하게 문자열로 정의한 여러 요소를 DOM에 추가할 수 있음<br>콘텐츠를 취득할 수 있음</td><td>특정 노드 한 개(노드, 텍스트, 데이터 등)를 DOM에 추가할 때 적합</td><td>간편하게 문자열로 정의된 여러 요소를 DOM에 추가할 수 있음<br>요소가 삽입되는 위치를 선정할 수 있음</td></tr><tr><td>단점</td><td>XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 사용자 이름 등)를 추가할 때 주의해야 함<br>해당 요소의 내용을 덮어 쓴다. 즉, HTML을 다시 파싱한다. 비효율적</td><td>innerHTML보다 느리고 더 많은 코드가 필요</td><td>XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은 콘텐츠(untrusted data: 댓글, 사용자 이름 등)를 추가할 때 주의해야 함</td></tr></tbody></table><p>결론적으로 Text를 추가하거나 변경할 때는 textContent, 새로운 element를 추가하거나 삭제할 때는 DOM manipulation 방식(createElement() 등)을 사용한다.</p><h2 id="5-style-Property"><a href="#5-style-Property" class="headerlink" title="5. style Property"></a>5. style Property</h2><p>style 프로퍼티를 사용하면 inline style 선언을 생성한다. 특정 element에 inline style을 지정할 때 사용한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> $four = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'four'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// inline 스타일 선언을 생성</span></span><br><span class="line">$four.style.color = <span class="hljs-string">'blue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// font-size와 같이 '-'으로 구분되는 프로퍼티는 카멜케이스로 변환해 사용한다.</span></span><br><span class="line">$four.style.fontSize = <span class="hljs-string">'2em'</span>;</span><br></pre></td></tr></table></figure><h3 id="6-DOM-load-“DOMContentLoaded”-event"><a href="#6-DOM-load-“DOMContentLoaded”-event" class="headerlink" title="6. DOM load, “DOMContentLoaded” event"></a>6. DOM load, “DOMContentLoaded” event</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTodos</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// DOM parsing 되고 resource도 로드됐을 때 발생하는 event</span></span><br><span class="line"><span class="hljs-built_in">window</span>.onload = getTodos;</span><br><span class="line"><span class="hljs-comment">// getTodos에 argument 넘길 수 있음</span></span><br><span class="line"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    getTodos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>DOMContentLoaded는 리소스 상관 없이 DOM parsing만 완료되었을 때 발생하는 event</p><hr><p><a href="https://poiemaweb.com/js-dom" target="_blank" rel="noopener">Reference</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-DOM-Document-Object-Model&quot;&gt;&lt;a href=&quot;#1-DOM-Document-Object-Model&quot; class=&quot;headerlink&quot; title=&quot;1. DOM (Document Object Model)&quot;&gt;&lt;/a&gt;1.
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://sub2n.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>28. Module</title>
    <link href="https://sub2n.github.io/2019/05/22/28-Module/"/>
    <id>https://sub2n.github.io/2019/05/22/28-Module/</id>
    <published>2019-05-22T07:16:28.000Z</published>
    <updated>2019-05-22T07:44:31.664Z</updated>
    
    <content type="html"><![CDATA[<p>원래 모듈화를 하거나 파일을 분리하면 각 모듈, 파일 별로 개별적인 스코프를 가져야하는데 자바스크립트는 파일을 분리해서 함께 사용할 때 하나의 전역 스코프만을 가진다. 즉, 여러 개의 js 파일에서 식별자 명이 겹칠 경우 의도한 바와 다르게 동작할 수 있다.</p><p>이전에는 각 파일을 IIFE(Imediately Invoked Function Expression)로 감쌌으나 근본적인 해결책은 아니다. 특정 클래스나 함수를 외부에 노출시키고 싶지 않을 때는 클로저를 사용해서 선택적으로 노출했다.</p><p>ES6에서 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능이 추가되었다. script tag에 <code>type=&quot;module&quot;</code> 어트리뷰트 추가시 해당 자바스크립트 파일은 모듈로 동작하며 파일 스코프를 가진다. 모듈화된 자바스크립트 파일을 사용할 때는 확장자 명을 <code>.mjs</code>라고 한다.</p><p>그러나 아직까지 문법이 엄격하고 구형 브라우저(IE 등)에서는 ES6 모듈을 지원하지 않는 문제가 있다. 그러니까 아직은 바벨 / 웹팩 등을 사용해서 개발해야한다.</p><blockquote><p>바벨: ES6 이상의 문법을 사용해서 코딩하더라도 ES5의 문법으로 다운그레이드해서 구형 브라우저에서 돌아갈 수 있게 함</p><p>웹팩: 여러 파일을 import하면 하나의 파일로 압축해줌</p></blockquote><h3 id="1-File-Scope"><a href="#1-File-Scope" class="headerlink" title="1. File Scope"></a>1. File Scope</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// lib.js</span></span><br><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// app.js</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>모듈을 사용하지 않을 경우 정상적으로 코드가 돌아가지만 <code>type=&quot;module&quot;</code> 사용시 각 파일마다 스코프가 분리되어 app.js에서 lib.js의 x에 접근할 수 없다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./lib.js"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./app.js"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-export-Keyword"><a href="#2-export-Keyword" class="headerlink" title="2. export Keyword"></a>2. export Keyword</h3><p>ES6의 모듈을 쓰면 각각 파일이 파일 스코프를 가지기 때문에 다른 파일에 공개할 변수나 함수, 클래스 앞에 <code>export</code> 키워드를 붙여서 선택적으로 노출할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// lib.js</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="3-import-Keyword"><a href="#3-import-Keyword" class="headerlink" title="3. import Keyword"></a>3. import Keyword</h3><p>다른 파일에서 <code>export</code> 키워드로 노출한 변수, 함수, 클래스 등을 <code>import</code> 키워드를 사용함으로써 사용할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// app.js</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; x &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib.js'</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>모듈에서 하나만 export할 때는 default 키워드를 사용할 수 있음</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// lib.js</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>;</span><br></pre></td></tr></table></figure><p>default 키워드로 export한 모듈은 import할 때 {} 없이 받아올 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// app.js</span></span><br><span class="line"><span class="hljs-keyword">import</span> y <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib.js'</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;원래 모듈화를 하거나 파일을 분리하면 각 모듈, 파일 별로 개별적인 스코프를 가져야하는데 자바스크립트는 파일을 분리해서 함께 사용할 때 하나의 전역 스코프만을 가진다. 즉, 여러 개의 js 파일에서 식별자 명이 겹칠 경우 의도한 바와 다르게 동작
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Modlue" scheme="https://sub2n.github.io/tags/Modlue/"/>
    
  </entry>
  
  <entry>
    <title>27. Class</title>
    <link href="https://sub2n.github.io/2019/05/21/27-Class/"/>
    <id>https://sub2n.github.io/2019/05/21/27-Class/</id>
    <published>2019-05-21T07:56:56.000Z</published>
    <updated>2019-05-23T04:20:14.332Z</updated>
    
    <content type="html"><![CDATA[<p>자바스크립트는 Prototype-based 객체지향 언어이다. Prototype-based 프로그래밍은 클래스 없이 프로토타입과 클로저 등으로 상속, 캡슐화 등의 개념을 구현할 수 있다.</p><p>대부분의 객체 지향 언어가 클래스 기반인 점을 고려하여 ES6에서 클래스를 도입했다. 그러나 그 <strong>클래스도 사실은 함수</strong>이고 기존의 프로토타입 기반 객체지향 패턴으로 동작한다.</p><h3 id="1-Calss-Definition"><a href="#1-Calss-Definition" class="headerlink" title="1. Calss Definition"></a>1. Calss Definition</h3><p>ES6 클래스는 다른 언어들과 같이 class 키워드를 사용해 정의한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// constructor</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// default method definition: class's prototype method</span></span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi! <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>._name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> mimi = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">'Mimi'</span>);</span><br><span class="line">mimi.sayHello(); <span class="hljs-comment">// Hi! Mimi</span></span><br></pre></td></tr></table></figure><p>표현식으로도 클래스를 정의할 수 있으나 일반적이지 않다. 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근할 수 없기 때문이다. 클래스가 함수처럼 동작하는 것은 사실 클래스도 함수이기 때문이다.</p><h3 id="2-Creation-of-Instance"><a href="#2-Creation-of-Instance" class="headerlink" title="2. Creation of Instance"></a>2. Creation of Instance</h3><p>Class의 instance를 생성하기 위해서는 new 연산자와 함께 constuctor를 호출한다. 클래스 선언식으로 정의한 클래스의 이름은 constructor와 동일하다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Foo === Foo.prototype.constructor); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Foo === <span class="hljs-built_in">Object</span>.getPrototypeOf(foo).constructor); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> foo2 = Foo(); <span class="hljs-comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure><p>new 연산자를 사용하지 않고 constructor를 호출하면 TypeError가 발생한다. 즉, <strong>클래스의 constructor는 new 연산자 없이 호출할 수 없다.</strong> new 연산자 없이 호출시 오류 없이 생성자 대신 일반 함수로 호출되던 생성자 함수와 다른 점이다.</p><h3 id="3-Constructor"><a href="#3-Constructor" class="headerlink" title="3. Constructor"></a>3. Constructor</h3><p>constructor는 인스턴스를 생성하고 클래스 필드를 초기화하는 특수한 메소드이다.</p><blockquote><h4 id="Class-Field"><a href="#Class-Field" class="headerlink" title="Class Field"></a>Class Field</h4><p>= Data Member, Member Variable. 클래스 내부의 캡슐화된 변수. Instance의 프로퍼티 또는 Static  프로퍼티를  Class field 라고 한다.</p></blockquote><ul><li>class 내에는 최대 한 개의 constructor만 존재할 수 있다.</li><li>new 연산자와 constructor로 인스턴스 생성시 constructor의 파라미터로 전달한 값으로 클래스의 필드를 초기화한다.</li><li>class 내부에 constructor 정의를 생략하면 default로 <code>constructor() {}</code> 가 동작한다. 즉, 빈 객체 { }를 생성한다.</li><li>constructor는 인스턴스의 생성과 동시에 클래스 필드의 생성과 초기화를 실행한다.</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(num) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Foo();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// Foo &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> bar = <span class="hljs-keyword">new</span> Bar(<span class="hljs-number">200</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar); <span class="hljs-comment">// Bar &#123;num: 200&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-Class-Field"><a href="#4-Class-Field" class="headerlink" title="4. Class  Field"></a>4. Class  Field</h3><p>클래스 내부에는 메소드만 선언할 수 있다. 모든 프로퍼티(인스턴스의  멤버 변수)는 <strong>반드시 constructor 내부에 선언</strong>해야 한다.</p><blockquote><h4 id="Class-Field-Declarations-Proposal"><a href="#Class-Field-Declarations-Proposal" class="headerlink" title="Class Field Declarations Proposal"></a>Class Field Declarations Proposal</h4><p>아직 표준은 아니지만 stage3 단계에 Class FIeld 선언 관련된 표준안이 있다.</p><ul><li>Field Declaration</li><li>Private Field</li><li>Static Public Fields</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;</span><br><span class="line">&gt;   x = <span class="hljs-number">1</span>; <span class="hljs-comment">// 생성자 함수 밖에서도 field 선언 가능</span></span><br><span class="line">&gt;   #p = 2; // private field</span><br><span class="line">&gt;   <span class="hljs-keyword">static</span> y = <span class="hljs-number">3</span>; <span class="hljs-comment">// Static puplic field</span></span><br><span class="line">&gt;   <span class="hljs-comment">// 현재 field declaration만 chrome에 구현됨</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// default 값 설정</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(name = '') &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi! <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>._name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor 내부의 this는 클래스가 생성할 인스턴스이다. constructor는 this, 즉 생성할 인스턴스에 선언한 프로퍼티를 바인딩한다. 이런 방식으로  constructor는 클래스가 생성할 인스턴스와 인스턴스의 프로퍼티를 생성하고 초기화한다. </p><p>클래스 프로퍼티는 언제나 <code>public</code>이다. 생성된 인스턴스를 통해서 클래스 외부에서도 클래스 내부의 프로퍼티에 접근할 수 있다.</p><p>ES6의 클래스는 다른 객체지향 언어처럼 private, public, protect 등의 Access Modifier(접근 제한자)를 지원하지 않는다.</p><h3 id="5-Hoisting"><a href="#5-Hoisting" class="headerlink" title="5. Hoisting"></a>5. Hoisting</h3><p>클래스는 ES6에서 추가 도입된 <code>let</code>, <code>const</code>와 같이 Hoisting 되지 않는 것처럼 동작한다. 선언 이전에 참조하면 ReferenceError가 발생한다.</p><blockquote><h4 id="Hoisting-되지-않는-것처럼-동작한다는-것"><a href="#Hoisting-되지-않는-것처럼-동작한다는-것" class="headerlink" title="Hoisting 되지 않는 것처럼 동작한다는 것"></a>Hoisting 되지 않는 것처럼 동작한다는 것</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-comment">// x 선언 없이 참조</span></span><br><span class="line">&gt; <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// ReferenceError: x is not defined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>코드 전역에서 x의 선언 없이 x를 참조하면 x is not defined, 즉 정의되지 않았다는 참조 에러가 뜬다.</p><p>그러나 let으로 선언하기 전에 x를 참조하면 다르게 동작한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-comment">// x를 참조하고 밑에서 let 키워드로 선언</span></span><br><span class="line">&gt; x; <span class="hljs-comment">// ReferenceError: Cannot access 'x' before initialization</span></span><br><span class="line">&gt; <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>위와 같이 x가 정의되지 않았다고 하지 않고, initialization 전에 x에 접근할 수 없다는 참조 에러가 뜬다. 왜일까?</p><p><code>var</code> 키워드와 다르게 <code>let</code>, <code>const</code> 키워드는 런타임 이전에 자바스크립트 엔진이 선언문을 미리 실행할 때, 1. 선언 단계(Declaration Phase)와 2. 초기화 단계(Initialization Phase)가 함께 진행되지 않는다. <code>let</code>, <code>const</code> 키워드로 선언한 변수는 1. 선언 단계만 미리 실행되어 스코프에 변수 명이 등록되지만 2. 초기화 단계는 런타임에 선언문이 실행될 때 실행된다. 2. 초기화 단계는 변수의 값을 위한 메모리 공간을 할당하고 undefined라는 값을 암묵적으로 넣어주는 것이다. 이런 초기화 단계를 진행하지 않았으니 참조 에러가 나는 것이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-comment">// 클래스 Gee를 선언하기 전에 참조</span></span><br><span class="line">&gt; <span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> Gee(); <span class="hljs-comment">// ReferenceError: Cannot access 'Gee' before initialization</span></span><br><span class="line">&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gee</span> </span>&#123;&#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>마찬가지로 class도 <code>let</code>이나 <code>const</code> 키워드로 선언한 변수처럼 동작한다. 호이스팅을 하지 <strong>않는 것처럼</strong> 동작한다고 하는 이유는, 런타임 이전에 1. 선언 단계가 진행되어 정말로 선언되지 않은 변수를 참조했을 때 발생하는 is not defined와는 다른 에러가 발생하기 때문이다.</p><p>ES6의  class도 사실은 함수이지만, function 키워드로 선언한 함수 선언식은 호이스팅 되는 반면 class로 선언한 함수는 호이스팅 되지 않는다. 즉, 선언만 해놓고 초기화를 하지 않아 호이스팅되지 않는 것처럼 동작한다.</p><p><code>let</code>이나 <code>const</code> 나 class 등의 선언문 이전을 TDZ(Temporal Dead Zone)이라고 한다. 선언만 되고 초기화되지 않아 참조할 수 없는 구간을 말한다.</p></blockquote><h3 id="6-getter-setter"><a href="#6-getter-setter" class="headerlink" title="6. getter, setter"></a>6. getter, setter</h3><p>객체 지향 언어에서 클래스를 사용하는 목적은 내부 상태(내부 데이터)에 접근하는 방법을 제한하고 최소한의 인터페이스를 제공해서 데이터의 캡슐화를 구현하기 위함이다. 접근자 프로퍼티 (getter, setter)를 사용하는 이유도 이와 같다. 클래스 내의 프로퍼티를 참조할 때는 get 함수, 프로퍼티를 설정할 때는 set 함수만을 이용할 수 있도록 구현해야 한다.</p><h4 id="6-1-getter"><a href="#6-1-getter" class="headerlink" title="6.1. getter"></a>6.1. getter</h4><p>getter는 클래스 프로퍼티에 접근할 때 사용한다. getter는 메소드 이름 앞에 <code>get</code> 키워드를 사용해서 정의한다. 이 때 메소드 이름은 클래스 프로퍼티 키처럼 사용된다. 즉, getter는 호출하는 것이 아니라 <strong>프로퍼티처럼 참조하는 것이고, 참조할 때 메소드가 호출</strong>된다. getter는 데이터를 얻기위해(get) 사용하므로 반드시 무언가를 리턴해야 한다.</p><h4 id="6-2-setter"><a href="#6-2-setter" class="headerlink" title="6.2. setter"></a>6.2. setter</h4><p>setter는 클래스 프로퍼티에 값을 할당할 때 사용한다. setter는 메소드 이름 앞에 <code>set</code> 키워드를 사용해서 정의한다. get 메소드와 마찬가지로 메소드 이름은 클래스 <strong>프로퍼티 키로 사용되어 참조되는 형식으로 메소드를 호출</strong>한다. setter는 데이터를 할당하기 위해서 호출하는 것이므로 메소드를 사용해서 할당할 때 set 메소드가 호출된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// default 값 설정</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(firstname = '', lastname = '') &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.firstname = firstname;</span><br><span class="line">        <span class="hljs-keyword">this</span>.lastname = lastname;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">get</span> fullName() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.firstname&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.lastname&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">set</span> fullName(fullname) &#123;</span><br><span class="line">        [<span class="hljs-keyword">this</span>.firstname, <span class="hljs-keyword">this</span>.lastname] = fullname.split(<span class="hljs-string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> mimi = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">'Mimi'</span>, <span class="hljs-string">'Kim'</span>); </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 메소드를 직접 호출하는 것이 아니라 프로퍼티에 접근하는 방식으로 getter, setter를 내부적으로 호출한다.</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(mimi.fullName); <span class="hljs-comment">// Mimi Kim (getter)</span></span><br><span class="line"></span><br><span class="line">mimi.fullName = <span class="hljs-string">'Mimi Park'</span>;<span class="hljs-comment">// setter</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(mimi.fullName); <span class="hljs-comment">// Mimi Park (getter)</span></span><br></pre></td></tr></table></figure><h3 id="7-Static-Method"><a href="#7-Static-Method" class="headerlink" title="7. Static Method"></a>7. Static Method</h3><p>Class는 static 메소드를 정의할 때 <code>static</code> 키워드를 사용한다. 정적 메소드는 인스턴스가 아니라 클래스 이름으로 호출하는 메소드이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(prop) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.prop = prop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">static</span> staticMethod() &#123;</span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">    정적 메소드는 this를 사용할 수 없다.</span></span><br><span class="line"><span class="hljs-comment">    정적 메소드 내부에서 this는 클래스의 인스턴스가 아닌 클래스 자신을 가리킨다.</span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'staticMethod'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  prototypeMethod() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Foo.staticMethod()); <span class="hljs-comment">// staticMethod</span></span><br></pre></td></tr></table></figure><p>정적 메소드는 클래스의 인스턴스 생성 없이 클래스 이름으로 호출하며 클래스의 인스턴스로는 호출할 수 없다.</p><h3 id="8-Class-Inheritance"><a href="#8-Class-Inheritance" class="headerlink" title="8. Class Inheritance"></a>8. Class Inheritance</h3><h4 id="8-1-extends-Keyword"><a href="#8-1-extends-Keyword" class="headerlink" title="8.1. extends Keyword"></a>8.1. <code>extends</code> Keyword</h4><p><code>extends</code> 키워드는 parent 클래스를 생속받는 child 클래스를 정의할 때 사용한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// parent class</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(radius) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getDiameter() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">this</span>.radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI * (<span class="hljs-keyword">this</span>.radius ** <span class="hljs-number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// child class</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cylinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(radius, height) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(radius);</span><br><span class="line">    <span class="hljs-keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// parent class Circle의 getArea overriding</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">super</span>.getPerimeter()) + (<span class="hljs-number">2</span> * <span class="hljs-keyword">super</span>.getArea());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 자신의 메소드 정의</span></span><br><span class="line">  getVolume() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getArea() * <span class="hljs-keyword">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Cylinder class는 Circle class를 상속한다.</span></span><br><span class="line">Cylinder.__proto__ === Circle <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-comment">// Cylinder의 prototype은 Circle의 prototype을 상속한다.</span></span><br><span class="line">Cylinder.prototype.__proto__ === Circle.prototype</span><br></pre></td></tr></table></figure><h4 id="8-2-super-Keyword"><a href="#8-2-super-Keyword" class="headerlink" title="8.2. super Keyword"></a>8.2. <code>super</code> Keyword</h4><p><code>super</code> 키워드는 <strong>parent 클래스를 참조</strong>하거나  <strong>parent 클래스의 constructor를 호출</strong>할 때 사용한다.</p><ol><li><p>super 클래스가 메소드로 사용될 때는 parent 클래스의 constructor를 호출한다. <strong>child 클래스의 constructor에서 super()를 호출하지 않으면 this에 대한 ReferenceError가 발생한다.</strong></p><p>child 클래스의 인스턴스를 만들 때 parent 클래스의 인스턴스를 우선 만들고 상속한다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// parent 클래스의 constructor를 호출한다.</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cylinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(radius, height) &#123;</span><br><span class="line">    <span class="hljs-comment">// super가 parent class의 constructor처럼 사용됨</span></span><br><span class="line">    <span class="hljs-keyword">super</span>(radius);</span><br><span class="line">    <span class="hljs-keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/48080762/58225537-6c111480-7d5d-11e9-9cbb-45fc8d66a2ff.png" alt="super"></p><p>ECMAScript의 스펙을 살펴보면 super가 argument를 전달받으며 호출될 때는 내부적으로 자신의 parent 클래스의 constructor를 호출하여 constructor가 리턴한 this 객체를 child 클래스 constructor의 this(child 클래스가 생성할 인스턴스)에 바인딩한다.</p></li><li><p>super 클래스가 객체로 사용될 때는 parent 클래스를 참조한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// super가 parent class Circle처럼 사용됨</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// parent class Circle의 getArea overriding</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">super</span>.getPerimeter()) + (<span class="hljs-number">2</span> * <span class="hljs-keyword">super</span>.getArea());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 자신의 메소드 정의</span></span><br><span class="line">  getVolume() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getArea() * <span class="hljs-keyword">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-3-Inheritance-of-Static-Method-and-Prototype-Method"><a href="#8-3-Inheritance-of-Static-Method-and-Prototype-Method" class="headerlink" title="8.3. Inheritance of Static Method and Prototype Method"></a>8.3. Inheritance of Static Method and Prototype Method</h4><p>Child 클래스의 static 메소드 내부에서 super 키워드를 사용하면 parent 클래스의 static 메소드를 호출할 수 있다. child 클래스는 프로토타입 체인에서 parent 클래스의 정적 메소드를 참조할 수 있기 때문이다.</p><p>그러나 child 클래스의 일반 메소드(prototype  메소드) 내부에서는 super 키워드를 사용해서 parent 클래스의 static 메소드를 호출할 수 없다. 이는 child 클래스의 <strong>인스턴스</strong>는 프로토타입 체인에 의해 parent 클래스의 static 메소드를 참조할 수 없기 때문이다. child 클래스의 인스턴스는 프로토타입 체인 상에 parent 클래스가 아니라 parent 클래스의 prototype만 가지고 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(prop) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.prop = prop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">static</span> staticMethod() &#123;</span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">    정적 메소드는 this를 사용할 수 없다.</span></span><br><span class="line"><span class="hljs-comment">    정적 메소드 내부에서 this는 클래스의 인스턴스가 아닌 클래스 자신을 가리킨다.</span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'staticMethod'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  prototypeMethod() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> staticMethod2() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    prototypeMethod() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.staticMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Bar.staticMethod2()); <span class="hljs-comment">// staticMethod</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> bar = <span class="hljs-keyword">new</span> Bar();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar.prototypeMethod()); <span class="hljs-comment">// TypeError: (intermediate value).staticMethod is not a function</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;자바스크립트는 Prototype-based 객체지향 언어이다. Prototype-based 프로그래밍은 클래스 없이 프로토타입과 클로저 등으로 상속, 캡슐화 등의 개념을 구현할 수 있다.&lt;/p&gt;
&lt;p&gt;대부분의 객체 지향 언어가 클래스 기반인 점을
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="https://sub2n.github.io/tags/Javascript/"/>
    
      <category term="Class" scheme="https://sub2n.github.io/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>26. Destructuring</title>
    <link href="https://sub2n.github.io/2019/05/21/26-Destructuring/"/>
    <id>https://sub2n.github.io/2019/05/21/26-Destructuring/</id>
    <published>2019-05-21T07:16:23.000Z</published>
    <updated>2019-05-22T07:15:43.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a>Destructuring</h3><p>구조화된 배열 / 객체를 풀어서(destructure) 개별적인 변수에 할당하는 것. 배열 / 객체 리터럴에서 필요한 값을 추출해서 변수에 할당하거나 리턴할 때 유용</p><h3 id="1-Array-Destructuring"><a href="#1-Array-Destructuring" class="headerlink" title="1. Array Destructuring"></a>1. Array Destructuring</h3><p>ES6의 배열 디스트럭처링은 배열의 각 요소를 배열에서 추출해 변수 리스트에 할당한다. 배열 인덱스를 기준으로 추출, 할당한다. </p><p>이 때 할당 연산자(=)의 왼 쪽에 <strong>배열 형태의 변수 리스트</strong>가 와야한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// ES6</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> [one, two, three] = arr;</span><br><span class="line"><span class="hljs-comment">// const [one, two, three] = [1, 2, 3];</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(one, two, three); <span class="hljs-comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>배열의 인덱스를 기준으로 <strong>오른쪽의 배열</strong>에서 왼쪽의 <strong>변수 리스트</strong>로 할당된다. 그러므로 변수의 <strong>순서가 중요</strong>하다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> x, y, z;</span><br><span class="line"></span><br><span class="line">[x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; </span><br><span class="line"><span class="hljs-built_in">console</span>.log([x, y]); <span class="hljs-comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line">[x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; </span><br><span class="line"><span class="hljs-built_in">console</span>.log([x, y]); <span class="hljs-comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line">[x, y] = [<span class="hljs-number">1</span>]; </span><br><span class="line"><span class="hljs-built_in">console</span>.log([x, y]); <span class="hljs-comment">// [1, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// default 설정</span></span><br><span class="line">[x, y = <span class="hljs-number">3</span>, z = <span class="hljs-number">4</span>] = [<span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-built_in">console</span>.log([x, y, z]); <span class="hljs-comment">// [1, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="2-Object-Destructuring"><a href="#2-Object-Destructuring" class="headerlink" title="2. Object Destructuring"></a>2. Object Destructuring</h3><p>ES6의 객체 디스트럭처링은 객체의 각 프로퍼티를 객체로부터 추출해서 변수 리스트에 할당한다. 할당 기준은 <strong>프로퍼티 키</strong>이다. 할당 연산자 왼쪽에는 <strong>객체 형태의 변수 리스트</strong>가 필요하다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// ES6 Destructuring</span></span><br><span class="line"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Subin'</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Park'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> &#123;firstName, lastName &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(firstName, lastName); <span class="hljs-comment">// Subin Park</span></span><br></pre></td></tr></table></figure><p>객체 destructing의 경우 할당 기준이 프로퍼티 키이므로 <strong>프로퍼티 키를 명시해주지 않으려면 변수명과 프로퍼티 키가 같아야 한다</strong>. 순서는 상관 없다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">prop1</span>: p1, <span class="hljs-attr">prop2</span>: p2 &#125; = &#123; <span class="hljs-attr">prop1</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">prop2</span>: <span class="hljs-string">'b'</span> &#125;;</span><br><span class="line"><span class="hljs-comment">// 변수명을 prop1, prop2가 아닌 p1, p2로 하기 위해서 pro1: p1 등으로 구분해줌</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(p1, p2); <span class="hljs-comment">// a, b</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(&#123; <span class="hljs-attr">prop1</span>: p1, <span class="hljs-attr">prop2</span>: p2 &#125;); <span class="hljs-comment">// &#123; prop1: 'a', prop2: 'b' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Shorthand(변수명을 프로퍼티 명과 같게 함) &amp; default 설정</span></span><br><span class="line"><span class="hljs-keyword">const</span> &#123; prop1, prop2, prop3 = <span class="hljs-string">'c'</span> &#125; = &#123; <span class="hljs-attr">prop1</span>: <span class="hljs-string">'a'</span>, <span class="hljs-attr">prop2</span>: <span class="hljs-string">'b'</span> &#125;;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(&#123; prop1, prop2, prop3 &#125;); <span class="hljs-comment">// &#123;prop1: "a", prop2: "b", prop3: "c"&#125;</span></span><br></pre></td></tr></table></figure><p>객체 디스트럭처링으로 객체에서 필요한 프로퍼티 키의 값만을 추출해낼 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> parts = [</span><br><span class="line">    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">department</span>: <span class="hljs-string">'Human Resource'</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">department</span>: <span class="hljs-string">'Development'</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">department</span>: <span class="hljs-string">'Management'</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">false</span> &#125;    </span><br><span class="line">];</span><br><span class="line"><span class="hljs-comment">// parts 배열의 객체 element 중에서 checked 프로퍼티의 값만을 checked라는 이름의 변수(parameter)로 받는다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> checkedParts = parts.filter(<span class="hljs-function">(<span class="hljs-params">&#123;checked&#125;</span>) =&gt;</span> checked);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(checkedParts); <span class="hljs-comment">//  &#123; id: 2, department: 'Development', checked: true &#125;</span></span><br></pre></td></tr></table></figure><p>위의 예제에서 filter 함수의 callback은 argument 로 parts의 객체 element를 하나씩 받는다. parameter에 {checked} 를 정의했다는 것은 내부적으로</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; checked &#125; = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">department</span>: <span class="hljs-string">'Human Resource'</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">false</span> &#125;;</span><br></pre></td></tr></table></figure><p>가 실행되는 것과 같다. callback 함수 내에서는 checked라는 parameter 변수에 객체 element의 checked 프로퍼티의 값이 할당되어있다. 따라서 filter 실행시배열의 element 중 checked 프로퍼티의 값을 할당한 변수 checked 가 true인 객체 element만 필터링된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> student = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Park'</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        zipCode: <span class="hljs-string">'12345'</span>,</span><br><span class="line">        city: <span class="hljs-string">'NewYork'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">address</span>: &#123; city &#125; &#125; = student;</span><br><span class="line"><span class="hljs-comment">// 왼 쪽의 city 변수에 student 객체의 address 프로퍼티의 값 객체의 city 프로퍼티의 값 'NeyWork'이 할당됨 (프로퍼티 추출)</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(city); <span class="hljs-comment">// 'NewYork'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Destructuring&quot;&gt;&lt;a href=&quot;#Destructuring&quot; class=&quot;headerlink&quot; title=&quot;Destructuring&quot;&gt;&lt;/a&gt;Destructuring&lt;/h3&gt;&lt;p&gt;구조화된 배열 / 객체를 풀어서(destruct
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="Javascript" scheme="https://sub2n.github.io/tags/Javascript/"/>
    
      <category term="Destructuring" scheme="https://sub2n.github.io/tags/Destructuring/"/>
    
  </entry>
  
</feed>
