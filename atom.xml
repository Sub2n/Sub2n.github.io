<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>수빈 개발블로그</title>
  
  <subtitle>Sub2n Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sub2n.github.io/"/>
  <updated>2019-07-01T04:15:29.169Z</updated>
  <id>https://sub2n.github.io/</id>
  
  <author>
    <name>Subin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>190701-TIL</title>
    <link href="https://sub2n.github.io/2019/07/01/190701-TIL/"/>
    <id>https://sub2n.github.io/2019/07/01/190701-TIL/</id>
    <published>2019-07-01T04:08:01.000Z</published>
    <updated>2019-07-01T04:15:29.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-Test"><a href="#Today-Test" class="headerlink" title="Today Test"></a>Today Test</h2><p>[오답]</p><ul><li>식별자를 검색했을 때 없으면 ReferenceError지만 Property를 검색했을 때 없으면 error가 아니고 undefined를 리턴</li><li>함수가 아닌 것에 () 붙여 실행하면 TypeError (SyntaxError 아님!!!!!!)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-Test&quot;&gt;&lt;a href=&quot;#Today-Test&quot; class=&quot;headerlink&quot; title=&quot;Today Test&quot;&gt;&lt;/a&gt;Today Test&lt;/h2&gt;&lt;p&gt;[오답]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;식별자를 검색했을 때 없으면 Refe
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190628-TIL</title>
    <link href="https://sub2n.github.io/2019/07/01/190628-TIL/"/>
    <id>https://sub2n.github.io/2019/07/01/190628-TIL/</id>
    <published>2019-07-01T04:07:46.000Z</published>
    <updated>2019-07-01T04:24:23.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FDS12-School-Hackaton"><a href="#FDS12-School-Hackaton" class="headerlink" title="FDS12 School Hackaton"></a>FDS12 School Hackaton</h2><p>패스트캠퍼스에 들어오고 두 번째 해커톤을 마쳤다. 총 10개 팀 중 3개 팀을 수상했는데 우리 팀이 <code>인생을 바꾸는 작은 유용함 상</code>을 수상했다. 각 스쿨의 매니저분들이 엑셀 파일로 학생 관리를 하는 불편함을 해소하고자 학생 관리 툴을 웹으로 옮겼다. 페어 해커톤이 아닌, 전체 스쿨 해커톤으로 백엔드와의 협업을 하고 싶었으나 전날 백엔드 팀이 빠지게 되어 프론트엔드 세명으로만 프로젝트를 진행했다. Angular Form을 사용해서 login 기능을 구현하고 싶었는데 아쉬웠다. 기대가 별로 없었는데 입상을 해서 기분이 좋았다. 앞으로 Final 프로젝트가 하나 남았다.</p><p>✨<a href="https://devpost.com/software/iwam" target="_blank" rel="noopener">IWAM on Devpost</a></p><p>✨<a href="https://github.com/Sub2n/Fastcampus-Student-Managing/tree/develop" target="_blank" rel="noopener">IWAM Github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FDS12-School-Hackaton&quot;&gt;&lt;a href=&quot;#FDS12-School-Hackaton&quot; class=&quot;headerlink&quot; title=&quot;FDS12 School Hackaton&quot;&gt;&lt;/a&gt;FDS12 School Hackaton&lt;/
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
      <category term="FDS12" scheme="https://sub2n.github.io/tags/FDS12/"/>
    
      <category term="Hackaton" scheme="https://sub2n.github.io/tags/Hackaton/"/>
    
  </entry>
  
  <entry>
    <title>Angular RxJS</title>
    <link href="https://sub2n.github.io/2019/06/25/Angular-RxJS/"/>
    <id>https://sub2n.github.io/2019/06/25/Angular-RxJS/</id>
    <published>2019-06-25T04:12:23.000Z</published>
    <updated>2019-06-25T07:32:29.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reactive-Programming"><a href="#Reactive-Programming" class="headerlink" title="Reactive Programming"></a>Reactive Programming</h2><blockquote><p><strong>Reactive Programming is programming with asynchronous data streams.</strong> <strong>You can listen to that stream and react accordingly.</strong></p></blockquote><p><strong>Reactive Programming은 비동기적 데이터 스트림을 처리하는 프로그래밍 패러다임</strong>이다. Data stream이란 연속적인 데이터의 흐름을 말한다. Reactive Programming은 모든 것을 stream으로 본다. Event, AJAX 요청 등 모든 data stream을 시간 순서에 의해 전달되는 stream으로 처리한다.</p><p>최근 참여한 FrontEndgame 컨퍼런스에서 Functional Programming과 Reactive Programming을 융합한 FRP에 대한 발표가 있었는데 이제 Reactive Programming을 공부해본다.</p><a id="more"></a><p>여태까지는 입력받는 Data가 synchronous한지 asynchronous한지에 따라서 처리하는 방법이 달라진다. 입력이 string일 때와 Promise/event 등일 때는 코딩하는 방법이 달라진다. Reactive Programming은 data를 async, sync로 구분하지 않고 data를 stream으로 보는 것이다. Data consumer는 Data producer가 연속적으로 생성하고 방출하는 data stream의 상태 변화에 반응하는 방식으로 동작한다.</p><h2 id="Observable-amp-Observer"><a href="#Observable-amp-Observer" class="headerlink" title="Observable &amp; Observer"></a>Observable &amp; Observer</h2><blockquote><p><strong>An observer subscribes to an Observable. An Observable emits items or sends notifications to its observers by calling the observers’ methods.</strong></p></blockquote><p>Data producer와 Data consumer 사이에 data stream을 전송하는 방법에는 두가지가 있다.</p><ol><li>Pull-scenario: Data consumer가 producer에게 data를 연속적으로 요청해서 획득한다. 이는 애플리케이션이 외부 환경에서 데이터를 끌어오는 방식이다.</li><li>Push-scenario: Data producer가 일정 시간 단위로 계속해서 data를 내보내면(emit) Data consumer가 producer를 관찰하고 있다가 data를 획득한다. 이는 외부 환경에서 애플리케이션으로 데이터를 밀어넣는 방식이다.</li></ol><p><strong>Observable</strong>: 외부 환경에서 애플리케이션 내부로 data stream을 생성하고 emit(방출)하는 객체</p><p><strong>Observer</strong>: Observable이 emit한 Notification(Observable이 emit할 수 있는 push 기반 event 값)을 획득해서 사용하는 객체</p><p>즉 Observer는 Data consumer이고 Observable은 Data producer이다. <strong>Observer는 Observable을 구독(subscribe)한다.</strong> 보통 Observable과 Observer는 일대다 관계를 가진다.</p><p>Observable은 ES7에 제안되어있는 비동기 데이터 처리를 위한 표준으로, Reactive Programming은 Observer pattern을 더 심화한 패턴이다.</p><blockquote><h4 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h4><p><img src="https://poiemaweb.com/img/observer-pattern.png" alt="observer-pattern"></p><p>Subject는 data member로 자신을 관찰하고 있는 Observer의 모음인 ObserverCollection을 유지한다. register/unregister로 Observer를 관리한다. 상태가 변화하면 자신의 ObserverCollection에 등록된 Observer들에게 noftify(status)로 상태 변화를 알린다. 상태 변화를 알리는 notify 메소드 내부에서 Observer의 Update(status)로 상태를 갱신한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;</span><br><span class="line">&gt; ObserverCollection = [];</span><br><span class="line">&gt; </span><br><span class="line">&gt; register(Observer) &#123;</span><br><span class="line">&gt;     <span class="hljs-keyword">this</span>.ObserverCollection = [Observer, ...this.ObserverCollection];</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; unregister(Observer) &#123;</span><br><span class="line">&gt;     <span class="hljs-keyword">this</span>.ObserverCollection = <span class="hljs-keyword">this</span>.ObserverCollection.filter(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o !== Observer);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; notify(status) &#123;</span><br><span class="line">&gt;     <span class="hljs-keyword">this</span>.ObserverCollection.forEach(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o.update(status));</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>&#123;</span><br><span class="line">&gt;   <span class="hljs-keyword">constructor</span>() &#123;</span><br><span class="line">&gt;     <span class="hljs-keyword">super</span>();</span><br><span class="line">&gt;     <span class="hljs-keyword">this</span>._state;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   </span><br><span class="line">&gt;   <span class="hljs-keyword">set</span> state(status) &#123;</span><br><span class="line">&gt;     <span class="hljs-keyword">this</span>._state = status;</span><br><span class="line">&gt;     <span class="hljs-keyword">this</span>.notify(<span class="hljs-keyword">this</span>.state);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;</span><br><span class="line">&gt;   <span class="hljs-keyword">constructor</span>() &#123;</span><br><span class="line">&gt;     <span class="hljs-keyword">this</span>.state = <span class="hljs-string">''</span></span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   update(status) &#123;</span><br><span class="line">&gt;     <span class="hljs-keyword">this</span>.state = status;</span><br><span class="line">&gt;     <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.state);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Reactive-Programming&quot;&gt;&lt;a href=&quot;#Reactive-Programming&quot; class=&quot;headerlink&quot; title=&quot;Reactive Programming&quot;&gt;&lt;/a&gt;Reactive Programming&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reactive Programming is programming with asynchronous data streams.&lt;/strong&gt; &lt;strong&gt;You can listen to that stream and react accordingly.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reactive Programming은 비동기적 데이터 스트림을 처리하는 프로그래밍 패러다임&lt;/strong&gt;이다. Data stream이란 연속적인 데이터의 흐름을 말한다. Reactive Programming은 모든 것을 stream으로 본다. Event, AJAX 요청 등 모든 data stream을 시간 순서에 의해 전달되는 stream으로 처리한다.&lt;/p&gt;
&lt;p&gt;최근 참여한 FrontEndgame 컨퍼런스에서 Functional Programming과 Reactive Programming을 융합한 FRP에 대한 발표가 있었는데 이제 Reactive Programming을 공부해본다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Reactive Programming" scheme="https://sub2n.github.io/tags/Reactive-Programming/"/>
    
      <category term="Observable" scheme="https://sub2n.github.io/tags/Observable/"/>
    
  </entry>
  
  <entry>
    <title>Angular Service &amp; Dependency Injection</title>
    <link href="https://sub2n.github.io/2019/06/25/Angular-Service-Dependency-Injection/"/>
    <id>https://sub2n.github.io/2019/06/25/Angular-Service-Dependency-Injection/</id>
    <published>2019-06-25T04:12:04.000Z</published>
    <updated>2019-06-25T06:17:25.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Component는 View를 구성하고 관리하는 역할을 해야한다. 그러나 View를 구성하다보면 필요한 데이터를 가져오기 위해서 서버와 통신을 하는 등의 부가 기능이 필요하게 된다. 이런 기능을 Component에서 하지 않고 Service로 분리한다.</p><p>Component의 관심사와 Application 전역의 관심사를 분리하는 것이다. 이렇게 기능을 분리하면 Application의 복잡도가 낮아지고 서비스를 재사용할 수 있다. 또한 의존도가 낮아져 유지보수성이 좋아진다.</p><a id="more"></a><h2 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h2><p>Service는 Dependency Injection이 가능한 class이다. @Injectable 데코레이터로 정의한다.</p><p>Dependency Injection이란 말 그대로 의존성(dependency)을 주입(inject)한다는 것이다.</p><p>어떤 Component에서 Service의 method를 사용하는 경우 둘은 <strong>의존 관계(Dependency relationship)</strong>에 있다고 한다. Component 내부에서 Service class의 instance를 생성하는 경우 둘은 <strong>강한 결합(Tight Coupling)</strong>을 하고 있는 것이다. 반면 Component에서 직접 Service를 생성하는 것이 아니라 constructor의 parameter로 선언하여 Angular가 생성한 Service instance를 주입받는 것은 <strong>느슨한 결합(Loose Coupling)</strong>이다.</p><p> Tight Coupling은 많은 문제를 일으킨다. 하나의 Service의 생성 방법 등에 변동이 있을 경우 해당 Service와 의존 관계에 있는 모든 Component가 영향을 받는다. </p><p>재사용과 유지보수가 효율적인 프로그램을 만들기 위해서는 객체 사이의 <strong>의존 관계를 최소화</strong>해야 한다. 필요에 의해 의존 관계가 있을 경우 Tight Coupling은 지양해야 한다.</p><p>Dependency Injection은 Design pattern 중 하나로, tight coupling에서 loose coupling으로 전환하는 방법이다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> A &#123;</span><br><span class="line">  <span class="hljs-comment">// dependency의 instance를 직접 생성하지 않고 외부 환경에 요구</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> dependency: B</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo() &#123; <span class="hljs-keyword">this</span>.dependency.bar(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> B &#123;</span><br><span class="line">  bar() &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar'</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A class처럼 constructor에서 instance를 parameter로 받는 경우, A class에서는 해당 instance의 생성 방법을 알 필요가 없다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// greeting.service.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="hljs-string">'root'</span> <span class="hljs-comment">/* @Injectable 프로바이더 */</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GreetingService &#123;</span><br><span class="line">  sayHi() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'Hi!'</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Angular에서 Dependency Injection을 받기 위해서는 @Injectable 데코레이터에 meta data로 <code>providedIn: &#39;root&#39;</code>를 설정해야 한다. 해당 선언이 된 Service는 전역에서 Injectable하다.</p><p>또는 해당 Service를 주입받을 Component에서 @Compinent 데코레이터에 meta data로 <code>providers: [GreetingService]</code>를 설정해주면 된다. 이 Component를 포함한 Child component 들에서만 Injectable하다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Service&quot;&gt;&lt;a href=&quot;#Service&quot; class=&quot;headerlink&quot; title=&quot;Service&quot;&gt;&lt;/a&gt;Service&lt;/h2&gt;&lt;p&gt;Component는 View를 구성하고 관리하는 역할을 해야한다. 그러나 View를 구성하다보면 필요한 데이터를 가져오기 위해서 서버와 통신을 하는 등의 부가 기능이 필요하게 된다. 이런 기능을 Component에서 하지 않고 Service로 분리한다.&lt;/p&gt;
&lt;p&gt;Component의 관심사와 Application 전역의 관심사를 분리하는 것이다. 이렇게 기능을 분리하면 Application의 복잡도가 낮아지고 서비스를 재사용할 수 있다. 또한 의존도가 낮아져 유지보수성이 좋아진다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
      <category term="Service" scheme="https://sub2n.github.io/tags/Service/"/>
    
      <category term="Dependency Injection" scheme="https://sub2n.github.io/tags/Dependency-Injection/"/>
    
  </entry>
  
  <entry>
    <title>190624-TIL</title>
    <link href="https://sub2n.github.io/2019/06/25/190624-TIL/"/>
    <id>https://sub2n.github.io/2019/06/25/190624-TIL/</id>
    <published>2019-06-25T04:06:03.000Z</published>
    <updated>2019-06-25T04:07:28.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>ToastUI를 JavaScript와 Angular로 구현했다.</li><li>window.pageYOffset은 wiondow.scrollY보다 cross browsing에 적합(IE 9 지원)하므로 pageYOffset을 사용하는 게 좋다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ToastUI를 Jav
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Angular Directive</title>
    <link href="https://sub2n.github.io/2019/06/24/Angular-Directive/"/>
    <id>https://sub2n.github.io/2019/06/24/Angular-Directive/</id>
    <published>2019-06-24T06:28:00.000Z</published>
    <updated>2019-06-25T04:13:52.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h2><p>Directive는 DOM의 모양이나 동작 등을 관리하기 위한 명령이다. HTML Element 또는 Attribute 형태로 사용한다.</p><p>Directive를 사용하는 HTML Element를 Directive 내에서 Host element라고 부르며, Directive 내부에서 host element의 event를 처리하거나 style 등을 변경할 수 있다.</p><a id="more"></a><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'[textBlue]'</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> TextBlueDirective &#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> el: ElementRef, <span class="hljs-keyword">public</span> renderer: Renderer2</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseenter'</span>) onMouse() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setColor(<span class="hljs-string">'blue'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseleave'</span>) offMouse() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setColor(<span class="hljs-literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setColor(color: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.renderer.setStyle(<span class="hljs-keyword">this</span>.el.nativeElement, <span class="hljs-string">'color'</span>, color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Directive class의 constructor에서 주입된 parameter는 class의 class field가 되어 class 전역에서 사용할 수 있다. 이를 constructor에 ElementRef instance가 Dependency Intect(의존성 주입)되었다고 한다.</p><ul><li><p>@Directive : meta data 객체에 Directive에 필요한 정보(selector등)를 입력한다.</p><table><thead><tr><th align="left">selector property</th><th align="left">설명</th></tr></thead><tbody><tr><td align="left">selector: ‘foo’</td><td align="left">foo element에 Directive가 적용된다.</td></tr><tr><td align="left">selector: ‘.foo’</td><td align="left">.foo class가 선언된 element에 Directive가 적용된다.</td></tr><tr><td align="left">selector: [foo]</td><td align="left">foo attribute가 선언된 element에 Directive가 적용된다.</td></tr><tr><td align="left">selector: [foo=bar]</td><td align="left">foo attribute의 값이 bar로 선언된 element에 Directive가 적용된다.</td></tr><tr><td align="left">selector: :not(foo)</td><td align="left">foo element를 제외한 모든 element에 Directive가 적용된다.</td></tr><tr><td align="left">selector: ‘foo, bar’</td><td align="left">foo 또는 bar element에 Directive가 적용된다.</td></tr></tbody></table><p>Directive의 selector는 attribute로 이용하는 것이 일반적이다. Component는 Directive를 상속받은 것으로 selector 규칙이 동일하게 적용된다.</p></li><li><p>ElementRef: host element를 감싼 wrapper object</p></li><li><p>el.nativeElement: host element</p></li><li><p>Renderer2: Angular에서는 el.nativeElement의 style 프로퍼티를 직접 변경하는 것이 아니라 Renderer2를 이용하는 것이 권장된다.</p></li><li><p>@HostListener : host element에서 발생한 event에 대한 event listener를 정의할 때 사용하는 데코레이터.</p></li></ul><h3 id="Directive로-data-보내기-property-binding"><a href="#Directive로-data-보내기-property-binding" class="headerlink" title="Directive로 data 보내기 | property binding"></a>Directive로 data 보내기 | property binding</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// app.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-root'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;!--The content below is only a placeholder and can be replaced.--&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;p [color]="color" textColor&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: []</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;</span><br><span class="line">  color = <span class="hljs-string">'red'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// text-color.directive.ts</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Directive</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'[textColor]'</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> TextColorDirective &#123;</span><br><span class="line">  <span class="hljs-meta">@Input</span>() color: <span class="hljs-built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> el: ElementRef, <span class="hljs-keyword">public</span> renderer: Renderer2</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseenter'</span>) onMouse() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setColor(<span class="hljs-keyword">this</span>.color);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'mouseleave'</span>) offMouse() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setColor(<span class="hljs-literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setColor(color: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.renderer.setStyle(<span class="hljs-keyword">this</span>.el.nativeElement, <span class="hljs-string">'color'</span>, color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Directive&quot;&gt;&lt;a href=&quot;#Directive&quot; class=&quot;headerlink&quot; title=&quot;Directive&quot;&gt;&lt;/a&gt;Directive&lt;/h2&gt;&lt;p&gt;Directive는 DOM의 모양이나 동작 등을 관리하기 위한 명령이다. HTML Element 또는 Attribute 형태로 사용한다.&lt;/p&gt;
&lt;p&gt;Directive를 사용하는 HTML Element를 Directive 내에서 Host element라고 부르며, Directive 내부에서 host element의 event를 처리하거나 style 등을 변경할 수 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>190622-TIL</title>
    <link href="https://sub2n.github.io/2019/06/22/190622-TIL/"/>
    <id>https://sub2n.github.io/2019/06/22/190622-TIL/</id>
    <published>2019-06-22T10:13:26.000Z</published>
    <updated>2019-06-25T06:41:33.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Front Endgame 컨퍼런스에 갔다왔다.</li><li>Angular와 React에 대한 정보를 많이 얻었다.</li><li>현직 프론트엔드 개발자들이 어떤 식으로 일 하는지 들을 수 있어 좋았다.</li></ul><hr><ul><li>앵귤러 공부 위해서</li></ul><ol><li>디렉티브 등 템플릿 문법 숙지해야함</li><li>RxJS 공부해야함</li></ol><ul><li><p>RxJS 는 비동기적 데이터 흐름을 한 곳에서 조작할 수 있음</p></li><li><p>Dependency Injection으로 다형성</p></li><li><p>UX</p><ol><li>예상 가능한 동작</li></ol><ul><li>뒤로가기시 스크롤 복원</li><li>모바일 Thumbs zone</li></ul><ol start="2"><li>SEO/SMO</li></ol></li><li><p>Observable 공부하기</p></li><li><p>도서</p><ul><li>하스켈로 배우는 함수형 프로그래밍</li><li>클린 코드</li><li>실용주의 프로그래머</li><li>프로그래밍 심리학</li></ul></li><li><p>함수형 프로그래밍이 왜 CPU보다 메모리를 많이 쓰는지 알기</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Front Endgam
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Angular Pipe</title>
    <link href="https://sub2n.github.io/2019/06/21/Angular-Pipe/"/>
    <id>https://sub2n.github.io/2019/06/21/Angular-Pipe/</id>
    <published>2019-06-21T05:16:51.000Z</published>
    <updated>2019-06-21T07:34:36.071Z</updated>
    
    <content type="html"><![CDATA[<p>AngularJS에는 60여개의 built-in Pipe가 있었으나 Angular는 9개의 built-in pipe를 지원한다. 나머지 기능은 pipe를 직접 구현하여 사용할 수 있다.</p><table><thead><tr><th align="left">pipe</th><th align="left">meaning</th></tr></thead><tbody><tr><td align="left"><a href="https://angular.io/api/common/DatePipe" target="_blank" rel="noopener">date</a></td><td align="left">날짜 형식 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/JsonPipe" target="_blank" rel="noopener">json</a></td><td align="left">JSON 형식 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/UpperCasePipe" target="_blank" rel="noopener">uppercase</a></td><td align="left">대문자 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/LowerCasePipe" target="_blank" rel="noopener">lowercase</a></td><td align="left">소문자 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/CurrencyPipe" target="_blank" rel="noopener">currency</a></td><td align="left">통화 형식 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/PercentPipe" target="_blank" rel="noopener">percent</a></td><td align="left">퍼센트 형식 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/DecimalPipe" target="_blank" rel="noopener">decimal</a></td><td align="left">자리수 형식 변환</td></tr><tr><td align="left"><a href="https://angular.io/api/common/SlicePipe" target="_blank" rel="noopener">slice</a></td><td align="left">문자열 추출</td></tr><tr><td align="left"><a href="https://angular.io/api/common/AsyncPipe" target="_blank" rel="noopener">async</a></td><td align="left">비동기 객체 출력</td></tr></tbody></table><a id="more"></a><p>new Date() 등으로 생성한 객체에 pipe를 사용하면 깔끔한 형식으로 출력할 수 있다.</p><p>객체 배열 형식으로 된 data를 확인하며 코딩할 때 <code>&lt;pre&gt;{ data | json }&lt;/pre&gt;</code>로 data를 확인할 수 있다.</p><p>Category가 있는 경우 category 별로 filtering해서 데이터를 보여줄 수도 있다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// filter.pipe.ts</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Pipe</span>(&#123;</span><br><span class="line">  name: <span class="hljs-string">'filter'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FilterPipe <span class="hljs-keyword">implements</span> PipeTransform &#123;</span><br><span class="line">  transform(todos: Todo[], active: NavItem): <span class="hljs-built_in">any</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (active === <span class="hljs-string">'All'</span>) <span class="hljs-keyword">return</span> todos;</span><br><span class="line">    <span class="hljs-keyword">return</span> active === <span class="hljs-string">'Active'</span></span><br><span class="line">      ? todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.completed)</span><br><span class="line">      : todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.completed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- todos.component.html --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let todo of (todos | filter: navState)"</span>&gt;</span></span><br><span class="line">  ....</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Angular는 template을 렌더링할 때 사용하는 data의 Reference value가 바뀌어야 상태 감지를 해서 재렌더링을 하며 pipe를 실행한다. 따라서 상태가 변경될 때는 명시적으로 재할당을 해주는 게 좋다. 재할당을 하지 않고 일부분만을 변경할 경우 pipe에 option을 주어야 한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ Pipe(&#123;</span><br><span class="line">  name: <span class="hljs-string">'filter'</span>,</span><br><span class="line">  pure: <span class="hljs-literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>pure: false</code> option을 주면 Reference value가 바뀌지 않더라도 상태를 감지하지만 퍼포먼스가 안 좋아진다. 재할당을 하자.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AngularJS에는 60여개의 built-in Pipe가 있었으나 Angular는 9개의 built-in pipe를 지원한다. 나머지 기능은 pipe를 직접 구현하여 사용할 수 있다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;pipe&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/DatePipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;date&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;날짜 형식 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/JsonPipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;json&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;JSON 형식 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/UpperCasePipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;uppercase&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;대문자 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/LowerCasePipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lowercase&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;소문자 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/CurrencyPipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;currency&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;통화 형식 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/PercentPipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;percent&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;퍼센트 형식 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/DecimalPipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;decimal&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;자리수 형식 변환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/SlicePipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;slice&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;문자열 추출&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://angular.io/api/common/AsyncPipe&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;async&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;비동기 객체 출력&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
      <category term="Pipe" scheme="https://sub2n.github.io/tags/Pipe/"/>
    
  </entry>
  
  <entry>
    <title>190619-TIL</title>
    <link href="https://sub2n.github.io/2019/06/19/190619-TIL/"/>
    <id>https://sub2n.github.io/2019/06/19/190619-TIL/</id>
    <published>2019-06-19T07:34:38.000Z</published>
    <updated>2019-06-19T07:37:20.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Angular 계층적 구조를 가진 Component 간의 Data 통신을 Service로 한다는 것을 알았다.</li><li>Angular의 Service는 전체 프로그램에서 하나의 Instance만을 가지는 Singleton이기 때문에 상태 관리가 가능하다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Angular 계층적 
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190618-TIL</title>
    <link href="https://sub2n.github.io/2019/06/18/190618-TIL/"/>
    <id>https://sub2n.github.io/2019/06/18/190618-TIL/</id>
    <published>2019-06-18T08:47:42.000Z</published>
    <updated>2019-06-18T08:51:01.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Angular로 AnalogClock과 StopWatch를 구현했다.</li><li>Angular Built-in Directive에 대해서 배웠다.</li><li>부모-자식 Component간 통신을 이용해서 simpleTodo를 구현했다.</li><li>자식 &gt; 부모 Component로 Data를 보낼 때는 @Output() 에 EventEmmitter의 instance로 event를 발생시킨다. emit()을 호출해야 event가 발생한다.</li><li>부모 &gt; 자식 Compinent로 Data를 보낼 때는 부모 Component에서 자식 Component로 Property binding을 하는 방식으로 Data를 보낸다. 자식 Compinent는 해당 프로퍼티를 @Input()으로 정의하고 값을 받는다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Angular로 Ana
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Angular Built-in Directive</title>
    <link href="https://sub2n.github.io/2019/06/18/Angular-Built-in-Directive/"/>
    <id>https://sub2n.github.io/2019/06/18/Angular-Built-in-Directive/</id>
    <published>2019-06-18T04:24:13.000Z</published>
    <updated>2019-06-21T06:42:11.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-Directive"><a href="#What-is-Directive" class="headerlink" title="What is Directive?"></a>What is Directive?</h2><p>지시, 명령. View에 관련한 명령을 내리는 모든 것을 directive라고 한다.</p><p>Component의 공통된 기능을 외부로 내보낸다.</p><blockquote><h4 id="Dependency-Injective"><a href="#Dependency-Injective" class="headerlink" title="Dependency Injective"></a>Dependency Injective</h4><p>type 지정하면 Angular가 class Instance를 생성한다.</p></blockquote><a id="more"></a><h3 id="Component-Directive"><a href="#Component-Directive" class="headerlink" title="Component Directive"></a>Component Directive</h3><p>Component의 템플릿 표시를 위한 Directive.  @Component</p><h3 id="Attribute-Directive"><a href="#Attribute-Directive" class="headerlink" title="Attribute Directive"></a>Attribute Directive</h3><p>ngClass, ngStyle 등</p><h4 id="ngClass"><a href="#ngClass" class="headerlink" title="ngClass"></a>ngClass</h4><p>여러 개의 Class를 추가하고 제거할 때 간편하다. String, Array, Object 형태로 바인딩할 수 있다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngClass</span>] = <span class="hljs-string">"'active red'"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- string --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngClass</span>] = <span class="hljs-string">""</span>['<span class="hljs-attr">active</span>', '<span class="hljs-attr">red</span>']"&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- array --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngClass</span>] = <span class="hljs-string">"&#123;'active': true, 'red': false&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- object --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ngStyle"><a href="#ngStyle" class="headerlink" title="ngStyle"></a>ngStyle</h4><p>여러 개의 Inline Style을 추가하고 제거한다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">"&#123; color: 'red', 'width.px': 100 &#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="Host-Element"><a href="#Host-Element" class="headerlink" title="Host Element"></a>Host Element</h4><p>Attribute가 사용된 Element</p></blockquote><h3 id="Structural-Directives"><a href="#Structural-Directives" class="headerlink" title="Structural Directives"></a>Structural Directives</h3><p>구조 디렉티브는 DOM 요소를 조건에 따라서 추가/삭제(ngIf, ngSwitch)하거나 반복 생성(ngFor)할 때 사용한다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;What-is-Directive&quot;&gt;&lt;a href=&quot;#What-is-Directive&quot; class=&quot;headerlink&quot; title=&quot;What is Directive?&quot;&gt;&lt;/a&gt;What is Directive?&lt;/h2&gt;&lt;p&gt;지시, 명령. View에 관련한 명령을 내리는 모든 것을 directive라고 한다.&lt;/p&gt;
&lt;p&gt;Component의 공통된 기능을 외부로 내보낸다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;Dependency-Injective&quot;&gt;&lt;a href=&quot;#Dependency-Injective&quot; class=&quot;headerlink&quot; title=&quot;Dependency Injective&quot;&gt;&lt;/a&gt;Dependency Injective&lt;/h4&gt;&lt;p&gt;type 지정하면 Angular가 class Instance를 생성한다.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>190617-TIL</title>
    <link href="https://sub2n.github.io/2019/06/17/190617-TIL/"/>
    <id>https://sub2n.github.io/2019/06/17/190617-TIL/</id>
    <published>2019-06-17T08:46:05.000Z</published>
    <updated>2019-06-17T08:47:36.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Angular Component의 Data Binding에 대해서 배웠다.</li><li>Angular의 ngFor와 ngIf Directive를 적용해서 TabsUI를 구현해봤다.</li><li>Angular 문법이 아직 익숙하지는 않은데 재미있다. 생각을 전환하기가 쉽지 않다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Angular Comp
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Angular Data Binding</title>
    <link href="https://sub2n.github.io/2019/06/17/Angular-Data-Binding/"/>
    <id>https://sub2n.github.io/2019/06/17/Angular-Data-Binding/</id>
    <published>2019-06-17T05:35:22.000Z</published>
    <updated>2019-06-21T06:42:28.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Interpolation"><a href="#Interpolation" class="headerlink" title="Interpolation"></a>Interpolation</h2><p><code></code></p><h2 id="Property-Binding"><a href="#Property-Binding" class="headerlink" title="Property Binding"></a>Property Binding</h2><p><code>[propertyName] = &quot;expression&quot;</code></p><p><code>&quot; &quot;</code> 내부에는 string이 아니라 expression(표현식)이 오는 곳이므로 주의하자.</p><blockquote><h4 id="Attribute-and-Property"><a href="#Attribute-and-Property" class="headerlink" title="Attribute and Property"></a>Attribute and Property</h4><p>Attribute는 HTML Element의 attribute이고 Property는 DOM node object인 HTML Element 객체의 property이다. 초기에 HTML Attribute가 초기값으로 그려지고 Property는 실시간으로 변경되는 DOM 최신값을 반영한다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Initial Value"</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"Property Value"</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>앞의 value는 attribute이고 [value]는 property이다. Property는 최신값이므로 실행시 “Property Value”가 view에 보여지게 된다.</p></blockquote><a id="more"></a><h2 id="Attribute-Binding"><a href="#Attribute-Binding" class="headerlink" title="Attribute Binding"></a>Attribute Binding</h2><p><code>[attr.attName] = &quot;expression&quot;</code></p><p>Property와 달리 <code>attr.</code>를 붙여줘야 한다.</p><p>HTML Element의 Property와 Attribute는 항상 1 대 1로 대응하지 않는다. HTML Element 별로 어떤 Attribute와 Property가 있는지 알고 있어야 한다.</p><h2 id="Class-Binding"><a href="#Class-Binding" class="headerlink" title="Class Binding"></a>Class Binding</h2><p>Class binding은 2가지 방법으로 사용할 수 있다. </p><h5 id="class-className-quot-expression-quot"><a href="#class-className-quot-expression-quot" class="headerlink" title="[class.className] = &quot;expression&quot;"></a><code>[class.className] = &quot;expression&quot;</code></h5><p>expression의 평가 결과가 true일 때는 class를 적용하고, false일 때는 class를 적용하지 않는다. classList.add와 remove를 간단하게 할 수 있다.</p><h5 id="class-quot-className-List-quot"><a href="#class-quot-className-List-quot" class="headerlink" title="[class]=&quot;className List&quot;"></a><code>[class]=&quot;className List&quot;</code></h5><p>class에 className List를 적용한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classNames = <span class="hljs-string">'active red block'</span>;</span><br></pre></td></tr></table></figure><p>여러 Class를 조건 별로 다룰 때에는 Angular의 built-in ngClass Directive를 사용하는 것이 좋다.</p><h2 id="Style-Binding"><a href="#Style-Binding" class="headerlink" title="Style Binding"></a>Style Binding</h2><p><code>[style.styleProp]=&quot;expression&quot;</code></p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// style property 이름은 camelExpression과 kebab-expression 모두 사용</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">style.fontSize.px</span>] = <span class="hljs-string">"'64'"</span>&gt;</span>..<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">style.font-size.px</span>]=<span class="hljs-string">"'64'"</span>&gt;</span>..<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Event-Binding"><a href="#Event-Binding" class="headerlink" title="Event Binding"></a>Event Binding</h2><p><code>(event)=&quot;event handler()&quot;</code></p><p>함수 <strong>호출문</strong>을 써야 한다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onClick()"</span>&gt;</span>..<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Two-way-Data-Binding"><a href="#Two-way-Data-Binding" class="headerlink" title="Two-way Data Binding"></a>Two-way Data Binding</h2><p>Property와 event binding을 한 번에</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> (<span class="hljs-attr">input</span>)=<span class="hljs-string">"changeVal($event.target.value)"</span></span></span><br><span class="line"><span class="hljs-tag">       [<span class="hljs-attr">value</span>]=<span class="hljs-string">"value"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"remove()"</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;</span><br><span class="line">  value= <span class="hljs-string">''</span>;</span><br><span class="line">  </span><br><span class="line">  changeVal(value: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  remove() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = <span class="hljs-string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input event로 인해서 AppComponent class의 value가 바뀌면 그 바뀐 value에 의해서 또 HTMLInputElement의  value도 영향을 받는다.</p><p>이런 상황을 양방향 데이터 바인딩으로 작성할 수 있다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"value"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위  와 같이 고치면 input tag에 대해서 input event 발생시 AppCoㅊㅌ      mponent의 value도 변경되고, AppComponent의 value가 변경되면 view에;ㅀ 반영된다.</p><p>ngModel을 사용하기 위해서는 FormsModule을 모듈에 등록해야 한다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Interpolation&quot;&gt;&lt;a href=&quot;#Interpolation&quot; class=&quot;headerlink&quot; title=&quot;Interpolation&quot;&gt;&lt;/a&gt;Interpolation&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;Property-Binding&quot;&gt;&lt;a href=&quot;#Property-Binding&quot; class=&quot;headerlink&quot; title=&quot;Property Binding&quot;&gt;&lt;/a&gt;Property Binding&lt;/h2&gt;&lt;p&gt;&lt;code&gt;[propertyName] = &amp;quot;expression&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;quot; &amp;quot;&lt;/code&gt; 내부에는 string이 아니라 expression(표현식)이 오는 곳이므로 주의하자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;Attribute-and-Property&quot;&gt;&lt;a href=&quot;#Attribute-and-Property&quot; class=&quot;headerlink&quot; title=&quot;Attribute and Property&quot;&gt;&lt;/a&gt;Attribute and Property&lt;/h4&gt;&lt;p&gt;Attribute는 HTML Element의 attribute이고 Property는 DOM node object인 HTML Element 객체의 property이다. 초기에 HTML Attribute가 초기값으로 그려지고 Property는 실시간으로 변경되는 DOM 최신값을 반영한다.&lt;/p&gt;
&lt;figure class=&quot;highlight html hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Initial Value&quot;&lt;/span&gt; [&lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;]=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Property Value&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;앞의 value는 attribute이고 [value]는 property이다. Property는 최신값이므로 실행시 “Property Value”가 view에 보여지게 된다.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular Component</title>
    <link href="https://sub2n.github.io/2019/06/14/Angular-Component/"/>
    <id>https://sub2n.github.io/2019/06/14/Angular-Component/</id>
    <published>2019-06-14T07:00:45.000Z</published>
    <updated>2019-06-25T05:15:42.467Z</updated>
    
    <content type="html"><![CDATA[<p>Angular Application은 component를 중심으로 구성되는만큼 component는 Angular의 핵심 개념이다.</p><p>Component는 application의 화면을 구성하는 View를 생성하고 관리한다. </p><p>Component는 template의 중첩 관계에 의해서 tree 구조를 갖는다. 여러 component 사이의 통신과 상태 관리를 위해서 Service가 있다.</p><a id="more"></a><h4 id="Compnonent-decorator"><a href="#Compnonent-decorator" class="headerlink" title="@Compnonent : decorator"></a>@Compnonent : decorator</h4><h4 id="Component-Metadata"><a href="#Component-Metadata" class="headerlink" title="Component Metadata"></a>Component Metadata</h4><p><img src="https://user-images.githubusercontent.com/48080762/59491021-0679f900-8ec1-11e9-9db7-31c3af5cce5d.png" alt="component metadata"></p><h4 id="export-class"><a href="#export-class" class="headerlink" title="export class"></a>export class</h4><p><img src="https://user-images.githubusercontent.com/48080762/59491315-6e304400-8ec1-11e9-9e53-ddff4b4861e9.png" alt="export class"></p><h4 id="Add-Component-to-app-module-ts"><a href="#Add-Component-to-app-module-ts" class="headerlink" title="Add Component to app.module.ts"></a>Add Component to app.module.ts</h4><p><img src="https://user-images.githubusercontent.com/48080762/59491403-a172d300-8ec1-11e9-8961-b685478fd3d6.png" alt="component declaration"></p><h4 id="Parent에서-Child로-data-보내는-법-Property-Binding"><a href="#Parent에서-Child로-data-보내는-법-Property-Binding" class="headerlink" title="Parent에서 Child로 data 보내는 법 : Property Binding"></a>Parent에서 Child로 data 보내는 법 : Property Binding</h4><p>parent Component는 자신의 template에 Child Component를 담고 있으므로 Child Component를 알 수 있다. 따라서 data를 쉽게 전송할 수 있다.</p><ol><li><p>Parent Component에서 Child의 Property로 값을 전달한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// app.component.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-root'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;!--The content below is only a placeholder and can be replaced.--&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;app-hello [hi]="greeting"&gt;&lt;/app-hello&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: []</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;</span><br><span class="line">  greeting = <span class="hljs-string">'hello'</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Child에서 @Input decorator로 Proterty value를 전달받는다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// hello.component.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Component, Input &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"@angular/core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  <span class="hljs-comment">// metadata</span></span><br><span class="line">  selector: <span class="hljs-string">'app-hello'</span>,</span><br><span class="line">  template: <span class="hljs-string">`&lt;h1&gt;&#123;&#123;hi&#125;&#125;&lt;/h1&gt;`</span>,</span><br><span class="line">  styles: [<span class="hljs-string">``</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HelloComponent &#123;</span><br><span class="line">  <span class="hljs-comment">// class Field</span></span><br><span class="line">  <span class="hljs-meta">@Input</span>() hi: <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Child-Component에서-Parent-Component로-data-보내는-법-Event-발생"><a href="#Child-Component에서-Parent-Component로-data-보내는-법-Event-발생" class="headerlink" title="Child Component에서 Parent Component로 data 보내는 법 : Event 발생"></a>Child Component에서 Parent Component로 data 보내는 법 : Event 발생</h4><p>Child Component는 Parent Component를 모르므로 Event를 발생시켜 Parent Component에서 Event를 Handling하는 방식으로 data를 전송한다.</p><ol><li><p>@Output, EventEmitter를 이용해서 Child Component에서 Event를 발생시킨다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component, Input, Output, EventEmitter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"@angular/core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  <span class="hljs-comment">// metadata</span></span><br><span class="line">  selector: <span class="hljs-string">'app-hello'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;h1&gt;&#123;&#123;hi&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;button (click)="greeting.emit('Hello')"&gt;greeting&lt;/button&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: [<span class="hljs-string">``</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HelloComponent &#123;</span><br><span class="line">  <span class="hljs-comment">// class Field</span></span><br><span class="line">  <span class="hljs-meta">@Input</span>() hi: <span class="hljs-built_in">string</span>;</span><br><span class="line">  <span class="hljs-meta">@Output</span>() greeting = <span class="hljs-keyword">new</span> EventEmitter&lt;<span class="hljs-built_in">string</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Output으로 선언한 method는 emit으로 argument를 전달할 수 있다.</p></li><li><p>Parent Component에서는 Event Handler를 이용해서 Event를 처리한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-root'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;!--The content below is only a placeholder and can be replaced.--&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;app-hello</span></span><br><span class="line"><span class="hljs-string">      [hi]="greeting"</span></span><br><span class="line"><span class="hljs-string">      (greeting)="changeGreet($event)"</span></span><br><span class="line"><span class="hljs-string">    &gt;&lt;/app-hello&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: []</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;</span><br><span class="line">  greeting = <span class="hljs-string">'Hi~~!!!!'</span>;</span><br><span class="line">  changeGreet(greet: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.greeting = greet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;app-hello&gt;</code> 내부에서 event greeting의 event handler를 등록하고 class 내부에서 정의한다. $event로 parameter에 argument 값을 받아온다.</p></li></ol><h2 id="Content-Projection"><a href="#Content-Projection" class="headerlink" title="Content Projection"></a>Content Projection</h2><p>Child Component의 selector tag 사이에 HTML content를 넣을 수 있다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- parent --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">app-child</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line">    Content from parent</span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">app-child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- child --&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Child component의 template에 <code>&lt;ng-content&gt;&lt;/ng-content&gt;</code>가 Parent component에서 전달한 template으로 치환된다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Angular Application은 component를 중심으로 구성되는만큼 component는 Angular의 핵심 개념이다.&lt;/p&gt;
&lt;p&gt;Component는 application의 화면을 구성하는 View를 생성하고 관리한다. &lt;/p&gt;
&lt;p&gt;Component는 template의 중첩 관계에 의해서 tree 구조를 갖는다. 여러 component 사이의 통신과 상태 관리를 위해서 Service가 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular Basics</title>
    <link href="https://sub2n.github.io/2019/06/14/Angular-Basics/"/>
    <id>https://sub2n.github.io/2019/06/14/Angular-Basics/</id>
    <published>2019-06-14T03:59:45.000Z</published>
    <updated>2019-06-14T07:03:39.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>Angular는 SPA(Single Page Application) 개발을 위한 Google의 Open source JavaScript <strong>Framework</strong>.</p><blockquote><h4 id="Framework-and-Library"><a href="#Framework-and-Library" class="headerlink" title="Framework and Library"></a>Framework and Library</h4><p>Library는 관련있는 함수를 모아놓아 개발자가 사용할 수 있는 도구이다. 즉, Library는 개발자에 의해 사용된다.</p><p>Framework는 클래스와 인터페이스의 집합으로 Application의 Flow를 쥐고 있다. 개발자가 Framework 틀 내부에서 작업하는 것이다.</p></blockquote><p>전통적인 웹 개발에서 JavaScript는 HTML/CSS에 의존한다. 의존한다는 것은 HTML/CSS에 접근해서 조작하는 방식으로 JavaScript 코드가 작성되었다는 것을 뜻한다. 이는 HTML/CSS가 변경되면 JavaScript 코드도 영향을 받음을 의미한다.</p><p>Angular는 HTML/CSS가 JavaScript에 의존하도록, 즉 JavaScript 코드의 상태 데이터 (State)에 바인딩해서 상태가 변경될 때마다 Rendering되도록 한다. HTML/CSS를 JavaScript의 Rendering 함수 내부의 문자열로 관리하면 앞서 말한 동작이 가능하다.</p><a id="more"></a><h2 id="Advantages-of-Angular"><a href="#Advantages-of-Angular" class="headerlink" title="Advantages of Angular"></a>Advantages of Angular</h2><ol><li>컴포넌트 기반 개발(CBD: Component Based Development) 로 생산성이 좋다.  Web에서 컴포넌트 기반 개발이 어려운 이유는 CSS가 서로에게 영향을 주기 때문인데,  Component 별로 CSS를 분리해내는 게 중요하다.</li><li>TypeScript 사용으로 정적 타이핑, ES6과 ESNext의 기능을 지원한다.</li><li>Angular는 대부분의 모던 브라우저를 지원한다. IE는 9 이상을 지원한다.</li></ol><h2 id="Angular-Project"><a href="#Angular-Project" class="headerlink" title="Angular Project"></a>Angular Project</h2><h4 id="app-component"><a href="#app-component" class="headerlink" title="app.component"></a>app.component</h4><p>Application의 root Component로, 실행 기본 page. (index.html처럼)</p><p><img src="https://user-images.githubusercontent.com/48080762/59484774-13d9b800-8eae-11e9-9762-ee95824f338f.png" alt="app.component"></p><h5 id="app-component-spec-ts"><a href="#app-component-spec-ts" class="headerlink" title="app.component.spec.ts"></a>app.component.spec.ts</h5><p>test specification</p><h5 id="ng-build-후-map-file"><a href="#ng-build-후-map-file" class="headerlink" title="ng build 후 map file"></a>ng build 후 map file</h5><p>디버깅용</p><h4 id="app-module"><a href="#app-module" class="headerlink" title="app.module"></a>app.module</h4><p>전체 모듈을 관리하므로 component 추가시 module에 추가됨</p><p><img src="https://user-images.githubusercontent.com/48080762/59485300-379dfd80-8eb0-11e9-987c-8154db2b8663.png" alt="app.module"></p><p>Component 생성 후 module file의 declarations에 추가해줘야함</p><h4 id="Generate-Component-Shortcut"><a href="#Generate-Component-Shortcut" class="headerlink" title="Generate Component Shortcut"></a>Generate Component Shortcut</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c service -s -t --skip-tests (-S)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/48080762/59485613-78e2dd00-8eb1-11e9-86da-a3d210def751.png" alt="shortcut"></p><h4 id="ng-generate"><a href="#ng-generate" class="headerlink" title="ng generate"></a>ng generate</h4><table><thead><tr><th>component</th><th>UI를 만들기 위해서 존재</th></tr></thead><tbody><tr><td>sercive</td><td>component와 직접적인 연관이 없는 state 관리</td></tr></tbody></table><p>component가 활성화된다 =&gt; component가 메모리에 올라가면 view가 보임</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="hljs-string">'이거슨 java'</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'이거슨 JavaScript'</span>);</span><br><span class="line">printf(<span class="hljs-string">'이거슨 C'</span>);</span><br><span class="line">cout&lt;&lt;<span class="hljs-string">'이거슨 c++'</span>;</span><br><span class="line">print(<span class="hljs-string">'이거슨 python'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Angular&quot;&gt;&lt;a href=&quot;#Angular&quot; class=&quot;headerlink&quot; title=&quot;Angular&quot;&gt;&lt;/a&gt;Angular&lt;/h2&gt;&lt;p&gt;Angular는 SPA(Single Page Application) 개발을 위한 Google의 Open source JavaScript &lt;strong&gt;Framework&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;Framework-and-Library&quot;&gt;&lt;a href=&quot;#Framework-and-Library&quot; class=&quot;headerlink&quot; title=&quot;Framework and Library&quot;&gt;&lt;/a&gt;Framework and Library&lt;/h4&gt;&lt;p&gt;Library는 관련있는 함수를 모아놓아 개발자가 사용할 수 있는 도구이다. 즉, Library는 개발자에 의해 사용된다.&lt;/p&gt;
&lt;p&gt;Framework는 클래스와 인터페이스의 집합으로 Application의 Flow를 쥐고 있다. 개발자가 Framework 틀 내부에서 작업하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;전통적인 웹 개발에서 JavaScript는 HTML/CSS에 의존한다. 의존한다는 것은 HTML/CSS에 접근해서 조작하는 방식으로 JavaScript 코드가 작성되었다는 것을 뜻한다. 이는 HTML/CSS가 변경되면 JavaScript 코드도 영향을 받음을 의미한다.&lt;/p&gt;
&lt;p&gt;Angular는 HTML/CSS가 JavaScript에 의존하도록, 즉 JavaScript 코드의 상태 데이터 (State)에 바인딩해서 상태가 변경될 때마다 Rendering되도록 한다. HTML/CSS를 JavaScript의 Rendering 함수 내부의 문자열로 관리하면 앞서 말한 동작이 가능하다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>190612-TIL</title>
    <link href="https://sub2n.github.io/2019/06/12/190612-TIL/"/>
    <id>https://sub2n.github.io/2019/06/12/190612-TIL/</id>
    <published>2019-06-12T10:34:40.000Z</published>
    <updated>2019-06-13T01:37:01.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>TypeScript에 대해서 배우고 실습해봤다.</li><li>Angular로 간단한 TodoList 기능을 구현해봤다. 맛보기만 해봤지만 재밌다! 그리고 엄청 편하다.</li><li>TypeScript는 기존에 알고 있던 객체지향개념(Class, Interface 등)이 있어 사용하기 편리할 것 같다. </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TypeScript에 
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript (2)</title>
    <link href="https://sub2n.github.io/2019/06/12/TypeScript-2/"/>
    <id>https://sub2n.github.io/2019/06/12/TypeScript-2/</id>
    <published>2019-06-12T09:16:03.000Z</published>
    <updated>2019-06-13T05:53:12.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TypeScript의-주요-기능"><a href="#TypeScript의-주요-기능" class="headerlink" title="TypeScript의 주요 기능"></a>TypeScript의 주요 기능</h4><ol><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Type-Declaration">타입 선언</a></li><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Class">Class</a></li><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Interface">Interface</a></li><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Generic">Generic</a></li></ol><a id="more"></a><h2 id="Type-Declaration"><a href="#Type-Declaration" class="headerlink" title="Type Declaration"></a>Type Declaration</h2><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 선언과 동시에 할당할 때는 바로 그 type으로 지정됨</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mult</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parameter의 type을 모두 명시해준 경우 Return type은 추론이 가능하므로 생략이 가능하다. Type은 any가 나오지 않게끔만 지정하면 된다.</p><p><code>void</code>: return을 하지 않는다. 사실은 <code>undefined</code>가 return되지만 <code>void</code>라고 한다.</p><h4 id="Types-of-TypeScript"><a href="#Types-of-TypeScript" class="headerlink" title="Types of TypeScript"></a>Types of TypeScript</h4><p><strong>From JavaScript:</strong> boolean,  null, undefined, number, string, symbol, object</p><p><strong>Added in TypeScript:</strong> array, tuple, enum, any, void, never</p><blockquote><h3 id="void와-never-차이"><a href="#void와-never-차이" class="headerlink" title="void와 never 차이"></a>void와 never 차이</h3><p>never는 함수가 종료하지 않아 결코 return하지 않을 때 사용된다. 무한루프 혹은 Error 메시지를 throw할 때 return type이 never이다.</p><p>void는 return 값이 없을 뿐이지 함수는 종료한다.</p></blockquote><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> list1: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> list2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Generic Array Type</span></span><br></pre></td></tr></table></figure><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> tuple: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];</span><br><span class="line">tuple = [<span class="hljs-string">'hello'</span>, <span class="hljs-number">10</span>];</span><br><span class="line">tuple.push(<span class="hljs-string">'good'</span>, <span class="hljs-number">30</span>);</span><br></pre></td></tr></table></figure><p>배열인데 고정된 element의 수만큼 type을 미리 선언한다.</p><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">enum</span> Season &#123;Spring, Summer, Fall, Winter&#125;;</span><br><span class="line"><span class="hljs-keyword">let</span> s1: Season = Season.Spring;</span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>TypeScript가 지원하는 Class는 ES6의 Class와 유사하지만 몇 가지 고유한 확장 기능을 가진다.</p><h3 id="1-Class-Definition"><a href="#1-Class-Definition" class="headerlink" title="1. Class Definition"></a>1. Class Definition</h3><p>ES6 Class와 다르게 constructor 외부, 즉 <strong>Class body에 Class field를 미리 선언해야 한다.</strong> 그렇지 않으면 Error가 발생한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Circle &#123;</span><br><span class="line">    <span class="hljs-comment">// Class field 미리 선언</span></span><br><span class="line">    radius: <span class="hljs-built_in">number</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">radius: <span class="hljs-built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor의 parameter에 Access Identifier를 사용하면 아래와 같이 선언할 수 있다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Circle &#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> radius</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// this.radius = radius;도 안 해줘도 됨</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Access-Identifier"><a href="#2-Access-Identifier" class="headerlink" title="2. Access Identifier"></a>2. Access Identifier</h3><ul><li>public : Class 내부, Child Class 내부, Class Instance에서 접근 가능</li><li>protected: Class 내부, Child Class 내부에서 접근 가능</li><li>private: Class 내부에서만 접근 가능</li></ul><p>Access identifier를 지정해주지 않으면 암묵적으로 public이 된다. 따라서 public으로 지정하고자 하는 Member variable과 method는 access identifier를 생략한다.</p><p>constructor parameter를 선언할 때 public를 붙이면 할당까지 이루어지고 Class 내부의 member variable이 된다. public을 쓰지 않으면 constructor 내부에서만 참조 가능한 지역 변수가 된다.</p><h3 id="3-readonly-Keyword"><a href="#3-readonly-Keyword" class="headerlink" title="3. readonly Keyword"></a>3. readonly Keyword</h3><p><code>readonly</code>가 선언된 클래스 프로퍼티는 선언할 때 또는 생성자 내부에서만 값을 할당할 수 있다. 그 외의 경우에는 값을 할당할 수 없고 오직 읽기만 가능한 상태가 된다. 상수를 선언할 때 사용한다.</p><h3 id="4-static-Keyword"><a href="#4-static-Keyword" class="headerlink" title="4. static Keyword"></a>4. static Keyword</h3><p>메소드 뿐만 아니라 프로퍼티도 static으로 지정할 수 있다.</p><h3 id="5-Abstract-Class"><a href="#5-Abstract-Class" class="headerlink" title="5. Abstract Class"></a>5. Abstract Class</h3><p>Abstract class는 <strong>하나 이상의 abstract method를 포함</strong>하며 일반 method도 가질 수 있다. Abstract method란 구현 없이 method 이름과 type만이 선언된 method를 말한다. 선언시 <code>abstract</code> 키워드를 사용한다.</p><p>Abstract class는 <strong>직접 instance를 생성할 수 없고 상속만을 위해 사용된다.</strong> <strong>Abstract class를 상속한 class는 반드시 abstract class의 abstract method를 구현해야 한다.</strong></p><p>Interface는 모든 method가 abstract이다.</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface는 일반적으로 type check를 위해서 사용된다. 변수, 함수, 클래스에 사용할 수 있다.</p><p>Interface는 여러가지 type을 갖는 property로 이루어진 새로운 type을 정의하는 것과 같다. Interface에 선언된 property와 method의 구현을 강제해서 일관성을 유지할 수 있게 한다.</p><h3 id="1-Variable-and-Interface"><a href="#1-Variable-and-Interface" class="headerlink" title="1. Variable and Interface"></a>1. Variable and Interface</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Definition of interface</span></span><br><span class="line"><span class="hljs-keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="hljs-built_in">number</span>;</span><br><span class="line">  content: <span class="hljs-built_in">string</span>;</span><br><span class="line">  completed: <span class="hljs-built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 변수의 type으로 interface Todo를 선언</span></span><br><span class="line"><span class="hljs-keyword">let</span> todo: Todo;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 변수 todo는 Todo interface를 따라야한다.</span></span><br><span class="line">todo = &#123; id: <span class="hljs-number">1</span>, content: <span class="hljs-string">'typescript'</span>, completed: <span class="hljs-literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수 parameter를 interface Todo로 선언</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span>(<span class="hljs-params">todo: Todo</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>필요에 따라서 새로운 타입을 생성하는 것과 같다. 함수의 parameter 선언시에도 interface를 사용하여 전달되는 argument의 type 형식을 제한할 수 있다.</p><h3 id="2-Function-and-Interface"><a href="#2-Function-and-Interface" class="headerlink" title="2. Function and Interface"></a>2. Function and Interface</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 함수 인터페이스의 정의</span></span><br><span class="line"><span class="hljs-keyword">interface</span> SquareFunc &#123;</span><br><span class="line">  (num: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수 인테페이스를 구현하는 함수는 인터페이스를 따라야 한다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> squareFunc: SquareFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num: <span class="hljs-built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(squareFunc(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 100</span></span><br></pre></td></tr></table></figure><p>잘 안 씀</p><h3 id="3-Class-and-Interface"><a href="#3-Class-and-Interface" class="headerlink" title="3. Class and Interface"></a>3. Class and Interface</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 인터페이스의 정의</span></span><br><span class="line"><span class="hljs-keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>;</span><br><span class="line">  sayHello(): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">인터페이스를 구현하는 클래스는 인터페이스에서 정의한 프로퍼티와 추상 메소드를 반드시 구현하여야 한다.</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-keyword">class</span> Person <span class="hljs-keyword">implements</span> IPerson &#123;</span><br><span class="line">  <span class="hljs-comment">// 인터페이스에서 정의한 프로퍼티의 구현</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 인터페이스에서 정의한 추상 메소드의 구현</span></span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;this.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span>(<span class="hljs-params">person: IPerson</span>): <span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">  person.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> me = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Lee'</span>);</span><br><span class="line">greeter(me); <span class="hljs-comment">// Hello Lee</span></span><br></pre></td></tr></table></figure><h3 id="4-Duck-Typing"><a href="#4-Duck-Typing" class="headerlink" title="4. Duck Typing"></a>4. Duck Typing</h3><p>Interface를 implements해서 구현하지 않아도, 해당 interface 내부의 property나 method를 모두 구현하면 type check에서 통과된다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> IDuck &#123; <span class="hljs-comment">// 1</span></span><br><span class="line">  quack(): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> MallardDuck <span class="hljs-keyword">implements</span> IDuck &#123; <span class="hljs-comment">// 3</span></span><br><span class="line">  quack() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Quack!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> RedheadDuck &#123; <span class="hljs-comment">// 4</span></span><br><span class="line">  quack() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'q~uack!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeNoise</span>(<span class="hljs-params">duck: IDuck</span>): <span class="hljs-title">void</span> </span>&#123; <span class="hljs-comment">// 2</span></span><br><span class="line">  duck.quack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeNoise(<span class="hljs-keyword">new</span> MallardDuck()); <span class="hljs-comment">// Quack!</span></span><br><span class="line">makeNoise(<span class="hljs-keyword">new</span> RedheadDuck()); <span class="hljs-comment">// q~uack! // 5</span></span><br></pre></td></tr></table></figure><p>Interface IDuck을 명시적으로 implements하지 않은 RedheadDuck의 instance도 IDuck 내부를 완벽하게 구현했다면 type이 IDuck으로 인정된다.</p><p>즉, implements 여부가 아니라 interface 구현 여부가 check된다.</p><h3 id="5-Optional-Property-in-Interface"><a href="#5-Optional-Property-in-Interface" class="headerlink" title="5. Optional Property in Interface"></a>5. Optional Property in Interface</h3><p>Interface 내부에서 <code>?</code>가 붙은 property는 구현을 생략해도 된다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> StudentInfo &#123;</span><br><span class="line">name: <span class="hljs-built_in">string</span>;</span><br><span class="line"><span class="hljs-built_in">number</span>: <span class="hljs-built_in">string</span>;</span><br><span class="line">age? : <span class="hljs-built_in">number</span>;</span><br><span class="line">address? : <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p>C나 C++ 등 정적 타입 언어에서는 함수 또는 클래스를 정의할 때 parameter나 return 값의 타입을 선언해야 한다. TypeScript도 정적 타입 언어이므로 정의 시점에 타입을 선언해야하는데, 함수 또는 클래스를 정의할 때 parameter나 return type을 선언하기 어려운 경우가 있다.</p><p>TypeScript는 선언시 타입을 지정하지 않으면 any타입이 되어 type check를 할 수 없게 된다. Stack이나 Queue를 구현하는 경우 배열에 어떤 type을 담을 것인지 정의할 때 확정짓기 어렵다. 이런 경우에 Generic을 사용한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Stack&lt;T&gt; &#123;</span><br><span class="line">  <span class="hljs-keyword">protected</span> data: <span class="hljs-built_in">Array</span>&lt;T&gt; = [];</span><br><span class="line">  push(item: T) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  pop(): T &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 class Stack을 정의할 때 타입을 따로 지정하지 않고 <code>&lt;T&gt;</code>를 사용했다. <code>&lt;T&gt;</code>는 Type Paremeter이며 Type의 약자이다. 어느 type이던 사용할 수 있음을 의미한다. </p><p>Generic은 선언 시점이 아니라 생성 시점에 타이블 명시해서 다양항 타입을 사용할 수 있도록 하는 기법이다. </p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">items: T[]</span>): <span class="hljs-title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> items.sort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위는 함수에서 Generic을 사용한 것이다. 어떤 type으로 이루어지는지는 모르지만 배열을 parameter로 받아서 sorting한 배열을 리턴한다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TypeScript의-주요-기능&quot;&gt;&lt;a href=&quot;#TypeScript의-주요-기능&quot; class=&quot;headerlink&quot; title=&quot;TypeScript의 주요 기능&quot;&gt;&lt;/a&gt;TypeScript의 주요 기능&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Type-Declaration&quot;&gt;타입 선언&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Class&quot;&gt;Class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Interface&quot;&gt;Interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Generic&quot;&gt;Generic&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://sub2n.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://sub2n.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript (1)</title>
    <link href="https://sub2n.github.io/2019/06/12/TypeScript-1/"/>
    <id>https://sub2n.github.io/2019/06/12/TypeScript-1/</id>
    <published>2019-06-12T09:15:55.000Z</published>
    <updated>2019-06-13T05:25:21.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>JavaScript는 모듈 기능을 지원하지 않고, 동적 타입 언어라는 단점 때문에 대형 프로젝트를 진행하기에 불편한 점이 많았다. 따라서 JavaScript의 단점을 보완하고자 하는 AltJS(Alternative) 언어들이 출시되었다. 브라우저는 JavaScript만을 인식하므로 AltJS 를 사용하더라도 JavaScript로 Compile해야한다.</p><p>TypeScript도 AltJS 중 하나로, JavaScript의 Superset(상위 호환)이라는 특징을 가진다. TypeScript는 ES5의 Superset이므로 기존 JavaScript 문법을 그대로 사용할 수 있다. 또한 Babel 등의 Transpiler를 사용하지 않아도 ES6의 새로운 기능을 기존 브라우저에서 실행할 수 있다. TypeScript의 가장 주된 장점은 Static Type을 지원한다는 것이다.</p><p>Angular가 TypeScript를 정식 채용하고 ECMAScript의 업그레이드되는 기능을 지속적으로 추가할 예정으로 많은 주목을 받고 있다.</p><a id="more"></a><h2 id="TypeScript-장점"><a href="#TypeScript-장점" class="headerlink" title="TypeScript 장점"></a>TypeScript 장점</h2><h3 id="1-정적-타입"><a href="#1-정적-타입" class="headerlink" title="1. 정적 타입"></a>1. 정적 타입</h3><p>TypeScript의 가장 큰 장점은 정적 타입을 지원하는 것이다. 변수의 타입이 없고 할당되는 값에 따라 타입이 정해지는 동적 타입 언어인 JavaScript는 type check를 해야하는 불편함이 있다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript는 명시적으로 정적 타입을 지정해 개발자의 의도대로 코드를 작성할 수 있다. 이는 코드의 가독성을 높여 효율적인 디버깅이 가능하다.</p><h3 id="2-도구의-지원"><a href="#2-도구의-지원" class="headerlink" title="2. 도구의 지원"></a>2. 도구의 지원</h3><p>IDE 기능을 사용할 수 있다.</p><h3 id="3-강력한-객체지향-프로그래밍-지원"><a href="#3-강력한-객체지향-프로그래밍-지원" class="headerlink" title="3. 강력한 객체지향 프로그래밍 지원"></a>3. 강력한 객체지향 프로그래밍 지원</h3><h3 id="4-ES6-ES-Next-지원"><a href="#4-ES6-ES-Next-지원" class="headerlink" title="4. ES6 / ES Next 지원"></a>4. ES6 / ES Next 지원</h3><p>Babel 없이도 ES6과 그 이상 버전을 지원하고 Babel보다 신기술에 빠르게 대응한다는 장점이 있다.</p><h3 id="5-Angular"><a href="#5-Angular" class="headerlink" title="5. Angular"></a>5. Angular</h3><p>Angular에서 TypeScript를 강력하게 지원한다.</p><blockquote><h4 id="HTML-code-내부에서-JavaScript를-보는-것과-JavaScript-code-내부에서-HTML을-보는-것의-차이"><a href="#HTML-code-내부에서-JavaScript를-보는-것과-JavaScript-code-내부에서-HTML을-보는-것의-차이" class="headerlink" title="HTML code 내부에서 JavaScript를 보는 것과, JavaScript code 내부에서 HTML을 보는 것의 차이"></a>HTML code 내부에서 JavaScript를 보는 것과, JavaScript code 내부에서 HTML을 보는 것의 차이</h4><p>JavaScript 내부에서 HTML element를 보면, 즉 querySelector를 사용해서 HTML Element에 접근하고 무언가 수행하면 Angular의 기본 원칙에 어긋난다. Angular는 기본적으로 HTML이 JavaScript에 영향을 받는 방식으로 HTML이 수정되어도 JavaScript code가 영항받지 않는다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h2&gt;&lt;p&gt;JavaScript는 모듈 기능을 지원하지 않고, 동적 타입 언어라는 단점 때문에 대형 프로젝트를 진행하기에 불편한 점이 많았다. 따라서 JavaScript의 단점을 보완하고자 하는 AltJS(Alternative) 언어들이 출시되었다. 브라우저는 JavaScript만을 인식하므로 AltJS 를 사용하더라도 JavaScript로 Compile해야한다.&lt;/p&gt;
&lt;p&gt;TypeScript도 AltJS 중 하나로, JavaScript의 Superset(상위 호환)이라는 특징을 가진다. TypeScript는 ES5의 Superset이므로 기존 JavaScript 문법을 그대로 사용할 수 있다. 또한 Babel 등의 Transpiler를 사용하지 않아도 ES6의 새로운 기능을 기존 브라우저에서 실행할 수 있다. TypeScript의 가장 주된 장점은 Static Type을 지원한다는 것이다.&lt;/p&gt;
&lt;p&gt;Angular가 TypeScript를 정식 채용하고 ECMAScript의 업그레이드되는 기능을 지속적으로 추가할 예정으로 많은 주목을 받고 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://sub2n.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://sub2n.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>190611-TIL</title>
    <link href="https://sub2n.github.io/2019/06/11/190611-TIL/"/>
    <id>https://sub2n.github.io/2019/06/11/190611-TIL/</id>
    <published>2019-06-11T08:18:05.000Z</published>
    <updated>2019-06-11T08:18:50.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>SPA (Sigle Page Application)에 대해서 배웠다.</li><li>JavaScript Class를 복습했다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SPA (Sigle P
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190610-TIL</title>
    <link href="https://sub2n.github.io/2019/06/10/190610-TIL/"/>
    <id>https://sub2n.github.io/2019/06/10/190610-TIL/</id>
    <published>2019-06-10T02:15:08.000Z</published>
    <updated>2019-06-11T04:11:44.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Tab UI를 만들었다.</li><li>Accordian UI를 만들었다.</li><li>Range Slider UI를 만들었다.</li><li>셋을 합쳤다.</li><li>jQuery로 구현된 코드를 Vanilla JavaScript로 고쳤다.</li></ul><p><a href="https://github.com/Sub2n/JavaScript-Exercise/blob/master/README.md#ui-exercise" target="_blank" rel="noopener">✨UI Exercise</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Tab UI를 만들었다
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
</feed>
