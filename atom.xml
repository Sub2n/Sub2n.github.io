<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>수빈 개발블로그</title>
  
  <subtitle>Sub2n Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sub2n.github.io/"/>
  <updated>2019-06-17T06:26:32.219Z</updated>
  <id>https://sub2n.github.io/</id>
  
  <author>
    <name>Subin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Angular Data Binding</title>
    <link href="https://sub2n.github.io/2019/06/17/Angular-Data-Binding/"/>
    <id>https://sub2n.github.io/2019/06/17/Angular-Data-Binding/</id>
    <published>2019-06-17T05:35:22.000Z</published>
    <updated>2019-06-17T06:26:32.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Interpolation"><a href="#Interpolation" class="headerlink" title="Interpolation"></a>Interpolation</h2><p><code></code></p><h2 id="Property-Binding"><a href="#Property-Binding" class="headerlink" title="Property Binding"></a>Property Binding</h2><p><code>[propertyName] = &quot;expression&quot;</code></p><p><code>&quot; &quot;</code> 내부에는 string이 아니라 expression(표현식)이 오는 곳이므로 주의하자.</p><blockquote><h4 id="Attribute-and-Property"><a href="#Attribute-and-Property" class="headerlink" title="Attribute and Property"></a>Attribute and Property</h4><p>Attribute는 HTML Element의 attribute이고 Property는 DOM node object인 HTML Element 객체의 property이다. 초기에 HTML Attribute가 초기값으로 그려지고 Property는 실시간으로 변경되는 DOM 최신값을 반영한다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Initial Value"</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"Property Value"</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>앞의 value는 attribute이고 [value]는 property이다. Property는 최신값이므로 실행시 “Property Value”가 view에 보여지게 된다.</p></blockquote><h2 id="Attribute-Binding"><a href="#Attribute-Binding" class="headerlink" title="Attribute Binding"></a>Attribute Binding</h2><p><code>[attr.attName] = &quot;expression&quot;</code></p><p>Property와 달리 <code>attr.</code>를 붙여줘야 한다.</p><p>HTML Element의 Property와 Attribute는 항상 1 대 1로 대응하지 않는다. HTML Element 별로 어떤 Attribute와 Property가 있는지 알고 있어야 한다.</p><h2 id="Class-Binding"><a href="#Class-Binding" class="headerlink" title="Class Binding"></a>Class Binding</h2><p>Class binding은 2가지 방법으로 사용할 수 있다. </p><h5 id="class-className-quot-expression-quot"><a href="#class-className-quot-expression-quot" class="headerlink" title="[class.className] = &quot;expression&quot;"></a><code>[class.className] = &quot;expression&quot;</code></h5><p>expression의 평가 결과가 true일 때는 class를 적용하고, false일 때는 class를 적용하지 않는다. classList.add와 remove를 간단하게 할 수 있다.</p><h5 id="class-quot-className-List-quot"><a href="#class-quot-className-List-quot" class="headerlink" title="[class]=&quot;className List&quot;"></a><code>[class]=&quot;className List&quot;</code></h5><p>class에 className List를 적용한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classNames = <span class="hljs-string">'active red block'</span></span><br></pre></td></tr></table></figure><h2 id="Event-Binding"><a href="#Event-Binding" class="headerlink" title="Event Binding"></a>Event Binding</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Interpolation&quot;&gt;&lt;a href=&quot;#Interpolation&quot; class=&quot;headerlink&quot; title=&quot;Interpolation&quot;&gt;&lt;/a&gt;Interpolation&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular Component</title>
    <link href="https://sub2n.github.io/2019/06/14/Angular-Component/"/>
    <id>https://sub2n.github.io/2019/06/14/Angular-Component/</id>
    <published>2019-06-14T07:00:45.000Z</published>
    <updated>2019-06-14T07:59:22.647Z</updated>
    
    <content type="html"><![CDATA[<p>Angular Application은 component를 중심으로 구성되는만큼 component는 Angular의 핵심 개념이다.</p><p>Component는 application의 화면을 구성하는 View를 생성하고 관리한다. </p><p>Component는 template의 중첩 관계에 의해서 tree 구조를 갖는다. 여러 component 사이의 통신과 상태 관리를 위해서 Service가 있다.</p><a id="more"></a><h4 id="Compnonent-decorator"><a href="#Compnonent-decorator" class="headerlink" title="@Compnonent : decorator"></a>@Compnonent : decorator</h4><h4 id="Component-Metadata"><a href="#Component-Metadata" class="headerlink" title="Component Metadata"></a>Component Metadata</h4><p><img src="https://user-images.githubusercontent.com/48080762/59491021-0679f900-8ec1-11e9-9db7-31c3af5cce5d.png" alt="component metadata"></p><h4 id="export-class"><a href="#export-class" class="headerlink" title="export class"></a>export class</h4><p><img src="https://user-images.githubusercontent.com/48080762/59491315-6e304400-8ec1-11e9-9e53-ddff4b4861e9.png" alt="export class"></p><h4 id="Add-Component-to-app-module-ts"><a href="#Add-Component-to-app-module-ts" class="headerlink" title="Add Component to app.module.ts"></a>Add Component to app.module.ts</h4><p><img src="https://user-images.githubusercontent.com/48080762/59491403-a172d300-8ec1-11e9-8961-b685478fd3d6.png" alt="component declaration"></p><h4 id="Parent에서-Child로-data-보내는-법-Property-Binding"><a href="#Parent에서-Child로-data-보내는-법-Property-Binding" class="headerlink" title="Parent에서 Child로 data 보내는 법 : Property Binding"></a>Parent에서 Child로 data 보내는 법 : Property Binding</h4><p>parent Component는 자신의 template에 Child Component를 담고 있으므로 Child Component를 알 수 있다. 따라서 data를 쉽게 전송할 수 있다.</p><ol><li><p>Parent Component에서 Child의 Property로 값을 전달한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// app.component.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-root'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;!--The content below is only a placeholder and can be replaced.--&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;app-hello [hi]="greeting"&gt;&lt;/app-hello&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: []</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;</span><br><span class="line">  greeting = <span class="hljs-string">'hello'</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Child에서 @Input decorator로 Proterty value를 전달받는다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// hello.component.ts</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Component, Input &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"@angular/core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  <span class="hljs-comment">// metadata</span></span><br><span class="line">  selector: <span class="hljs-string">'app-hello'</span>,</span><br><span class="line">  template: <span class="hljs-string">`&lt;h1&gt;&#123;&#123;hi&#125;&#125;&lt;/h1&gt;`</span>,</span><br><span class="line">  styles: [<span class="hljs-string">``</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HelloComponent &#123;</span><br><span class="line">  <span class="hljs-comment">// class Field</span></span><br><span class="line">  <span class="hljs-meta">@Input</span>() hi: <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Child-Component에서-Parent-Component로-data-보내는-법-Event-발생"><a href="#Child-Component에서-Parent-Component로-data-보내는-법-Event-발생" class="headerlink" title="Child Component에서 Parent Component로 data 보내는 법 : Event 발생"></a>Child Component에서 Parent Component로 data 보내는 법 : Event 발생</h4><p>Child Component는 Parent Component를 모르므로 Event를 발생시켜 Parent Component에서 Event를 Handling하는 방식으로 data를 전송한다.</p><ol><li><p>@Output, EventEmitter를 이용해서 Child Component에서 Event를 발생시킨다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component, Input, Output, EventEmitter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"@angular/core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  <span class="hljs-comment">// metadata</span></span><br><span class="line">  selector: <span class="hljs-string">'app-hello'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;h1&gt;&#123;&#123;hi&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;button (click)="greeting.emit('Hello')"&gt;greeting&lt;/button&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: [<span class="hljs-string">``</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HelloComponent &#123;</span><br><span class="line">  <span class="hljs-comment">// class Field</span></span><br><span class="line">  <span class="hljs-meta">@Input</span>() hi: <span class="hljs-built_in">string</span>;</span><br><span class="line">  <span class="hljs-meta">@Output</span>() greeting = <span class="hljs-keyword">new</span> EventEmitter&lt;<span class="hljs-built_in">string</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Output으로 선언한 method는 emit으로 argument를 전달할 수 있다.</p></li><li><p>Parent Component에서는 Event Handler를 이용해서 Event를 처리한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="hljs-string">'app-root'</span>,</span><br><span class="line">  template: <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">    &lt;!--The content below is only a placeholder and can be replaced.--&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;app-hello</span></span><br><span class="line"><span class="hljs-string">      [hi]="greeting"</span></span><br><span class="line"><span class="hljs-string">      (greeting)="changeGreet($event)"</span></span><br><span class="line"><span class="hljs-string">    &gt;&lt;/app-hello&gt;</span></span><br><span class="line"><span class="hljs-string">  `</span>,</span><br><span class="line">  styles: []</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;</span><br><span class="line">  greeting = <span class="hljs-string">'Hi~~!!!!'</span>;</span><br><span class="line">  changeGreet(greet: <span class="hljs-built_in">string</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.greeting = greet;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;app-hello&gt;</code> 내부에서 event greeting의 event handler를 등록하고 class 내부에서 정의한다. $event로 parameter에 argument 값을 받아온다.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Angular Application은 component를 중심으로 구성되는만큼 component는 Angular의 핵심 개념이다.&lt;/p&gt;
&lt;p&gt;Component는 application의 화면을 구성하는 View를 생성하고 관리한다. &lt;/p&gt;
&lt;p&gt;Component는 template의 중첩 관계에 의해서 tree 구조를 갖는다. 여러 component 사이의 통신과 상태 관리를 위해서 Service가 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sub2n.github.io/2019/06/14/Untitled/"/>
    <id>https://sub2n.github.io/2019/06/14/Untitled/</id>
    <published>2019-06-14T04:21:07.181Z</published>
    <updated>2019-06-14T04:21:07.181Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Angular Basics</title>
    <link href="https://sub2n.github.io/2019/06/14/Angular-Basics/"/>
    <id>https://sub2n.github.io/2019/06/14/Angular-Basics/</id>
    <published>2019-06-14T03:59:45.000Z</published>
    <updated>2019-06-14T07:03:39.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>Angular는 SPA(Single Page Application) 개발을 위한 Google의 Open source JavaScript <strong>Framework</strong>.</p><blockquote><h4 id="Framework-and-Library"><a href="#Framework-and-Library" class="headerlink" title="Framework and Library"></a>Framework and Library</h4><p>Library는 관련있는 함수를 모아놓아 개발자가 사용할 수 있는 도구이다. 즉, Library는 개발자에 의해 사용된다.</p><p>Framework는 클래스와 인터페이스의 집합으로 Application의 Flow를 쥐고 있다. 개발자가 Framework 틀 내부에서 작업하는 것이다.</p></blockquote><p>전통적인 웹 개발에서 JavaScript는 HTML/CSS에 의존한다. 의존한다는 것은 HTML/CSS에 접근해서 조작하는 방식으로 JavaScript 코드가 작성되었다는 것을 뜻한다. 이는 HTML/CSS가 변경되면 JavaScript 코드도 영향을 받음을 의미한다.</p><p>Angular는 HTML/CSS가 JavaScript에 의존하도록, 즉 JavaScript 코드의 상태 데이터 (State)에 바인딩해서 상태가 변경될 때마다 Rendering되도록 한다. HTML/CSS를 JavaScript의 Rendering 함수 내부의 문자열로 관리하면 앞서 말한 동작이 가능하다.</p><a id="more"></a><h2 id="Advantages-of-Angular"><a href="#Advantages-of-Angular" class="headerlink" title="Advantages of Angular"></a>Advantages of Angular</h2><ol><li>컴포넌트 기반 개발(CBD: Component Based Development) 로 생산성이 좋다.  Web에서 컴포넌트 기반 개발이 어려운 이유는 CSS가 서로에게 영향을 주기 때문인데,  Component 별로 CSS를 분리해내는 게 중요하다.</li><li>TypeScript 사용으로 정적 타이핑, ES6과 ESNext의 기능을 지원한다.</li><li>Angular는 대부분의 모던 브라우저를 지원한다. IE는 9 이상을 지원한다.</li></ol><h2 id="Angular-Project"><a href="#Angular-Project" class="headerlink" title="Angular Project"></a>Angular Project</h2><h4 id="app-component"><a href="#app-component" class="headerlink" title="app.component"></a>app.component</h4><p>Application의 root Component로, 실행 기본 page. (index.html처럼)</p><p><img src="https://user-images.githubusercontent.com/48080762/59484774-13d9b800-8eae-11e9-9762-ee95824f338f.png" alt="app.component"></p><h5 id="app-component-spec-ts"><a href="#app-component-spec-ts" class="headerlink" title="app.component.spec.ts"></a>app.component.spec.ts</h5><p>test specification</p><h5 id="ng-build-후-map-file"><a href="#ng-build-후-map-file" class="headerlink" title="ng build 후 map file"></a>ng build 후 map file</h5><p>디버깅용</p><h4 id="app-module"><a href="#app-module" class="headerlink" title="app.module"></a>app.module</h4><p>전체 모듈을 관리하므로 component 추가시 module에 추가됨</p><p><img src="https://user-images.githubusercontent.com/48080762/59485300-379dfd80-8eb0-11e9-987c-8154db2b8663.png" alt="app.module"></p><p>Component 생성 후 module file의 declarations에 추가해줘야함</p><h4 id="Generate-Component-Shortcut"><a href="#Generate-Component-Shortcut" class="headerlink" title="Generate Component Shortcut"></a>Generate Component Shortcut</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng g c service -s -t --skip-tests (-S)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/48080762/59485613-78e2dd00-8eb1-11e9-86da-a3d210def751.png" alt="shortcut"></p><h4 id="ng-generate"><a href="#ng-generate" class="headerlink" title="ng generate"></a>ng generate</h4><table><thead><tr><th>component</th><th>UI를 만들기 위해서 존재</th></tr></thead><tbody><tr><td>sercive</td><td>component와 직접적인 연관이 없는 state 관리</td></tr></tbody></table><p>component가 활성화된다 =&gt; component가 메모리에 올라가면 view가 보임</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="hljs-string">'이거슨 java'</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'이거슨 JavaScript'</span>);</span><br><span class="line">printf(<span class="hljs-string">'이거슨 C'</span>);</span><br><span class="line">cout&lt;&lt;<span class="hljs-string">'이거슨 c++'</span>;</span><br><span class="line">print(<span class="hljs-string">'이거슨 python'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Angular&quot;&gt;&lt;a href=&quot;#Angular&quot; class=&quot;headerlink&quot; title=&quot;Angular&quot;&gt;&lt;/a&gt;Angular&lt;/h2&gt;&lt;p&gt;Angular는 SPA(Single Page Application) 개발을 위한 Google의 Open source JavaScript &lt;strong&gt;Framework&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;Framework-and-Library&quot;&gt;&lt;a href=&quot;#Framework-and-Library&quot; class=&quot;headerlink&quot; title=&quot;Framework and Library&quot;&gt;&lt;/a&gt;Framework and Library&lt;/h4&gt;&lt;p&gt;Library는 관련있는 함수를 모아놓아 개발자가 사용할 수 있는 도구이다. 즉, Library는 개발자에 의해 사용된다.&lt;/p&gt;
&lt;p&gt;Framework는 클래스와 인터페이스의 집합으로 Application의 Flow를 쥐고 있다. 개발자가 Framework 틀 내부에서 작업하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;전통적인 웹 개발에서 JavaScript는 HTML/CSS에 의존한다. 의존한다는 것은 HTML/CSS에 접근해서 조작하는 방식으로 JavaScript 코드가 작성되었다는 것을 뜻한다. 이는 HTML/CSS가 변경되면 JavaScript 코드도 영향을 받음을 의미한다.&lt;/p&gt;
&lt;p&gt;Angular는 HTML/CSS가 JavaScript에 의존하도록, 즉 JavaScript 코드의 상태 데이터 (State)에 바인딩해서 상태가 변경될 때마다 Rendering되도록 한다. HTML/CSS를 JavaScript의 Rendering 함수 내부의 문자열로 관리하면 앞서 말한 동작이 가능하다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
      <category term="Angular" scheme="https://sub2n.github.io/categories/JavaScript/Angular/"/>
    
    
      <category term="Angular" scheme="https://sub2n.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>190612-TIL</title>
    <link href="https://sub2n.github.io/2019/06/12/190612-TIL/"/>
    <id>https://sub2n.github.io/2019/06/12/190612-TIL/</id>
    <published>2019-06-12T10:34:40.000Z</published>
    <updated>2019-06-13T01:37:01.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>TypeScript에 대해서 배우고 실습해봤다.</li><li>Angular로 간단한 TodoList 기능을 구현해봤다. 맛보기만 해봤지만 재밌다! 그리고 엄청 편하다.</li><li>TypeScript는 기존에 알고 있던 객체지향개념(Class, Interface 등)이 있어 사용하기 편리할 것 같다. </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TypeScript에 
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript (2)</title>
    <link href="https://sub2n.github.io/2019/06/12/TypeScript-2/"/>
    <id>https://sub2n.github.io/2019/06/12/TypeScript-2/</id>
    <published>2019-06-12T09:16:03.000Z</published>
    <updated>2019-06-13T05:53:12.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TypeScript의-주요-기능"><a href="#TypeScript의-주요-기능" class="headerlink" title="TypeScript의 주요 기능"></a>TypeScript의 주요 기능</h4><ol><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Type-Declaration">타입 선언</a></li><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Class">Class</a></li><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Interface">Interface</a></li><li><a href="https://sub2n.github.io/2019/06/12/TypeScript-2/#Generic">Generic</a></li></ol><a id="more"></a><h2 id="Type-Declaration"><a href="#Type-Declaration" class="headerlink" title="Type Declaration"></a>Type Declaration</h2><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 선언과 동시에 할당할 때는 바로 그 type으로 지정됨</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mult</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parameter의 type을 모두 명시해준 경우 Return type은 추론이 가능하므로 생략이 가능하다. Type은 any가 나오지 않게끔만 지정하면 된다.</p><p><code>void</code>: return을 하지 않는다. 사실은 <code>undefined</code>가 return되지만 <code>void</code>라고 한다.</p><h4 id="Types-of-TypeScript"><a href="#Types-of-TypeScript" class="headerlink" title="Types of TypeScript"></a>Types of TypeScript</h4><p><strong>From JavaScript:</strong> boolean,  null, undefined, number, string, symbol, object</p><p><strong>Added in TypeScript:</strong> array, tuple, enum, any, void, never</p><blockquote><h3 id="void와-never-차이"><a href="#void와-never-차이" class="headerlink" title="void와 never 차이"></a>void와 never 차이</h3><p>never는 함수가 종료하지 않아 결코 return하지 않을 때 사용된다. 무한루프 혹은 Error 메시지를 throw할 때 return type이 never이다.</p><p>void는 return 값이 없을 뿐이지 함수는 종료한다.</p></blockquote><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> list1: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> list2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Generic Array Type</span></span><br></pre></td></tr></table></figure><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> tuple: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];</span><br><span class="line">tuple = [<span class="hljs-string">'hello'</span>, <span class="hljs-number">10</span>];</span><br><span class="line">tuple.push(<span class="hljs-string">'good'</span>, <span class="hljs-number">30</span>);</span><br></pre></td></tr></table></figure><p>배열인데 고정된 element의 수만큼 type을 미리 선언한다.</p><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">enum</span> Season &#123;Spring, Summer, Fall, Winter&#125;;</span><br><span class="line"><span class="hljs-keyword">let</span> s1: Season = Season.Spring;</span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>TypeScript가 지원하는 Class는 ES6의 Class와 유사하지만 몇 가지 고유한 확장 기능을 가진다.</p><h3 id="1-Class-Definition"><a href="#1-Class-Definition" class="headerlink" title="1. Class Definition"></a>1. Class Definition</h3><p>ES6 Class와 다르게 constructor 외부, 즉 <strong>Class body에 Class field를 미리 선언해야 한다.</strong> 그렇지 않으면 Error가 발생한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Circle &#123;</span><br><span class="line">    <span class="hljs-comment">// Class field 미리 선언</span></span><br><span class="line">    radius: <span class="hljs-built_in">number</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params">radius: <span class="hljs-built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor의 parameter에 Access Identifier를 사용하면 아래와 같이 선언할 수 있다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Circle &#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> radius</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// this.radius = radius;도 안 해줘도 됨</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Access-Identifier"><a href="#2-Access-Identifier" class="headerlink" title="2. Access Identifier"></a>2. Access Identifier</h3><ul><li>public : Class 내부, Child Class 내부, Class Instance에서 접근 가능</li><li>protected: Class 내부, Child Class 내부에서 접근 가능</li><li>private: Class 내부에서만 접근 가능</li></ul><p>Access identifier를 지정해주지 않으면 암묵적으로 public이 된다. 따라서 public으로 지정하고자 하는 Member variable과 method는 access identifier를 생략한다.</p><p>constructor parameter를 선언할 때 public를 붙이면 할당까지 이루어지고 Class 내부의 member variable이 된다. public을 쓰지 않으면 constructor 내부에서만 참조 가능한 지역 변수가 된다.</p><h3 id="3-readonly-Keyword"><a href="#3-readonly-Keyword" class="headerlink" title="3. readonly Keyword"></a>3. readonly Keyword</h3><p><code>readonly</code>가 선언된 클래스 프로퍼티는 선언할 때 또는 생성자 내부에서만 값을 할당할 수 있다. 그 외의 경우에는 값을 할당할 수 없고 오직 읽기만 가능한 상태가 된다. 상수를 선언할 때 사용한다.</p><h3 id="4-static-Keyword"><a href="#4-static-Keyword" class="headerlink" title="4. static Keyword"></a>4. static Keyword</h3><p>메소드 뿐만 아니라 프로퍼티도 static으로 지정할 수 있다.</p><h3 id="5-Abstract-Class"><a href="#5-Abstract-Class" class="headerlink" title="5. Abstract Class"></a>5. Abstract Class</h3><p>Abstract class는 <strong>하나 이상의 abstract method를 포함</strong>하며 일반 method도 가질 수 있다. Abstract method란 구현 없이 method 이름과 type만이 선언된 method를 말한다. 선언시 <code>abstract</code> 키워드를 사용한다.</p><p>Abstract class는 <strong>직접 instance를 생성할 수 없고 상속만을 위해 사용된다.</strong> <strong>Abstract class를 상속한 class는 반드시 abstract class의 abstract method를 구현해야 한다.</strong></p><p>Interface는 모든 method가 abstract이다.</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface는 일반적으로 type check를 위해서 사용된다. 변수, 함수, 클래스에 사용할 수 있다.</p><p>Interface는 여러가지 type을 갖는 property로 이루어진 새로운 type을 정의하는 것과 같다. Interface에 선언된 property와 method의 구현을 강제해서 일관성을 유지할 수 있게 한다.</p><h3 id="1-Variable-and-Interface"><a href="#1-Variable-and-Interface" class="headerlink" title="1. Variable and Interface"></a>1. Variable and Interface</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Definition of interface</span></span><br><span class="line"><span class="hljs-keyword">interface</span> Todo &#123;</span><br><span class="line">  id: <span class="hljs-built_in">number</span>;</span><br><span class="line">  content: <span class="hljs-built_in">string</span>;</span><br><span class="line">  completed: <span class="hljs-built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 변수의 type으로 interface Todo를 선언</span></span><br><span class="line"><span class="hljs-keyword">let</span> todo: Todo;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 변수 todo는 Todo interface를 따라야한다.</span></span><br><span class="line">todo = &#123; id: <span class="hljs-number">1</span>, content: <span class="hljs-string">'typescript'</span>, completed: <span class="hljs-literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수 parameter를 interface Todo로 선언</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span>(<span class="hljs-params">todo: Todo</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>필요에 따라서 새로운 타입을 생성하는 것과 같다. 함수의 parameter 선언시에도 interface를 사용하여 전달되는 argument의 type 형식을 제한할 수 있다.</p><h3 id="2-Function-and-Interface"><a href="#2-Function-and-Interface" class="headerlink" title="2. Function and Interface"></a>2. Function and Interface</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 함수 인터페이스의 정의</span></span><br><span class="line"><span class="hljs-keyword">interface</span> SquareFunc &#123;</span><br><span class="line">  (num: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수 인테페이스를 구현하는 함수는 인터페이스를 따라야 한다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> squareFunc: SquareFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num: <span class="hljs-built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(squareFunc(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 100</span></span><br></pre></td></tr></table></figure><p>잘 안 씀</p><h3 id="3-Class-and-Interface"><a href="#3-Class-and-Interface" class="headerlink" title="3. Class and Interface"></a>3. Class and Interface</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 인터페이스의 정의</span></span><br><span class="line"><span class="hljs-keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="hljs-built_in">string</span>;</span><br><span class="line">  sayHello(): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">인터페이스를 구현하는 클래스는 인터페이스에서 정의한 프로퍼티와 추상 메소드를 반드시 구현하여야 한다.</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-keyword">class</span> Person <span class="hljs-keyword">implements</span> IPerson &#123;</span><br><span class="line">  <span class="hljs-comment">// 인터페이스에서 정의한 프로퍼티의 구현</span></span><br><span class="line">  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 인터페이스에서 정의한 추상 메소드의 구현</span></span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;this.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span>(<span class="hljs-params">person: IPerson</span>): <span class="hljs-title">void</span> </span>&#123;</span><br><span class="line">  person.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> me = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Lee'</span>);</span><br><span class="line">greeter(me); <span class="hljs-comment">// Hello Lee</span></span><br></pre></td></tr></table></figure><h3 id="4-Duck-Typing"><a href="#4-Duck-Typing" class="headerlink" title="4. Duck Typing"></a>4. Duck Typing</h3><p>Interface를 implements해서 구현하지 않아도, 해당 interface 내부의 property나 method를 모두 구현하면 type check에서 통과된다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> IDuck &#123; <span class="hljs-comment">// 1</span></span><br><span class="line">  quack(): <span class="hljs-built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> MallardDuck <span class="hljs-keyword">implements</span> IDuck &#123; <span class="hljs-comment">// 3</span></span><br><span class="line">  quack() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Quack!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> RedheadDuck &#123; <span class="hljs-comment">// 4</span></span><br><span class="line">  quack() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'q~uack!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeNoise</span>(<span class="hljs-params">duck: IDuck</span>): <span class="hljs-title">void</span> </span>&#123; <span class="hljs-comment">// 2</span></span><br><span class="line">  duck.quack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeNoise(<span class="hljs-keyword">new</span> MallardDuck()); <span class="hljs-comment">// Quack!</span></span><br><span class="line">makeNoise(<span class="hljs-keyword">new</span> RedheadDuck()); <span class="hljs-comment">// q~uack! // 5</span></span><br></pre></td></tr></table></figure><p>Interface IDuck을 명시적으로 implements하지 않은 RedheadDuck의 instance도 IDuck 내부를 완벽하게 구현했다면 type이 IDuck으로 인정된다.</p><p>즉, implements 여부가 아니라 interface 구현 여부가 check된다.</p><h3 id="5-Optional-Property-in-Interface"><a href="#5-Optional-Property-in-Interface" class="headerlink" title="5. Optional Property in Interface"></a>5. Optional Property in Interface</h3><p>Interface 내부에서 <code>?</code>가 붙은 property는 구현을 생략해도 된다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> StudentInfo &#123;</span><br><span class="line">name: <span class="hljs-built_in">string</span>;</span><br><span class="line"><span class="hljs-built_in">number</span>: <span class="hljs-built_in">string</span>;</span><br><span class="line">age? : <span class="hljs-built_in">number</span>;</span><br><span class="line">address? : <span class="hljs-built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p>C나 C++ 등 정적 타입 언어에서는 함수 또는 클래스를 정의할 때 parameter나 return 값의 타입을 선언해야 한다. TypeScript도 정적 타입 언어이므로 정의 시점에 타입을 선언해야하는데, 함수 또는 클래스를 정의할 때 parameter나 return type을 선언하기 어려운 경우가 있다.</p><p>TypeScript는 선언시 타입을 지정하지 않으면 any타입이 되어 type check를 할 수 없게 된다. Stack이나 Queue를 구현하는 경우 배열에 어떤 type을 담을 것인지 정의할 때 확정짓기 어렵다. 이런 경우에 Generic을 사용한다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Stack&lt;T&gt; &#123;</span><br><span class="line">  <span class="hljs-keyword">protected</span> data: <span class="hljs-built_in">Array</span>&lt;T&gt; = [];</span><br><span class="line">  push(item: T) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  pop(): T &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 class Stack을 정의할 때 타입을 따로 지정하지 않고 <code>&lt;T&gt;</code>를 사용했다. <code>&lt;T&gt;</code>는 Type Paremeter이며 Type의 약자이다. 어느 type이던 사용할 수 있음을 의미한다. </p><p>Generic은 선언 시점이 아니라 생성 시점에 타이블 명시해서 다양항 타입을 사용할 수 있도록 하는 기법이다. </p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">items: T[]</span>): <span class="hljs-title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> items.sort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위는 함수에서 Generic을 사용한 것이다. 어떤 type으로 이루어지는지는 모르지만 배열을 parameter로 받아서 sorting한 배열을 리턴한다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TypeScript의-주요-기능&quot;&gt;&lt;a href=&quot;#TypeScript의-주요-기능&quot; class=&quot;headerlink&quot; title=&quot;TypeScript의 주요 기능&quot;&gt;&lt;/a&gt;TypeScript의 주요 기능&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Type-Declaration&quot;&gt;타입 선언&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Class&quot;&gt;Class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Interface&quot;&gt;Interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sub2n.github.io/2019/06/12/TypeScript-2/#Generic&quot;&gt;Generic&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://sub2n.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://sub2n.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript (1)</title>
    <link href="https://sub2n.github.io/2019/06/12/TypeScript-1/"/>
    <id>https://sub2n.github.io/2019/06/12/TypeScript-1/</id>
    <published>2019-06-12T09:15:55.000Z</published>
    <updated>2019-06-13T05:25:21.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>JavaScript는 모듈 기능을 지원하지 않고, 동적 타입 언어라는 단점 때문에 대형 프로젝트를 진행하기에 불편한 점이 많았다. 따라서 JavaScript의 단점을 보완하고자 하는 AltJS(Alternative) 언어들이 출시되었다. 브라우저는 JavaScript만을 인식하므로 AltJS 를 사용하더라도 JavaScript로 Compile해야한다.</p><p>TypeScript도 AltJS 중 하나로, JavaScript의 Superset(상위 호환)이라는 특징을 가진다. TypeScript는 ES5의 Superset이므로 기존 JavaScript 문법을 그대로 사용할 수 있다. 또한 Babel 등의 Transpiler를 사용하지 않아도 ES6의 새로운 기능을 기존 브라우저에서 실행할 수 있다. TypeScript의 가장 주된 장점은 Static Type을 지원한다는 것이다.</p><p>Angular가 TypeScript를 정식 채용하고 ECMAScript의 업그레이드되는 기능을 지속적으로 추가할 예정으로 많은 주목을 받고 있다.</p><a id="more"></a><h2 id="TypeScript-장점"><a href="#TypeScript-장점" class="headerlink" title="TypeScript 장점"></a>TypeScript 장점</h2><h3 id="1-정적-타입"><a href="#1-정적-타입" class="headerlink" title="1. 정적 타입"></a>1. 정적 타입</h3><p>TypeScript의 가장 큰 장점은 정적 타입을 지원하는 것이다. 변수의 타입이 없고 할당되는 값에 따라 타입이 정해지는 동적 타입 언어인 JavaScript는 type check를 해야하는 불편함이 있다.</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript는 명시적으로 정적 타입을 지정해 개발자의 의도대로 코드를 작성할 수 있다. 이는 코드의 가독성을 높여 효율적인 디버깅이 가능하다.</p><h3 id="2-도구의-지원"><a href="#2-도구의-지원" class="headerlink" title="2. 도구의 지원"></a>2. 도구의 지원</h3><p>IDE 기능을 사용할 수 있다.</p><h3 id="3-강력한-객체지향-프로그래밍-지원"><a href="#3-강력한-객체지향-프로그래밍-지원" class="headerlink" title="3. 강력한 객체지향 프로그래밍 지원"></a>3. 강력한 객체지향 프로그래밍 지원</h3><h3 id="4-ES6-ES-Next-지원"><a href="#4-ES6-ES-Next-지원" class="headerlink" title="4. ES6 / ES Next 지원"></a>4. ES6 / ES Next 지원</h3><p>Babel 없이도 ES6과 그 이상 버전을 지원하고 Babel보다 신기술에 빠르게 대응한다는 장점이 있다.</p><h3 id="5-Angular"><a href="#5-Angular" class="headerlink" title="5. Angular"></a>5. Angular</h3><p>Angular에서 TypeScript를 강력하게 지원한다.</p><blockquote><h4 id="HTML-code-내부에서-JavaScript를-보는-것과-JavaScript-code-내부에서-HTML을-보는-것의-차이"><a href="#HTML-code-내부에서-JavaScript를-보는-것과-JavaScript-code-내부에서-HTML을-보는-것의-차이" class="headerlink" title="HTML code 내부에서 JavaScript를 보는 것과, JavaScript code 내부에서 HTML을 보는 것의 차이"></a>HTML code 내부에서 JavaScript를 보는 것과, JavaScript code 내부에서 HTML을 보는 것의 차이</h4><p>JavaScript 내부에서 HTML element를 보면, 즉 querySelector를 사용해서 HTML Element에 접근하고 무언가 수행하면 Angular의 기본 원칙에 어긋난다. Angular는 기본적으로 HTML이 JavaScript에 영향을 받는 방식으로 HTML이 수정되어도 JavaScript code가 영항받지 않는다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h2&gt;&lt;p&gt;JavaScript는 모듈 기능을 지원하지 않고, 동적 타입 언어라는 단점 때문에 대형 프로젝트를 진행하기에 불편한 점이 많았다. 따라서 JavaScript의 단점을 보완하고자 하는 AltJS(Alternative) 언어들이 출시되었다. 브라우저는 JavaScript만을 인식하므로 AltJS 를 사용하더라도 JavaScript로 Compile해야한다.&lt;/p&gt;
&lt;p&gt;TypeScript도 AltJS 중 하나로, JavaScript의 Superset(상위 호환)이라는 특징을 가진다. TypeScript는 ES5의 Superset이므로 기존 JavaScript 문법을 그대로 사용할 수 있다. 또한 Babel 등의 Transpiler를 사용하지 않아도 ES6의 새로운 기능을 기존 브라우저에서 실행할 수 있다. TypeScript의 가장 주된 장점은 Static Type을 지원한다는 것이다.&lt;/p&gt;
&lt;p&gt;Angular가 TypeScript를 정식 채용하고 ECMAScript의 업그레이드되는 기능을 지속적으로 추가할 예정으로 많은 주목을 받고 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="https://sub2n.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://sub2n.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>190611-TIL</title>
    <link href="https://sub2n.github.io/2019/06/11/190611-TIL/"/>
    <id>https://sub2n.github.io/2019/06/11/190611-TIL/</id>
    <published>2019-06-11T08:18:05.000Z</published>
    <updated>2019-06-11T08:18:50.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>SPA (Sigle Page Application)에 대해서 배웠다.</li><li>JavaScript Class를 복습했다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SPA (Sigle P
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190610-TIL</title>
    <link href="https://sub2n.github.io/2019/06/10/190610-TIL/"/>
    <id>https://sub2n.github.io/2019/06/10/190610-TIL/</id>
    <published>2019-06-10T02:15:08.000Z</published>
    <updated>2019-06-11T04:11:44.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Tab UI를 만들었다.</li><li>Accordian UI를 만들었다.</li><li>Range Slider UI를 만들었다.</li><li>셋을 합쳤다.</li><li>jQuery로 구현된 코드를 Vanilla JavaScript로 고쳤다.</li></ul><p><a href="https://github.com/Sub2n/JavaScript-Exercise/blob/master/README.md#ui-exercise" target="_blank" rel="noopener">✨UI Exercise</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Tab UI를 만들었다
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>36. SPA</title>
    <link href="https://sub2n.github.io/2019/06/10/36-SPA/"/>
    <id>https://sub2n.github.io/2019/06/10/36-SPA/</id>
    <published>2019-06-10T01:46:03.000Z</published>
    <updated>2019-06-11T08:26:24.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPA-Single-Page-Application"><a href="#SPA-Single-Page-Application" class="headerlink" title="SPA (Single Page Application)"></a>SPA (Single Page Application)</h2><p>Single Page Application은 모던 웹 패러다임으로, 기본적으로 하나의 페이지로 구성된다. 하나의 페이지라는 것은 html 파일이 하나라는 뜻이다. 기존의 Sever-side 렌더링과 비교할 때 배포가 간단하고 <strong>Native application과 유사한 UX를 제공할 수 있다는 장점</strong>이 있다.</p><a id="more"></a><p>전통적인 웹 방식은 link tag를 사용해서 새로운 페이지를 요청한다. 새로운 페이지(html)를 요청할 때마다 필요한 static resource가 다운로드되고 전체 페이지를 다시 렌더링해야하므로 새로고침이 발생된다.</p><blockquote><h4 id="lt-a-gt-tag"><a href="#lt-a-gt-tag" class="headerlink" title="&lt;a&gt; tag"></a>&lt;a&gt; tag</h4><p>&lt;a&gt; tag 클릭시 href attribute의 url의 page로 이동한다. 즉, 화면 전환이 일어나 새로운 html이 렌더링된다. 화면 전환시 화면이 깜빡거리는 웹의 특성은 Native App과 비교해 단점으로 언급되어왔다.</p></blockquote><p>SPA는 기본적으로 Web Application에 필요한 모든 static resource를 처음 한 번에 다운로드한다. 이후에 새로운 페이지를 요청하면 갱신에 필요한 데이터만 전달받고 변경이 필요한 부분만 렌더링하므로 트래픽이 감소하고 Native application과 유사한 UX를 제공한다.</p><p>특히 모바일 사용이 증가하고 있는 요즘 SPA는 트래픽의 감소와 속도, 사용성, 반응성 등 <strong>사용자 경험(UX) 향상</strong> 면에서 가치를 갖는다. Mobile First 전략에 부합한다.</p><p>그러나 모든 Software Architecture에는 trade-off가 존재하므로 SPA 또한 구조적인 단점을 갖는다.</p><h4 id="초기-구동-속도가-느리다"><a href="#초기-구동-속도가-느리다" class="headerlink" title="초기 구동 속도가 느리다."></a>초기 구동 속도가 느리다.</h4><p>SPA는 Web Application에 필요한 모든 static resource를 최초 한 번에 다운로드 하므로 초기 구동 속도가 상대적으로 느리다. 그러나 한 번 다운로드가 이루어진 이후에는 모든 resource를 가지고 있으므로 속도가 향상된다.</p><h4 id="SEO-Search-Engine-Optimization-Issue"><a href="#SEO-Search-Engine-Optimization-Issue" class="headerlink" title="SEO(Search Engine Optimization) Issue"></a>SEO(Search Engine Optimization) Issue</h4><p>SPA는 Server Rendering 방식이 아닌, 자바스크립트 기반 비동기 모델(Client Rendering 방식)이다. 따라서 SEO가 단점으로 꼽힌다. 그러나 Angular 또는 React 등의 SPA 프레임워크는 Server Side Rendering을 지원하는 SEO 대응 기술이 존재하고 있다.</p><blockquote><h3 id="Web-Page-vs-Web-Application"><a href="#Web-Page-vs-Web-Application" class="headerlink" title="Web Page vs. Web Application"></a>Web Page vs. Web Application</h3><p>일반적인 정보를 제공하는 단순한 웹 사이트는 Web Page</p><p>사용자가 웹 사이트에서 <strong>일 (데이터를 입력, 저장, 수정, 삭제 등등)</strong>을 하면 Web Application</p></blockquote><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>Routing은 source에서 destination까지의 경로를 결정하는 기능이다. <strong>Application의 routing</strong>은 사용자가 task를 수행하기 위해서 어떤 화면(view)에서 다른 화면으로 화면을 전환하는 Navigation을 관리하기 위한 기능을 의미한다.</p><p>일반적으로 <strong>사용자가 요청한 URL 또는 Event를 해석하고 새로운 페이지로 전환하기 위한 데이터를 얻기 위해서 서버에 필요한 데이터를 요청하고 화면을 전환하는 행위</strong>를 말한다.</p><h4 id="브라우저가-화면을-전환하는-경우-3"><a href="#브라우저가-화면을-전환하는-경우-3" class="headerlink" title="브라우저가 화면을 전환하는 경우 3"></a>브라우저가 화면을 전환하는 경우 3</h4><ol><li><p>브라우저 주소창에 URL을 입력해서 해당 페이지로 이동</p></li><li><p>웹 페이지의 링크를 클릭해서 해당 페이지로 이동할 수 있다.</p></li><li><p>브라우저의 뒤로가기, 앞으로가기 버튼으로 사용자가 방문한 웹페이지 history의 뒤, 앞으로 이동</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">window</span>.history.back();</span><br><span class="line"><span class="hljs-built_in">window</span>.history.forward();</span><br><span class="line"><span class="hljs-built_in">window</span>.history.go();</span><br></pre></td></tr></table></figure></li></ol><p>AJAX Request에 의해서 서버로부터 받은 데이터로 화면을 생성하는 경우, 브라우저 주소창의 URL은 변경되지 않는다. URL이 변경되지 않으면 사용자의 history를 관리할 수 없고 이는 SEO 이슈가 된다. <strong>history 관리를 위해서는 각 페이지가 브라우저의 주소창에서 구별할 수 있는 유일한 URL을 소유해야 한다.</strong></p><h2 id="SPA-and-Routing"><a href="#SPA-and-Routing" class="headerlink" title="SPA and Routing"></a>SPA and Routing</h2><h3 id="1-HashBang-Method"><a href="#1-HashBang-Method" class="headerlink" title="1. HashBang Method"></a>1. HashBang Method</h3><p>html 내에서 element의 id 앞에 #를 붙이면 <strong>페이지 리소스를 다시 요청하지 않는다</strong>. 그러나 주소창의 uri는 변경되므로 <strong>페이지마다 고유한 uri를 만들어 history를 이용할 수 있다</strong>.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>SPA<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css/style.css"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/index.js"</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#service"</span>&gt;</span>Service<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#about"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app-root"</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> root = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.app-root'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> json = <span class="hljs-built_in">JSON</span>.parse(data);</span><br><span class="line">    root.innerHTML = <span class="hljs-string">`&lt;h1&gt;<span class="hljs-subst">$&#123;json.title&#125;</span>&lt;/h1&gt;&lt;p&gt;<span class="hljs-subst">$&#123;json.content&#125;</span>&lt;/p&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderHtml</span>(<span class="hljs-params">html</span>) </span>&#123;</span><br><span class="line">    root.innerHTML = html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><br><span class="line">      req.open(<span class="hljs-string">'GET'</span>, url);</span><br><span class="line">      req.send();</span><br><span class="line"></span><br><span class="line">      req.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (req.readyState === XMLHttpRequest.DONE) &#123;</span><br><span class="line">          <span class="hljs-keyword">if</span> (req.status === <span class="hljs-number">200</span>) resolve(req.response);</span><br><span class="line">          <span class="hljs-keyword">else</span> reject(req.statusText);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// switch 문 대신 쓰는 방법</span></span><br><span class="line">  <span class="hljs-keyword">const</span> routes = &#123;</span><br><span class="line">    <span class="hljs-string">''</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">get</span>('/data/home.json').then(render);</span><br><span class="line">    &#125;,</span><br><span class="line">    'service': function () &#123;</span><br><span class="line">      <span class="hljs-keyword">get</span>('/data/service.json').then(render);</span><br><span class="line">    &#125;,</span><br><span class="line">    'about': function () &#123;</span><br><span class="line">      <span class="hljs-keyword">get</span>('/data/about.html').then(renderHtml);</span><br><span class="line">    &#125;,</span><br><span class="line">    otherwise() &#123;</span><br><span class="line">      root.innerHTML = <span class="hljs-string">`<span class="hljs-subst">$&#123;location.hash&#125;</span> Not Found`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">router</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// url의 hash를 취득</span></span><br><span class="line">    <span class="hljs-keyword">const</span> hash = location.hash.replace(<span class="hljs-string">'#'</span>, <span class="hljs-string">''</span>);</span><br><span class="line">    <span class="hljs-comment">// property 참조 방식 1. o.prop 2. o['prop']</span></span><br><span class="line">    (routes[hash] || routes.otherwise)();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 네비게이션을 클릭하면 uri의 hash가 변경된다. 주소창의 uri가 변경되므로 history 관리가 가능하다.</span></span><br><span class="line">  <span class="hljs-comment">// 이때 uri의 hash만 변경되면 서버로 요청을 수행하지 않는다.</span></span><br><span class="line">  <span class="hljs-comment">// 따라서 uri의 hash가 변경하면 발생하는 이벤트인 hashchange 이벤트를 사용하여 hash의 변경을 감지하여 필요한 AJAX 요청을 수행한다.</span></span><br><span class="line">  <span class="hljs-comment">// hash 방식의 단점은 uri에 불필요한 #이 들어간다는 것이다.</span></span><br><span class="line">  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'hashchange'</span>, router);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// DOMContentLoaded은 HTML과 script가 로드된 시점에 발생하는 이벤트로 load 이벤트보다 먼저 발생한다. (IE 9 이상 지원)</span></span><br><span class="line">  <span class="hljs-comment">// 새로고침이 클릭되었을 때, 웹페이지가 처음 로딩되었을 때, 현 페이지(예를들어 loclahost:5003/#service)를 요청하므로 index.html이 재로드되고 DOMContentLoaded 이벤트가 발생하여 router가 호출된다.</span></span><br><span class="line">  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, router);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>결국 HashBang의 목적은 주소창의 uri가 바뀌어도 서버로 해당 uri를 요청하지 않는 것인데, HTML5에서 이를 지원하는 기능을 도입했다.</p><h4 id="DOMContentLoaded-and-load"><a href="#DOMContentLoaded-and-load" class="headerlink" title="DOMContentLoaded and load"></a>DOMContentLoaded and load</h4><p><strong>DOMContentLoaded 이벤트</strong>는 DOM이 만들어지면 발생하는 이벤트로 load 이벤트보다 먼저 발생한다.</p><p><strong>load 이벤트</strong>는 모든 리소스를 다 load했을 때 발생하는 이벤트이다.</p><h3 id="2-PJAX-Method"><a href="#2-PJAX-Method" class="headerlink" title="2. PJAX Method"></a>2. PJAX Method</h3><p>HTML5의 Histroy API인 <a href="https://developer.mozilla.org/ko/docs/Web/API/History_API" target="_blank" rel="noopener">pushState</a>와 <a href="https://developer.mozilla.org/ko/docs/Web/Reference/Events/popstate" target="_blank" rel="noopener">popstate 이벤트</a>를 사용한 PJAX 방식이다. pushState와 popstate은 IE 10 이상에서 동작한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="hljs-string">"viewport"</span> content=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="hljs-string">"X-UA-Compatible"</span> content=<span class="hljs-string">"ie=edge"</span>&gt;</span><br><span class="line">  &lt;title&gt;PJAX&lt;<span class="hljs-regexp">/title&gt;</span></span><br><span class="line"><span class="hljs-regexp">  &lt;link rel="stylesheet" href="css/</span>style.css<span class="hljs-string">"&gt;</span></span><br><span class="line"><span class="hljs-string">  &lt;script src="</span>js/index.js<span class="hljs-string">" defer&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;/head&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;body&gt;</span></span><br><span class="line"><span class="hljs-string">  &lt;nav&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;ul id="</span>navigation<span class="hljs-string">"&gt;</span></span><br><span class="line"><span class="hljs-string">      &lt;li&gt;&lt;a href="</span>/<span class="hljs-string">"&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="hljs-string">      &lt;li&gt;&lt;a href="</span>/service<span class="hljs-string">"&gt;Service&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="hljs-string">      &lt;li&gt;&lt;a href="</span>/about<span class="hljs-string">"&gt;About&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="hljs-string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="hljs-string">  &lt;/nav&gt;</span></span><br><span class="line"><span class="hljs-string">  &lt;div class="</span>app-root<span class="hljs-string">"&gt;Loading...&lt;/div&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;/body&gt;</span></span><br><span class="line"><span class="hljs-string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>이는 Server Side Rendering (Server에서 html을 주는 것)방식과 AJAX 방식이 혼합된 것이다. 그러나 브라우저의 새로고침 버튼을 클릭하면 요청이 서버로 전달된다. 따라서 복잡한 처리가 요구된다.</p><p>모던 웹 SPA를 구현하기 위해서는 프레임워크를 사용하는 게 좋을 것 같다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SPA-Single-Page-Application&quot;&gt;&lt;a href=&quot;#SPA-Single-Page-Application&quot; class=&quot;headerlink&quot; title=&quot;SPA (Single Page Application)&quot;&gt;&lt;/a&gt;SPA (Single Page Application)&lt;/h2&gt;&lt;p&gt;Single Page Application은 모던 웹 패러다임으로, 기본적으로 하나의 페이지로 구성된다. 하나의 페이지라는 것은 html 파일이 하나라는 뜻이다. 기존의 Sever-side 렌더링과 비교할 때 배포가 간단하고 &lt;strong&gt;Native application과 유사한 UX를 제공할 수 있다는 장점&lt;/strong&gt;이 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="자바스크립트" scheme="https://sub2n.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="SPA" scheme="https://sub2n.github.io/tags/SPA/"/>
    
      <category term="Single Page Application" scheme="https://sub2n.github.io/tags/Single-Page-Application/"/>
    
      <category term="Routing" scheme="https://sub2n.github.io/tags/Routing/"/>
    
  </entry>
  
  <entry>
    <title>35. Closure</title>
    <link href="https://sub2n.github.io/2019/06/07/35-Closure/"/>
    <id>https://sub2n.github.io/2019/06/07/35-Closure/</id>
    <published>2019-06-07T03:59:09.000Z</published>
    <updated>2019-06-11T08:26:18.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Purpose-of-Closure-Maintain-Status"><a href="#Purpose-of-Closure-Maintain-Status" class="headerlink" title="Purpose of Closure: Maintain Status"></a>Purpose of Closure: Maintain Status</h2><p>클로저의 주된 목적은 <strong>안전한</strong> 상태 유지를 하는 것이다. 다른 객체지향 프로그래밍 언어의 경우 private, public, protect 등의 접근 제한자(Access Specifier)를 제공하지만 자바스크립트에는 그런 기능이 없다. (ES6의 Class에 private이 도입된다고 하지만 아직 완벽하게 적용되지 않음) 자바스크립트의 클로저를 사용하면 상태를 안전하게 유지할 수 있다.</p><a id="more"></a><h2 id="What-is-Closure"><a href="#What-is-Closure" class="headerlink" title="What is Closure?"></a>What is Closure?</h2><blockquote><p>“A closure is the combination of a function and the lexical environment within which that function was declared.”</p><p> 클로저는 함수와 그 함수가 선언된 Lexical Environment의 조합이다.</p></blockquote><h3 id="함수가-선언된-Lexical-Environment"><a href="#함수가-선언된-Lexical-Environment" class="headerlink" title="함수가 선언된 Lexical Environment"></a>함수가 선언된 Lexical Environment</h3><p>함수 내부에서 정의된 함수를 중첩 함수(nested function)라고 한다. 함수 정의는 평가되어 함수 객체가 된다. <strong>함수 객체는 생성되는 시점에 실행중인 실행 컨텍스트(running execution context)의 LexicalEnvironment를 자신의 상위 스코프로 가진다.</strong> 함수 객체의 내부 슬롯 <code>[[Environment]]</code>에 running execution context의 LexicalEnvironment이 저장된다. 즉, 함수는 호출과 무관하게 선언된 위치에서 평가되어 함수 객체가 될 때 자신의 상위 스코프를 <code>[[Environment]]</code>에 저장한다. 이는 함수 객체가 소멸되기 전까지 유지되며 함수가 호출될 때마다 참조하여 상위 스코프로 삼는다. 함수가 호출되어 실행 컨텍스트가 생성될 때 Lexical Environment의 OuterLexicalEnvironmentReference에 그 함수의 <code>[[Environment]]</code>에 저장된 Lexical Environment의 참조값을 저장한다. 이렇게 함수가 어디서 호출되는지에 상관 없이 <strong>정의된 위치로 스코프를 결정하는 것을 Lexical Scope</strong>(또는 Static Scope)라고 한다.</p><p>스코프의 실체는 렉시컬 환경이다.</p><h3 id="함수-객체의-내부-슬롯-Environment"><a href="#함수-객체의-내부-슬롯-Environment" class="headerlink" title="함수 객체의 내부 슬롯 [[Environment]]"></a>함수 객체의 내부 슬롯 <code>[[Environment]]</code></h3><p>모든 함수 객체는 자신의 내부 슬롯 <code>[[Environment]]</code>에 상위 스코프의 참조, 즉 생성될 때 실행중이던 실행 컨텍스트의 Lexical Environment의 참조를 저장한다.</p><p>그리고 함수가 호출되어 평가될 때 생성되는 실행 컨텍스트의 OuterLexicalEnvironmentReference로 <code>[[Environment]]</code> 내부 슬롯에 저장해놓은 Lexical Environment를 바인딩해 스코프 체인을 구성한다.</p><h2 id="Closure-and-Lexical-Environment"><a href="#Closure-and-Lexical-Environment" class="headerlink" title="Closure and Lexical Environment"></a>Closure and Lexical Environment</h2><p>자바스크립트에서 함수는 1급 객체(First-class Object)이므로 값처럼 취급된다. 따라서 함수에서 함수 객체를 argument로 받거나 리턴하는 것이 가능하다. 함수를 argument로 받거나 리턴하는 함수를 고차 함수(Higher Order Function)라고 한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ①</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> x = <span class="hljs-number">10</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(x); &#125;; <span class="hljs-comment">// ②</span></span><br><span class="line">  <span class="hljs-keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수 outer를 호출하면 중첩 함수 inner를 반환한다.</span></span><br><span class="line"><span class="hljs-comment">// 그리고 함수 outer의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop된다. (life cycle 마감)</span></span><br><span class="line"><span class="hljs-keyword">const</span> innerFunc = outer(); <span class="hljs-comment">// ③</span></span><br><span class="line">innerFunc(); <span class="hljs-comment">// ④ 10</span></span><br></pre></td></tr></table></figure><p>③에서 outer 함수는 중첩 함수 inner를 리턴하고 종료한다. 함수가 종료하면 실행 컨텍스트가 실행 컨텍스트 스택에서 pop된다. 소멸되는 것이다. 일반적인 함수의 경우 실행 컨텍스트가 소멸할 때 Lexical Environment도 같이 소멸한다. </p><p>그러나 위의 outer 함수처럼 <strong>자신의 중첩 함수를 리턴하며 종료하는 경우</strong>, outer의 실행 컨텍스트는 소멸하더라도 중첩 함수 inner가 내부 슬롯 <code>[[Environment]]</code>로 outer의 Lexical Environment를 참조하고 있으므로 Reference Count가 남아있는 <strong>outer의 Lexical Environment는 소멸하지 않는다</strong>. </p><p>따라서 inner 함수가 호출되어 inner 실행 컨텍스트를 생성할 때마다 outer의 Lexical Environment를 자신의 상위 스코프로 삼고 outer의 변수를 참조할 수 있는 것이다. outer의 x와 같은 변수를 자유 변수(free variable)라고 한다.</p><p>outer는 종료했으므로 outer의 Lexical Environment에 접근할 수 있는 것은 참조값을 가지고 있는 inner 함수 뿐이다. 따라서 outer 내부의 상태가 안전하게 유지된다.</p><p>이론적으로 모든 함수는 기본적으로 클로저이지만, 모던 브라우저에서는 상위 스코프의 식별자를 참조하지 않는 중첩 함수의 경우 해당 함수의 외부 Lexical Environment를 유지하지 않는다. 또한 외부 함수 내부에서 호출되는 등, 외부 함수와 life cycle을 함께 하는 중첩 함수도 클로저라고 하지 않는다.<br>따라서 일반적으로 <strong>클로저</strong>는 <strong>자신의 외부 함수보다 오래 살아남고</strong>, 자신이 기억하는 <strong>상위 스코프의 식별자를 참조하는 함수</strong>를 말한다.</p><h2 id="Usage-of-Closure"><a href="#Usage-of-Closure" class="headerlink" title="Usage of Closure"></a>Usage of Closure</h2><p>클로저는 상태를 안전하게 유지하기 위해서 사용한다. 즉, 상태가 의도치 않게 변경되지 않도록 정보 은닉(Information hiding)을 통해 캡슐화(Encapsulation) 하는 것이다.</p><p>어떤 상태를 안전하게 유지하기 위해서는 그 상태에 접근할 수 있는 방법을 제한해야한다. 즉, 상태 변경을 위해서 사용하는 메소드를 제외한 다른 외부로부터 상태를 숨겨야 한다.</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"increase"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"counter"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"decrease"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">const</span> $counter = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.counter'</span>);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">const</span> counter = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 카운트 상태를 유지하기 위한 자유 변수</span></span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 클로저를 메소드로 갖는 객체를 반환한다.</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 객체 리터럴은 스코프를 만들지 않는다.</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// 따라서 아래 메소드들의 상위 스코프는 즉시 실행 함수의 스코프이다.</span></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="line"><span class="hljs-actionscript">        <span class="hljs-comment">// num: 0, // 프로퍼티는 public이므로 정보 은닉이 되지 않는다.</span></span></span><br><span class="line"><span class="hljs-undefined">        increase() &#123;</span></span><br><span class="line"><span class="hljs-actionscript">          $counter.textContent = ++num; <span class="hljs-comment">// 상태 변경</span></span></span><br><span class="line"><span class="hljs-undefined">        &#125;,</span></span><br><span class="line"><span class="hljs-undefined">        decrease() &#123;</span></span><br><span class="line"><span class="hljs-actionscript">          <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;</span></span><br><span class="line"><span class="hljs-actionscript">          $counter.textContent = --num; <span class="hljs-comment">// 상태 변경</span></span></span><br><span class="line"><span class="hljs-undefined">        &#125;</span></span><br><span class="line"><span class="hljs-undefined">      &#125;;</span></span><br><span class="line"><span class="hljs-undefined">    &#125;());</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.increase'</span>).onclick = counter.increase;</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.decrease'</span>).onclick = counter.decrease;</span></span><br><span class="line"><span class="hljs-undefined">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위의 스크립트가 실행되면 IIFE(즉시 실행 함수)가 호출되고 <strong>리턴문이 실행될 때 리턴하는 객체가 생성된다</strong>. <strong>객체가 생성될 때 객체의 메소드인 increase와 decrease 함수 객체 또한 생성된다</strong>. 이 때 increase와 decrease 함수는 자신이 정의될 때의 running execution context인 IIFE 실행 컨텍스트의 Lexical Environment를 <code>[[Environment]]</code>에 기억한다. 그러므로 IIFE는 한 번 호출되고 종료했지만 리턴되어 counter 변수에 저장된 객체의 메소드로서 increase, decrease 함수가 호출될 때마다 IIFE의 Lexical Environment에 등록된 num에 접근하고 상태를 변경할 수 있는 것이다. 다시 말하면 increase, decrease 함수 외에는 num에 접근할 방법이 없으므로 num의 상태가 안전하게 유지된다.</p><p>이를 생성자 함수로 바꾸면 객체의 프로퍼티는 public이므로 다음과 같이 구현해야 한다. </p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"increase"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"counter"</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"decrease"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">const</span> $counter = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.counter'</span>);</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">const</span> Counter = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-comment">// ① 카운트 상태를 유지하기 위한 자유 변수</span></span></span><br><span class="line"><span class="hljs-javascript">      <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span><span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">        <span class="hljs-comment">// this.num = 0; // ② 프로퍼티는 public이므로 정보 은닉이 되지 않는다.</span></span></span><br><span class="line"><span class="hljs-undefined">      &#125;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      Counter.prototype.increase = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-undefined">        $counter.textContent = ++num;</span></span><br><span class="line"><span class="hljs-undefined">      &#125;;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      Counter.prototype.decrease = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span></span><br><span class="line"><span class="hljs-actionscript">        <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;</span></span><br><span class="line"><span class="hljs-undefined">        $counter.textContent = --num;</span></span><br><span class="line"><span class="hljs-undefined">      &#125;;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">      <span class="hljs-keyword">return</span> Counter; <span class="hljs-comment">// Counter.prototype에 method 정의했으므로 Counter 함수 객체만 리턴</span></span></span><br><span class="line"><span class="hljs-undefined">    &#125;());</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-actionscript">    <span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> Counter();</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.increase'</span>).onclick = counter.increase;</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.decrease'</span>).onclick = counter.decrease;</span></span><br><span class="line"><span class="hljs-undefined">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>생성자 함수의 프로퍼티가 아니라 자유 변수로 상태를 안전하게 유지한다. Counter.prototype의 메소드는 IIFE에서 정의되었으므로 IIFE의 변수 num에 접근할 수 있다.</p><h4 id="함수형-프로그래밍"><a href="#함수형-프로그래밍" class="headerlink" title="함수형 프로그래밍"></a>함수형 프로그래밍</h4><p>변수의 사용을 가급적 자제하고, 상태 변화를 최소화 시키는 방법으로 프로그래밍 한다. mutable data를 피하고 <strong>immutable을 지향</strong>하는 함수형 프로그래밍에서 프로그래밍의 안정성을 높이기 위해 클로저는 적극적으로 사용된다. mutable value는 참조값이 전달되므로(Pass by reference) shared data가 되어 상태 변화의 위험성이 높아진다. 또한 외부 상태가 아니라 자신의 지역변수만을 변경시키는 pure function (순수 함수)의 사용을 지향한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 함수를 인자로 전달받고 함수를 반환하는 고차 함수</span></span><br><span class="line"><span class="hljs-comment">// 이 함수가 반환하는 함수는 클로저로서 카운트 상태를 유지하기 위한 자유 변수 counter을 기억한다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span>(<span class="hljs-params">predicate</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 카운트 상태를 유지하기 위한 자유 변수</span></span><br><span class="line">  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 클로저를 반환</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 인자로 전달 받은 보조 함수에 상태 변경을 위임한다.</span></span><br><span class="line">    counter = predicate(counter);</span><br><span class="line">    <span class="hljs-keyword">return</span> counter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 보조 함수</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increase</span>(<span class="hljs-params">n</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 보조 함수</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrease</span>(<span class="hljs-params">n</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> --n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수로 함수를 생성한다.</span></span><br><span class="line"><span class="hljs-comment">// makeCounter 함수는 보조 함수를 인자로 전달받아 함수를 반환한다</span></span><br><span class="line"><span class="hljs-keyword">const</span> increaser = makeCounter(increase); <span class="hljs-comment">// ①</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(increaser()); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(increaser()); <span class="hljs-comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> decreaser = makeCounter(decrease); <span class="hljs-comment">// ②</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(decreaser()); <span class="hljs-comment">// -1</span></span><br></pre></td></tr></table></figure><h2 id="Closure-Mistake"><a href="#Closure-Mistake" class="headerlink" title="Closure Mistake"></a>Closure Mistake</h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = [];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; j++) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(arr[j]()); <span class="hljs-comment">// 5 5 5 5 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제의 실행 결과는 5 5 5 5 5이다. 이유는 <code>var</code> 키워드로 선언한 i는 block-level scope를 지원하지 않기 때문이다. 즉, for문의 block이 scope를 만들지 않아서 arr의 element에 저장된 함수 객체들이 자신의 상위 스코프로 전역 렉시컬 환경을 기억한다.</p><p>이는 for 문 내부의 선언문에 <code>let</code> 키워드를 사용함으로써 보완할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = [];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(arr[i]()); <span class="hljs-comment">// 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 문은 자바스크립트 엔진에 의해 평가될 때 내부 선언문이 <code>let</code>인지, <code>var</code>인지, expression인지에 따라서 다르게 동작한다. <code>let</code> 키워드로 선언된 선언문일 경우 block-level scope를 만들어야하므로 LOOP Lexical Environment를 우선 생성하고 i를 환경 레코드에 등록한다. 그리고 나서 for문의 body를 평가하고 실행하는데 한 반복 당 하나의 per Iteration Lexical Environment를 생성하고, i의 값이 유효한지 검사하고, statement를 실행한 후 다음 반복을 위한 per Iteration Lexical Environment를 생성하고 increment를 진행한다. 이를 반복한다. 따라서 각 Iteration에서 생성된 함수는 각각 다른 Lexical Environment를 자신의 <code>[[Environment]]</code>로 참조하고 있기 때문에 원하는 결과를 얻을 수 있는 것이다.</p><p>비슷하게 Iterable에 사용할 수 있는 for of 문, 객체의 프로퍼티 순회에 사용할 수 있는 for in  문 내부의 선언문에 <code>const</code> 키워드를 사용할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> o) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(o[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> arr = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이는 for of, for in 문의 선언부의 선언문은 for문 body 가장 상단에서 실행되는 것과 같이 동작하기 때문이다. 즉, 반복하는 횟수만큼 선언된다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Purpose-of-Closure-Maintain-Status&quot;&gt;&lt;a href=&quot;#Purpose-of-Closure-Maintain-Status&quot; class=&quot;headerlink&quot; title=&quot;Purpose of Closure: Maintain Status&quot;&gt;&lt;/a&gt;Purpose of Closure: Maintain Status&lt;/h2&gt;&lt;p&gt;클로저의 주된 목적은 &lt;strong&gt;안전한&lt;/strong&gt; 상태 유지를 하는 것이다. 다른 객체지향 프로그래밍 언어의 경우 private, public, protect 등의 접근 제한자(Access Specifier)를 제공하지만 자바스크립트에는 그런 기능이 없다. (ES6의 Class에 private이 도입된다고 하지만 아직 완벽하게 적용되지 않음) 자바스크립트의 클로저를 사용하면 상태를 안전하게 유지할 수 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="자바스크립트" scheme="https://sub2n.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>190605-TIL</title>
    <link href="https://sub2n.github.io/2019/06/05/190605-TIL/"/>
    <id>https://sub2n.github.io/2019/06/05/190605-TIL/</id>
    <published>2019-06-05T08:53:10.000Z</published>
    <updated>2019-06-05T08:54:37.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>오늘은 실행 컨텍스트를 배웠다.</li><li>엄청 어렵다..</li><li>변수 선언문을 배울 때부터 의문점이었던 실행 컨텍스트의 렉시컬 환경의 정체에 대해서 알게 되어서 속이 시원한 것 같다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;오늘은 실행 컨텍스트를
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>34. Execution Context</title>
    <link href="https://sub2n.github.io/2019/06/05/34-Execution-Context/"/>
    <id>https://sub2n.github.io/2019/06/05/34-Execution-Context/</id>
    <published>2019-06-05T01:43:07.000Z</published>
    <updated>2019-06-11T08:26:27.934Z</updated>
    
    <content type="html"><![CDATA[<p><strong>실행 컨텍스트(Execution Context)</strong>는 <strong>실행 가능한 코드를 평가</strong>하고 <strong>실행하기 위해 필요한 환경을 제공</strong>하고 <strong>코드의 실행 결과를 실제로 관리</strong>하는 영역이다.</p><p>Context는 문맥, 맥락이라는 뜻이다. 프로그램에도 맥락이 있다. 예를 들면 식별자가 어느 스코프에서 사용되었는지에 따라서 다른 값을 참조한다.</p><a id="more"></a><h2 id="1-Executable-Code"><a href="#1-Executable-Code" class="headerlink" title="1. Executable Code"></a>1. Executable Code</h2><p>실행 가능한 코드(Executable Code)를 4가지 유형으로 구분한다.</p><table><thead><tr><th>Executable Code</th><th align="left">Explaination</th></tr></thead><tbody><tr><td>Global code</td><td align="left">전역에 존재하는 Text code. 전역에 정의된 함수나 클래스의 내부 코드는 포함되지 않음</td></tr><tr><td>Function code</td><td align="left">함수 내부에 존재하는 Text code. 함수 내부에 중첩된 함수나 클래스의 내부 코드는 포함되지 않음</td></tr><tr><td>Eval code</td><td align="left">Built-in 전역 함수인 eval 함수에 argument로 전달된 Text code</td></tr><tr><td>Module code</td><td align="left">모듈 내부에 존재하는 Text code. 모듈 내부의 함수나 클래스의 내부 코드는 포함되지 않음</td></tr></tbody></table><h4 id="전역-코드-Global-Code"><a href="#전역-코드-Global-Code" class="headerlink" title="전역 코드 Global Code"></a>전역 코드 Global Code</h4><p>전역 코드는 전역 스코프를 생성해야하며 전역 객체와 연결되어야 한다. 이를 위해서 <strong>전역 코드가 평가되면 전역 실행 컨텍스트가 생성</strong>된다. </p><p><code>var</code> 키워드로 선언한 전역 변수는 전역 객체(window)의 프로퍼티가 된다.  그러나 전역 스코프를 통해서도 검색이 가능해야한다. <code>let</code>과 <code>const</code> 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되는 것이 아니라 전역 스코프에 등록된다.</p><h4 id="함수-코드-Function-Code"><a href="#함수-코드-Function-Code" class="headerlink" title="함수 코드 Function Code"></a>함수 코드 Function Code</h4><p>함수 코드는 지역 스코프를 생성해야하며 생성된 지역 스코프는 스코프 체인의 최상위인 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결되어야 한다. 이를 위해서 <strong>함수 코드가 평가되면 함수 실행 컨텍스트가 생성</strong>된다.</p><h2 id="2-Evaluation-and-Execution-of-Executable-Code"><a href="#2-Evaluation-and-Execution-of-Executable-Code" class="headerlink" title="2. Evaluation and Execution of Executable Code"></a>2. Evaluation and Execution of Executable Code</h2><p>모든 Executable code는 실행하기 전에 평가 과정을 거친다. </p><h4 id="1-코드의-평가-과정"><a href="#1-코드의-평가-과정" class="headerlink" title="1. 코드의 평가 과정"></a>1. 코드의 평가 과정</h4><p>코드의 평가 과정에서 <strong>실행 컨텍스트가 생성</strong>된다.</p><p>변수, 함수, 클래스 등의 <strong>선언문이 우선 평가되고 그 결과가 실행 컨텍스트에 등록</strong>된다. </p><blockquote><h4 id="Evaluation-and-Hoisting"><a href="#Evaluation-and-Hoisting" class="headerlink" title="Evaluation and Hoisting"></a>Evaluation and Hoisting</h4><p><code>var</code> 키워드로 선언한 변수 선언문은 평가되어 변수명(식별자)이 실행 컨텍스트에 등록된다. 이 때 1. 선언 단계(Declaration Phase)로 변수명을 등록하고 2. 초기화 단계(Initialazation Phase)로 변수명에 <code>undefined</code>를 할당한다. 이는 자바스크립트 엔진에 변수의 존재를 알려 변수를 관리하도록 한다.</p><p><code>let</code>이나 <code>const</code> 키워드로 선언한 변수 선언문은 평가되어 실행 컨텍스트에 등록될 때 1. 선언 단계만 거친다. 2. 초기화 단계로 <code>undefined</code>를 할당하는 것이 아니라 자바스크립트 엔진이 알고 있는 특별한 값을 할당하여 초기화 이전에 해당 값을 참조하면 <code>ReferenceError: Cannot access &#39;x&#39; before initialization</code>을 발생시킨다. <code>let</code>이나 <code>const</code> 키워드로 선언한 변수의 <strong>2. 초기화 단계는 코드의 실행 중 선언문을 실행시킬 때 이루어진다.</strong></p><p>함수 선언문의 경우 함수명과 동일한 변수명을 실행 컨텍스트에 등록하고, 즉시 함수 객체를 생성해서 변수명에 할당한다. </p><p>함수 호출시 진행되는 함수 코드의 평가에서는 parameter와 내부 코드의 선언문을 평가한다. 이 때 parameter는 <code>var</code> 키워드로 선언한 변수로 취급되어 <code>undefined</code>로 초기화된다. 또한 함수 내부에서 지역 변수처럼 사용할 수 있는  arguments 객체도 생성되어 지역 스코프에 등록된다. arguments 객체는 유사배열객체(Array-like Object)로, spread 연산자를 사용해서 배열로 만들어 사용할 수 있다.</p></blockquote><h4 id="2-코드의-실행"><a href="#2-코드의-실행" class="headerlink" title="2. 코드의 실행"></a>2. 코드의 실행</h4><p>코드의 평가 과정이 끝나면 선언문을 제외한 코드가 순차적으로 실행된다. 이 때 할당문 등 코드 실행에 필요한 정보를 실행 컨텍스트에서 가져온다. 코드의 실행 결과는 실행 컨텍스트에서 관리된다.</p><p>코드 실행 중 식별자를 만나면 우선 해당 실행 컨텍스트의 스코프에서 검색하고, 없으면 전역 스코프까지 올라간다. console 같은 식별자의 경우 전역 스코프에 등록되지 않았다. 그러나 ReferenceError가 나지 않는다. 이는 전역 스코프에서 식별자를 못 찾을 시 전역 객체의 프로퍼티를 검색하기 때문이다. 전역 객체의 프로퍼티는 마치 전역 스코프에 등록된 식별자처럼 동작한다.</p><h2 id="3-Role-of-Execution-Context"><a href="#3-Role-of-Execution-Context" class="headerlink" title="3. Role of Execution Context"></a>3. Role of Execution Context</h2><h4 id="1-전역-코드-평가"><a href="#1-전역-코드-평가" class="headerlink" title="1. 전역 코드 평가"></a>1. 전역 코드 평가</h4><p>전역 코드를 한 줄씩 실행하기 이전에 전역 코드가 평가된다. 평가 과정에서 변수 선언문과 함수 선언문이 평가된다. 그 결과로 전역 변수와 전역 함수가 전역 스코프에 등록된다. <code>var</code> 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티가 된다. <code>let</code>이나 <code>const</code> 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 아니라 전역 스코프의 식별자로 등록된다.</p><h4 id="2-전역-코드-실행"><a href="#2-전역-코드-실행" class="headerlink" title="2. 전역 코드 실행"></a>2. 전역 코드 실행</h4><p>전역 코드 평가가 끝나면 전역 코드를 순차적으로 실행한다. 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 전역 코드의 실행이 멈추고 호출된 함수 내부로 진입한다. </p><h4 id="3-함수-코드-평가"><a href="#3-함수-코드-평가" class="headerlink" title="3. 함수 코드 평가"></a>3. 함수 코드 평가</h4><p>함수 내부로 진입하면 함수 내부 코드를 실행하기 이전에 함수 코드가 평가된다. 이 때 parameter와 지역 변수 선언문이 평가된다. 그 결과로 parameter와 지역 변수는 지역 스코프에 등록된다. arguments 객체도 생성되어 스코프에 등록된다.</p><h4 id="4-함수-코드-실행"><a href="#4-함수-코드-실행" class="headerlink" title="4. 함수 코드 실행"></a>4. 함수 코드 실행</h4><p>함수 코드가 순차적으로 실행되고 종료되면 함수를 빠져나와 함수 호출 다음의 전역 코드를 실행한다.</p><p>결국 실행 컨텍스트가 해야하는 역할은 다음과 같다.</p><ol><li>선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분해서 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리해야 한다.</li><li>스코프 중첩 관계에 의해서 스코프 체인을 형성해야 한다. 스코프 체인을 통해서 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.</li><li>함수 호출 등으로 현재 실행중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수 있어야 한다.</li></ol><p><strong>실행 컨텍스트(Execution Context)는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.</strong></p><p>다시 말해, 실행 컨텍스트는 식별자(변수, 함수, 클래스, this 등)를 등록하고 관리하기 위한 <strong>스코프와 실행 순서 관리를 구현한 내부 매커니즘</strong>으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.</p><h2 id="4-Execution-Context-Stack"><a href="#4-Execution-Context-Stack" class="headerlink" title="4. Execution Context Stack"></a>4. Execution Context Stack</h2><p>Stack은 LIFO(Last In First Out) 방식의 자료구조이다. Stack의 가장 윗부분을 Top이라고 하고,  데이터를 넣는 것을 push, 꺼내는 것을 pop이라고 한다.</p><p>함수 호출 등에 따라서 생성되는 실행 컨텍스트는 Stack 자료구조로 관리된다. 이를 실행 컨텍스트 스택이라고 한다. 우리가 익히 알고 있는 Call Stack이 Execution context stack이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cosnt x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">funtcion foo() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> y = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> z = <span class="hljs-number">3</span>;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(x + y + z);</span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h4 id="1-전역-코드의-평가와-실행"><a href="#1-전역-코드의-평가와-실행" class="headerlink" title="1. 전역 코드의 평가와 실행"></a><strong>1. 전역 코드의 평가와 실행</strong></h4><p>자바스크립트 엔진은 자바스크립트 파일을 로드하고 실행하기 이전에 평가 과정을 거치며 전역 실행 컨텍스트를 생성한다. 전역 객체는 전역 실행 컨텍스트 이전에 생성되어있다.  그러므로 전역 코드를 평가할 때 <code>var</code> 키워드 등으로 선언한 변수를 전역 객체의 프로퍼티로 추가할 수 있는 것이다.  전역 실행 컨텍스트는 생성되는 즉시 Execution Context Stack에 push된다. 이 때 전역 변수  x와 전역 함수 foo는 전역 실행 컨텍스트에 등록된다. 이후에 전역 코드가 실행되며 x에 값이 할당되고 foo가 호출된다.</p><h4 id="2-foo-함수의-평가와-실행"><a href="#2-foo-함수의-평가와-실행" class="headerlink" title="2. foo 함수의 평가와 실행"></a>2. foo 함수의 평가와 실행</h4><p>전역 함수 foo가 호출되면 전역 코드의 실행이 멈추고 control이 foo 함수 내부로 이동한다. 자바스크립트 엔진은 foo 함수 내부의 함수 코드를 평가해서 foo 함수 실행 컨텍스트를 생성하고 Execution Context Stack에 push한다. foo 함수 평가가 끝나고 실행을 하다가 중첩 함수 bar를 만나면 bar를 호출한다.</p><h4 id="3-bar-함수의-평가와-실행"><a href="#3-bar-함수의-평가와-실행" class="headerlink" title="3. bar 함수의 평가와 실행"></a>3. bar 함수의 평가와 실행</h4><p>중첩 함수 bar가 호출되면 foo 코드의 실행이 멈추고 control이 bar 함수 내부로 이동한다. 자바스크립트 엔진은 bar 함수 내부의 함수 코드를 평가해서 bar 함수 실행 컨텍스트를 생성하고 Execution Context Stack에 push한다. bar 함수는 실행을 마치고 종료한다.</p><h4 id="4-foo-함수-코드로-복귀"><a href="#4-foo-함수-코드로-복귀" class="headerlink" title="4. foo 함수 코드로 복귀"></a>4. foo 함수 코드로 복귀</h4><h4 id="5-전역-코드로-복귀"><a href="#5-전역-코드로-복귀" class="headerlink" title="5. 전역 코드로 복귀"></a>5. 전역 코드로 복귀</h4><h2 id="5-Lexical-Environment"><a href="#5-Lexical-Environment" class="headerlink" title="5. Lexical Environment"></a>5. Lexical Environment</h2><p><strong>Lexical Environment는 식별자가 선언되는 환경,</strong> 즉 <strong>렉시컬 스코프</strong>를 의미한다. 렉시컬 환경은 스코프와 식별자를 관리한다.</p><p>실행 컨텍스트는 LexicalEnvorinment 컴포넌트와 VariableEnvironment 컴포넌트로 구성된다. 생성 초기에 두 컴포넌트는 하나의 동일한 렉시컬 환경을 참조한다. with 문을 사용하지 않으면 둘은 언제나 동일한 렉시컬 환경을 참조한다.</p><p><img src="https://poiemaweb.com/assets/fs-images/22-7.png" alt="img"></p><p><img src="https://poiemaweb.com/assets/fs-images/22-8.png" alt="img"></p><ol><li>EnvironmentRecord : 환경 레코드. 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소. 환경 레코드는 Executable Code의 종류에 따라 내용이 다르다. 예를 들어 전역 코드의 경우 전역 객체와 연결되어야하고 함수 코드는 그렇지 않다.</li><li>Outer Lexical Enciromnent Reference : 외부 렉시컬 환경을 가리키는 참조를 저장. 해당 실행 컨텍스트를 생성한 Executable code를 포함하는 상위 코드의 렉시컬 환경을 말한다. 이를 통해서 One-way linked list인 스코프 체인을 구현한다.</li><li>ThisBinding : this 바인딩. 렉시컬 환경의 this에 바인딩된 객체(ThisBinding)를 나타낸다. this 바인딩은 Abstract operation ResolveThisBinding을 통해 결정할 수 있다.</li></ol><p>결국 스코프 체인은 각 실행 컨텍스트의 Lexical Environment의 link로 구성된 Linked List이다.</p><h2 id="6-Creation-of-Executable-Context-and-Identifier-Search-Process"><a href="#6-Creation-of-Executable-Context-and-Identifier-Search-Process" class="headerlink" title="6. Creation of Executable Context and Identifier Search Process"></a>6. Creation of Executable Context and Identifier Search Process</h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> y = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">a</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> y = <span class="hljs-number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span> (<span class="hljs-params">b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> z = <span class="hljs-number">5</span>;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a + b + x + y + z);</span><br><span class="line">&#125;</span><br><span class="line">  bar(<span class="hljs-number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="hljs-number">20</span>); <span class="hljs-comment">// 42</span></span><br></pre></td></tr></table></figure><h4 id="1-전역-객체-생성"><a href="#1-전역-객체-생성" class="headerlink" title="1. 전역 객체 생성"></a>1. 전역 객체 생성</h4><p>전역 객체는 생성자 함수를 제공하지 않으므로 의도적으로 생성할 수 없다. 전역 객체는 애플리케이션 로딩시 전역 코드가 평가되기 이전에 생성된다. 전역 객체에는 전역 프로퍼티와 전역 함수, builtin 객체가 추가되며 Client Side인 경우 CIient-side Web API를 포함한다.</p><h4 id="2-전역-코드-평가"><a href="#2-전역-코드-평가" class="headerlink" title="2. 전역 코드 평가"></a>2. 전역 코드 평가</h4><h5 id="1-전역-실행-컨텍스트-생성"><a href="#1-전역-실행-컨텍스트-생성" class="headerlink" title="1. 전역 실행 컨텍스트 생성"></a>1. 전역 실행 컨텍스트 생성</h5><p>전역 실행 컨텍스트를 생성하고 즉시 실행 컨텍스트 스택에 생성된 전역 실행 컨텍스트를 push한다.</p><h5 id="2-전역-렉시컬-환경-생성"><a href="#2-전역-렉시컬-환경-생성" class="headerlink" title="2. 전역 렉시컬 환경 생성"></a>2. 전역 렉시컬 환경 생성</h5><p>전역 Lexical Environment를 생성하고 전역 실행 컨텍스트의 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트에 바인딩한다. Lexical Environment는 EnvironmentRecord, OuterLexicalEnvironmentReference, ThisBinding의 3가지 컴포넌트로 구성된다.</p><h5 id="2-1-전역-환경-레코드-생성-Global-Environment-Record"><a href="#2-1-전역-환경-레코드-생성-Global-Environment-Record" class="headerlink" title="2.1. 전역 환경 레코드 생성 Global Environment Record"></a>2.1. 전역 환경 레코드 생성 Global Environment Record</h5><p>전역 환경 레코드(Global Environment Record)는 함수 환경 레코드와는 다르게, 객체 환경 레코드(Object Environment Record)와 선언적 환경 레코드(Declarative Environment Record)로 구성되어 있다. Object Environment Record와 Declarative Environment Record는 서로 협력해 전역 스코프와 전역 객체를 관리한다.</p><h6 id="2-1-1-객체-환경-레코드-생성-Object-Environment-Record"><a href="#2-1-1-객체-환경-레코드-생성-Object-Environment-Record" class="headerlink" title="2.1.1. 객체 환경 레코드 생성 Object Environment Record"></a>2.1.1. 객체 환경 레코드 생성 Object Environment Record</h6><p><code>var</code> 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 Object Environment Record에 등록되고 관리된다.</p><p>정확히 말하면 Object Environment Record는 bindingObject라는 객체와 연결되는데, Object Environment Record에 등록한 식별자는 bindingObject의 프로퍼티가 된다. Global Environment Record의 경우 Object Environment Record의 bindingObject는 전역 객체(window)이다.</p><p>따라서 <code>var</code> 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티가 된다. 등록된 식별자를 Global Environment Record의 Object Environment Record에서 검색하면 전역 객체의 프로퍼티를 검색해서 반환한다. 따라서 <code>var x = 1</code>과 같이 선언한 변수는 <code>x</code> 또는 <code>window.x</code>로 검색할 수 있는 것이다. 전역 함수 또한 마찬가지이다.</p><h6 id="변수-호이스팅과-함수-호이스팅"><a href="#변수-호이스팅과-함수-호이스팅" class="headerlink" title="변수 호이스팅과 함수 호이스팅"></a>변수 호이스팅과 함수 호이스팅</h6><p><code>var</code> 키워드로 선언한 변수는 Object Environment Record에 바인딩된 bindingObject에 변수 식별자를 등록(1. 선언 단계)한 다음, 암묵적으로 undefined로 초기화(2. 초기화 단계)한다.</p><p>함수 선언문으로 정의한 함수는 평가되면 함수명과 동일한 이름의 식별자를 Object Environment Record에 등록하고, 함수 객체를 생성해서 즉시 할당한다. 그래서 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있는 것이다.</p><h6 id="2-1-2-선언적-환경-레코드-생성-Declarative-Environment-Record"><a href="#2-1-2-선언적-환경-레코드-생성-Declarative-Environment-Record" class="headerlink" title="2.1.2. 선언적 환경 레코드 생성 Declarative Environment Record"></a>2.1.2. 선언적 환경 레코드 생성 Declarative Environment Record</h6><p><code>let</code>, <code>const</code> 키워드로 선언된전역 변수는 Declarative Environment Record에 등록되고 관리된다. <code>let</code>, <code>const</code> 키워드로 선언한 변수는 1. 선언 단계와 2. 초기화 단계가 분리되어 진행된다. 평가 단계에서는 선언 단계만 진행되어 식별자가 등록이 되고, 초기화 단계는 실행 시간에 선언문을 실행할 때 진행되므로 선언문 실행 이전까지를 TDZ(Temporal Dead Zone)라고 한다. 이들은 전역 객체의 프로퍼티가 아니라 Global Lexical Environment의 Declarative Environment Record에 등록되어 관리된다.</p><h5 id="2-2-외부-렉시컬-환경에-대한-참조-할당-Outer-Lexical-Envronment-Reference"><a href="#2-2-외부-렉시컬-환경에-대한-참조-할당-Outer-Lexical-Envronment-Reference" class="headerlink" title="2.2. 외부 렉시컬 환경에 대한 참조 할당 Outer Lexical Envronment Reference"></a>2.2. 외부 렉시컬 환경에 대한 참조 할당 Outer Lexical Envronment Reference</h5><p>전역(Global)은 코드의 가장 외부이므로 Global Lexical Environment</p><h5 id="2-3-this-바인딩-ThisBinding"><a href="#2-3-this-바인딩-ThisBinding" class="headerlink" title="2.3. this 바인딩 ThisBinding"></a>2.3. this 바인딩 ThisBinding</h5><h4 id="3-전역-코드-실행"><a href="#3-전역-코드-실행" class="headerlink" title="3. 전역 코드 실행"></a>3. 전역 코드 실행</h4><h4 id="4-함수-코드-평가"><a href="#4-함수-코드-평가" class="headerlink" title="4. 함수 코드 평가"></a>4. 함수 코드 평가</h4><h5 id="1-함수-실행-컨텍스트-생성"><a href="#1-함수-실행-컨텍스트-생성" class="headerlink" title="1. 함수 실행 컨텍스트 생성"></a>1. 함수 실행 컨텍스트 생성</h5><h5 id="2-함수-Lexical-Environment-생성"><a href="#2-함수-Lexical-Environment-생성" class="headerlink" title="2. 함수 Lexical Environment 생성"></a>2. 함수 Lexical Environment 생성</h5><h5 id="2-1-함수-Environment-Record-생성"><a href="#2-1-함수-Environment-Record-생성" class="headerlink" title="2-1. 함수 Environment Record 생성"></a>2-1. 함수 Environment Record 생성</h5><h5 id="2-1-Outer-Lexical-Environment-Reference-할당"><a href="#2-1-Outer-Lexical-Environment-Reference-할당" class="headerlink" title="2-1. Outer Lexical Environment Reference 할당"></a>2-1. Outer Lexical Environment Reference 할당</h5><p>함수는 함수 정의가 평가되어 함수 객체가 생성될 때, 현재 실행 중인 실행 컨텍스트의 Lexical Environment를 함수 객체의 내부 슬롯 <code>[[Environment]]</code>에 저장한다. </p><p>즉, 생성된 함수 객체가 호출되어 평가될 때 생성되는 함수 실행 컨텍스트의 Lexical Environment의 OuterLexicalEnvironmentReference 컴포넌트의 참조는 해당 함수 객체의 내부 슬롯 <code>[[Environment]]</code>에 저장된 Lexical Environment와 같다.</p><h5 id="2-3-this-바인딩"><a href="#2-3-this-바인딩" class="headerlink" title="2-3. this 바인딩"></a>2-3. this 바인딩</h5><p>일반적으로 this는 호출되는 방식에 따라서 다르게 바인딩된다.</p><p>this를 참조하는 순간 추상 연산 ResolveThisBinding 메소드가 도는데, 화살표 함수의 경우 선언된 코드가 실행중인 실행 컨텍스트의 Lexical Environment의 this, 즉 Lexical this를 자신의 this로 바인딩한다.</p><h4 id="5-함수-코드-실행"><a href="#5-함수-코드-실행" class="headerlink" title="5. 함수 코드 실행"></a>5. 함수 코드 실행</h4><h2 id="7-Execution-Context-and-Block-level-Scope"><a href="#7-Execution-Context-and-Block-level-Scope" class="headerlink" title="7. Execution Context and Block-level Scope"></a>7. Execution Context and Block-level Scope</h2><p><a href="http://tc39.es/ecma262/#sec-block-runtime-semantics-evaluation" target="_blank" rel="noopener">ECMAScript block spec</a></p><p>스코프는 렉시컬 환경으로 구현된다. 즉, 블록 레벨 스코프를 만들기 위해서는 Block 렉시컬 환경을 만들어야한다. 그러나 실행 컨텍스트는 4가지 실행 가능한 코드(Executable Code)만이 생성할 수 있다. 그러므로 블록문이 평가될 때는 실행 컨텍스트가 아닌 Lexical Environment만 생성한다.</p><p>Block: { Statement }가 평가될 때 일어나는 일은 다음과 같다.</p><ol><li><p>변수 oldEnv에 running execution context의 LexicalEnvironment를 담는다.</p></li><li><p>변수 blockEnv = NewDeclarativeEnvironment(oldEnv)</p><ul><li>NewDeclarativeEnvironment(E)</li></ul><ol><li>env = new LexicalEnvironment</li><li>envRec = 바인딩 안 된 new declarative Environment Record</li><li>env의 EnvironmentRecord = envRec</li><li>env의 OuterLexicalEnvironmentReference = E</li><li>env를 리턴</li></ol><p>즉 현재 실행중인 실행 컨텍스트의 Lexical Environment를 OuterLexicalEnvironment로 하는 새로운 Block Lexical Environment를 생성해 blockEnv에 담는다. 이 Lexical Environment의 Environment Record 컴포넌트로 Declarative Environment Record를 가진다.</p></li><li><p>BlockDeclarationInstantiation(StatementList, blockEnv) 수행</p><p>Block 또는 CaseBlock이 평가되면 새로운 Declarative Environment Record가 생성되고 블록에서 선언 된 각 block scoped 변수, 상수, 함수 또는 클래스에 대한 바인딩이 환경 레코드에서 인스턴스화된다.</p><ul><li>BlockDeclarationInstantiation ( code, env )<ol><li>envRec = env의 EnvironmentRecord (Deciarative)</li><li>code에서 각 선언문 평가하며 식별자와 값을 바인딩해서 envRec에 추가한다.</li></ol></li></ul></li><li><p>running execution context의 LexicalEnvironment를 새로 생성한 blockEnv로 지정한다. (blockEnv에는 내부 코드가 평가되어 식별자가 등록된 상태)</p></li><li><p>StatementList(block 문 내부의 문들)을 평가하고 결과를 blockValue에 넣는다.</p></li><li><p>running execution context의 LexicalEnvironment를 oldEnv (blockEnv의 상위 Env)로 다시 돌려놓는다.</p></li><li><p>block 문의 실행 결과인 blockValue를 리턴한다.</p></li></ol><p>쉽게 말하면 블록 문을 실행하면 현재 실행 컨텍스트는 변화하지 않는다. 대신 새로운 Block LexicalEnvironment를 생성해서 현재 실행중인 실행 컨텍스트의 LexicalEnvironment로 잠시 대체한다. 원래의 LexicalEnvironment는 oldEnv에 저장해놓는다. 새로 생성한 blovkEnv는 oldEnv를 상위 스코프로 삼는다. blockEnv를 LexicalEnvironment로 참조하는 상태에서 블록 문을 실행한 후에 현재 실행중인 실행 컨텍스트의 LexicalEnvironment를 다시 oldEnv, 즉 블록문을 실행하기 전의 LexicalEnvironment로 돌려놓는다.</p><h2 id="Before-Closure"><a href="#Before-Closure" class="headerlink" title="Before Closure"></a>Before Closure</h2><p>클로저를 이해하기 위해서는 실행 컨텍스트에 대한 선행 지식이 요구된다. 실행 컨텍스트와 스코프 체인, 프로토 타입을 이해하고 있어야 풀 수 있는 아래 문제를 먼저 풀고 넘어가자. foo 함수의 호출 결과는 무엇일까?</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.prototype.x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h4 id="Object-prototype에-x-프로퍼티-추가"><a href="#Object-prototype에-x-프로퍼티-추가" class="headerlink" title="Object.prototype에 x 프로퍼티 추가"></a>Object.prototype에 x 프로퍼티 추가</h4><p><img src="https://user-images.githubusercontent.com/48080762/59080999-cd70e000-8926-11e9-906a-e7f5e7fec911.png" alt="window object inherits Object.prototype"></p><p>전역 객체 window 또한 객체(object)이므로 Object.prototype을 상속받는다.</p><p><img src="https://user-images.githubusercontent.com/48080762/59081249-107f8300-8928-11e9-82e8-68316f16c4c3.png" alt="and Object is window&#39;s builtin object property"></p><p>자바스크립트 엔진은 객체의 프로퍼티에 접근할 때 <code>[[Get]]</code> 내부 메소드를 호출한다. <code>[[Get]]</code> 내부 메소드는 프로토타입 체인에서 프로퍼티를 검색하고 값을 리턴한다. 객체의 프로퍼티에 접근해서 값을 할당할 때는 <code>[[Set]]</code> 내부 메소드를 호출하는데, 똑같이 프로토타입 체인에서 프로퍼티를 검색한다. 그러나 <code>[[Set]]</code> 내부 메소드는 검색한 프로퍼티가 없으면 프로퍼티를 추가하고 할당하는 역할까지 한다.</p><p>Object.prototype에 x라는 프로퍼티가 없었으므로 <code>[[Set]]</code> 내부 메소드가 Object.prototype에 x 프로퍼티를 추가하고 1을 할당한다.</p><h4 id="foo-함수-실행"><a href="#foo-함수-실행" class="headerlink" title="foo 함수 실행"></a>foo 함수 실행</h4><p>식별자 x를 찾기 위해서는 스코프 체인에서 검색을 한다. 따라서 <strong>우선 실행 컨텍스트 스택의 top인 실행중인 실행 컨텍스트(running execution context)의 환경 레코드에서 x를 검색</strong>한다. foo 함수의 실행 컨텍스트에는 식별자 x가 존재하지 않으므로 foo 함수의 OuterLexicalEnvironmentReference로 참조하는, 즉 상위 스코프인 Global Lexical Environment의 환경 레코드로 이동해서 검색을 시작한다. Global(전역)의 경우 환경 레코드가 Object, Declarative 2개의 컴포넌트로 구성된다. Declarative Environment Record에도 x가 없으므로 Object Environment Record에 바인딩된 <strong>window 객체의 프로퍼티 중에 x가 있는지 검색</strong>한다. 이 때 <strong>x는 프로퍼티로 검색되는 것이므로 프로토타입 체인에서 검색</strong>된다. window 객체는 Object.prototype을 상속한다고 했다. 그러므로 1이 할당된 x가 검색되는 것이다.</p><p>여기서 알아야할 것은 스코프 체인과 프로토타입 체인은 별개가 아니라 서로 협력하는 관계라는 것이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;실행 컨텍스트(Execution Context)&lt;/strong&gt;는 &lt;strong&gt;실행 가능한 코드를 평가&lt;/strong&gt;하고 &lt;strong&gt;실행하기 위해 필요한 환경을 제공&lt;/strong&gt;하고 &lt;strong&gt;코드의 실행 결과를 실제로 관리&lt;/strong&gt;하는 영역이다.&lt;/p&gt;
&lt;p&gt;Context는 문맥, 맥락이라는 뜻이다. 프로그램에도 맥락이 있다. 예를 들면 식별자가 어느 스코프에서 사용되었는지에 따라서 다른 값을 참조한다.&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="자바스크립트" scheme="https://sub2n.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="실행 컨텍스트" scheme="https://sub2n.github.io/tags/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>190604-TIL</title>
    <link href="https://sub2n.github.io/2019/06/04/190604-TIL/"/>
    <id>https://sub2n.github.io/2019/06/04/190604-TIL/</id>
    <published>2019-06-04T04:11:33.000Z</published>
    <updated>2019-06-04T07:51:44.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>MongoDB는 Document-Oriented NoSQL Database이다. RDBMS의 Table을 Collection, Tuple를 Document라고 부른다.<br>RDBMS처럼 고정된 Schema가 존재하지 않고 하나의 Collection 내의 DOcument가 각각 다른 Schema를 가질 수 있다.</p><h3 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h3><p>Sass(Syntactically Awesome StyleSheets)는 CSS pre-processor로 CSS의 단점을 보완하고 코드 재사용에 유리한 CSS를 생성하기 위한 CSS의 extension이다.</p><ul><li>변수의 사용</li><li>조건문과 반복문</li><li>Import</li><li>Nesting</li><li>Mixin</li><li>Extend/Inheritance</li></ul><p>등의 도구들을 제공한다.</p><h3 id="한-일"><a href="#한-일" class="headerlink" title="한 일"></a>한 일</h3><ul><li>Todos version 3을 만들었다.</li><li>MongoDB 서버를 연동</li><li>복습하는 겸 네트워크 공부를 조금 했다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;h3 id=&quot;MongoDB&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190603-TIL</title>
    <link href="https://sub2n.github.io/2019/06/03/190603-TIL/"/>
    <id>https://sub2n.github.io/2019/06/03/190603-TIL/</id>
    <published>2019-06-03T08:42:08.000Z</published>
    <updated>2019-06-03T08:46:19.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>오후에 3분간 나가서 자바스크립트 키워드에 대해서 설명하는 시험을 봤다. 자바스크립트 원시타입과 객체타입의 차이에 대해서 발표했다. <a href="https://sub2n.github.io/2019/05/31/자바스크립트-키워드-정리/">💛 키워드 정리</a></li><li>Todo List Server가 있는 환경에서 실습하기 위해서 작업환경을 세팅했다.</li><li>Webpack과 Babel, Sass를 위한 작업 환경을 구성했다.</li><li>호스팅 서비스를 이용해서 MongoDB를 설치했다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;오후에 3분간 나가서 
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Development Environment Setting</title>
    <link href="https://sub2n.github.io/2019/06/03/npm/"/>
    <id>https://sub2n.github.io/2019/06/03/npm/</id>
    <published>2019-06-03T05:22:17.000Z</published>
    <updated>2019-06-03T11:22:53.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-node-package-manager-and-Modularization"><a href="#npm-node-package-manager-and-Modularization" class="headerlink" title="npm (node package manager) and Modularization"></a>npm (node package manager) and Modularization</h2><p>자바스크립트는 웹페이지의 보조적인 기능을 수행하기 위해 만들어진 언어로, 다른 범용 프로그래밍 언어와는 달리 모듈 기능이 없다.</p><p>모듈이란 애플리케이션을 구성하는 개별적인 요소를 말한다. 일반적으로 파일 단위로 분리된다. 모듈을 기능별로 분리해서 개발의 효율성과 유지보수성이 좋아진다.</p><p>그러나 자바스크립트는 파일을 나누었다고 해도 모듈을 로드했을 때 하나의 전역 스코프로 합쳐진다. 즉, 파일 스코프를 지원하지 않는다. 모듈은 그리고 모듈 내부에서 외부로 선택적으로 노출할 수 있는 기능이 있어야 하는데 자바스크립트는 그런 기능이 없었다.</p><p>ES6에서 자바스크립트에서도 <code>&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</code>와 같이 모듈을 지원하지만,  2019년 6월 현재까지는 최신브라우저에서만 지원을 하므로 사용할 수 없다.</p><p>또한 대형 애플리케이션을 만들 때 모듈의 개수가 백 단위를 넘어갈 때 하나하나를 순서에 맞춰서 import하기 어렵다. 이런 문제를 Webpack과 같은 module bundler를 사용해서 하나의 파일로 만들어(module bundling) 해결할 수 있다.</p><p>Babel은 크로스브라우징을 위한 다운그레이드 작업 등의 전처리를 해준다.</p><p>Node.js에서는 CommonJS spec을 받아들여 RequireJS 로 모듈화를 구현하고 있다.</p><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>npm은 자바스크립트 패키지 매니저로, Node.js에서 사용할 수 있는 모듈을 패키지화 해서 모아둔 <strong>저장소 역할</strong>과 패키지 설치 및 관리를 위한 <strong>CLI를 제공</strong>한다. 여기서 패키지란 여러 모듈의 구조를 가지고 모여있는 것을 의미한다. 누구나 자신의 패키지를 공개할 수 있으므로 install할 때는 신뢰성 있는 패키지인지 확인해야 한다.</p><h4 id="node-emoji-설치"><a href="#node-emoji-설치" class="headerlink" title="node-emoji 설치"></a>node-emoji 설치</h4><p><img src="https://user-images.githubusercontent.com/48080762/58779464-ff293480-8610-11e9-8a00-ae1ae039983a.png" alt="npm emoji install"></p><p>package.json이 없어서 안 깔림</p><p><img src="https://user-images.githubusercontent.com/48080762/58779663-95f5f100-8611-11e9-8f76-36b0280b4cb9.png" alt="Again"></p><p>깔림</p><p><a href="https://poiemaweb.com/es6-babel-webpack-1" target="_blank" rel="noopener">Babel Webpack 개발 환경 구축 1</a></p><p><a href="https://poiemaweb.com/es6-babel-webpack-2" target="_blank" rel="noopener">Babel Webpack 개발 환경 구축 2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;npm-node-package-manager-and-Modularization&quot;&gt;&lt;a href=&quot;#npm-node-package-manager-and-Modularization&quot; class=&quot;headerlink&quot; title=&quot;npm (n
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="Node.js" scheme="https://sub2n.github.io/tags/Node-js/"/>
    
      <category term="npm" scheme="https://sub2n.github.io/tags/npm/"/>
    
      <category term="Babel" scheme="https://sub2n.github.io/tags/Babel/"/>
    
      <category term="Webpack" scheme="https://sub2n.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>190531-TIL</title>
    <link href="https://sub2n.github.io/2019/05/31/190531-TIL/"/>
    <id>https://sub2n.github.io/2019/05/31/190531-TIL/</id>
    <published>2019-05-31T09:35:26.000Z</published>
    <updated>2019-05-31T09:39:31.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>Ajax, Promise로 CRUD 구현</li><li>fetch, async 와 await도 사용해봤다</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Ajax, Promis
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트 키워드 정리</title>
    <link href="https://sub2n.github.io/2019/05/31/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%A0%95%EB%A6%AC/"/>
    <id>https://sub2n.github.io/2019/05/31/자바스크립트-키워드-정리/</id>
    <published>2019-05-31T08:44:37.000Z</published>
    <updated>2019-06-13T01:51:08.675Z</updated>
    
    <content type="html"><![CDATA[<p>자바스크립트 키워드 20개</p><a id="more"></a><h2 id="1-Data-Type"><a href="#1-Data-Type" class="headerlink" title="1. Data Type"></a>1. Data Type</h2><p>Data type은 값의 종류를 말한다. 대부분의 프로그래밍 언어는 데이터 타입을 지원한다. 왜일까? 값을 구분할 필요가 있기 때문이다. 메모리 공간은 연속된 메모리 주소로 구분한다. 값을 메모리에 저장할 때는 데이터의 형태가 다르더라도 모두 2진수로 저장된다.</p><ol><li>값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해서,</li><li>메모리에 저장해둔 값을 참조할 때 한 번에 읽어들일 메모리 공간의 크기를 결정하기 위해서,</li><li>메모리에서 읽어들인 2진수를 어떻게 변환할 지 결정하기 위해서 데이터 타입이 필요하다.</li></ol><p>자바스크립트의 데이터 타입은 크게 원시 타입(Primitive Type)과 객체 타입(Object Type)으로 나뉜다. 원시 타입을 제외한 데이터는 모두 객체 타입이다. 그러므로 원시 타입을 우선 살펴보겠다. </p><h3 id="Primitive-Type"><a href="#Primitive-Type" class="headerlink" title="Primitive Type"></a>Primitive Type</h3><p>자바스크립트의 원시 타입은 6종류가 있다.</p><ol><li><p>Number</p><p>자바스크립트는 정수와 실수를 구분하지 않고 모든 수를 실수로 표현한다. 배정밀도 64비트 부동소수점 형식을 따른다. -(2<sup>53</sup> -1) ~ 2<sup>53</sup> -1 사이의 숫자 값을 표현할 수 있다.</p><ul><li>Infinity</li><li>-Infinity</li><li>NaN</li></ul></li><li><p>String</p><p>문자열은 0개 이상의 16bit (2byte) 유니코드 문자 (UTF-16)들의 집합으로 전세계 대부분의 문자를 표현할 수 있다. 자바스크립트에서는 일반적으로 작은 따옴표(‘’)를 사용해서 문자열을 표현한다.</p><p>C나 Java와 달리 자바스크립트의 문자열은 원시타입이고 immutable value다. 한 번 생성된 문자열은 재할당하지 않고서는 변경할 수 없다.</p><ul><li><p>Template Literal</p><p>템플릿 리터럴은 backtick(``)을 사용하며 다음과 같은 특징을 가진다.</p><ul><li>Template literal 내의 모든 공백은 그대로 적용된다. (줄바꿈 포함)</li><li>String interpolation을 사용해서 간단하게 새로운 문자열을 삽입할 수 있다. <code>${ expression }</code>으로 표현식을 감싸면 표현식의 평과 결과가 문자열로 강제 타입 변환 된다.</li></ul></li></ul></li><li><p>Boolean</p><p>true, false</p></li><li><p>undefined</p><p>undefined 타입의 값은 <code>undefined</code>뿐이다. 선언만 하고 명시적으로 값을 할당하지 않은 변수에는 <code>undefiend</code>가 들어있다.</p><p>C 에서는 변수를 선언하고 초기화해주지 않으면 선언만 한 변수에는 garbage value가 들어가있지만, 자바스크립트는 선언문을 평가할 때 암묵적으로 변수를 undefined로 초기화한다.</p></li><li><p>null</p><p>null 타입의 값은 <code>null</code>이 유일하다. null은 변수에 값이 없음을 의도적으로 명시할 때 사용한다. 함수가 유효한 값을 반환할 수 없을 때 명시적으로 null을 반환하기도 한다.</p></li><li><p>Symbol</p><p>symbol은 ES6에서 추가된 타입으로 이름이 충돌하면 안되는 객체의 유일한 Property key를 만들기 위해서 사용한다.</p></li></ol><h3 id="Object-Reference-Type"><a href="#Object-Reference-Type" class="headerlink" title="Object (Reference) Type"></a>Object (Reference) Type</h3><p>객체, 함수, 배열 등 원시타입을 제외한 모든 것이 객체이다.</p><p>typeof undefined는 undefined인데 typeof null은 object임</p><p>자바스크립트는 동적 타입(Dynamic Type) 언어로, 선언할 때가 아니라 할당할 때 타입이 결정된다. 그러므로 재할당에 의해서 변수의 타입이 동적으로 변한다.</p><h2 id="2-Literal"><a href="#2-Literal" class="headerlink" title="2. Literal"></a>2. Literal</h2><p>Literal은 <strong>소스 코드 안에서 직접 만들어낸 고정된 값 그 자체</strong>를 말한다. 리터럴은 자바스크립트 엔진에 의해 해석되어 값으로 평가된다. Literal은 Literal Notation으로 생성한다.</p><h3 id="Literal-Notation"><a href="#Literal-Notation" class="headerlink" title="Literal Notation"></a>Literal Notation</h3><p>리터럴 표기법은 값을 생성하는 방법. 리터럴은 사람이 이해할 수 있는 표기법으로 자바스크립트 엔진에게 값의 생성을 명령하는 것이다.</p><p>리터럴 표기법으로 작성한 리터럴은 자바스크립트 엔진에 의해 해석되어 값으로 평가된다. 리터럴은 결국 값이 되므로 리터럴을 값 자체라고 할 때가 많다. 리터럴은 그 자체로 표현식이며 표현식의 일부로 다른 값을 생성할 때 사용된다.</p><ul><li><p>숫자 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 정수 리터럴</span></span><br><span class="line"><span class="hljs-number">100</span></span><br><span class="line"><span class="hljs-comment">// 부동 소숫점 리터럴</span></span><br><span class="line"><span class="hljs-number">10.5</span></span><br><span class="line"><span class="hljs-comment">// 2진수 리터럴(0b로 시작)</span></span><br><span class="line"><span class="hljs-number">0b01000001</span></span><br><span class="line"><span class="hljs-comment">// 8진수 리터럴(ES6에서 도입. 0o로 시작)</span></span><br><span class="line"><span class="hljs-number">0o101</span></span><br><span class="line"><span class="hljs-comment">// 16진수 리터럴(ES6에서 도입. 0x로 시작)</span></span><br><span class="line"><span class="hljs-number">0x41</span></span><br></pre></td></tr></table></figure></li><li><p>문자열 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 문자열 리터럴</span></span><br><span class="line"><span class="hljs-string">'Hello'</span></span><br><span class="line"><span class="hljs-string">"World"</span></span><br></pre></td></tr></table></figure></li><li><p>불리언 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 불리언 리터럴</span></span><br><span class="line"><span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// null 리터럴</span></span><br><span class="line"><span class="hljs-literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// undefined 리터럴</span></span><br><span class="line"><span class="hljs-literal">undefined</span></span><br></pre></td></tr></table></figure></li><li><p>객체 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 객체 리터럴</span></span><br><span class="line">&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'Lee'</span>, <span class="hljs-attr">gender</span>: <span class="hljs-string">'male'</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>배열 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 배열 리터럴</span></span><br><span class="line">[ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]</span><br></pre></td></tr></table></figure></li><li><p>함수 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 함수 리터럴</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>정규표현식 리터럴 표기법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 정규표현식 리터럴</span></span><br><span class="line">/ab+c/</span><br></pre></td></tr></table></figure></li></ul><p>등을 사용해서 리터럴을 생성하고, 리터럴은 평가되어 값이 된다.</p><h2 id="3-Expression"><a href="#3-Expression" class="headerlink" title="3. Expression"></a>3. Expression</h2><p>표현식은 </p><ul><li>리터럴</li><li>식별자(변수명, 함수명)</li><li>연산자</li><li>함수 호출 </li></ul><p>등의 조합을 말한다. 표현식은 평가되어 하나의 값을 만든다.</p><p><strong>표현식은 하나의 값으로 평가될 수 있는 문(statement)</strong>이다. 표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식으로 나뉜다.</p><p><strong>문(statement)은 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령</strong>이다. 문의 집합으로 이루어진 게 프로그램이다. 문은 선언문, 표현식 문, 조건문, 반복문으로 구분한다.</p><p>표현식인 문과 표현식이 아닌 문을 구분하기 위해서는 변수에 할당하는 것이 가장 빠른 방법이다. 아니면 크롬 개발자 도구에 찍어볼 수도 있다.</p><p><img src="https://user-images.githubusercontent.com/48080762/58757742-806ac380-854c-11e9-855f-158deaf88968.png" alt="Completed Value"></p><blockquote><h3 id="Completion-Value"><a href="#Completion-Value" class="headerlink" title="Completion Value"></a>Completion Value</h3><p>크롬 개발자 도구에서 표현식이 아닌 문은 언제나 undefined를 출력한다. 이를 완료 값(Completion value)이라고 한다.</p></blockquote><h2 id="4-Primitive-type-vs-Object-type"><a href="#4-Primitive-type-vs-Object-type" class="headerlink" title="4. Primitive type vs. Object type"></a>4. Primitive type vs. Object type</h2><p>자바스크립트에서는 데이터 타입을 원시 타입과 객체 타입으로 구분한다. 둘은 그만큼 구분되는 성질을 가진다.</p><ol><li>원시 타입 값은 immutable value이고 객체 타입 값은 mutable value이다.</li><li>원시 값을 변수에 할당하면 변수의 메모리 공간에는 실제 값이 저장되고 객체를 변수에 할당하면 메모리 공간에 참조 값이 저장된다.</li><li>Pass by value 원시 값을 가지는 변수를 다른 변수에 할당하면 원본 원시 값이 복사되어 전달된다. Pass by reference 객체를 가리키는 변수를 다른 변수에 할당하면 원본 참조 값이 복사되어 전달된다.</li></ol><p>그렇다면 immutable value란 무엇일까? 변경 불가능한 값. 즉, read only한 값이다. 값을 변경할 수 없다는 것은 변수가 참조하는 메모리 공간에 저장된 값을 수정할 수 없음을 의미한다. 원시 값이 저장된 변수의 값을 바꾸기 위해서는 새로운 원시 값을 재할당하는 수밖에 없다. 원시 값을 재할당하면 원래 참조하던 메모리 공간에 새로운 원시 값을 뒤집어 쓰는게 아니라 새로운 메모리 공간에 새로운 값을 저장하고 변수가 그 메모리를 참조하게 된다.</p><p>나는 처음 immutable 개념을 공부할 때 변경할 수 없다는 말 때문에 immutable value와 const로 선언한 변수(constant 상수)를 혼동했었는데, constant는 그저 선언과 동시에 할당한 값을 재할당할 수 없는 변수일 뿐이고, constant에 저장되는 값의 종류가 immutable과 mutable인 것이다. 그러므로 그 둘은 개념이 다르다.</p><p>Pass by value란 값에 의한 전달이다. 변수에 변수를 할당했을 때, 변수가 원시 값을 참조하고 있다면 저장되어있는 <strong>값 자체가 복사되어 전달</strong>된다. 반면 변수가 객체 값을 참조하고 있다면 저장된 참조값이 복사되어 <strong>전달된다</strong>. 이처럼 참조값이 전달되는 것을 Pass by reference라고 한다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57297341-57e8d880-710a-11e9-9007-36ec715ebcf7.png" alt="Pass by Value"></p><p><img src="https://user-images.githubusercontent.com/48080762/57299971-d34d8880-7110-11e9-8fc7-1ee9d64a5f13.png" alt="Pass by Reference"></p><h2 id="5-Function-Definition"><a href="#5-Function-Definition" class="headerlink" title="5. Function Definition"></a>5. Function Definition</h2><p>함수 정의를 통해서 함수를 생성할 수 있다. 자바스크립트에서 함수는</p><ul><li>함수 선언문</li><li>함수 표현식</li><li>Function 생성자 함수</li><li>화살표 함수</li></ul><p>로 정의할 수 있다.  그러나 Function 생성자 함수를 통한 함수 정의는 잘 하지 않는다.</p><ol><li><p>함수 선언문</p><p>함수 선언문은 <strong>표현식이아닌 문</strong>으로 해석된다. 함수 선언문은 실행되어 함수 객체를 생성한다. 함수 선언문을 작성할 때는 함수의 이름을 생략할 수가 없다. 자바스크립트 엔진이 선언문을 실행해서 함수 객체를 생성할 때 함수 객체를 저장할 변수를 암묵적으로 함수명과 동일한 이름으로 선언하기 때문이다. 결국 우리가 선언한 함수를 호출할 때 부르는 함수명은 함수 객체를 참조하는 변수명이다. 실제 함수명은 함수 내부에서만 참조할 수 있는 식별자이다. 주로 재귀함수에서 사용한다.</p></li><li><p>함수 표현식</p><p>함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이렇게 변수에 함수를 할당하는 함수 정의 방식을 함수 표현식이라고 한다. 주의해야할 점은, 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수는 호이스팅할 때 다르게 동작한다는 것이다. <strong>함수 선언문</strong>은 선언문이므로 자바스크립트 엔진이 <strong>런타임 이전에 먼저 실행</strong>시켜 함수 객체를 생성하지만, <strong>함수 표현식</strong>은 런타임 도중에 <strong>할당문이 실행되는 시점</strong>에 평가되어 함수 객체가 생성된다. 즉, 함수 표현식으로 생성한 함수는 호이스팅 되지 않는다.</p></li><li><p>화살표 함수</p><p>ES6에서 도입되었으나 모든 함수를 대체하기 위한 것은 아니다. 기존 함수와 다르게 호출 시점이 아니라 선언될 때 상위 lexical scope의 this와 바인딩되고, prototype 프로퍼티가 없고 argument 객체를 생성하지 않는다.</p></li></ol><h2 id="6-Scope"><a href="#6-Scope" class="headerlink" title="6. Scope"></a>6. Scope</h2><p>변수의 유효 범위를 scope라고 한다. 변수는 자신이 <strong>선언된 위치</strong>에 의해서 scope가 결정된다. 유효 범위, <strong>scope란 다른 코드가 변수 자신을 참조할 수 있는 범위를 말한다.</strong></p><p>scope는 전역과 지역으로 나눌 수 있는데, 함수 가장 바깥을 전역이라고 하고 전역에서 선언된 변수를 전역 변수라고 한다. 전역 변수는 코드 상 어디에서나 참조할 수 있다. 지역은 함수 몸체 내부(또는 블록 내부)를 의미하며 지역 스코프에서 선언된 변수를 지역 변수라고 한다. 지역 변수는 자신의 지역 스코프와 그 하위 지역 스코프에서 유효하다.</p><p>scope는 중첩될 수 있으며 scope는 중첩 관계를 바탕으로 scope chain을 만든다. scope는 자바스크립트 엔진이 참조할 변수를 검색할 때 사용되는 규칙이라고 할 수 있다.</p><p>변수를 참조할 때 자바스크립트 엔진은 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하면서 변수를 검색한다. 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 연결한 것으로, 함수의 렉시컬 환경은 함수가 호출되며 생성된다.</p><p>스코프 체인 내의 식별자 검색은 상위 방향으로만 이루어지므로 하위 스코프의 식별자를 상위 스코프에서 참조할 수 없다.</p><p>자바스크립트의 스코프는 Lexical Scope (Static Scope)로 <strong>함수를 어디서 정의했는지에 따라서 함수의 상위 스코프를 결정</strong>한다.</p><h2 id="7-Lexical-Scope"><a href="#7-Lexical-Scope" class="headerlink" title="7. Lexical Scope"></a>7. Lexical Scope</h2><p>자바스크립트의 스코프는 Lexical Scope (Static Scope)로 함수를 어디서 정의했는지에 따라서 함수의 상위 스코프를 결정한다고 했다. 함수가 호출된 위치에 따라서 스코프가 결정되는 것은 Dynamic Scope이다.</p><p>자바스크립트는 렉시컬 스코프를 따르므로 모든 함수 정의가 평가되어 함수 객체를 생성할 때, 자신이 정의된 스코프를 기억한다. 함수가 기억하는 것은 Lexical Enviromnent인데, 함수 객체의 내부 슬롯 <code>[[Environment]]</code>에 저장한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="hljs-comment">// 1</span></span><br><span class="line">bar(); <span class="hljs-comment">// 1</span></span><br></pre></td></tr></table></figure><p>bar() 함수는 foo() 함수 내부에서 호출되었으나, 전역에서 선언되었기 때문에 전역 스코프의 x =1을 우선 찾는다.</p><h2 id="8-전역-변수의-문제점"><a href="#8-전역-변수의-문제점" class="headerlink" title="8. 전역 변수의 문제점"></a>8. 전역 변수의 문제점</h2><ul><li><p><strong>암묵적 결합</strong></p><p>모든 코드가 전역 변수를 참조하고 변경할 수 있기 때문에 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있어 위험하다.</p></li><li><p>긴 생명 주기</p><p>생명 주기가 길다는 것은 리소스가 변경될 수 있는 시간이 길어진다는 것을 의미한다. 또한 브라우저가 종료하기 전까지 소멸되지 않아 메모리 상에 남아있다는 문제가 있다.</p></li><li><p>스코프 체인 상에서 종점에 존재</p><p>변수를 검색할 때 전역 변수가 가장 마지막에 검색되기 때문에 검색 속도가 가장 느리다.</p></li><li><p><strong>네임 스페이스 오염</strong></p><p>파일이 분리되어 있다고 해도 결국 하나의 전역을 갖게 된다. 따라서 각각 다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.</p></li></ul><h2 id="9-var-키워드로-선언한-변수의-문제점"><a href="#9-var-키워드로-선언한-변수의-문제점" class="headerlink" title="9. var 키워드로 선언한 변수의 문제점"></a>9. var 키워드로 선언한 변수의 문제점</h2><p><code>var</code> 키워드로 선언한 변수는 크게 세가지의 문제점을 가진다.</p><ul><li><p>같은 스코프 내에서 중복 선언이 허용된다.</p><p>나중에 작성된 변수 선언문은 마치 var키워드가 없는 것처럼 동작한다. 즉, 오류를 내지 않고 재할당한다. 의도치 않게 재할당되어 먼저 선언된 값이 변경되는 결과를 초래할 수 있다.</p></li><li><p>block-level scope 를 지원하지 않는다. (function-level scope)</p><p>제어문(if문, for문)의 평가식에 선언한 변수는 전역 변수가 된다. 전역 변수를 남발할 가능성이 높아진다.</p><p>for문에서 반복을 위해 사용된 변수 i는 for문 외부에서 사용할 일이 없지만  var 키워드로 선언하면 전역 변수가 된다. 이는 예상치 못한 결과를 가져올 수 있다.</p></li><li><p>변수 호이스팅</p><p>변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.</p><p>변수 선언문 이전에 참조할 수 있다. 이는 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.</p></li></ul><p>이를 보완하기 위해서 ES6에서 let과 const keyword를 도입했다.</p><p><code>let</code>과 <code>const</code>의 특징은 다음과 같다.</p><ul><li>같은 스코프 내에서 중복 선언을 할 수 없다.</li><li>block-level scope를 지원한다.</li><li>hoisting 되지 않는 것처럼 동작한다.</li></ul><h2 id="10-Constructor-Function"><a href="#10-Constructor-Function" class="headerlink" title="10. Constructor Function"></a>10. Constructor Function</h2><p><strong>생성자 함수란?</strong></p><ul><li>new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다.</li><li>자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의 빌트인(intrinsic 내장) 생성자 함수를 제공한다.</li><li>생성자 함수는 다른 함수와 구별하기 위해 함수명의 맨 앞 글자를 대문자로 사용한다.</li><li>생성자 함수는 어떤 특별한 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 정의하고 <strong>new연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.</strong></li></ul><h5 id="생성자-함수에-의한-객체-생성-방식의-장점"><a href="#생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="생성자 함수에 의한 객체 생성 방식의 장점"></a>생성자 함수에 의한 객체 생성 방식의 장점</h5><ul><li>생성자 함수로 객체를 생성하면 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</li></ul><h5 id="내부메소드"><a href="#내부메소드" class="headerlink" title="내부메소드"></a>내부메소드</h5><ul><li><strong>constructor는 생성자 함수로서 호출할 수 있는 객체를 의미</strong>한다. 생성자 함수로서 호출할 수 있다</li><li>new 연산자(또는 super 연산자)와 함께 생성자 함수로서 호출되면 내부 메소드 [[Constructor]]가 호출된다</li><li><strong>모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다.</strong><ul><li>화살표 함수와  ES6의 메소드 축약 표현으로 정의된 함수는 생성자 함수로 호출할 수 없다.</li></ul></li></ul><h5 id="생성자-함수의-동작-방식"><a href="#생성자-함수의-동작-방식" class="headerlink" title="생성자 함수의 동작 방식"></a>생성자 함수의 동작 방식</h5><ul><li>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 <strong>인스턴스를 생성</strong> 하는 것과 <strong>생성된 인스턴스의 프로퍼티 값을 초기화</strong>하는 것이다.</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 1. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다.</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 2. 생성된 빈 객체를 가리키는 this를 사용하여 프로퍼티나 메소드를 추가하고 초기화한다.</span></span><br><span class="line">  <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="hljs-keyword">this</span>.getDiameter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 3. 암묵적으로 this를 반환한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환한다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(circle); <span class="hljs-comment">// Circle &#123;radius: 1, getDiameter: ƒ&#125;</span></span><br></pre></td></tr></table></figure><ul><li>생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손한다. 따라서 <strong>생성자 함수 내부에서 return 문을 반드시 생략해야 한다.</strong></li></ul><h2 id="11-this"><a href="#11-this" class="headerlink" title="11. this"></a>11. this</h2><p>this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 <strong>자기 참조 변수</strong>이다.</p><p>this가 가리키는 객체는 <strong>함수 호출 방식</strong>에 따라 <strong>동적으로 결정</strong>된다.</p><table><thead><tr><th>함수 호출 방식</th><th>this가 가리키는 객체</th></tr></thead><tbody><tr><td>일반 함수로서 호출</td><td>전역 객체</td></tr><tr><td>메소드로서 호출</td><td>메소드를 호출한 객체</td></tr><tr><td>생성자 함수로서 호출</td><td>생성자 함수가(미래에) 생성할 인스턴스</td></tr></tbody></table><ul><li><p>화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다. </p></li><li><p>이벤트 핸들러 내부의 this는 이벤트가 발생한 요소 객체를 가리킨다.</p></li><li><p>Function.prototype.apply/call/bind 메소드에 의한 간접 호출 =&gt; this는 메소드에 argument로 전달한 객체를 가리킨다.</p></li><li><p>바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수는 할당에 의해 값이 바인딩된다.</p></li></ul><h2 id="12-DOM"><a href="#12-DOM" class="headerlink" title="12. DOM"></a>12. DOM</h2><h5 id="DOM이란"><a href="#DOM이란" class="headerlink" title="DOM이란?"></a>DOM이란?</h5><ul><li>브라우저의 렌더링 엔진은  웹 문서를 로드한 후, 파싱하여 <strong>웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재</strong>하는데 이를 DOM이라 한다.</li><li>모든 요소와 요소의 어트리뷰트, 텍스트를 <strong>각각의 객체</strong>로 만들고 이들 객체를 <strong>부자 관계</strong>를 표현할 수 있는 <strong>트리 구조로 구성</strong>한 것이 DOM이다.</li><li><strong>DOM은 자바스크립트를 통해 동적으로 변경</strong>할 수 있으며 변경된 DOM은 렌더링에 반영된다.</li><li>동적 변경을 위해 DOM은 프로그래밍 언어가 자신에게 접근하고 수정할 수 있는 방법을 제공하는데 일반적으로 프로퍼티와 메소드를 갖는 자바스크립트 객체로 제공된다. 이를 DOM API라고 부른다.</li><li>DOM은 ECMAScript에서 정의한 표준이 아닌 별개의 W3C의 공식 표준이다.</li><li><strong>DOM에서 모든 요소, 어트리뷰트, 텍스트는 하나의 객체이며 Document 객체의 자식이다</strong></li></ul><h5 id="DOM의-두-가지-기능"><a href="#DOM의-두-가지-기능" class="headerlink" title="DOM의 두 가지 기능"></a>DOM의 두 가지 기능</h5><ul><li><p><strong>HTML 문서에 대한 모델 구성</strong></p><ul><li>브라우저는 HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성한다. 이때 모델은 객체의 트리로 구성되는데 이것을 <strong>DOM tree</strong>라 한다.</li></ul></li><li><p><strong>HTML 문서 내의 각 요소에 접근 / 수정</strong></p><ul><li>DOM은 모델 내의 각 객체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공한다. DOM이 수정되면 브라우저를 통해 사용자가 보게 될 내용 또한 변경된다.</li></ul></li><li><h5 id="DOM-tree의-네-종류-노드"><a href="#DOM-tree의-네-종류-노드" class="headerlink" title="DOM tree의 네 종류 노드"></a>DOM tree의 네 종류 노드</h5><ul><li><p>문서 노드</p><p>트리의 최상위에 존재</p><p>DOM tree에 접근하기 위한 시작점</p></li><li><p>요소 노드</p><p><strong>HTML 요소를 표현</strong>(div, h1, ul 등)</p><p><strong>중첩에 의해 부자 관계를 가진다.</strong></p><p>어트리뷰트, 텍스트 노드에 접근하려면 먼저 요소 노드를 찾아 접근해야 한다.</p><p>HTMLElement 객체를 상속한 객체로 구성된다</p></li><li><p>어트리뷰트 노드</p><p>HTML 요소의 어트리뷰트를 표현</p><p>해당 어트리뷰트가 지정된 <strong>요소의 자식이 아니라</strong> 해당 요소의 일부로 표현</p></li><li><p>텍스트 노드</p><p>HTML 요소의 텍스트를 표현</p><p><strong>요소 노드의 자식</strong>이며 자신의 자식 노드를 가질 수 없다. 즉, 텍스트 노드는 DOM tree의 최종단이다.</p></li></ul></li></ul><h2 id="13-브라우저-동작"><a href="#13-브라우저-동작" class="headerlink" title="13. 브라우저 동작"></a>13. 브라우저 동작</h2><ul><li>브라우저는 <strong>동기(Synchronous)적</strong>으로 HTML, CSS, 자바스크립트를 처리한다. 이것은 <strong>script 태그의 위치</strong>에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 <strong>script 태그의 위치는 중요한 의미를 갖는다.</strong></li><li>body 요소의 가장 아래에 script 태그를 위치시키면 <strong>이미 HTML 파서가 HTML 요소를 모두 파싱하여 DOM 객체를 생성</strong>하였기 때문에 자바스크립트가 <strong>DOM 조작 시 에러가 발생하지 않는다.</strong> 또한, HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 <strong>페이지 로딩 시간이 단축</strong>된다.</li></ul><h5 id="웹-브라우저의-동작-순서"><a href="#웹-브라우저의-동작-순서" class="headerlink" title="웹 브라우저의 동작 순서"></a>웹 브라우저의 동작 순서</h5><ol><li>클라이언트가 서버에게 <strong>Request(요청)</strong>을 보낸다.</li><li>서버가 <strong>Response(응답)</strong>을 보낸다.</li><li>클라이언트가 서버의 응답을 받아서 HTML, CSS, JavaScript, 이미지 등의 파일을 <strong>Load</strong>한다.</li><li>렌더링 엔진의 HTML 파서와 CSS 파서가 HTML, CSS 파일을 <strong>파싱(Parsing)</strong>한다.<ul><li>자바스크립트는 렌더링 엔진이 아닌 <strong>자바스크립트 엔진</strong>이 처리한다.</li><li>HTML 파서는 <strong>script 태그</strong>를 만나면 자바스크립트 코드를 실행하기 위해 <strong>DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다.</strong></li><li>자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 <strong>브라우저가 중지했던 시점</strong>부터 DOM 생성을 재개한다.</li></ul></li><li>파싱된 결과를 바탕으로 HTML은 <strong>DOM tree</strong>, CSS는 <strong>CSSOM tree</strong>, JavaScript는 <strong>syntax tree</strong>로 변환한다.</li><li>자바스크립트가 DOM tree와 CSSOM tree를 제어한다.</li><li>DOM tree와 CSSOM tree가 <strong>렌더 트리로 결합</strong>된다.</li><li>생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 표시한다.</li></ol><h2 id="14-Event-Delegation"><a href="#14-Event-Delegation" class="headerlink" title="14. Event Delegation"></a>14. Event Delegation</h2><h5 id="이벤트-위임이란"><a href="#이벤트-위임이란" class="headerlink" title="이벤트 위임이란?"></a>이벤트 위임이란?</h5><ul><li><p>다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 <strong>하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법</strong></p></li><li><p>이벤트가 <a href="https://poiemaweb.com/js-event#7-event-flow-이벤트의-흐름" target="_blank" rel="noopener">이벤트 흐름</a>에 의해 <strong>이벤트를 발생시킨 요소의 부모 요소에도 영향**</strong>(버블링)**을 미치기 때문에 가능한 것</p></li></ul><h5 id="이벤트-위임이-효과적인-경우"><a href="#이벤트-위임이-효과적인-경우" class="headerlink" title="이벤트 위임이 효과적인 경우"></a>이벤트 위임이 효과적인 경우</h5><ul><li><p>모든 li 요소가 클릭 이벤트에 반응하는 처리를 구현하고 싶은 경우 =&gt; 부모요소인 ul요소에 클릭 이벤트 핸들러를 바인딩하는 것이 효율적이다.</p></li><li><p><strong>동적으로 li 요소가 추가되는 경우, 아직 추가되지 않은 요소는 DOM에 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다.</strong></p></li></ul><h2 id="15-Event-Capturing-vs-Event-Bubbling"><a href="#15-Event-Capturing-vs-Event-Bubbling" class="headerlink" title="15. Event Capturing vs. Event Bubbling"></a>15. Event Capturing vs. Event Bubbling</h2><h4 id="Capturing"><a href="#Capturing" class="headerlink" title="Capturing"></a>Capturing</h4><ul><li>이벤트가 window 객체에서 출발해서 DOM 트리를 통해서 이벤트 타깃까지 전파되는 것.</li><li>이벤트 타깃이 이벤트를 수신하기 전에 이벤트를 빼돌리는 단계라는 뜻에서 캡처링 단계라는 이름이 붙음</li></ul><h4 id="Bubbling"><a href="#Bubbling" class="headerlink" title="Bubbling"></a>Bubbling</h4><ul><li>이벤트가 이벤트 타깃에서 출발해서 DOM 트리를 타고 window 객체까지 전파되는 것.</li><li>이벤트가 마치 거품이 올라오는 것처럼 DOM트리 아래에서부터 위로 올라온다는 뜻에서 버블링 단계라는 이름이 붙음</li></ul><h2 id="16-Class"><a href="#16-Class" class="headerlink" title="16. Class"></a>16. Class</h2><p>대부분의 객체 지향 언어가 클래스 기반인 점을 고려하여 ES6에서 클래스를 도입했다. 그러나 그 <strong>클래스도 사실은 함수</strong>이고 기존의 프로토타입 기반 객체지향 패턴으로 동작한다.</p><p>클래스는 상속을 빼놓고 말할 수 없다. 상속이란 객체지향의 핵심적인 기능으로, 클래스는 상속을 지원한다.</p><p>클래스의 기본적인 문법은 아래와 같다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// constructor</span></span><br><span class="line">    <span class="hljs-keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// default method definition: class's prototype method</span></span><br><span class="line">    sayHello() &#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi! <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>._name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> mimi = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">'Mimi'</span>);</span><br><span class="line">mimi.sayHello(); <span class="hljs-comment">// Hi! Mimi</span></span><br></pre></td></tr></table></figure><p>클래스 정의 내부에는 최대 한 개의 constructor가 필요하며 constructor를 생략할 경우에 default connstructir() {}가 실행되어 인스턴스 생성시 빈 객체가 생성된다. constructor는 인스턴스를 생성하고 클래스 필드를 초기화하는 특수한 메소드이다.</p><h4 id="Class-Field"><a href="#Class-Field" class="headerlink" title="Class Field"></a>Class Field</h4><p>클래스 내부에는 메소드만 선언한다. 모든 프로퍼티(인스턴스의 멤버 변수)는 constructor 내부에 선언한다. contstructor는 생성자 함수와 같이 this로 빈 객체를 생성해서 프로퍼티를 추가하고 this를 리턴한다.</p><h4 id="Class-Hoisting"><a href="#Class-Hoisting" class="headerlink" title="Class Hoisting"></a>Class Hoisting</h4><p>Class는 <code>let</code>이나 <code>const</code>와 같이 <strong>호이스팅 되지 않는 것처럼</strong> 동작한다. 선언 이전에 참조하면 ReferenceError가 발생한다.</p><blockquote><h4 id="호이스팅되지-않는-것처럼-동작한다는-것"><a href="#호이스팅되지-않는-것처럼-동작한다는-것" class="headerlink" title="호이스팅되지 않는 것처럼 동작한다는 것"></a>호이스팅되지 않는 것처럼 동작한다는 것</h4><p><code>var</code> 키워드와 다르게 <code>let</code>, <code>const</code> 키워드는 런타임 이전에 자바스크립트 엔진이 선언문을 미리 실행할 때, 1. 선언 단계(Declaration Phase)와 2. 초기화 단계(Initialization Phase)가 함께 진행되지 않는다. </p><p><code>let</code>, <code>const</code> 키워드로 선언한 변수는 1. 선언 단계만 미리 실행되어 스코프에 변수 명이 등록되지만 2. 초기화 단계는 런타임에 <strong>선언문이 실행될 때</strong> 실행된다. 2. 초기화 단계는 변수의 값을 위한 메모리 공간을 할당하고 undefined라는 값을 암묵적으로 넣어주는 것이다. 이런 초기화 단계를 진행하지 않았으니 참조 에러가 나는 것이다. </p><p>ES6의  class도 사실은 함수이지만, function 키워드로 선언한 함수 선언식은 호이스팅 되는 반면 class로 선언한 함수는 호이스팅 되지 않는다. 즉, 선언만 해놓고 초기화를 하지 않아 호이스팅되지 않는 것처럼 동작한다.</p><p><code>let</code>이나 <code>const</code> 나 class 등의 선언문 이전을 TDZ(Temporal Dead Zone)이라고 한다. 선언만 되고 초기화되지 않아 참조할 수 없는 구간을 말한다.</p></blockquote><h2 id="17-super"><a href="#17-super" class="headerlink" title="17. super"></a>17. super</h2><h4 id="1-extends-Keyword"><a href="#1-extends-Keyword" class="headerlink" title="1. extends Keyword"></a>1. <code>extends</code> Keyword</h4><p><code>extends</code> 키워드는 parent 클래스를 생속받는 child 클래스를 정의할 때 사용한다.</p><h4 id="2-super-Keyword"><a href="#2-super-Keyword" class="headerlink" title="2. super Keyword"></a>2. <code>super</code> Keyword</h4><p><code>super</code> 키워드는 <strong>parent 클래스를 참조</strong>하거나  <strong>parent 클래스의 constructor를 호출</strong>할 때 사용한다.</p><ol><li><p>super 클래스가 메소드로 사용될 때는 parent 클래스의 constructor를 호출한다. <strong>child 클래스의 constructor에서 super()를 호출하지 않으면 this에 대한 ReferenceError가 발생한다.</strong></p><p>child 클래스의 인스턴스를 만들 때 parent 클래스의 인스턴스를 우선 만들고 상속한다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// parent 클래스의 constructor를 호출한다.</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cylinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(radius, height) &#123;</span><br><span class="line">    <span class="hljs-comment">// super가 parent class의 constructor처럼 사용됨</span></span><br><span class="line">    <span class="hljs-keyword">super</span>(radius);</span><br><span class="line">    <span class="hljs-keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/48080762/58225537-6c111480-7d5d-11e9-9cbb-45fc8d66a2ff.png" alt="super"></p><p>ECMAScript의 스펙을 살펴보면 super가 argument를 전달받으며 호출될 때</p><ol><li>내부적으로 자신의 parent 클래스의 constructor를 호출하고</li><li>constructor가 리턴한 this 객체를 child 클래스 constructor의 this(child 클래스가 생성할 인스턴스)에 바인딩한다.</li></ol></li><li><p>super 클래스가 객체로 사용될 때는 parent 클래스를 참조한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// super가 parent class Circle처럼 사용됨</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// parent class Circle의 getArea overriding</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">super</span>.getPerimeter()) + (<span class="hljs-number">2</span> * <span class="hljs-keyword">super</span>.getArea());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 자신의 메소드 정의</span></span><br><span class="line">  getVolume() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getArea() * <span class="hljs-keyword">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="18-Prototype"><a href="#18-Prototype" class="headerlink" title="18. Prototype"></a>18. Prototype</h2><p><strong>상속 (inheritance)</strong> : 객체지향 프로그래밍의 핵심 개념으로 부모 객체의 프로퍼티를 자식 개체가 상속받아 그대로 사용할 수 있는 것을 말한다.</p><p>자바스크립트의 상속은 프로토타입(prototype)을 기반으로 구현된다.</p><p>상속을 사용해야 하는 이유는,</p><ol><li>동일한 프로퍼티 구조를 갖는 객체를 여러개 만들 때 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 <strong>메모리적 관점에서 비효율적</strong>이기 때문이다. 상속을 사용하면 하나의 프로토타입을 생성해 모든 인스턴스가 공유할 수 있다.</li><li>인스턴스를 생성할 때마다 메소드를 생성하므로 <strong>퍼포먼스적으로 비효율적</strong>이다. 상속은 코드의 재사용이란 관점에서 유용하다. 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해놓으면 생성되는 인스턴스는 메소드 생성 없이 미리 구현된 프로토타입의 프로퍼티를 사용할 수 있다.</li></ol><h4 id="proto-amp-prototype-property"><a href="#proto-amp-prototype-property" class="headerlink" title="_proto_ &amp; prototype property"></a>_<em>proto_</em> &amp; prototype property</h4><p>모든 객체는 <code>[[Prototype]]</code> 내부슬롯에 자신의 프로토타입을 가지고, 접근하기 위해서 _<em>proto_</em> 접근자 프로퍼티를 사용한다. </p><p>함수 객체는 _<em>proto_</em> 접근자 프로퍼티 외에 prorotype 프로퍼티도 소유하는데, 이 둘을 헷갈리면 안된다.</p><p>__proto__는 모든 객체가 가지는 자신의 프로토타입 접근자 프로퍼티이고, prototype 프로퍼티는 함수 객체가 자신이 생성할 인스턴스에 할당하는 프로토타입이다.</p><table><thead><tr><th align="center">구분</th><th align="center">prototype 프로퍼티</th><th align="center">_<em>proto_</em> 접근자 프로퍼티</th></tr></thead><tbody><tr><td align="center">소유</td><td align="center">함수 객체</td><td align="center">모든 객체</td></tr><tr><td align="center">값</td><td align="center">프로토타입의 참조값</td><td align="center">프로토타입의 참조값</td></tr><tr><td align="center">사용 주체</td><td align="center">생성자 함수</td><td align="center">모든 객체</td></tr><tr><td align="center">사용 목적</td><td align="center">자신이 생성할 객체의 프로토타입을 할당하기 위해 사용</td><td align="center">자신의 프로토타입에 접근하기 위해서 사용</td></tr></tbody></table><p>프로토타입은 생성자 함수가 생성되는 시점에 함께 생성된다.</p><h4 id="Prototype-Chain"><a href="#Prototype-Chain" class="headerlink" title="Prototype Chain"></a>Prototype Chain</h4><p><img src="https://user-images.githubusercontent.com/48080762/57827738-7f633380-77e3-11e9-92b8-ccf1ba0c77ab.png" alt="Prototype Chain"></p><p>자바스크립트 엔진은 객체의 프로퍼티에 접근하려고 할 때 해당 객체에서 우선 프로퍼티를 검색하고, 없으면 _<em>proto_</em> 접근자 프로퍼티가 가리키는 프로토타입 객체의 프로퍼티를 순차적으로 검색한다. </p><p>이렇게 연결된 프로토타입들을 프로토타입 체인이라고 한다. <strong>프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘</strong>이다.</p><p>프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. Object.prototype을 프로토 타입 체인의 종점(End ofprototype chain)이라고 한다. </p><p>프로퍼티 체인의 끝까지 올라가 검색했는데도 프로퍼티를 찾지 못 할 경우 에러가 아니라 <code>undefined</code>를 리턴한다.</p><p>식별자의 검색은 함수의 중첩 관계로 이루어진 스코프의 계층적인 구조에서 이루어지고, 프로퍼티의 검색은 객체 간의 상속 관계로 이루어진 프로토타입의 계층적인 구조에서 이루어진다.</p><h2 id="19-Promise"><a href="#19-Promise" class="headerlink" title="19. Promise"></a>19. Promise</h2><p>자바스크립트는 비동기 처리를 위해서 callback 함수 패턴을 사용한다. 그러나 callback 패턴은 가독성이 나쁘고 <strong>에러의 예외 처리가 곤란</strong>하다. ES6에서 Asynchronous processing을 위한 패턴으로 Promise를 도입했다. </p><p>Promise는 비동기 처리를 하고 Response가 오면 해야할 일을 약속하는 것이다.</p><h4 id="콜백-패턴의-단점"><a href="#콜백-패턴의-단점" class="headerlink" title="콜백 패턴의 단점"></a>콜백 패턴의 단점</h4><ol><li><p>콜백 헬</p><p>콜백 패턴을 사용할 때 처리 순서를 위해서 여러 개의 콜백 함수가 중첩되어 프로그래밍의 복잡도가 높아진다. 그래서 콜백 헬이 발생한다.</p></li><li><p>에러 처리의 한계</p><p>Exception(예외)는 Caller 방향으로 전파되는데, 콜백 함수의 경우 Caller를 찾을 수 없으므로 try catch로 에러를 캐치할 수 없다.</p></li></ol><p>이러한 콜백의 단점을 보완하기 위해서 ES6에서 Promise를 도입했다.</p><h4 id="Promise-생성"><a href="#Promise-생성" class="headerlink" title="Promise 생성"></a>Promise 생성</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Asynchronous process</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-comment">/* Asynchronous process Fulilled */</span>) &#123;</span><br><span class="line">        resolve(<span class="hljs-string">'result'</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">/* Asynchronous process Rejected */</span></span><br><span class="line">        reject(<span class="hljs-string">'failure reason'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise constructor function은 비동기 작업을 수행할 callback 함수를 argument로 전달받는다. 이 callback 함수는 resolve, reject 함수를 argument로 전달받는다.</p><p>resolve 함수는 argument로 실행 결과를 전달하며 호출, reject 함수는 argument로 에러 메시지를 전달하며 호출한다.</p><h4 id="Promise-후속-처리"><a href="#Promise-후속-처리" class="headerlink" title="Promise 후속 처리"></a>Promise 후속 처리</h4><p>비동기 함수는 Promise 객체를 리턴해야 한다. 그러면 Promise 객체의 메소드인 then과 catch를 사용해서 후속 처리를 한다.</p><blockquote><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then 메소드는 두 개의 콜백 함수를 argument로 전달받는다. <strong>첫 번째 callback 함수는 성공</strong>(fulfilled, resolve 함수가 호출된 상태) 시 호출되고 <strong>두 번째 callback은 실패</strong>(rejected, reject 함수가 호출된 상태) 시 호출된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; p.then(onFulfilled, onRejected);</span><br><span class="line">&gt; p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;</span><br><span class="line">&gt; <span class="hljs-comment">// fulfilled</span></span><br><span class="line">&gt; &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>&#123;</span><br><span class="line">&gt; <span class="hljs-comment">// rejected</span></span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>onFulfilled</code></p><p>​    Promise가 성공했을 때 호출되는 function. <strong>Fulfillment value</strong> (수행 결과)  (Promise의  resolve argument에 넘겨준 response) 하나를 argument로 받는다. Promise를 리턴한다.</p><p><code>onRejected</code></p><p>​    Promise가 거부되었을 때 호출되는 function. <strong>Rejected reason</strong> (에러 이유) (Promise의  regect argument에 넘겨준 error mesagge) 하나를 argument로 받는다. Promise를 리턴한다.</p></blockquote><blockquote><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p><strong>예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출</strong>된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; p.catch(onRejected);</span><br><span class="line">&gt; </span><br><span class="line">&gt; p.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>&#123;</span><br><span class="line">&gt; <span class="hljs-comment">// rejected</span></span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>onRejected</code></p><p>​    Promise가 거부되었을 때 호출되는 function. Rejected reason을 argument로 받는다.</p></blockquote><p>then과 catch 메소드도 Promise 객체를 리턴하므로 Promise Chaining이 가능하다. 콜백을 중첩시키지 않고서도 처리 순서를 지킬 수 있다.</p><h2 id="20-동기식-처리-모델-vs-비동기식-처리-모델"><a href="#20-동기식-처리-모델-vs-비동기식-처리-모델" class="headerlink" title="20. 동기식 처리 모델 vs. 비동기식 처리 모델"></a>20. 동기식 처리 모델 vs. 비동기식 처리 모델</h2><p>동기식 처리 모델(Synchronous Processing Model)은 Blocking model이라고도 불리며, 어떤 작업 도중에 클라이언트가 서버에 데이터를 요청하는 것과 같이 시간이 오래 걸리는 일이 발생하면 다른 작업을 Blocking 시켜놓고 해당 작업이 끝날 때까지 기다리는 것과 같이 동작한다.</p><p>반면 비동기식 처리 모델(Asynchronous Processing Model)은 작업 도중 서버로의 요청 등 시간이 오래 걸리는 일이 발생하면 기다리지 않고 (non-blocking) 바로 다음 작업을 실행한다.</p><p>자바스크립트의 대부분의 DOM 이벤트와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기식 처리 모델로 동작한다.</p><p><img src="https://poiemaweb.com/img/event-loop.gif" alt="event-loop"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;자바스크립트 키워드 20개&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="자바스크립트" scheme="https://sub2n.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>190529-TIL</title>
    <link href="https://sub2n.github.io/2019/05/29/190529-TIL/"/>
    <id>https://sub2n.github.io/2019/05/29/190529-TIL/</id>
    <published>2019-05-29T09:32:29.000Z</published>
    <updated>2019-05-31T09:36:55.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li>JavaScript Ajax, RESPful API, Promise에 대해서 배웠다.</li><li>알고리즘 문제 해결 전략 책을 샀다. 틈틈히 알고리즘 공부를 해야겠다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JavaScript A
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190527-TIL</title>
    <link href="https://sub2n.github.io/2019/05/27/190527-TIL/"/>
    <id>https://sub2n.github.io/2019/05/27/190527-TIL/</id>
    <published>2019-05-27T09:37:55.000Z</published>
    <updated>2019-05-27T09:47:27.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h3><ul><li>JavaScript Event를 연습하기위해서 TodoList를 여러가지로 구현했다.</li><li>Class를 이용해서 구현하는 방법도 알았다.</li><li>Event Listener를 Class의 method로 만들었을 때 해당 메소드의 this는 class의 instance가 아니라 event를 바인딩한 DOM객체가 되는 문제<ul><li>bind로 event listener method에 this를 binding</li><li>this가 없는 Arrow function을 사용해서 상위 lexical scope, 즉 class의 this를 바인딩하게 하는 방법</li></ul></li></ul><hr><p><a href="https://github.com/Sub2n/Todos-1.0" target="_blank" rel="noopener">Todos 1.0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JavaScript E
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
</feed>
