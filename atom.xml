<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>수빈 개발블로그</title>
  
  <subtitle>Sub2n Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sub2n.github.io/"/>
  <updated>2019-05-17T08:57:57.779Z</updated>
  <id>https://sub2n.github.io/</id>
  
  <author>
    <name>Subin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>22. Array</title>
    <link href="https://sub2n.github.io/2019/05/17/22-Array/"/>
    <id>https://sub2n.github.io/2019/05/17/22-Array/</id>
    <published>2019-05-17T08:05:12.000Z</published>
    <updated>2019-05-17T08:57:57.779Z</updated>
    
    <content type="html"><![CDATA[<p>자바스크립트에서는 배열(Array)도 객체이다. 배열은 Array 생성자로 생성된 Array type의 객체이며 프로토타입 객체로 Array.prototype을 가진다.</p><h1 id="1-Creation-of-Array"><a href="#1-Creation-of-Array" class="headerlink" title="1. Creation of Array"></a>1. Creation of Array</h1><h2 id="1-1-Array-Literal"><a href="#1-1-Array-Literal" class="headerlink" title="1.1. Array Literal"></a>1.1. Array Literal</h2><p>Array literal은 0개 이상의 값을 쉼표(,)로 구분하여 대괄호([])로 묶는다. 배열은 index를 가지며, 첫번째 값은 index 0으로 읽을 수 있다. 존재하지 않는 index로 접근하면 <code>undefined</code>를 리턴한다.</p><p>배열은 순회할 수 있으므로 길이를 나타내는 length 프로퍼티를 가진다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">1</span>]); <span class="hljs-comment">// undefined</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr.length); <span class="hljs-comment">// 0</span></span><br></pre></td></tr></table></figure><p>객체가 프로퍼티의 키와 값을 가지고 프로퍼티 키로 값에 접근하는 반면 배열은 요소의 index로 요소의 값에 접근할 수 있다. Index는 0부터 시작한다.</p><p>다른 프로그래밍 언어와 다르게 자바스크립트의 배열은 서로 다른 데이터 타입의 원소들을 함께 포함할 수 있다.</p><h2 id="1-2-Array-Constructor-Function"><a href="#1-2-Array-Constructor-Function" class="headerlink" title="1.2. Array() Constructor Function"></a>1.2. Array() Constructor Function</h2><p>배열은 보통 배열 리터럴 방식으로 생성하지만 Array 생성자 함수를 사용해서 생성할 수도 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;자바스크립트에서는 배열(Array)도 객체이다. 배열은 Array 생성자로 생성된 Array type의 객체이며 프로토타입 객체로 Array.prototype을 가진다.&lt;/p&gt;
&lt;h1 id=&quot;1-Creation-of-Array&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Array" scheme="https://sub2n.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>190517-TIL</title>
    <link href="https://sub2n.github.io/2019/05/17/190517-TIL/"/>
    <id>https://sub2n.github.io/2019/05/17/190517-TIL/</id>
    <published>2019-05-17T07:46:21.000Z</published>
    <updated>2019-05-17T08:19:02.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h4><ul><li><p>this가 바인딩되는 방식에 대해서 팀원들과 토론했다.</p><p>💛<a href="https://github.com/Sub2n/JavaScript-Study/blob/master/190517-brain-stretching.md" target="_blank" rel="noopener">190517 Brain Stretching</a> </p></li><li><p>Math, String, Number 객체의 메소드를 응용한 알고리즘 연습 문제를 풀었다.</p><p>💛 <a href="https://github.com/Sub2n/FDS12-Algorithm/blob/master/190517.js" target="_blank" rel="noopener">풀이 보러가기</a></p></li><li><p>자바스크립트 Array에 대해서 배웠다.</p></li></ul><hr><h4 id="주말에-할-일"><a href="#주말에-할-일" class="headerlink" title="주말에 할 일"></a>주말에 할 일</h4><ul><li>자바스크립트 String 자주 쓰이는 method 정리하기</li><li>자바스크립트  Array 정리하기</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;this가 바인딩
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>190516-TIL</title>
    <link href="https://sub2n.github.io/2019/05/16/190516-TIL/"/>
    <id>https://sub2n.github.io/2019/05/16/190516-TIL/</id>
    <published>2019-05-16T09:48:57.000Z</published>
    <updated>2019-05-16T09:52:47.241Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h4><ul><li>Prototype 포스팅을 하면서 다시 한 번 정리 했다.</li><li>String, Number, Math, Date 객체의 프로퍼티와 메소드를 공부했다.</li><li><a href="https://github.com/Sub2n/JavaScript-Study/blob/master/190516_problems.js" target="_blank" rel="noopener">String, Number, Math, Date 연습문제</a>를 풀었다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Prototype 포스
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>21. Number, Math and String Object</title>
    <link href="https://sub2n.github.io/2019/05/15/21-Number-Math-Date-and-String-Object/"/>
    <id>https://sub2n.github.io/2019/05/15/21-Number-Math-Date-and-String-Object/</id>
    <published>2019-05-15T10:23:44.000Z</published>
    <updated>2019-05-17T07:51:48.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Number-wrapper-object"><a href="#1-Number-wrapper-object" class="headerlink" title="1. Number wrapper object"></a>1. Number wrapper object</h1><p>Number 객체 : primitive type number를 다룰 때 유용한 프로퍼티와 메소드를 제공하는 wrapper 객체. 변수 또는 객체의 프로퍼티의 값이 숫자라면 Number 객체를 별도로 생성하지 않고 Number 객체의 프로퍼티와 메소드를 사용할 수 있다.</p><p>Primitive type이 wrapper 객체의 메소드를 사용할 수 있는 이유: primitive type으로 wrapper 객체의 프로퍼티나 메소드를 호출할 때 일시적으로 해당 타입과 연관된 wrapper 객체로 변환해 프로토타입 객체를 공유하기 때문.</p><h2 id="1-1-Number-Constructor"><a href="#1-1-Number-Constructor" class="headerlink" title="1.1 Number Constructor"></a>1.1 Number Constructor</h2><p>Number 객체는 Number() 생성자 함수를 통해 생성한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> y = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-string">'123'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> z = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-string">'string'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 123</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(y); <span class="hljs-comment">// 123</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(z); <span class="hljs-comment">// NaN</span></span><br></pre></td></tr></table></figure><p>new 연산자 없이 Number() 함수를 사용하면 Number 객체가 아니라 primitive type number를 반환한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> x = <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> y = <span class="hljs-built_in">Number</span>(<span class="hljs-string">'123'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> z = <span class="hljs-built_in">Number</span>(<span class="hljs-string">'string'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 123</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(y); <span class="hljs-comment">// 123</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(z); <span class="hljs-comment">// NaN</span></span><br></pre></td></tr></table></figure><p>이를 이용해 형변환을 할 수 있다.</p><h2 id="1-2-Number-Property"><a href="#1-2-Number-Property" class="headerlink" title="1.2. Number Property"></a>1.2. Number Property</h2><p>Number 객체의 프로퍼티는 static property로, Number 객체를 생성할 필요 없이 Number.propertyName의 형태로 사용한다.</p><blockquote><h4 id="Static-Property"><a href="#Static-Property" class="headerlink" title="Static Property"></a>Static Property</h4><p>Static method는 생성자 함수로 인스턴트 객체를 만들지 않아도 생성자 함수의 메소드로 직접 호출 가능하며, 생성자 함수가 생성한 인스턴스 객체에서는 사용할 수 없다.</p></blockquote><h3 id="1-2-1-Number-EPSILONES6"><a href="#1-2-1-Number-EPSILONES6" class="headerlink" title="1.2.1. Number.EPSILONES6"></a>1.2.1. Number.EPSILON<sup>ES6</sup></h3><p>Number.EPSILON은 JavaScript에서 표현할 수 있는 가장 작은 수를 나타낸다. EPSILON은 컴퓨터에서 부동소숫점을 표현하는 데에 한계가 있기 때문에 발생하는 오차이다. </p><p>컴퓨터가 표현할 수있는 어떤 임의의 수와, 그 바로 다음으로 표현할 수 있는 수와의 차이를 EPSILON이라고 한다. </p><p>컴퓨터에서 부동소숫점 수를 비교할 때는 Number.EPSILON을 사용하여 두 수의 차이가 최소 오차인 Number.EPSILON보다 작으면 같은 수로 인정한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> === <span class="hljs-number">0.3</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-comment">// 0.1 + 0.2 = 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEqual</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(a - b) &lt; <span class="hljs-built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(isEqual(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-Number-MAX-VALUEES1"><a href="#1-2-2-Number-MAX-VALUEES1" class="headerlink" title="1.2.2. Number.MAX_VALUEES1"></a>1.2.2. Number.MAX_VALUE<sup>ES1</sup></h3><p>Number.MAX_VALUE는 JavaScript에서 사용 가능한 가장 큰 숫자를 반환한다. MAX_VALUE보다 큰 숫자는 Infinity이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>.MAX_VALUE; <span class="hljs-comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="hljs-keyword">const</span> num = <span class="hljs-built_in">Number</span>.MAX_VALUE + <span class="hljs-number">1</span>; <span class="hljs-comment">// num = Number.MAX_VALUE</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">Infinity</span> &gt; <span class="hljs-built_in">Number</span>.MAX_VALUE); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-Number-MIN-VALUEES1"><a href="#1-2-3-Number-MIN-VALUEES1" class="headerlink" title="1.2.3. Number.MIN_VALUEES1"></a>1.2.3. Number.MIN_VALUE<sup>ES1</sup></h3><p>Number.MIN_VALUE는 JavaScript에서 사용 가능한 가장 작은 숫자를 반환한다. MIN_VALUE는 0에 가장 가까운 양수 값이다. MIN_VALUE보다 작은 숫자는 0으로 변환된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>.MIN_VALUE; <span class="hljs-comment">// 5e-324</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MinEpsilon</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.MIN_VALUE &gt; <span class="hljs-built_in">Number</span>.EPSILON) &#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'MIN_VALUE &gt; EPSILON'</span>);</span><br><span class="line"> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.MIN_VALUE &lt; <span class="hljs-built_in">Number</span>.EPSILON) &#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'MIN_VALUE &lt; EPSILON'</span>);</span><br><span class="line"> &#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'MIN_VALUE = EPSILON'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MinEpsilon(); <span class="hljs-comment">// MIN_VALUE &lt; EPSILON</span></span><br></pre></td></tr></table></figure><h3 id="1-2-4-Number-POSITIVE-INFINITYES1"><a href="#1-2-4-Number-POSITIVE-INFINITYES1" class="headerlink" title="1.2.4. Number.POSITIVE_INFINITYES1"></a>1.2.4. Number.POSITIVE_INFINITY<sup>ES1</sup></h3><p>Number.POSITIVE_INFINITY는 양의 무한대 <code>Infinity</code>를 반환한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>.POSITIVE_INFINITY <span class="hljs-comment">// Infinity</span></span><br></pre></td></tr></table></figure><h3 id="1-2-5-Number-NEGATIVE-INFINITYES1"><a href="#1-2-5-Number-NEGATIVE-INFINITYES1" class="headerlink" title="1.2.5. Number.NEGATIVE_INFINITYES1"></a>1.2.5. Number.NEGATIVE_INFINITY<sup>ES1</sup></h3><p>Number.NEGTIVE_INFINITY는 음의 무한대 <code>-Infinity</code>를 반환한다</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>.NEGATIVE_INFINITY <span class="hljs-comment">// -Infinity</span></span><br></pre></td></tr></table></figure><h3 id="1-2-6-Number-NaNES1"><a href="#1-2-6-Number-NaNES1" class="headerlink" title="1.2.6. Number.NaNES1"></a>1.2.6. Number.NaN<sup>ES1</sup></h3><p>Number.NaN은 Not-a-Number를 나타내는 숫자값이다. Number.NaN 프로퍼티는 window.NaN 프로퍼티와 같다. NaN의 type은 number임을 명심하자.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>(<span class="hljs-string">'abc'</span>); <span class="hljs-comment">// NaN</span></span><br><span class="line"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// number</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="isNaN-method"><a href="#isNaN-method" class="headerlink" title="isNaN method"></a>isNaN method</h4><p>NaN은 ==나 === 연산자로 NaN인지 판변할 수 없다. 어떤 숫자가 NaN인지 알기 위해서는 isNaN 메소드를 써야하는데, 2가지 종류가 있으며 다르게 동작하니 알아두면 좋다.</p><ul><li>isNaN() (window.isNaN) : built-in 메소드로, 특이한 형변환을 수행한다.<ul><li>argument가 Number 형이 아닐 경우 값을 순간적으로 Number로 형변환 한 후 NaN인지 검사한다.</li><li>즉, argument가 Number로 강제 형변환 될 경우의 NaN 여부를 반환한다.</li></ul></li><li>Number.isNaN() : 위의 global isNaN()의 보다 엄격한 버전으로, 주어진 값이 NaN인지 검사한다.<ul><li>개선된 점으로 argument가 Number 형이고 값이 NaN일 때만 true를, 아니면 false를 반환한다.</li><li>즉, argument를 강제로 Number 형으로 변환하지 않고 Number 형이 아닌 argument를 전달받을 경우 false를 반환한다.</li></ul></li></ul></blockquote><h2 id="1-3-Number-Method"><a href="#1-3-Number-Method" class="headerlink" title="1.3. Number Method"></a>1.3. Number Method</h2><p>Number 객체의 메소드</p><h3 id="1-3-1-Number-isFinite-testValue-number-boolean-ES6"><a href="#1-3-1-Number-isFinite-testValue-number-boolean-ES6" class="headerlink" title="1.3.1. Number.isFinite(testValue: number): boolean ES6"></a>1.3.1. Number.isFinite(testValue: number): boolean <sup>ES6</sup></h3><p>Number.isFinite() 메소드는 parameter에 전달된 값이 정상적인 유한수인지를 검사하고 결과를 Boolean으로 리턴한다.</p><p>Number.isFinite()는 전역 함수 isFinite()와 달리 argument를 숫자로 강제 형변환 하지 않는다. 숫자가 아닌 argument가 들어오면 언제나 false를 리턴한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-built_in">Number</span>.EPSILON); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-string">'0'</span>); <span class="hljs-comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// isFinite()와 Number.isFinite()</span></span><br><span class="line"><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-literal">null</span>); <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-Number-isInteger-testValue-number-boolean-ES6"><a href="#1-3-2-Number-isInteger-testValue-number-boolean-ES6" class="headerlink" title="1.3.2. Number.isInteger(testValue: number): boolean ES6"></a>1.3.2. Number.isInteger(testValue: number): boolean <sup>ES6</sup></h3><p>Number.isInteger() 메소드는 parameter에 전달된 값이 정수(Integer)인지 검사하고 결과를 Boolean으로 리턴한다. 이 또한 검사 전에 argument를 강제로 Number 형으로 변환하지 않는다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-number">3.0000</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-number">3</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isInteger(<span class="hljs-string">'string'</span>); <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3-Number-isNaN-testValue-number-boolean-ES6"><a href="#1-3-3-Number-isNaN-testValue-number-boolean-ES6" class="headerlink" title="1.3.3. Number.isNaN(testValue: number): boolean ES6"></a>1.3.3. Number.isNaN(testValue: number): boolean <sup>ES6</sup></h3><p>Number.isNaN() 메소드는 parameter에 전달된 값이 NaN인지를 검사하고 결과를 Boolean으로 리턴한다. 검사 전에 argument를 숫자로 변환하지 않는다. global isNaN()과 다르다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-literal">true</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-literal">null</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-number">37</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-string">'string'</span>); <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="1-3-4-Number-isSafeInteger-testValue-number-boolean-ES6"><a href="#1-3-4-Number-isSafeInteger-testValue-number-boolean-ES6" class="headerlink" title="1.3.4. Number.isSafeInteger(testValue: number): boolean ES6"></a>1.3.4. Number.isSafeInteger(testValue: number): boolean <sup>ES6</sup></h3><p>Number.isSafeInteger() 메소드는 parameter에 전달된 값이 정수 표현 범위 내의 안전한 정수 값인지 검사하고 결과를 Boolean으로 리턴한다. 역시 검사 전에 argument를 숫자로 변환하지 않는다.</p><p>안전한 정수 값은  -(2<sup>53</sup> - 1) 이상 (2<sup>53</sup> - 1) 이하의 정수를 말한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Number</span>.isSafeInteger(<span class="hljs-number">2</span>**<span class="hljs-number">53</span>); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isSafeInteger(<span class="hljs-number">2</span>**<span class="hljs-number">53</span> - <span class="hljs-number">1</span>); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isSafeInteger(-(<span class="hljs-number">2</span>**<span class="hljs-number">53</span>)); <span class="hljs-comment">// false</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isSafeInteger(-(<span class="hljs-number">2</span>**<span class="hljs-number">53</span> - <span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">Number</span>.isSafeInteger(<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="1-3-5-Number-prototype-toExponential-fractionDigits-number-string-ES3"><a href="#1-3-5-Number-prototype-toExponential-fractionDigits-number-string-ES3" class="headerlink" title="1.3.5. Number.prototype.toExponential(fractionDigits?: number): string ES3"></a>1.3.5. Number.prototype.toExponential(fractionDigits?: number): string <sup>ES3</sup></h3><p>Number.prototype.toExponential() 메소드는 호출 대상을 지수 표기법으로 변환하여 문자열로 리턴한다. 지수 표기법(Exponential Notation)이란 큰 숫자를 표기할 때 e(Exponent) 앞에 있는 숫자에 10의 n 제곱을 하는 형식으로 수를 나타내는 방식이다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12345 = 1.2345e+3</span><br><span class="line"></span><br><span class="line">0.0000891 = 8.91e-5</span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">0.0000891</span>.toExponential() <span class="hljs-comment">// "8.91e-5"</span></span><br><span class="line"><span class="hljs-number">12345.</span>toExponential() <span class="hljs-comment">// SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="hljs-number">12345</span> .toExponential() <span class="hljs-comment">// "1.2345e+4"</span></span><br><span class="line"><span class="hljs-number">12345.0</span>.toExponential() <span class="hljs-comment">// "1.2345e+4"</span></span><br></pre></td></tr></table></figure><p><code>12345.toExponential()</code>이 SyntaxError를 발생시키는 이유는 무엇일까? 다른 객체와 달리 숫자값 뒤의 <code>.</code>는 2가지 의미를 가진다.</p><ol><li>부동소숫점의 소숫점 구분 기호</li><li>객체 프로퍼티에 접근하기 위한 마침표 표기법(Dot Notation)</li></ol><p>자바스크립트 엔진은 숫자 뒤의 <code>.</code>를 부동 소숫점 숫자의 일부로 해석한다. 따라서 12345.<code>toExponential()</code>이 숫자가 아니기 때문에 문법 오류로 SyntaxError가 발생하는 것이다.</p><p>그렇다면 <code>12345 .toExponential()</code>이 에러를 발생시키지 않는 이유는 무엇일까? <code>.</code>가 숫자 바로 뒤에 오는 것이 아니기 때문에 객체 프로퍼티 접근을 위한 Dot Notation으로 해석했기 때문이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Object</span>         .prototype === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">Object</span>.                 prototype === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-built_in">Object</span>         .     prototype === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-comment">// 띄어쓰기는 Dot Notation에 영향을 주지 않지만 굳이 그렇게 써야할 필요가 없다.</span></span><br></pre></td></tr></table></figure><p>정수 리터럴에 Number.prototype의 메소드를 사용할 경우 아래처럼 괄호로 묶는 것이 권장된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-number">12345</span>).toExponential()</span><br></pre></td></tr></table></figure><h3 id="1-3-6-Number-prototype-toFixed-fractionDigits-number-string-ES3"><a href="#1-3-6-Number-prototype-toFixed-fractionDigits-number-string-ES3" class="headerlink" title="1.3.6. Number.prototype.toFixed(fractionDigits?: number): string ES3"></a>1.3.6. Number.prototype.toFixed(fractionDigits?: number): string <sup>ES3</sup></h3><p>Number.prototype.toFixed() 메소드는 parameter로 지정된 소숫점 자리를 반올림해서 문자열로 리턴한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> num = <span class="hljs-number">12345.6789</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// default: 0</span></span><br><span class="line"><span class="hljs-comment">// 소숫점 이하 반올림</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toFixed()); <span class="hljs-comment">// '12346'</span></span><br><span class="line"><span class="hljs-comment">// 소숫점 이하 1자리수에서 반올림</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toFixed(<span class="hljs-number">1</span>)); <span class="hljs-comment">// '12345.7'</span></span><br><span class="line"><span class="hljs-comment">// 소숫점 이하 2자리수에서 반올림</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toFixed(<span class="hljs-number">2</span>)); <span class="hljs-comment">// '12345.68'</span></span><br><span class="line"><span class="hljs-comment">// 소숫점 이하 3자리수에서 반올림</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toFixed(<span class="hljs-number">3</span>)); <span class="hljs-comment">// '12345.679'</span></span><br><span class="line"><span class="hljs-comment">// 소숫점 이하 4자리수에서 반올림</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toFixed(<span class="hljs-number">4</span>)); <span class="hljs-comment">// '12345.6789'</span></span><br></pre></td></tr></table></figure><h2 id="1-3-7-Number-prototype-toPrecision-precision-number-string-ES3"><a href="#1-3-7-Number-prototype-toPrecision-precision-number-string-ES3" class="headerlink" title="1.3.7. Number.prototype.toPrecision(precision?: number): string ES3"></a>1.3.7. Number.prototype.toPrecision(precision?: number): string <sup>ES3</sup></h2><p>Number.prototype.toPrecision() 메소드는 parameter로 지정된 전체 자릿수(소숫점 자리 아님)까지만 유효하도록 나머지 자릿수를 반올림해서 문자열로 리턴한다. 표현할 수 없는 경우 지수 표기법(Exponential Notation)으로 결과를 반올림한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> num = <span class="hljs-number">12345.6789</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// default: 전체 자릿수</span></span><br><span class="line"><span class="hljs-comment">// 전체 자릿수 유효</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toPrecision()); <span class="hljs-comment">// '12345.6789'</span></span><br><span class="line"><span class="hljs-comment">// 전체 1 자릿수만 유효</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">1</span>)); <span class="hljs-comment">// '1e+4'</span></span><br><span class="line"><span class="hljs-comment">// 전체 2 자릿수만 유효</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">2</span>)); <span class="hljs-comment">// '1.2e+4'</span></span><br><span class="line"><span class="hljs-comment">// 전체 3 자릿수만 유효</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">3</span>)); <span class="hljs-comment">// '1.23e+4'</span></span><br><span class="line"><span class="hljs-comment">// 전체 4 자릿수만 유효</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">4</span>)); <span class="hljs-comment">// '1.235e+4'</span></span><br><span class="line"><span class="hljs-comment">// 전체 5 자릿수만 유효</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">5</span>)); <span class="hljs-comment">// '12346'</span></span><br></pre></td></tr></table></figure><h3 id="1-3-8-Number-prototype-toString-radix-number-string-ES1"><a href="#1-3-8-Number-prototype-toString-radix-number-string-ES1" class="headerlink" title="1.3.8. Number.prototype.toString(radix?: number): string ES1"></a>1.3.8. Number.prototype.toString(radix?: number): string <sup>ES1</sup></h3><p>Number.prototype.toString() 메소드는 숫자를 문자열로 변환해서 리턴한다. radix로 진법(2 ~ 36: 기본 10진수)을 지정할 수 있지만 생략 가능하다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> num = <span class="hljs-number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toString()); <span class="hljs-comment">// '17'</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toString(<span class="hljs-number">2</span>)); <span class="hljs-comment">// '10001'</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toString(<span class="hljs-number">8</span>)); <span class="hljs-comment">// '21'</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(num.toString(<span class="hljs-number">16</span>)); <span class="hljs-comment">// '11'</span></span><br></pre></td></tr></table></figure><h3 id="1-3-9-Number-prototype-valueOf-number-ES1"><a href="#1-3-9-Number-prototype-valueOf-number-ES1" class="headerlink" title="1.3.9. Number.prototype.valueOf(): number ES1"></a>1.3.9. Number.prototype.valueOf(): number <sup>ES1</sup></h3><p>Number.prototype.valueOf() 메소드는 Number 객체의 primitive value를 리턴한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> numObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-string">'30'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> num = numObj.valueOf();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typeof</span> numObj; <span class="hljs-comment">// object</span></span><br><span class="line"><span class="hljs-keyword">typeof</span> num; <span class="hljs-comment">// number</span></span><br></pre></td></tr></table></figure><h1 id="2-Math-Object"><a href="#2-Math-Object" class="headerlink" title="2. Math Object"></a>2. Math Object</h1><p>Math Object : 수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 built-in 객체.</p><p>Math 객체의 프로퍼티와 메소드는 전부 static 프로퍼티와 메소드이다. 생성자 함수 또한 존재하지 않아 직접 Math.property, Math.method()로 호출하면 된다.</p><h2 id="2-1-Math-Property"><a href="#2-1-Math-Property" class="headerlink" title="2.1. Math Property"></a>2.1. Math Property</h2><h2 id="2-1-1-Math-PI"><a href="#2-1-1-Math-PI" class="headerlink" title="2.1.1.Math.PI"></a>2.1.1.Math.PI</h2><p>Math.PI는 PI값(&pi;)을 리턴한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.PI; <span class="hljs-comment">// 3.141592653589793</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Math-Method"><a href="#2-2-Math-Method" class="headerlink" title="2.2. Math Method"></a>2.2. Math Method</h2><h3 id="2-2-1-Math-abs-x-number-number-ES1"><a href="#2-2-1-Math-abs-x-number-number-ES1" class="headerlink" title="2.2.1. Math.abs(x: number): number ES1"></a>2.2.1. Math.abs(x: number): number <sup>ES1</sup></h3><p>Math.abs() 메소드는 숫자의 절댓값(Absolute Value)을 리턴한다. Number.prototype의 메소드처럼 엄격한 type 검사를 하지 않는다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.abs(<span class="hljs-number">-1</span>); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.abs(<span class="hljs-string">'-1'</span>); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.abs(-<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// Infinity</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.abs(<span class="hljs-string">'-Infinity'</span>); <span class="hljs-comment">// Infinity</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.abs(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 0</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.abs([]); <span class="hljs-comment">// 0</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.abs(&#123;&#125;); <span class="hljs-comment">// 0</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.abs(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// NaN</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.abs(<span class="hljs-string">'string'</span>); <span class="hljs-comment">// NaN</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.abs(); <span class="hljs-comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="2-2-2-Math-round-x-number-number-ES1"><a href="#2-2-2-Math-round-x-number-number-ES1" class="headerlink" title="2.2.2. Math.round(x: number): number ES1"></a>2.2.2. Math.round(x: number): number <sup>ES1</sup></h3><p>Math.round() 메소드는 숫자를 가장 인접한 정수로 올림 또는 내림 한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">10.4</span>); <span class="hljs-comment">// 10</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">10.499999999999999</span>); <span class="hljs-comment">// 10</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">10.4999999999999992</span>); <span class="hljs-comment">// 11</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">-10.5</span>); <span class="hljs-comment">// -10</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">-10.500000000000001</span>); <span class="hljs-comment">// -11</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">-10.6</span>); <span class="hljs-comment">// -11</span></span><br></pre></td></tr></table></figure><h3 id="2-2-3-Math-sqrt-x-number-number-ES1"><a href="#2-2-3-Math-sqrt-x-number-number-ES1" class="headerlink" title="2.2.3. Math.sqrt(x: number): number ES1"></a>2.2.3. Math.sqrt(x: number): number <sup>ES1</sup></h3><p>Math.sqrt() 메소드는 숫자의 양의 제곱근(square root)을 리턴한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">16</span>); <span class="hljs-comment">// 4</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">-16</span>); <span class="hljs-comment">// NaN</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-string">'16'</span>); <span class="hljs-comment">// 4</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// Infinity</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 0</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.sqrt([]); <span class="hljs-comment">// 0</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.sqrt(&#123;&#125;); <span class="hljs-comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="2-2-4-Math-ceil-x-number-number-ES1"><a href="#2-2-4-Math-ceil-x-number-number-ES1" class="headerlink" title="2.2.4. Math.ceil(x: number): number ES1"></a>2.2.4. Math.ceil(x: number): number <sup>ES1</sup></h3><p>Math.ceil() 메소드는 숫자를  자신과 가장 가까우면서 큰 정수로 올림한다. Ceil은 천장을 뜻하니 올림한다고 생각하자.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.ceil(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 4</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.ceil(<span class="hljs-number">-3.14</span>); <span class="hljs-comment">// -3</span></span><br></pre></td></tr></table></figure><h3 id="2-2-5-Math-floor-x-number-number-ES1"><a href="#2-2-5-Math-floor-x-number-number-ES1" class="headerlink" title="2.2.5. Math.floor(x: number): number ES1"></a>2.2.5. Math.floor(x: number): number <sup>ES1</sup></h3><p>Math.floor() 메소드는 숫자를 자신과 가장 가까우면서 작은 정수로 내림한다. Floor는 바닥을 뜻한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">3.14</span>); <span class="hljs-comment">//3</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">-3.14</span>); <span class="hljs-comment">// -4</span></span><br></pre></td></tr></table></figure><h3 id="2-2-6-Math-random-number-ES1"><a href="#2-2-6-Math-random-number-ES1" class="headerlink" title="2.2.6. Math.random(): number ES1"></a>2.2.6. Math.random(): number <sup>ES1</sup></h3><p>Math.random() 메소드는 0 이상 1 미만의 임의의 숫자를 리턴한다. 0은 포함하지만 1은 포함하지 않는다는 것에 유의하자. Math.random() 메소드의 결과에 원하는 숫자를 곱해서 PesudoRandom 수를 자유자재로 얻을 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.random(); <span class="hljs-comment">// 0 이상 1 미만의 소수</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 1부터 10까지의 랜덤 정수</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">10</span> + <span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-7-Math-pow-x-number-y-number-number-ES1"><a href="#2-2-7-Math-pow-x-number-y-number-number-ES1" class="headerlink" title="2.2.7. Math.pow(x: number, y: number): number ES1"></a>2.2.7. Math.pow(x: number, y: number): number <sup>ES1</sup></h3><p>Math.pow(base, exponent) 메소드는 첫번째 argument를 밑(base), 두번째 argument를 지수(exponent)로 한 거듭제곱을 리턴한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// 256</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ES7 Exponentiation Operator</span></span><br><span class="line"><span class="hljs-number">2</span> ** <span class="hljs-number">8</span>; <span class="hljs-comment">// 256</span></span><br></pre></td></tr></table></figure><h3 id="2-2-8-Math-max-…-values-number-number-ES1"><a href="#2-2-8-Math-max-…-values-number-number-ES1" class="headerlink" title="2.2.8. Math.max(… values: number[]): number ES1"></a>2.2.8. Math.max(… values: number[]): number <sup>ES1</sup></h3><p>Math.max() 메소드는 argument들 중 가장 큰 수를 리턴한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Math</span>.max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 5</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.max([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]); <span class="hljs-comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];</span><br><span class="line"><span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, arr); <span class="hljs-comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ES6 Spread Opertator</span></span><br><span class="line"><span class="hljs-built_in">Math</span>.max( ... arr); <span class="hljs-comment">// 5</span></span><br></pre></td></tr></table></figure><p>Math.max 의 argument로 배열을 전달할 수 없기 때문에 Function.prototype.apply() 메소드를 이용해서 배열 argument를 전달할 수 있었다.</p><p>그러나 ES6에서는 Spread Operator의 도입으로 apply() 메소드를 사용하지 않아도 배열을 열거된 list argument처럼 풀어서 전달할 수 있다.</p><h3 id="2-2-9-Math-min-…-values-number-number-ES1"><a href="#2-2-9-Math-min-…-values-number-number-ES1" class="headerlink" title="2.2.9. Math.min(… values: number[]): number ES1"></a>2.2.9. Math.min(… values: number[]): number <sup>ES1</sup></h3><p>Math.min() 메소드는 argument들 중 가장 작은 수를 리턴한다. 사용법은 Math.max와 같다.</p><h1 id="3-String-Object"><a href="#3-String-Object" class="headerlink" title="3. String Object"></a>3. String Object</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Number-wrapper-object&quot;&gt;&lt;a href=&quot;#1-Number-wrapper-object&quot; class=&quot;headerlink&quot; title=&quot;1. Number wrapper object&quot;&gt;&lt;/a&gt;1. Number wrappe
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Number" scheme="https://sub2n.github.io/tags/Number/"/>
    
      <category term="Math" scheme="https://sub2n.github.io/tags/Math/"/>
    
      <category term="Date" scheme="https://sub2n.github.io/tags/Date/"/>
    
      <category term="String" scheme="https://sub2n.github.io/tags/String/"/>
    
      <category term="Wrapper" scheme="https://sub2n.github.io/tags/Wrapper/"/>
    
  </entry>
  
  <entry>
    <title>190515-TIL</title>
    <link href="https://sub2n.github.io/2019/05/15/190515-TIL/"/>
    <id>https://sub2n.github.io/2019/05/15/190515-TIL/</id>
    <published>2019-05-15T07:38:04.000Z</published>
    <updated>2019-05-15T08:51:59.648Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h4><ul><li>자바스크립트의 Strict Mode, 전역 객체 window, this 바인딩에 대해서 배웠다.</li><li>Underscore의 each 메소드를 구현했다.</li><li>자바스크립트 알고리즘 문제 3개를 풀었다.<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// if문 사용</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evenOrOdd</span>(<span class="hljs-params">num</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span>) &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'Odd'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">'Even'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 3항 연산자 사용</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evenOrOdd2</span>(<span class="hljs-params">num</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> num % <span class="hljs-number">2</span> ? <span class="hljs-string">'Odd'</span> : <span class="hljs-string">'Even'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evenOrOdd(<span class="hljs-number">42</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evenOrOdd(<span class="hljs-number">55</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evenOrOdd2(<span class="hljs-number">288</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evenOrOdd2(<span class="hljs-number">25</span>));</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// #2. 1 ~ 10,000의 숫자 중 8이 등장하는 횟수 구하기 (Google)</span></span><br><span class="line"><span class="hljs-comment">// 1부터 10,000까지 8이라는 숫자가 총 몇번 나오는가? 이를 구하는 함수를 완성하라.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 단, 8이 포함되어 있는 숫자의 갯수를 카운팅 하는 것이 아니라 8이라는 숫자를 모두 카운팅 해야 한다. 예를 들어 8808은 3, 8888은 4로 카운팅 해야 한다.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// (hint) 문자열 중 n번째에 있는 문자 : str.charAt(n) or str[n]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCount8</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">let</span> concatString = <span class="hljs-string">''</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10001</span>; i++) &#123;</span><br><span class="line">  concatString += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; concatString.length; j++) &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (concatString[j] === <span class="hljs-string">'8'</span>) &#123;</span><br><span class="line">    count += <span class="hljs-number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(getCount8()); <span class="hljs-comment">// 4000</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 3. 문자열 다루기</span></span><br><span class="line"><span class="hljs-comment">// alphaString46 함수는 문자열 s를 매개변수로 입력받는다. s의 길이가 4 ~ 6이고, 숫자로만 구성되어 있는지 확인하는 alphaString46 함수를 완성하라.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 예를 들어 s가 'a234'이면 false를 리턴하고 '1234'라면 true를 리턴한다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alphaString46</span>(<span class="hljs-params">s</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (s === <span class="hljs-literal">undefined</span> || s.length &lt; <span class="hljs-number">4</span> || s.length &gt; <span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="hljs-comment">// eslint-disable-next-line no-restricted-globals</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(s[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46(<span class="hljs-string">'1234'</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46(<span class="hljs-string">'9014'</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46(<span class="hljs-string">'723'</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46(<span class="hljs-string">'a234'</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46(<span class="hljs-string">''</span>));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(alphaString46());</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;자바스크립트의 Stri
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>Underscore: each</title>
    <link href="https://sub2n.github.io/2019/05/15/Underscore-each/"/>
    <id>https://sub2n.github.io/2019/05/15/Underscore-each/</id>
    <published>2019-05-15T04:08:16.000Z</published>
    <updated>2019-05-16T09:49:08.935Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/48080762/57747874-59ba2980-7712-11e9-8a09-b7f1825254e4.png" alt="each pass"></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_.each = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection, iterator</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(collection)) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; collection.length; index++) &#123;</span><br><span class="line">      iterator(collection[index], <span class="hljs-built_in">Number</span>(index), collection);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> collection) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (key !== <span class="hljs-string">'someProperty'</span>)</span><br><span class="line">        iterator(collection[key], key, collection);</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/48080762/57747874-59ba2980-7712-11e9-8a09-b7f1825254e4.png&quot; alt=&quot;each pass&quot;&gt;&lt;/p&gt;
&lt;fig
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://sub2n.github.io/categories/Algorithm/"/>
    
      <category term="UnderScore" scheme="https://sub2n.github.io/categories/Algorithm/UnderScore/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Algorithm" scheme="https://sub2n.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>20. this</title>
    <link href="https://sub2n.github.io/2019/05/15/20-this/"/>
    <id>https://sub2n.github.io/2019/05/15/20-this/</id>
    <published>2019-05-15T03:45:06.000Z</published>
    <updated>2019-05-16T05:53:03.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-this-Keyword"><a href="#1-this-Keyword" class="headerlink" title="1. this Keyword"></a>1. this Keyword</h1><p>this는 객체가 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수(Self-referencing variable)이다. 함수 호출시 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. arguments 객체와 this는 함수 내부에서 지역 변수처럼 사용할 수 있다. this가 가리키는 값은 <strong>함수 호출 방식에 의해 동적으로 결정</strong>된다.</p><p>C++, Java와 같은 클래스 기반 언어에서 this는 항상 클래스로부터 생성되는 인스턴스를 가리킨다. 그러나 자바스크립트의 this는 함수가 호출되는 방식에 따라서 this에 바인딩될 객체가 동적으로 결정된다.</p><blockquote><h4 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h4><p>바인딩이란 식별자와 값을 연결하는 과정을 의미한다.</p></blockquote><p>객체 리터럴은 할당 단계에 평가되므로 객체의 식별자를 this 대신 사용할 수 있지만, 일반적이지 않다. 생성자를 이용해서 객체를 생성할 때는 인스턴트를 가리킬 식별자를 미리 알 수 없기 때문이다.</p><p>this는 객체의 프로퍼티나 메소드를 참조하기 위한 변수이므로 객체의 메소드 또는 생성자 함수에서만 의미가 있다. strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩 된다. 적용되지 않을 경우 일반 함수 내부에서 this는 전역 객체 window를 가리킨다.</p><blockquote><h4 id="strict-mode"><a href="#strict-mode" class="headerlink" title="strict mode"></a>strict mode</h4><p>‘use strict’;  strict mode는 자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.</p></blockquote><h1 id="2-Function-call-types-and-this-Binding"><a href="#2-Function-call-types-and-this-Binding" class="headerlink" title="2. Function call types and this Binding"></a>2. Function call types and this Binding</h1><p><strong>스코프</strong>의 경우 렉시컬 스코프(Lexical Scope)는 <strong>함수 정의가 평가되어 함수 객체가 생성되는 시점</strong>에 상위 스코프가 결정된다. <strong>this</strong>에 바인딩될 객체는 <strong>함수 호출 시점</strong>에 결정된다.</p><p>함수 호출 방식은 다음과 같다.</p><ol><li>일반 함수 호출 : this는 window</li><li>메소드 호출 : this는 메소드를 호출한 객체</li><li>생성자 함수 호출 : this는 생성할 instance</li><li>Function.prototype.apply/call/bind 메소드에 의한 간접 호출 (??)</li></ol><h2 id="2-1-General-Function-Call"><a href="#2-1-General-Function-Call" class="headerlink" title="2.1. General Function Call"></a>2.1. General Function Call</h2><p><strong>일반 함수로 호출된 함수 내부의 this</strong>에는 <strong>전역 객체(Global Object)</strong>가 바인딩된다.</p><p>전역 함수는 물론 <strong>중첩 함수를 일반 함수로 호출했을 때에도 함수 내부의 this에는 전역 객체가 바인딩</strong>된다. 일반 함수에서는 this로 객체의 프로퍼티나 메소드를 참조할 일이 없으므로 this에 의미가 없다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo this: '</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">// window</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar this: '</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>메소드 내에서 정의한 중첩 함수일지라도 <strong>일반 함수로 호출되면 중첩 함수의 this는 전역 객체</strong>이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo this: '</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">// &#123;foo: f&#125;</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar this: '</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 메소드 내부에서 정의한 중첩 함수라도 일반 함수로 호출하면 this에 전역 객체가 바인딩된다.</span></span><br><span class="line">    bar();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure><p>마찬가지로 콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 정리하면 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.</p><p>메소드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 메소드의 this 바인딩과 일치시키기 위한 방법은 다음과 같다.</p><ol><li><p>this를 변수에 저장하고 콜백 함수의 this를 변수로 대체 </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="hljs-number">100</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    cosnt that = <span class="hljs-keyword">this</span>;</span><br><span class="line">    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(that.value); <span class="hljs-comment">// 100</span></span><br><span class="line">    &#125;, <span class="hljs-number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메소드 이용</p> <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123;</span><br><span class="line">  value: <span class="hljs-number">100</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="hljs-comment">// bind method의 argument를 콜백 함수의 this로 바인딩한다.</span></span><br><span class="line">    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.value); <span class="hljs-comment">// 100</span></span><br><span class="line">    &#125;.bind(<span class="hljs-keyword">this</span>), <span class="hljs-number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-Method-Call"><a href="#2-2-Method-Call" class="headerlink" title="2.2. Method Call"></a>2.2. Method Call</h2><p><strong>메소드 내부의 this는 메소드를 호출한 객체</strong>, 즉 메소드 호출시 (.) 연산자 앞에 오는 객체에 바인딩된다.</p><p>메소드를 소유한 객체가 아닌, 메소드를 호출한 객체에 바인딩된다는 것을 주의해야 한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> me = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Park'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> you = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Kim'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">you.getName = me.getName;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(me.getName()); <span class="hljs-comment">// "Park"</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(you.getName()); <span class="hljs-comment">// "Kim"</span></span><br></pre></td></tr></table></figure><h2 id="2-3-Constructor-Function-Call"><a href="#2-3-Constructor-Function-Call" class="headerlink" title="2.3. Constructor Function Call"></a>2.3. Constructor Function Call</h2><p>생성자 함수 내부의 this에는 생성자 함수가 생성할 instance가 바인딩된다.</p><p>생성자 함수는 객체(instance)를 생성하는 함수로, new 연산자와 함께 호출되면 빈 객체를 만들고 this에 바인딩한다. 연산을 하며 this 객체를 완성시킨 후 this를 리턴한다.</p><p>함수가 new 연산자와 함께 호출되지 않아 일반 함수로 동작할 경우 this는 전역 객체를 가리킨다.</p><h2 id="2-4-Indirect-Call-by-Function-prototype-apply-call-bind-method"><a href="#2-4-Indirect-Call-by-Function-prototype-apply-call-bind-method" class="headerlink" title="2.4. Indirect Call by Function.prototype.apply / call / bind method"></a>2.4. Indirect Call by Function.prototype.apply / call / bind method</h2><h3 id="apply-call"><a href="#apply-call" class="headerlink" title="apply, call"></a>apply, call</h3><p>Function.prototype의 메소드 apply와 call은 argument로 this와 arguments list를 전달받아 함수를 호출한다. Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 Function.prototype.apply와 call을 상속받아 사용할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출한다.</span></span><br><span class="line"><span class="hljs-comment"> * @param thisArg - this로 사용될 객체</span></span><br><span class="line"><span class="hljs-comment"> * @param argsArray - 함수에게 전달할 인수 리스트 배열</span></span><br><span class="line"><span class="hljs-comment"> * @returns 호출된 함수의 반환값</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-built_in">Function</span>.prototype.apply(thisArg, [argsArray]))</span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 주어진 this 바인딩과 인수 리스트를 사용하여 함수를 호출한다.</span></span><br><span class="line"><span class="hljs-comment"> * @param thisArg - this로 사용될 객체</span></span><br><span class="line"><span class="hljs-comment"> * @param arg1, arg2, ... - 함수에게 전달할 인수 리스트</span></span><br><span class="line"><span class="hljs-comment"> * @returns 호출된 함수의 반환값</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-built_in">Function</span>.prototype.call(thisArg, arg1, arg2, ...))</span><br></pre></td></tr></table></figure><p>두 메소드의 차이는,</p><ul><li>apply 메소드는 호출할 함수의 arguments를 배열로 묶어 전달한다.</li><li>call 메소드는 호출할 함수의 arguments를 쉼표로 구분한 리스트 형식으로 전달한다.</li></ul><p>apply와 call은 호출할 함수에 argument를 전달하는 방식만 다를 뿐, this로 사용할 객체와 argument를 전달하며 함수를 호출한다.</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>bind 메소드는 메소드의 this와, 메소드 내부의 중첩함수 또는 콜백 함수의 this가 불일치하는 문제를 해결할 때 사용된다. 콜백 함수 foo는 외부 함수 callName을 돕는 헬퍼 함수(보조 함수)의 역할을 해야하기 때문에 외부 함수 내부의 this와 콜백함수 내부의 this가 다르면 문제가 발생한다.</p><p>이 때 bind 메소드를 사용해서 this를 일치시킨다. apply와 call 메소드 또한 사용할 수 있다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.callName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;</span><br><span class="line">    callback.bind(<span class="hljs-keyword">this</span>)();</span><br><span class="line">    <span class="hljs-comment">// callback.apply(this);</span></span><br><span class="line">    <span class="hljs-comment">// callback.apply(this);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind로 this를 전달한 callback을 실행할 수도 있고, apply나 call로 this를 전달하며 동시에 호출할 수도 있다.</p><p>정리하면 this 바인딩은 다음과 같이 실행된다.</p><table><thead><tr><th style="text-align:center">함수 호출 방식</th><th style="text-align:center">this 바인딩</th></tr></thead><tbody><tr><td style="text-align:center">일반 함수 호출</td><td style="text-align:center">전역 객체</td></tr><tr><td style="text-align:center">메소드 호출</td><td style="text-align:center">메소드를 호출한 객체</td></tr><tr><td style="text-align:center">생성자 함수 호출</td><td style="text-align:center">생성자 함수가 생성할 instance</td></tr><tr><td style="text-align:center">Function.prototype.apply/call/bind 메소드에 의한 간접 호출</td><td style="text-align:center">Function.prototype.apply/call/bind 메소드에 argument로 전달한 객체</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-this-Keyword&quot;&gt;&lt;a href=&quot;#1-this-Keyword&quot; class=&quot;headerlink&quot; title=&quot;1. this Keyword&quot;&gt;&lt;/a&gt;1. this Keyword&lt;/h1&gt;&lt;p&gt;this는 객체가 자신의 프로퍼티나 
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="this" scheme="https://sub2n.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>19. Global Object</title>
    <link href="https://sub2n.github.io/2019/05/15/19-Global-Object/"/>
    <id>https://sub2n.github.io/2019/05/15/19-Global-Object/</id>
    <published>2019-05-15T03:43:39.000Z</published>
    <updated>2019-05-15T06:03:04.310Z</updated>
    
    <content type="html"><![CDATA[<p>전역 객체는 어떤 객체보다도 먼저 생성하고 어느 객체에도 속하지 않는 최상위 객체.</p><ul><li><p>client side 환경(브라우저)에서는 window</p></li><li><p>server side 환경에서는 global 객체</p></li></ul><p>전역 객체는</p><ul><li>개발자가 의도적으로 생성할 수 없다.</li><li>전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.</li><li>전역 객체는 Object, String, Number,Boolean, Function, Array RegExp, Date, Math, Promise 등 모든 built-in 객체를 프로퍼티로 가지고 있다.</li><li>브라우저의 window 객체는 DOM, BOM, Canvas, XMLHttpRequest, Fetch, SVG, Web Storage 등 Client side Web API를 프로퍼티로 소유한다.</li><li>var 키워드로 선언한 전역 변수와 암묵적 전역 변수, 전역 함수는 전역 객체의 프로퍼티가 된다. (단, let이나 const 키워드로 선언한 전역 변수는 전역 객체  window의 프로퍼티가 아니다.)</li><li>전역 객체의 프로퍼티와 메소드는 window를 생략하고 참조/호출 할 수 있으므로 전역 함수처럼 사용할 수 있다.</li></ul><h1 id="1-Global-Property"><a href="#1-Global-Property" class="headerlink" title="1. Global Property"></a>1. Global Property</h1><p>전역 프로퍼티는 전역 객체의 프로퍼티이다.</p><h2 id="1-1-Infinity"><a href="#1-1-Infinity" class="headerlink" title="1.1. Infinity"></a>1.1. Infinity</h2><p>Infinity 프로퍼티는 양/음의 무한대를 나타내는 Number Infinity를 갖는다. 숫자를 0으로 나누면 NaN이 될 것 같지만 무한대를 나타낸다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>/<span class="hljs-number">0</span>);<span class="hljs-comment">// Infinity</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>/<span class="hljs-number">-0</span>);<span class="hljs-comment">// -Infinity</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">Infinity</span>);<span class="hljs-comment">// number</span></span><br></pre></td></tr></table></figure><h2 id="1-2-NaN"><a href="#1-2-NaN" class="headerlink" title="1.2. NaN"></a>1.2. NaN</h2><p>NaN(Not-a-Number) 프로퍼티는 숫자가 아님을 나타내는 Number NaN을 갖는다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">'string'</span>));<span class="hljs-comment">// NaN</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> * <span class="hljs-string">'string'</span>); <span class="hljs-comment">// NaN</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>);<span class="hljs-comment">// number</span></span><br></pre></td></tr></table></figure><h2 id="1-3-undefined"><a href="#1-3-undefined" class="headerlink" title="1.3. undefined"></a>1.3. undefined</h2><p>undefined 프로퍼티는 primitive type undefined를 값으로 갖는다.</p><h1 id="2-Global-Function"><a href="#2-Global-Function" class="headerlink" title="2. Global Function"></a>2. Global Function</h1><p>전역 함수는 전역 객체의 메소드이다. 애플리케이션 전역에서 호출할 수 있다.</p><h2 id="2-1-eval"><a href="#2-1-eval" class="headerlink" title="2.1. eval"></a>2.1. eval</h2><p>문자열로 코드를 주면 그 코드를 실행하는데, 평가시 자신의 스코프를 만들고 상위 스코프로 변형시켜 비용이 많이 든다.</p><h2 id="2-2-isFinite"><a href="#2-2-isFinite" class="headerlink" title="2.2. isFinite"></a>2.2. isFinite</h2><p>parameter에 전달된 값이 정상적인 유한수인지 검사해서 Boolean을 리턴한다. 숫자가 아닌 값 전달받으면 숫자 타입으로 변환 후 검사를 수행한다.</p><h2 id="2-3-isNaN"><a href="#2-3-isNaN" class="headerlink" title="2.3. isNaN"></a>2.3. isNaN</h2><p>parameter에 전달된 값이 NaN인지 검사해서 Boolean을 리턴한다. 숫자가 아닌 값 전달받으면 숫자 타입으로 변환 후 검사를 수행한다.</p><h2 id="2-4-parseFloat"><a href="#2-4-parseFloat" class="headerlink" title="2.4. parseFloat"></a>2.4. parseFloat</h2><p>parameter에 전달된 <strong>String을 부동소숫점 숫자(floating point number)로</strong> 변환하여 반환한다.</p><h2 id="2-5-parseInt"><a href="#2-5-parseInt" class="headerlink" title="2.5. parseInt"></a>2.5. parseInt</h2><p>parameter에 전달된 <strong>String을 정수형 숫자(Integer)로</strong> parsing하여 리턴한다. 리턴값은 10진수이다.</p><p>10진수 숫자를 10진수가 아닌 수의 문자열로 변환하고 싶을 때는 Number.prototype.toString 메소드를 사용한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> x = <span class="hljs-number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x.toString(<span class="hljs-number">2</span>));<span class="hljs-comment">// '1010'</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x.toString(<span class="hljs-number">8</span>));<span class="hljs-comment">// '12'</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x.toString(<span class="hljs-number">16</span>));<span class="hljs-comment">// 'a'</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(x.toString());<span class="hljs-comment">// '10'</span></span><br></pre></td></tr></table></figure><h2 id="2-6-encodeURI-decodeURI"><a href="#2-6-encodeURI-decodeURI" class="headerlink" title="2.6. encodeURI / decodeURI"></a>2.6. encodeURI / decodeURI</h2><p>encodeURI 함수는 paremeter로 전달된 URI(Uniform Resource Identifier)를 인코딩한다.</p><blockquote><h4 id="URI-Uniform-Resource-Identifier"><a href="#URI-Uniform-Resource-Identifier" class="headerlink" title="URI (Uniform Resource Identifier)"></a>URI (Uniform Resource Identifier)</h4><p>인터넷에 있는 자원을 나타내는 유일한 주소. URI의 하위 개념으로 URL, URN이 있다.</p><ul><li>Scheme(protocol) : 통신 방식</li><li>Host : 찾아갈 server의 주소<ul><li>localhost : 컴퓨터 한 대에서 client와 server를 동시에 돌릴 때 server를 의미. Port 번호로 server에 고유 번호를 매김</li></ul></li><li>Port : port 번호</li><li>Path : file 경로<ul><li>REST API : 서버와 통신시 메소드 호출방식처럼 사용</li></ul></li><li>Query Parameter : ?key=value&amp;key=value&amp;key=value</li><li>Fragment : # page 내 이동에서 씀</li></ul></blockquote><p>인코딩이랑 URI의 문자들을 Escape 처리 하는 것을 의미한다. Escape 처리는 네트워크를 통해 정보를 공유할 때 ASCII Character-set으로 변환하는 것이다. 한글은 %EC%9E%90 등과 같이 인코딩 된다.</p><p>decodeURI 함수는 paremeter로 전달된 encoded URI을 전달받아 escape 처리 되기 전으로 디코딩한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;전역 객체는 어떤 객체보다도 먼저 생성하고 어느 객체에도 속하지 않는 최상위 객체.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;client side 환경(브라우저)에서는 window&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;server side 환경에서는 global 객
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="window" scheme="https://sub2n.github.io/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>18. JavaScript Prototype</title>
    <link href="https://sub2n.github.io/2019/05/12/18-JavaScript-Prototype/"/>
    <id>https://sub2n.github.io/2019/05/12/18-JavaScript-Prototype/</id>
    <published>2019-05-12T01:42:10.000Z</published>
    <updated>2019-05-17T05:32:00.369Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript는</p><ul><li>명령형 (Imperative)</li><li>함수형 (Functional)</li><li>프로토타입 기반 (Prototype-based) 객체지향 프로그래밍</li></ul><p>을 지원하는 멀티 패러다임 프로그래밍 언어.</p><p>프로토타입은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 방식이다.</p><p>자바스크립트는 객체 기반 프로그래밍 언어로, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다.</p><h1 id="1-Object-Oriented-Programming"><a href="#1-Object-Oriented-Programming" class="headerlink" title="1. Object-Oriented Programming"></a>1. Object-Oriented Programming</h1><p>이전에 포스팅한 객체 지향 프로그래밍 포스팅을 참고</p><p><a href="https://sub2n.github.io/2019/04/24/4-Fundamental-of-Object-Oriented-Programming/">4 Fundamental of Object Oriented Programming</a></p><p>객체지향 프로그래밍은 프로그래밍을 명령어 또는 함수의 목록으로 보는 명령형 프로그래밍의 절차지향적 관점에서 벗어나 <strong>프로그램을 여러개의 독립적 객체들의 집합으로 표현</strong>하려는 프로그래밍 패러다임을 말한다.</p><p>객체지향 프로그래밍에는 몇 가지 원칙이 있다.</p><ul><li>추상화 (abstraction) : 다양한 속성 중에서 프로그램에 필요한 속성만을 간추려내어 표현하는 것을 추상화라고 한다. 불필요한 정보는 숨기고 필요한 정보만을 표현함으로써 공토</li><li>캡슐화 (encapsulation) : 모든 객체가 자신의 상태(state, private variavles)를 클래스 내부에 private으로 보유함으로써 지켜진다. 내부 상태를 내부 메소드로만 접근할 수 있게 한다.</li><li><strong>상속 (inheritance)</strong> : 객체지향 프로그래밍의 핵심 개념으로 부모 객체의 프로퍼티를 자식 개체가 상속받아 그대로 사용할 수 있는 것을 말한다.</li><li>다형성 (polymorpism) : 부모 객체가 선언한 interface 메소드를 자식 객체가 재정의(overiding) 함으로써 하나의 interface로 상황에 따라 기능을 달리 하는 것을 말한다.</li></ul><h1 id="2-Inheritance-and-Prototype"><a href="#2-Inheritance-and-Prototype" class="headerlink" title="2. Inheritance and Prototype"></a>2. Inheritance and Prototype</h1><p>자바스크립트의 상속은 프로토타입(prototype)을 기반으로 구현된다.</p><p>상속을 사용해야 하는 이유는,</p><ol><li>동일한 프로퍼티 구조를 갖는 객체를 여러개 만들 때 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리적 관점에서 비효율적이기 때문이다. 상속을 사용하면 하나의 프로토타입을 생성해 모든 인스턴스가 공유할 수 있다.</li><li>인스턴스를 생성할 때마다 메소드를 생성하므로 퍼포먼스적으로도 비효율적이다. 상속은 코드의 재사용이란 관점에서 유용하다. 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해놓으면 생성되는 인스턴스는 메소드 생성 없이 미리 구현된 프로토타입의 프로퍼티를 사용할 수 있다.</li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Add getGeometer method to Circle's prototype object(prototype).</span></span><br><span class="line"><span class="hljs-comment">// The prototype is bound to the prototype property of the Circle constructor function.</span></span><br><span class="line">Circle.prototype.getGeometer = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">this</span>.radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> circle1 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">2</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> circle2 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// All instances of Circle constuctor have same prototype(Circle constuctor function's prototype proeprety).</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(circle1) === <span class="hljs-built_in">Object</span>.getPrototypeOf(circle2)) <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(circle1) === Circle.prototype) <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="3-prototype-Object"><a href="#3-prototype-Object" class="headerlink" title="3. prototype Object"></a>3. prototype Object</h1><p><strong>Prototype Object(prototype)는 Object간의 상속을 구현하기 위해 사용된다</strong>. 프로토타입은 어떤 object의 Parent obect 역할을 하는 객체로, 다른 객체에 Shared property를 제공한다.  Prototype을 상속받은 Child object는 Parent object의 프로퍼티를 자신의 프로퍼티처럼 사용할 수 있다.</p><p>모든 객체는 <code>[[Prototype]]</code> 내부 슬롯을 가지며, 내부 슬롯의 값으로 프로토타입 객체의 참조를 저장한다. 프로토타입은 객체의 생성 방식에 의해 결정된다.</p><p>객체 리터럴로 생성된 객체의 프로토타입은 <strong>Object.prototype</strong>이고, 생성자 함수에 의해 생성된 객체의 프로토타입은 <strong>자신을 생성한 함수의 prototype 프로퍼티</strong>이다.</p><p><strong>모든 객체는 하나의 프로토타입을 가지며 모든 프로토타입은 생성자 함수와 연결되어 있다.</strong> 이는 객체와 프로토타입, 생성자 사이를 연결한다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57820069-2042f600-77c6-11e9-8292-68c91244925a.png" alt="Prototype Connection"></p><ul><li>Constructor Function : prototype property가 prototype object를 가리킴</li><li>Constructor Function.prototype Object : constructor property가 constructor function를 가리킴</li><li>Obejct : <strong> proto </strong> Accessor property로 자신을 생성한 함수의 prototype Obect에 접근할 수 있음 (내부 슬롯 <code>[[Prototype]]</code>이 가리키고 있음)</li></ul><h2 id="3-1-Object’s-proto-Accessor-Property"><a href="#3-1-Object’s-proto-Accessor-Property" class="headerlink" title="3.1. Object’s __proto__ Accessor Property"></a>3.1. Object’s __proto__ Accessor Property</h2><p>모든 객체는 <strong> proto </strong> 접근자 프로퍼티를 통해 자신의 프로토타입 (<code>[[Prototype]]</code> 내부 슬롯)에 접근할 수 있다.</p><h4 id="proto-is-an-Accessor-Property"><a href="#proto-is-an-Accessor-Property" class="headerlink" title="__proto__ is an Accessor Property"></a>__proto__ is an Accessor Property</h4><p>내부 슬롯은 프로퍼티가 아니므로 직접 접근할 수 없고 제공하는 접근자 프로퍼티를 통해서 접근할 수 있다. 접근자 프로퍼티는 접근자 함수로 구성된 프로터티다. <a href="https://sub2n.github.io/2019/05/09/15-Property-Definition/">프로퍼티 정의 포스팅 참고</a></p><p><img src="https://user-images.githubusercontent.com/48080762/57598149-05397180-758d-11e9-88f0-6b24cffc4ef4.png" alt="__proto__"></p><p>Object.prototype의 __proto__ 접근자 프로퍼티는 자신의 getter, settter 함수(get <code>__proto__</code>, set <code>__proto__</code>)를 통해 <code>[[Prototype]]</code> 내부 슬롯의 값, 즉 프로토타입을 가져오거나 저장한다. </p><blockquote><h4 id="Internal-Method-GetPrototypeOf-amp-SetPrototypeOf"><a href="#Internal-Method-GetPrototypeOf-amp-SetPrototypeOf" class="headerlink" title="Internal Method [[GetPrototypeOf]] &amp; [[SetPrototypeOf]]"></a>Internal Method [[GetPrototypeOf]] &amp; [[SetPrototypeOf]]</h4><p>get <strong> proto </strong>는 자신의 프로토타입 취득시 [[GetPrototypeOf]] 내부 메소드를 호출</p><p>set <strong> proto </strong>는 새로운 프로토타입 할당시 [[SetPrototypeOf]] 내부 메소드를 호출</p></blockquote><h4 id="코드-내에서-proto-접근자-프로퍼티-직접-사용-자제"><a href="#코드-내에서-proto-접근자-프로퍼티-직접-사용-자제" class="headerlink" title="코드 내에서 __proto__ 접근자 프로퍼티 직접 사용 자제"></a>코드 내에서 __proto__ 접근자 프로퍼티 직접 사용 자제</h4><p>코드 내에서 __proto__ 직접 사용하는 것 대신 Object.getPrototypeOf, Object.setPrototypeOf 메소드를 사용하는 것을 권장한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(Person) === Person.__proto__);<span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="proto-접근자-프로퍼티는-상속을-통해-사용됨"><a href="#proto-접근자-프로퍼티는-상속을-통해-사용됨" class="headerlink" title="__proto__ 접근자 프로퍼티는 상속을 통해 사용됨"></a>__proto__ 접근자 프로퍼티는 상속을 통해 사용됨</h4><p>__proto__ 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아닌, Object.prototype으로부터 상속받은 프로퍼티이다. 모든 객체는 상속을 통해서 Object.prototype.<strong> proto </strong> 접근자 프로퍼티를 사용할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57592782-75d39480-7573-11e9-887c-c49eef672893.png" alt="Object.prototype"></p><blockquote><h4 id="Prototype-Chain"><a href="#Prototype-Chain" class="headerlink" title="Prototype Chain"></a>Prototype Chain</h4><p>모든 객체는 프로토타입 계층 구조인 프로토타입 체인에 묶여있다. 자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 __proto__ 접근자 프로퍼티가 가리키는 링크를 따라서 부모 프로토타입의 프로퍼티를 검색한다. 프로토타입 체인의 최상위 객체는 Object.prototype이다. 모든 객체는 Object.prototype 객체를 상속하므로 Object.prototype의 프로퍼티를 사용할 수 있다.</p></blockquote><h4 id="proto-접근자-프로퍼티를-통해서-프로토타입에-접근하는-이유"><a href="#proto-접근자-프로퍼티를-통해서-프로토타입에-접근하는-이유" class="headerlink" title="__proto__ 접근자 프로퍼티를 통해서 프로토타입에 접근하는 이유"></a>__proto__ 접근자 프로퍼티를 통해서 프로토타입에 접근하는 이유</h4><p>__proto__ 접근자 프로퍼티를 통해서 프로토타입에 접근하면 객체들이 서로가 자신의 프로토타입이 되어 순환 참조적 프로토타입 체인이 만들어지지 않도록 에러를 발생시킨다. 프로토타입 체인이 cyclic하게 되면 프로퍼티 검색시 무한 루프에 빠진다.</p><p>즉, Object.prototype의 set __proto__() (setter function)이 객체가 프로토타입을 상호참조할 때 에러를 발생시킨다.</p><h2 id="3-2-Function-Object’s-prototype-Property"><a href="#3-2-Function-Object’s-prototype-Property" class="headerlink" title="3.2. Function Object’s prototype Property"></a>3.2. Function Object’s prototype Property</h2><p>함수 객체는 __proto__ 접근자 프로퍼티 외에 prototype 프로퍼티도 소유한다.</p><p>__proto__는 모든 객체가 가지는 자신의 프로토타입 접근자 프로퍼티이고, prototype 프로퍼티는 함수 객체가 자신이 생성할 인스턴스에 할당하는 프로토타입이다.</p><table><thead><tr><th style="text-align:center">구분</th><th style="text-align:center">prototype 프로퍼티</th><th style="text-align:center">__proto__ 접근자 프로퍼티</th></tr></thead><tbody><tr><td style="text-align:center">소유</td><td style="text-align:center">함수 객체</td><td style="text-align:center">모든 객체</td></tr><tr><td style="text-align:center">값</td><td style="text-align:center">프로토타입의 참조값</td><td style="text-align:center">프로토타입의 참조값</td></tr><tr><td style="text-align:center">사용 주체</td><td style="text-align:center">생성자 함수</td><td style="text-align:center">모든 객체</td></tr><tr><td style="text-align:center">사용 목적</td><td style="text-align:center">자신이 생성할 객체의 프로토타입을 할당하기 위해 사용</td><td style="text-align:center">자신의 프로토타입에 접근하기 위해서 사용</td></tr></tbody></table><h2 id="3-3-Prototype’s-constructor-Property-and-the-Constructor-Function"><a href="#3-3-Prototype’s-constructor-Property-and-the-Constructor-Function" class="headerlink" title="3.3. Prototype’s constructor Property and the Constructor Function"></a>3.3. Prototype’s constructor Property and the Constructor Function</h2><p>함수 객체가 소유한 prototype 프로퍼티는 상속할 프로토타입을 가리킨다. 모든 프로토타입은 constructor 프로퍼티를 갖는다. constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. </p><p><img src="https://user-images.githubusercontent.com/48080762/57821160-75810680-77ca-11e9-8aad-04f7dbfc2800.png" alt="constructor Property &amp; prototype Property"></p><p><strong>생성자 함수가 생성될 때 암묵적으로 프로토타입과 생성자 함수 간의 연결이 이루어진다.</strong> </p><h1 id="4-Constructor-Functions-and-Prototypes-of-Objects-Created-by-Literal-Notation"><a href="#4-Constructor-Functions-and-Prototypes-of-Objects-Created-by-Literal-Notation" class="headerlink" title="4. Constructor Functions and Prototypes of Objects Created by Literal Notation"></a>4. Constructor Functions and Prototypes of Objects Created by Literal Notation</h1><p>생성자 함수로 만들지 않은 객체도 Object.prototype을 상속받아야하므로 Object constructor function과도 연결된다.</p><p>프로토타입과 생성자 함수는 언제나 pair로 존재해야 하기 때문에 리터럴 표기법에 의해 생성된 객체는 엄밀히 말하면 생성자 함숭 의해 생성된 객체가 아니지만, 생성자 함수의 프로토타입과 연결된다.</p><table><thead><tr><th style="text-align:center">Literal Notation</th><th style="text-align:center">Constructor Function</th><th style="text-align:center">Prototype</th></tr></thead><tbody><tr><td style="text-align:center">Object Literal</td><td style="text-align:center">Object</td><td style="text-align:center">Object.prototype</td></tr><tr><td style="text-align:center">Function Literal</td><td style="text-align:center">Function</td><td style="text-align:center">Function.prototype</td></tr><tr><td style="text-align:center">Array Literal</td><td style="text-align:center">Array</td><td style="text-align:center">Array.prototype</td></tr><tr><td style="text-align:center">RegExp Literal</td><td style="text-align:center">RegExp</td><td style="text-align:center">RegExp.prototype</td></tr></tbody></table><h1 id="5-When-will-prototypes-be-created"><a href="#5-When-will-prototypes-be-created" class="headerlink" title="5. When will prototypes be created?"></a>5. When will prototypes be created?</h1><p>위에서 리터럴 표기법에 의해서 생성된 객체도 생성자 함수와 연결되는 것을 알아보았다. 생성자 함수는 사용자 정의 생성자 함수와 자바스크립트 built-in 생성자 함수로 구분할 수 있다. <strong>프로토타입은 생성자 함수가 생성되는 시점에 생성된다.</strong></p><h2 id="5-1-User-Defined-Constructor-Function-and-Prototype-Creation"><a href="#5-1-User-Defined-Constructor-Function-and-Prototype-Creation" class="headerlink" title="5.1. User Defined Constructor Function and Prototype Creation"></a>5.1. User Defined Constructor Function and Prototype Creation</h2><p>화살표 함수나 ES6의 메소드 축약 표현으로 정의하지 않고 일반적으로 정의(함수 선언문, 함수 표현식)한 함수는 내부 메소드 <code>[[Constructor]]</code>가 구현되어 new 연산자와 함께 호출하면 생성자 함수로 호출할 수 있다.</p><p>생성자 함수로 호출할 수 있는 constructor는 함수 객체가 생성될 때 프로토타입도 함께 생성된다. 함수 객체는 함수 정의가 평가될 때 생성된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 함수 정의는 Hoisting되어 런타임 이전에 함수 객체를 생성하므로 Student.prototype도 함께 생성되어있다.</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Student.prototype);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="함수의-생성-시점"><a href="#함수의-생성-시점" class="headerlink" title="함수의 생성 시점"></a>함수의 생성 시점</h4><ul><li><p>함수 선언문으로 정의한 함수</p><p>함수 선언문으로 정의한 함수는 자바스크립트 엔진이 런타임 이전에 모든 선언문을 미리 실행할 때 평가되어 함수 객체가 된다. 이 때 생성된 함수 객체는 암묵적으로 함수명과 동일한 이름을 가진 변수에 할당된다.</p></li><li><p>함수 표현식으로 정의한 함수</p><p>함수 표현식으로 정의한 함수는 런타입에 변수에 할당될 때, 즉 런타임에 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.</p></li></ul></blockquote><h2 id="5-2-Built-in-Constructor-Function-and-Prototype-Creation"><a href="#5-2-Built-in-Constructor-Function-and-Prototype-Creation" class="headerlink" title="5.2. Built-in Constructor Function and Prototype Creation"></a>5.2. Built-in Constructor Function and Prototype Creation</h2><p>Object, Function, Number, String, Array, RegExp, Date, Promise 등과 같은 built-in 생성자 함수도 마찬가지로 built-in 생성자 함수가 생성되는 시점에 프로토타입이 같이 생성된다. 모든 built-in 생성자 함수는 전역 객체(window)가 생성되는 시점에 생성된다. 전역 객체는 웹 애플리케이션 실행시 가장 처음으로 생성된다.</p><p>웹 애플리케이션 실행시 전역 객체 window 가 만들어지고, built-in 생성자 함수들이 만들어짐과 동시에 프로토타입 객체도 생성되어 built-in 생성자 함수의 prototype 프로퍼티에 바인딩된다.</p><h1 id="6-How-to-Create-an-Object-and-Determine-its-Prototype"><a href="#6-How-to-Create-an-Object-and-Determine-its-Prototype" class="headerlink" title="6. How to Create an Object and Determine its Prototype"></a>6. How to Create an Object and Determine its Prototype</h1><p>객체는 다양한 방식으로 생성할 수 있다.</p><ul><li>객체 리터럴</li><li>Object 생성자 함수</li><li>생성자 함수</li><li>Object.create 메소드</li><li>클래스 (ES6)</li></ul><p>객체 리터럴로 생성하는 방식이 가장 간단한 객체 생성 방식이다. 객체 생성방식은 여러가지지만 모두 추상 연산 ObjectCreate에 의해 생성된다. </p><p>추상 연산 ObjectCreate는 필수로 자신이 생성할 객체의 프로토타입을 argument로 전달받는다. 추상 연산 ObjectCreate는 객체를 생성한 후 인수로 전달받은 프로토타입을 자신이 생성한 객체의 <code>[[Prototype]]</code> 내부 슬롯에 할당한 후, 생성한 객체를 반환한다.</p><p>ObjectCreate의 proto parameter로 전달될 argument는 객체가 생성되는 시점에, 객체 생성 방식에 따라서 결정된다.</p><h2 id="6-1-Prototype-of-Object-Created-by-Object-Literal"><a href="#6-1-Prototype-of-Object-Created-by-Object-Literal" class="headerlink" title="6.1. Prototype of Object Created by Object Literal"></a>6.1. Prototype of Object Created by Object Literal</h2><p>자바스크립트 엔진은 객체 리터럴을 평가해서 객체를 생성할 때 추상 연산 ObjectCreate를 호출한다. 이 때 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다.</p><p>즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이다.</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj) === <span class="hljs-built_in">Object</span>.prototype); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-comment">// 객체 리터럴의 생성자 함수는 Object 생성자 함수와 연결된다.</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj.constructor === <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="6-2-Prototype-of-Object-Created-by-Object-Constructor-Function"><a href="#6-2-Prototype-of-Object-Created-by-Object-Constructor-Function" class="headerlink" title="6.2. Prototype of Object Created by Object Constructor Function"></a>6.2. Prototype of Object Created by Object Constructor Function</h2><p>Object 생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다. Object 생성자 함수를 호출하면 객체 리터럴을 평가할 때와 같이 추상 연산 ObjectCeate를 호출한다.</p><p>이 때 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Object 생성자 함수에 의해 생성된 객체의 프로토타입은 Object.prototype이다.</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj) === <span class="hljs-built_in">Object</span>.prototype); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj.constructor === <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="6-3-Prototype-of-Object-Created-by-Constructor-Function"><a href="#6-3-Prototype-of-Object-Created-by-Constructor-Function" class="headerlink" title="6.3. Prototype of Object Created by Constructor Function"></a>6.3. Prototype of Object Created by Constructor Function</h2><p>new 연산자와 함께 생성자 함수를 호출해서 인스턴스를 생성하면 역시나 추상 연산 ObjectCreate를 호출한다.</p><p>이 때 추상 연산 ObjectCreate에 전달되는 프로토타입은 호출된 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다.</p><p>즉, 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩된 객체이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> me = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">'Park'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩된 객체이다.</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(me) === Student.prototype); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(me.constructor === Student); <span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><p>생성자 함수의 prototype 프로퍼티에 바인딩된 프로토타입 객체는 프로퍼티와 메소드를 동적으로 추가할 수 있다.</p><h1 id="7-Prototype-Chain"><a href="#7-Prototype-Chain" class="headerlink" title="7. Prototype Chain"></a>7. Prototype Chain</h1><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Student.prototype에 메소드 추가</span></span><br><span class="line">Student.prototype.callMyName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi! I'm <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> me = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">'Park'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(me.hasOwnProperty(<span class="hljs-string">'name'</span>)); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(me.hasOwnProperty(<span class="hljs-string">'callMyName'</span>)); <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><p>위의 예제에서 name 프로퍼티는 Student의 인스턴스인 me의 고유 프로퍼티이지만, callMyName은 me 프로토타입의 프로퍼티이므로 hasOwnProperty가 false를 리턴한다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57827129-17abe900-77e1-11e9-8512-e30fa7dd32ba.png" alt="Object &#39;me&#39;"></p><p>그런데 hasOwnProperty는 어느 객체의 메소드인데 별다른 정의 없이 호출할 수 있는 것일까? hasOwnProperty는 Object.prototype의 메소드로, 모든 객체가 Object.prototype을 상속하므로 호출할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57827185-5d68b180-77e1-11e9-92f2-cb18be530e24.png" alt="Prototype Chain of me"></p><p>조금 복잡해보이는 me 객체, me 객체의 prototype, Object.prototype의 관계를 그림으로 표현하면 아래와 같다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57827738-7f633380-77e3-11e9-92b8-ccf1ba0c77ab.png" alt="Prototype Chain"></p><p>자바스크립트 엔진은 객체의 프로퍼티에 접근하려고 할 때 해당 객체에서 우선 프로퍼티를 검색하고, 없으면 __proto__ 접근자 프로퍼티가 가리키는 프로토타입 객체의 프로퍼티를 순차적으로 검색한다. 이렇게 연결된 프로토타입들을 프로토타입 체인이라고 한다. <strong>프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘</strong>이다.</p><p>프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. Object.prototype을 프로토 타입 체인의 종점(End ofprototype chain)이라고 한다. Object.prototype의 <code>[[Prototype]]</code>에 __proto__로 접근하면 null이다.</p><p>프로퍼티 체인의 끝까지 올라가 검색했는데도 프로퍼티를 찾지 못 할 경우 에러가 아니라 <code>undefined</code>를 리턴한다.</p><p>식별자의 검색은 함수의 중첩 관계로 이루어진 스코프의 계층적인 구조에서 이루어지고, 프로퍼티의 검색은 객체 간의 상속 관계로 이루어진 프로토타입의 계층적인 구조에서 이루어진다.</p><h1 id="8-Static-Property-Method"><a href="#8-Static-Property-Method" class="headerlink" title="8. Static Property/Method"></a>8. Static Property/Method</h1><p>Static 프로퍼티(메소드 포함)는 생성자 함수로 인스턴트를 생성하지 않아도 참조하거나 호출할 수 있는 프로퍼티를 말한다. Static 메소드 내부에는 this를 쓸 필요가 없다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Constructor Function</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.staticProp = <span class="hljs-string">'static property'</span>;</span><br><span class="line"></span><br><span class="line">Student.staticMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'static method'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student.staticProp; <span class="hljs-comment">// 'static property'</span></span><br><span class="line">Student.staticMethod(); <span class="hljs-comment">// 'static method'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> me = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">'Park'</span>);</span><br><span class="line"></span><br><span class="line">me.staticMethod(); <span class="hljs-comment">// Uncaught TypeError: me.staticMethod is not a function</span></span><br></pre></td></tr></table></figure><p>Student 생성자 함수는 객체이므로 자신의 프로퍼티와 메소드를 소유할 수 있다. 생성자 함수가 소유한 프로퍼티와 메소드를 정적 프로퍼티, 정적 메소드(Static property, method)라고 부른다. Static 프로퍼티와 메소드는 생성자 함수가 생성한 인스턴스로는 참조하거나 호출할 수 없다.</p><p>이는 프로토타입 체인을 이해하고 있다면 당연한 결과이다. 위 예제에서 인스턴스 객체 me가 프로퍼티를 검색하는 프로토타입 체인에는 Student의 staticProp와 staticMethod()가 없기 때문이다.</p><p>프로토타입 객체에 정의되어있는 메소드를 Prototype Method, 생성자 함수에 정의되어있는 메소드를 Static Method라고 한다.</p><h1 id="8-Property-Existance-Check-in-Operator"><a href="#8-Property-Existance-Check-in-Operator" class="headerlink" title="8. Property Existance Check : in Operator"></a>8. Property Existance Check : <code>in</code> Operator</h1><p>in 연산자는 객체 내에 프로퍼티가 존재하는지 확인해 Boolean 값을 반환한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> student = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Park'</span>,</span><br><span class="line">    grade: <span class="hljs-string">'3'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'name'</span> <span class="hljs-keyword">in</span> student); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'grade'</span> <span class="hljs-keyword">in</span> student); <span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'address'</span> <span class="hljs-keyword">in</span> student); <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><p>in 연산자는 확인의 대상이 되는 객체 (student)의 프로퍼티 뿐만 아니라 그 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인한다. 그 객체의 고유 프로퍼티만 검색하고 싶다면 Object.hasOwnProperty(prototype)을 사용한다.</p><h1 id="9-Property-Enumeration"><a href="#9-Property-Enumeration" class="headerlink" title="9. Property Enumeration"></a>9. Property Enumeration</h1><p>객체의 모든 프로퍼티를 순회하려면 for…in 문을 사용한다. for…in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> student = &#123;</span><br><span class="line">    name: <span class="hljs-string">'Park'</span>,</span><br><span class="line">    grade: <span class="hljs-string">'3'</span>,</span><br><span class="line">    address: <span class="hljs-string">'Seoul'</span>,</span><br><span class="line">    age: <span class="hljs-number">22</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> student) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;prop&#125;</span>: <span class="hljs-subst">$&#123;student[prop]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// name: Park,</span></span><br><span class="line"><span class="hljs-comment">// grade: 3,</span></span><br><span class="line"><span class="hljs-comment">// address: Seoul,</span></span><br><span class="line"><span class="hljs-comment">// age: 22</span></span><br></pre></td></tr></table></figure><p>for…in 문은 객체의 프로퍼티 개수만큼 반복해서 prop에 student의 프로퍼티를 할당한다. in 연산자와 마찬가지로 순회 대상 객체의 프로퍼티 뿐만 아니라 객체가 상속받은 모든 프로토타입의 프로퍼티를 열거한다. 그러나 왜 Object.prototype의 프로퍼티들은 열거되지 않았을까?</p><p>Object.prototype의 프로퍼티들의 프로퍼티 어트리뷰트 <code>[[Enumarable]]</code>의 값이 false로, 열거할 수 없도록 정의된 프로퍼티이기 때문이다.</p><p>배열에는 for…in 문 대신 일반적인 for문이나 for…of, Array.prototype.forEach 메소드를 사용하는 게 좋다.</p><h1 id="10-Disallow-use-of-Object-prototypes-builtins-directly"><a href="#10-Disallow-use-of-Object-prototypes-builtins-directly" class="headerlink" title="10. Disallow use of Object.prototypes builtins directly"></a>10. Disallow use of Object.prototypes builtins directly</h1><p><a href="https://eslint.org/docs/rules/no-prototype-builtins" target="_blank" rel="noopener">ESLint: no-prototype-builtins</a></p><p>ECScript 5.1에서  Object.create가 도입되면서 특정한 <code>[[Prototype]]</code>을 지정하여 객체를 생성할 수 있게 되었다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> parent = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;</span><br><span class="line"><span class="hljs-comment">// parent 객체를 상속받는 child 객체를 생성한다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> child = <span class="hljs-built_in">Object</span>.create(parent);</span><br></pre></td></tr></table></figure><p> 그러나 만약 Object.create()의 argument를 null로 호출할 경우 생성된 객체는 프로토타입 체인에 홀로 존재하게 된다. 즉, Object.prototype의 메소드에 접근할 수 없다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj)); <span class="hljs-comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// obj가 Object.prototype을 상속받지 않았으므로 obj.hasOwnProperty는 undefined이다.</span></span><br><span class="line">obj.hasOwnProperty(<span class="hljs-string">'bar'</span>); <span class="hljs-comment">// TypeError: obj.hasOwnProperty is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Object.prototype의 static method를 호출하였으므로 정상 호출된다.</span></span><br><span class="line"><span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, <span class="hljs-string">'bar'</span>); <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><p>게다가 Object.prototype을 상속한 객체라고 할지라도 자신의 고유 메소드로 Object.prototype의 builtin 메소드를 overriding 할 수 있다. 이를 자바스크립트에서는 Property Shadowing이라고 한다. C++에서는 Polymorphism을 구현하는 방식이 상속받은 객체의 overriding이다. </p><p>Object.prototype의 builtin 메소드를 인스턴스에서 재정의한 경우에도 의도치 않은 동작이 발생할 수 있으니, Object.prototype의 builtin 메소드는 Object.prototype의 static 메소드로서 호출하는 것이 좋다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;명령형 (Imperative)&lt;/li&gt;
&lt;li&gt;함수형 (Functional)&lt;/li&gt;
&lt;li&gt;프로토타입 기반 (Prototype-based) 객체지향 프로그래밍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;을 지원하는 멀
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Prototype" scheme="https://sub2n.github.io/tags/Prototype/"/>
    
  </entry>
  
  <entry>
    <title>17. Function and First-class Object</title>
    <link href="https://sub2n.github.io/2019/05/12/17-Function-and-First-class-Object/"/>
    <id>https://sub2n.github.io/2019/05/12/17-Function-and-First-class-Object/</id>
    <published>2019-05-12T01:40:32.000Z</published>
    <updated>2019-05-13T06:27:34.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-First-class-Object"><a href="#1-First-class-Object" class="headerlink" title="1. First-class Object"></a>1. First-class Object</h1><p>자바스크립트에서 함수는 객체이며 값처럼 사용할 수 있다. 값처럼 사용할 수 있는 객체를 일급 객체라고 한다. 자바스크립트의 함수는 일급 객체(first-class object)이다.</p><h3 id="First-class-Object"><a href="#First-class-Object" class="headerlink" title="First-class Object"></a>First-class Object</h3><ul><li>런타임에 무명의 리터럴로 생성할 수 있다.</li><li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li><li>함수의 매개변수로 전달될 수 있다.</li><li>함수의 반환값으로 사용될 수 있다.</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 1. 무명의 리터럴로 생성할 수 있다.</span></span><br><span class="line"><span class="hljs-comment">// 2. 변수나 자료 구조에 저장할 수 있다.</span></span><br><span class="line"><span class="hljs-comment">// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> increase = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> ++num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> decrease = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> --num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수 객체를 객체에 저장할 수 있다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> predicates = &#123; increase, decrease &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span>(<span class="hljs-params">predicate</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 4. 함수의 반환값으로 사용할 수 있다.</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    num = predicate(num);</span><br><span class="line">    <span class="hljs-keyword">return</span> num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 3. 함수의 매개변수에게 전달할 수 있다.</span></span><br><span class="line"><span class="hljs-comment">// makeCounter의 매개변수에게 함수 객체를 전달</span></span><br><span class="line"><span class="hljs-keyword">const</span> increaser = makeCounter(predicates.increase);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(increaser()); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(increaser()); <span class="hljs-comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// makeCounter의 매개변수에게 함수 객체를 전달</span></span><br><span class="line"><span class="hljs-keyword">const</span> decreaser = makeCounter(predicates.decrease);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(decreaser()); <span class="hljs-comment">// -1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(decreaser()); <span class="hljs-comment">// -2</span></span><br></pre></td></tr></table></figure><p>자바스크립트의 함수는 일급객체의 조건을 모두 만족하는 일급 객체이다. 따라서 함수는,</p><ul><li>무명의 리터럴로 생성할 수 있으므로 어디에서나 정의할 수 있다.</li><li>함수를 변수나 자료구조의 값으로 할당할 수 있다.</li><li>함수를 값처럼 매개변수로 전달할 수 있다.</li><li>함수에서 함수를 반환할 수 있다.</li></ul><p>자바스크립트의 함수가 일급 객체이므로 함수형 프로그래밍을 할 수 있다.</p><blockquote><h3 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a>Functional Programming</h3><p>함수형 프로그래밍이랑 Pure function과 보조 함수의 조합을 통해 외부 상태를 변경하는 side-effect를 최소화하여 immutability를 지향하는 프로그래밍 패러다임이다.</p><p>함수형 프로그래밍 패러다임에서 함수를 매개변수에 전달하거나 반환하는 함수를 Hign Order Function이라고 한다.</p></blockquote><p>함수는 객체이지만 일반 객체와 달리 호출할 수 있다. 함수 객체는 일반 객체에는 없는 함수 고유의 프로퍼티를 소유한다.</p><h1 id="2-Property-of-Function-Object"><a href="#2-Property-of-Function-Object" class="headerlink" title="2. Property of Function Object"></a>2. Property of Function Object</h1><p><img src="https://user-images.githubusercontent.com/48080762/57577077-034ab200-74aa-11e9-9242-6def63879626.png" alt="Function Object Properties"></p><p><img src="https://user-images.githubusercontent.com/48080762/57577086-4573f380-74aa-11e9-9a26-734acab4b018.png" alt="Object Property"></p><p>함수 객체와 일반 객체를 각각 콘솔에 찍어보면 함수 객체에는 일반 객체에 없는 프로퍼티들이 있다. 함수 객체 내에는 arguments, caller, length, name, prototype 프로퍼티가 존재한다. <strong> proto </strong> 프로퍼티는 함수 객체, 일반 객체에 모두 존재한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// function object의 Data property들</span></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'arguments'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: null, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'caller'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: null, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'length'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: 0, writable: false, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'name'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: "add", writable: false, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'prototype'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// __proto__는 function object가 아닌, Object.prototype으로부터 상속받은 Accessor property이다.</span></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(add, <span class="hljs-string">'__proto__'</span>);</span><br><span class="line"><span class="hljs-comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-built_in">Object</span>.prototype, <span class="hljs-string">'__proto__'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li>함수 객체의 데이터 프로퍼티 : argunemts, caller, length, name, prototype </li><li><strong> proto </strong>는 접근자 프로퍼티로, Object.prototype객체의 프로퍼티를 상속받은 것.</li></ul><h2 id="2-1-arguments-Property"><a href="#2-1-arguments-Property" class="headerlink" title="2.1 arguments Property"></a>2.1 arguments Property</h2><p>arguments 프로퍼티의 value는 arguments 객체이다. arguments 객체는 함수 호출 시 전달된 argument들의 정보를 담고 있는 iterable array-like object이며, 함수 내부에서만 참조 가능하다.</p><blockquote><h4 id="arguments-Property"><a href="#arguments-Property" class="headerlink" title="arguments Property"></a>arguments Property</h4><p>함수 객체의 arguments property는 일부 브라우저에서 지원하고 있으나 ES3부터 표준에서 페지되었다. arguments 프로퍼티를 통해서가 아니라 함수 내부에서 지역 변수처럼 사용할 수 있는 <strong>arguments 객체를 직접 참조</strong>하는 것이 좋다.</p></blockquote><h4 id="arguments-Object"><a href="#arguments-Object" class="headerlink" title="arguments Object"></a>arguments Object</h4><p><img src="https://user-images.githubusercontent.com/48080762/57577250-ef08b400-74ad-11e9-820a-d6bf77e6ae79.png" alt="arguments object"></p><ul><li>argument들을 value로 가진다. 0, 1, 2 등 key는 argumet의 전달 순서를 나타낸다.</li><li>callee:  호출된 함수, 즉 arguments 객체를 생성한 함수를 가리킨다.</li><li>length: argument의 개수</li><li>Symbol(Symbol.iteraor): arguments object를 순회 가능한 iterable 자료 구조로 만들기 위한 프로퍼티.</li></ul><p>arguments object는 parameter의 개수를 확정할 수 없는 <strong>가변 인자 함수 (Variable Argument Function)</strong>를 구현할 때 유용하게 사용한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// arguments 객체는 length property를 가진 array-like object이므로 iterable하다.</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)</span><br><span class="line">        result += <span class="hljs-built_in">arguments</span>[i];</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Array-like Object</strong>란 length property를 가진 객체로, 실제 배열이 아니지만 for 문 등으로 순회할 수 있는 객체를 말한다. 배열이 아니므로 배열 메소드를 사용하면 에러가 발생한다.</p><p>arguments object에 reduce, for…each 등 고차 함수를 사용하기 위해 배열로 변환한 후 사용하기도 한다.</p><p>ES6에서는 argument를 배열로 사용하기 위해 Rest parameter를 도입했다.</p><h2 id="2-2-caller-Property"><a href="#2-2-caller-Property" class="headerlink" title="2.2. caller Property"></a>2.2. caller Property</h2><p>caller property는 ECMAScript spec에 포함되지 않은 비표준 프로퍼티이다. 함수 객체의 caller property는 함수 자신을 호출한 함수를 가리킨다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">func</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">'caller : '</span> + bar.caller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 브라우저에서의 실행 결과</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo(bar)); <span class="hljs-comment">// caller : function foo(func) &#123;...&#125;</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar());    <span class="hljs-comment">// caller : null</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Node.js에서의 실행 결과</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo(bar)); <span class="hljs-comment">// caller : function foo(func) &#123;...&#125;</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar());    <span class="hljs-comment">// caller : function (exports, require, module, __filename, __dirname) &#123;전역 코드 전체&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-length-Property"><a href="#2-3-length-Property" class="headerlink" title="2.3 length Property"></a>2.3 length Property</h2><p>함수 객체의 length property는 함수 정의 시 선언한 매개변수의 개수를 가리킨다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> a + b +c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(add.length)<span class="hljs-comment">//3</span></span><br></pre></td></tr></table></figure><p>arguments Object의 length property와 Function Object의 length property의 값은 다름을 알고 넘어가자.</p><ul><li><p>arguments Object’s length property : 넘겨받은 argument의 개수</p></li><li><p>Function Object’s length property : 함수에 정의된 parameter의 개수</p></li></ul><h2 id="2-4-name-Property"><a href="#2-4-name-Property" class="headerlink" title="2.4. name Property"></a>2.4. name Property</h2><p>함수 객체의 name property는 함수명을 나타낸다. ES6에서 정식 표준이 되었다.</p><p>익명 함수의 경우 ES5에서 name property는 빈 문자열이지만 ES6에서는 함수 객체를 가리키는 변수명을 값으로 갖는다. (함수 선언문일 경우 함수명과 동일한 변수명, 익명 함수 표현식일 경우 함수 표현식을 할당한 변수명)</p><h2 id="2-5-proto-Accessor-Property"><a href="#2-5-proto-Accessor-Property" class="headerlink" title="2.5. __proto__ Accessor Property"></a>2.5. __proto__ Accessor Property</h2><p>모든 객체는 <code>[[Prototype]]</code>이라는 내부 슬롯을 갖는다. [[Prototype]] 내부 슬롯은 프로토타입 객체를 가리킨다.</p><p>__proto__ property는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">'value'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj.__proto__ === <span class="hljs-built_in">Object</span>.prototype);<span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj.hasOwnProperty(<span class="hljs-string">'key'</span>));<span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj.hasOwnProperty(<span class="hljs-string">'__proto__'</span>));<span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="2-6-prototype-Property"><a href="#2-6-prototype-Property" class="headerlink" title="2.6. prototype Property"></a>2.6. prototype Property</h2><p>prototype Property는 함수 객체만이 소유하는 프로퍼티이다.</p><p>prototype Property는 함수가 객체를 생성하는 생성자 함수로 사용될 때 생성자 함수가 생성할 객체의 프로토타입 객체를 가리킨다.</p><p>즉, </p><ul><li><strong>prototype</strong> Data Property는 <strong>함수가 생성자로 동작하여 생성할 instatnce의 prototype 객체</strong>를 가리키고</li><li><strong>__proto__</strong> Accessor Property는 <strong>자신을 생성한 생성자 함수의 prototype 객체</strong>, 즉 <strong>자신이 상속받은 prototype 객체</strong>를 가리킨다.</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> circle2 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Circle.prototype === circle2.__proto__); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Person.__proto__ === Circle.__proto__);<span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-First-class-Object&quot;&gt;&lt;a href=&quot;#1-First-class-Object&quot; class=&quot;headerlink&quot; title=&quot;1. First-class Object&quot;&gt;&lt;/a&gt;1. First-class Object&lt;/h1
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="First-class object" scheme="https://sub2n.github.io/tags/First-class-object/"/>
    
      <category term="일급 객체" scheme="https://sub2n.github.io/tags/%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4/"/>
    
  </entry>
  
  <entry>
    <title>16. Creating an Object with a Constructor Function</title>
    <link href="https://sub2n.github.io/2019/05/10/16-Creating-an-Object-with-a-Constructor-Function/"/>
    <id>https://sub2n.github.io/2019/05/10/16-Creating-an-Object-with-a-Constructor-Function/</id>
    <published>2019-05-10T06:43:45.000Z</published>
    <updated>2019-05-13T05:25:48.969Z</updated>
    
    <content type="html"><![CDATA[<p>객체 리터럴 표기법은 가장 일반적이고 간단한 객체 생성 방법이다. 객체는 객체 리터럴 표기법 외에도 다양한 방법으로 생성할 수 있다. </p><p>객체를 생성하기 위한 용도로 사용되는 함수를 생성자 함수라고 한다.</p><h1 id="1-Object-Constructor-Function"><a href="#1-Object-Constructor-Function" class="headerlink" title="1. Object Constructor Function"></a>1. Object Constructor Function</h1><p>객체 리터럴 표기법은 분명 간단한 방법이지만, 같은 구조를 가진 객체를 <strong>여러 개</strong> 만들어야할 경우가 있다.</p><p>new 연선자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 생성한 빈 객체에 프로퍼티와 메소드를 추가한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> student = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">student.name = <span class="hljs-string">'Park'</span>;</span><br><span class="line">student.sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hi! I am '</span> + <span class="hljs-keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object 생성자 함수는 함수 <strong>객체</strong>이므로 프로퍼티와 메소드를 갖는다. 앞서 살펴본 <code>Object.getOwnPropertyDescriptor()</code> 또한 Object 생성자 함수의 메소드이다.</p><p>Constructor 함수는 new 연산자와 함께 호출해서 Object(instance)를 생성하는 함수이다. 생성자 함수에 의해 생성된 객체는 instance라고 한다.</p><blockquote><h3 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h3><p>생성자 함수도 객체이므로 생성자 함수나 클래스가 생성한 객체를 다른 객체와 구분하기 위해 실체라는 의미로 인스턴스라고 한다.</p></blockquote><h2 id="1-1-Built-in-Constructor-Function-Wrapper-Object"><a href="#1-1-Built-in-Constructor-Function-Wrapper-Object" class="headerlink" title="1.1. Built-in Constructor Function (Wrapper Object)"></a>1.1. Built-in Constructor Function (Wrapper Object)</h2><p>자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의 built-in(intrinsic) 생성자 함수를 제공한다. 이들은 전역객체(window)의 메소드이다. 자바스크립트에서 <strong>함수는 객체</strong>이므로 Built-in 생성자 함수는 객체로서 메소드도 가진다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-string">'str'</span>);<span class="hljs-comment">//가능하지만 잘 안 씀</span></span><br><span class="line"><span class="hljs-keyword">const</span> strObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'str'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> numObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);</span><br></pre></td></tr></table></figure><p>String, Number 생성자 함수로 형변환도 가능하지만 잘 안 쓴다.</p><blockquote><h3 id="Wrapper-Object"><a href="#Wrapper-Object" class="headerlink" title="Wrapper Object"></a>Wrapper Object</h3><p>원시 값을 객체처럼 쓰면 자바스크립트 엔진이 <strong>원시값 타입의 객체로 순간 바꾸고 평가한 후 다시 원시 값으로 되돌린다</strong>. 이 때 원시값 타입의 객체를 wrapper object라고 부른다.</p></blockquote><h1 id="2-Constructor-Function"><a href="#2-Constructor-Function" class="headerlink" title="2. Constructor Function"></a>2. Constructor Function</h1><p>객체 리터럴로 객체를 생성하는 경우 프로퍼티 구조가 동일해도 매번 같은 프로퍼티와 메소드를 작성해야하는 문제가 있다. 객체 리터럴은 한 번 평가되어 값을 만드므로 재사용할 수 없으며 동일한 코드의 중복 또한 문제가 된다.</p><h2 id="2-1-Advantages-of-object-creation-by-constructor-function"><a href="#2-1-Advantages-of-object-creation-by-constructor-function" class="headerlink" title="2.1 Advantages of object creation by constructor function"></a>2.1 Advantages of object creation by constructor function</h2><p>생성자 함수로 객체를 생성하면 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</p><p>생성자 함수는 일반 함수와 동일한 방법으로 <strong>미리 정의한 후</strong>에, <strong>new 연산자와 함께 호출했을 때만 생성자 함수로 동작한다</strong>.</p><p>생성자 함수는 보통 Pascal case로 naming 한다. (ex. Object, Circle, String 등)</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Constructor Function</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// this indicates the instance that the constructor function will create.</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="hljs-keyword">this</span>.getDiameter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">this</span>.radius;  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// instance creation</span></span><br><span class="line"><span class="hljs-keyword">const</span> circle1 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> circle2 = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">10</span>);</span><br></pre></td></tr></table></figure><p>new 연산자 없이 함수를 호출하면, 일반 함수로 호출되는 것이므로 this는 전역 객체(window)가 된다.</p><blockquote><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><code>this</code>는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 Self-regerencing variable이다. <code>this</code>가 가리키는 객체는 함수 호출 방식에 따라 동적으로 결정된다.</p><table><thead><tr><th style="text-align:center">Function call</th><th style="text-align:center">Object <code>this</code> points to</th></tr></thead><tbody><tr><td style="text-align:center">As a normal function</td><td style="text-align:center">Global object (window)</td></tr><tr><td style="text-align:center">As a method</td><td style="text-align:center"><strong>Object</strong> that called a method</td></tr><tr><td style="text-align:center">As a constructor function</td><td style="text-align:center"><strong>Instance</strong> that a constructor function will create in the future.</td></tr></tbody></table></blockquote><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Called as a general function</span></span><br><span class="line">foo ();<span class="hljs-comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Called as a method</span></span><br><span class="line"><span class="hljs-keyword">const</span> obj = &#123; foo &#125;;<span class="hljs-comment">// ES6 property shorthand</span></span><br><span class="line">obj.foo();<span class="hljs-comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Called as a constructor function</span></span><br><span class="line"><span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> foo();<span class="hljs-comment">// inst</span></span><br></pre></td></tr></table></figure><h2 id="2-3-Internal-method-Call-and-Constructor"><a href="#2-3-Internal-method-Call-and-Constructor" class="headerlink" title="2.3. Internal method [[Call]] and [[Constructor]]"></a>2.3. Internal method [[Call]] and [[Constructor]]</h2><p>함수 객체는 일반 객체와 달리 내부 메소드로 [[Call]]과 [[Constructor]]를 가진다.</p><p>내부 메소드 [[Call]]은 함수가 일반 함수로 호출되었을 때 실행되고, 내부 메소드 [[Constructor]]는 함수가 생성자 함수로 호출되었을 때 실행된다.</p><p>내부 메소드 [[Call]]이 구현되어 있는 객체를 callable, [[Constuctor]]가 구현되어 있는 객체는 constructor, [[Constructor]]가 구현되어 있지 않은 객체는 non-constructor라고 부른다.</p><p>단, arrow function은 constructor function으로 생성할 수 없다. ES6의 메소드 축약 표현으로 선언한 메소드 또한 non-constructor이다. 따라서 모든 함수는 callable이지만 모두 constructor인 것은 아니다.</p><h2 id="2-4-constructors-and-non-constructors"><a href="#2-4-constructors-and-non-constructors" class="headerlink" title="2.4. constructors and non-constructors"></a>2.4. constructors and non-constructors</h2><p>자바스크립트 엔진은 함수 생성시 FunctionCreate라는 abstract operation을 사용한다.</p><p>Abstract operation FunctionCreate는 함수 정의가 평가될 때 호출된다. 함수 정의 방식에 따라서 FunctionCreate의 kind parameter에 함수의 종류를 나타내는 문자열이 전달된다.</p><table><thead><tr><th style="text-align:center">Kinds</th><th style="text-align:center">Strings</th></tr></thead><tbody><tr><td style="text-align:center">일반 함수 정의(함수 선언문, 함수 표현식) 평가</td><td style="text-align:center">Normal</td></tr><tr><td style="text-align:center">화살표 함수 정의 평가</td><td style="text-align:center">Arrow</td></tr><tr><td style="text-align:center">메소드 정의 평가</td><td style="text-align:center">Method</td></tr></tbody></table><p>일반 함수로 정의된 함수만 constructor, Arrow나 Method는 con-constructor이다.</p><p>이 때 주의해야할 점은 ES6의 메소드 축약 표현만을 메소드 정의로 인정한다는 것이다.</p><h2 id="2-5-How-the-Constructor-Function-Works"><a href="#2-5-How-the-Constructor-Function-Works" class="headerlink" title="2.5. How the Constructor Function Works"></a>2.5. How the Constructor Function Works</h2><p>생성자 함수의 역할은 인스턴스를 생성하는 것과 생성된 인스턴스의 프로퍼티 값을 초기화하는 것이다.</p><p>생성자 함수가 호출되면,</p><ol><li>자바스크립트 내부에서 빈 객체를 만들고 <code>this</code>에 할당한다. (this binding)</li><li>내부 코드를 실행한 후 <code>this</code>를 return한다. 즉, <code>this</code>는 생성자 함수로 생성하는 instance가 된다.</li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 1. create empty object and bind it to this. this = &#123;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 2. run internal codes (create property)</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 3. return this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Park'</span>));<span class="hljs-comment">// Person &#123;name: 'Park'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-6-new-Operator"><a href="#2-6-new-Operator" class="headerlink" title="2.6. new Operator"></a>2.6. new Operator</h2><p>new 연산자와 함께 constructor인 함수를 호출하면 함수는 생성자 함수로 동작한다. 이 때 함수 객체의 내부 메소드 [[Constructor]]가 호출된다. 함수 내부의 this는 생성자 함수가 생성할 instance를 가리킨다.</p><p>new 연산자 없이 함수를 호출하면 함수 객체의 내부 메소드 [[Call]]이 호출된다. 이 때 함수 내부의 this는 전역 객체 window를 가리킨다.</p><h2 id="2-7-new-target"><a href="#2-7-new-target" class="headerlink" title="2.7. new.target"></a>2.7. new.target</h2><p>new 연산자 없이 생성자 함수를 호출하는 것을 방지하기 위해서 ES6에서 new.target을 지원한다.</p><p>new.target은 함수 내부에서 지역 변수와 같이 사용되는 meta property이다. (IE는 new.target을 지원하지 않음!)</p><p>함수가 new 연산자와 함께 호출되면 new.target은 함수 자신을 가리키고, new 연산자 없이 호출된 함수 내부의 new.target은 undefined이다.</p><p>new 연산자와 함께 호출된 생성자 함수로부터 생성된 instance는 프로토타입에 의해 생성자 함수와 연결된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;객체 리터럴 표기법은 가장 일반적이고 간단한 객체 생성 방법이다. 객체는 객체 리터럴 표기법 외에도 다양한 방법으로 생성할 수 있다. &lt;/p&gt;
&lt;p&gt;객체를 생성하기 위한 용도로 사용되는 함수를 생성자 함수라고 한다.&lt;/p&gt;
&lt;h1 id=&quot;1-Ob
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Object" scheme="https://sub2n.github.io/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>CodeWars 6kyu. Build a pile of Cubes</title>
    <link href="https://sub2n.github.io/2019/05/09/CodeWars-6kyu-Build-a-pile-of-Cubes/"/>
    <id>https://sub2n.github.io/2019/05/09/CodeWars-6kyu-Build-a-pile-of-Cubes/</id>
    <published>2019-05-09T07:19:09.000Z</published>
    <updated>2019-05-09T08:17:34.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CodeWars-6kyu-Build-a-pile-of-Cubes"><a href="#CodeWars-6kyu-Build-a-pile-of-Cubes" class="headerlink" title="CodeWars 6kyu. Build a pile of Cubes"></a><a href="https://www.codewars.com/kata/build-a-pile-of-cubes/javascript" target="_blank" rel="noopener">CodeWars 6kyu. Build a pile of Cubes</a></h2><p>Find the largest number of cubes can be piled.</p><a id="more"></a><blockquote><p>Your task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume of n^3, the cube above will have volume of (n-1)^3 and so on until the top which will have a volume of 1^3.</p><p>You are given the total volume m of the building. Being given m can you find the number n of cubes you will have to build?</p><p>The parameter of the function findNb (find_nb, find-nb, findNb) will be an integer m and you have to return the integer n such as n^3 + (n-1)^3 + … + 1^3 = m if such a n exists or -1 if there is no such n.</p></blockquote><blockquote><p>Examples:</p><p>findNb(1071225) –&gt; 45<br>findNb(91716553919377) –&gt; -1<br>mov rdi, 1071225<br>call find_nb            ; rax &lt;– 45</p><p>mov rdi, 91716553919377<br>call find_nb            ; rax &lt;– -1</p></blockquote><h2 id="접근법"><a href="#접근법" class="headerlink" title="접근법"></a>접근법</h2><p>Σ k<sup>3</sup> (k = 1~n) == ((n * (n+1))/2))**2 가 m보다 작아야 한다.</p><p>따라서 n == Math.sqrt(2 * Math.sqrt(m)) 에 근사한 값으로 설정한 후 m보다 커질 때까지 반복한다.</p><h2 id="JavaScript-Solution"><a href="#JavaScript-Solution" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h2><p><img src="https://user-images.githubusercontent.com/48080762/57434636-5c320480-7276-11e9-9045-4b17910f48f8.png" alt="Solution Submit"></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNb</span>(<span class="hljs-params">m</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> n = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">2</span> * (<span class="hljs-built_in">Math</span>.sqrt(m)))) - <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> ( ((n * (n+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>) ** <span class="hljs-number">2</span> &lt; m ) &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ((n * (n+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>) ** <span class="hljs-number">2</span> &gt; m ? <span class="hljs-number">-1</span> : n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CodeWars-6kyu-Build-a-pile-of-Cubes&quot;&gt;&lt;a href=&quot;#CodeWars-6kyu-Build-a-pile-of-Cubes&quot; class=&quot;headerlink&quot; title=&quot;CodeWars 6kyu. Build a pile of Cubes&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.codewars.com/kata/build-a-pile-of-cubes/javascript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CodeWars 6kyu. Build a pile of Cubes&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Find the largest number of cubes can be piled.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://sub2n.github.io/categories/Algorithm/"/>
    
      <category term="CodeWars" scheme="https://sub2n.github.io/categories/Algorithm/CodeWars/"/>
    
    
      <category term="Algorithm" scheme="https://sub2n.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>190509-TIL</title>
    <link href="https://sub2n.github.io/2019/05/09/190509-TIL/"/>
    <id>https://sub2n.github.io/2019/05/09/190509-TIL/</id>
    <published>2019-05-09T07:15:52.000Z</published>
    <updated>2019-05-09T07:18:13.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learned"><a href="#Today-I-Learned" class="headerlink" title="Today I Learned"></a>Today I Learned</h2><ul><li><p>Implemented underscore libray’s last function</p><p><img src="https://user-images.githubusercontent.com/48080762/57434410-e332ad00-7275-11e9-9c6f-2c85032b12d2.png" alt="Condition complete"></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Like first, but for the last elements. If n is undefined, return just the</span></span><br><span class="line"><span class="hljs-comment">// last element.</span></span><br><span class="line">_.last = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">array, n</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> n === <span class="hljs-literal">undefined</span> ? array[array.length<span class="hljs-number">-1</span>] : n &gt; array.length ? array : array.slice(array.length-n, array.length);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Studied about JavaScript global variable and let, const keyword variables.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learned&quot;&gt;&lt;a href=&quot;#Today-I-Learned&quot; class=&quot;headerlink&quot; title=&quot;Today I Learned&quot;&gt;&lt;/a&gt;Today I Learned&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Implement
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>15. Property Definition</title>
    <link href="https://sub2n.github.io/2019/05/09/15-Property-Definition/"/>
    <id>https://sub2n.github.io/2019/05/09/15-Property-Definition/</id>
    <published>2019-05-09T06:11:04.000Z</published>
    <updated>2019-05-10T06:42:59.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-What-is-Property-Definition"><a href="#1-What-is-Property-Definition" class="headerlink" title="1. What is Property Definition?"></a>1. What is Property Definition?</h1><p>프로퍼티 정의란 프로퍼티 어트리뷰트의 값을 정의하여 프로퍼티의 상태를 관리하는 것이다. 예를 들면 프로퍼티 값을 갱신 가능하도록 할 것인지(writable), 프로퍼티를 열거 가능하도록 할 것인지(enumarable), 재정의 가능하도록 할 것인지(configurable)를 정의할 수 있다.</p><p>객체 리터럴이 평가되거나 프로퍼티가 동적 생성될 때 프로퍼티가 생성된다. 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//Dynamic creation of properties. The JavaScript engine creates the property and defines the property's attributes as the default.</span></span><br><span class="line">obj.prop = <span class="hljs-number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">'prop'</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(descriptor);</span><br><span class="line"><span class="hljs-comment">// &#123;value: 10, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><p>프로퍼티 동적 생성은 프로퍼티가 존재하지 않을 때 프로퍼티를 생성하여 추가하는 것이다.</p><p>프로퍼티 정의는 프로퍼티 어트리뷰트를 정의하는 것을 말한다. 프로퍼티 어트리뷰트는 프로퍼티의 상태를 나타낸다.</p><p>프로퍼티의 상태란 프로퍼티의,</p><ul><li>value</li><li>writable</li><li>enumerable</li><li>configurable</li></ul><p>프로퍼티 어트리뷰트는 <code>Object.getOwnPropertyDescriptor</code> 메소드를 사용해 참조할 수 있다. 이 메소드는 프로퍼티 어트리뷰트를 객체로 표현한 PropertyDescriptor 객체를 반환한다. 존재하지 않는 프로퍼티나, 상속받은 프로퍼티에 대한 PropertyDescriptor를 요구하면 undefined가 반환된다.</p><p>프로퍼티가 동적 생성될 때 자바스크립트 엔진은 프로퍼티 어트리뷰트를 기본값으로 정의한다. 이미 정의된 프로퍼티 어트리뷰트를 재정의할 수도 있다.</p><h1 id="2-Internal-Slot-Method"><a href="#2-Internal-Slot-Method" class="headerlink" title="2. Internal Slot / Method"></a>2. Internal Slot / Method</h1><p>Internal slot and internal method는 ECMAScript 스펙에서 요구하는 객체 관련 내부 상태와 내부 동작을 정의한 것이다. ECMAScript 스펙에서 <code>[[...]]</code>로 감싼 이름들이 내부 슬롯과 내부 메소드이다.</p><p>Internal slot과 method는 자바스크립트 엔진의 내부 구현 사양을 정의한 것이므로 외부에 노출되지 않는다. </p><p>객체의 프로퍼티 키로 프로퍼티 값에 접근할 때 <code>[[Get]]</code> 내부 메소드가 내부적으로 호출된다. <code>[[Get]]</code> 내부 메소드는 다음과 같이 동작한다.</p><ol><li>프로퍼티 키가 유효한지 확인한다. (문자열 또는 심볼)</li><li>프로토타입 체인에서 프로퍼티를 검색한다.</li></ol><blockquote><h3 id="Prototype-and-Prototype-Chain"><a href="#Prototype-and-Prototype-Chain" class="headerlink" title="Prototype and Prototype Chain"></a>Prototype and Prototype Chain</h3><p>프로토타입은 어떤 객체의 parent 객체 역할을 하는 객체이다. 프로토타입은 Child 객체에게 자신의 프로퍼티와 메소드를 상속한다. Prototype객체의 프로퍼티나 메소드를 상속받은 child 객체는 parent 객체의 프로퍼티나 메소드를 자유롭게 사용한다.</p><p>프로토타입 체인은 프로토타입 객체가 연결되어있는 상속 구조이다. 어떤 객체의 프로퍼티나 메소드에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티나 메소드가 없다면 프로토타입 체인을 따라 상위(부모) 객체의 프로퍼티나 메소드를 차례대로 검색한다.</p></blockquote><ol start="3"><li>검색된 프로퍼티가 Data property라면 프로퍼티 값(데이터 프로퍼티의 프로퍼티 어트리뷰트 [[Value]])의 값을 그대로 반환한다.</li><li>만약 검색된 프로퍼티가 Accessor property라면 접근자 프로퍼티의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하고 그 결과를 반환한다.</li></ol><p>함수 객체에는 [[Call]]이라는 고유한 internal method가 있다. [[Call]]은 함수를 호출하면 내부적으로 호출된다. 이는 일반 객체에는 없는 함수 객체만의 고유한 internal method이다.</p><blockquote><h3 id="Abstract-Operation"><a href="#Abstract-Operation" class="headerlink" title="Abstract Operation"></a>Abstract Operation</h3><p>ECMAScript 스펙에서 Abstract operation으로 구현 방향을 제시한다. ECMAScript의 내부 동작을 이해하기 위해서 읽으면 좋음..</p></blockquote><h1 id="3-Accessor-Property"><a href="#3-Accessor-Property" class="headerlink" title="3. Accessor Property"></a>3. Accessor Property</h1><p>프로퍼티는 Data property와 Accessor property로 구분할 수 있다.</p><ul><li>Data property<ul><li>키와 값으로 구성된 일반 프로퍼티. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티이다.</li></ul></li><li>Accessor property<ul><li>자체적으로는 값을 갖지 않고 다른 data property의 값을 읽거나 저장할 때 사용되는 Accessor function으로 구성된 프로퍼티</li></ul></li></ul><p>Accessor function은 getter / setter 함수라고도 부른다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> student = &#123;</span><br><span class="line">    <span class="hljs-comment">// Data property</span></span><br><span class="line">    name: <span class="hljs-string">'Park'</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// Accessor property</span></span><br><span class="line">    <span class="hljs-keyword">get</span> infoName() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-keyword">set</span> infoName(newName) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// A reference to a property value through a data property.</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(student);<span class="hljs-comment">// &#123;name: "Park", age: 25&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Setting Property Values with Accessor Properties</span></span><br><span class="line"><span class="hljs-comment">// If store the value in the accessor property infoName, the setter function is called.</span></span><br><span class="line">student.infoName = <span class="hljs-string">'Kim'</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(student);<span class="hljs-comment">// &#123;name: "Kim", age: 25&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Getting Property Values with Accessor Properties</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(student.infoName);<span class="hljs-comment">// Kim</span></span><br></pre></td></tr></table></figure><p>student 객체의 name은 일반적인 데이터 프로퍼티이다.</p><p>get infoName은 getter 함수, set infoName은 setter 함수이고 함수의 이름인 infoName이 바로 접근자 프로퍼티이다. 접근자 프로터티는 값([[Value]] attribute)을 가지지 않고 데이터 프로퍼티의 값을 읽거나(get) 저장(set)할 때 동작한다.</p><p>Accessor property infoName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] internal method가 호출되어 다음과 같이 동작한다.</p><ol><li>프로퍼티 키가 유효한지 확인한다. (문자열 또는 숫자인지)</li><li>프로토타입 체인에서 프로퍼티를 검색한다.</li><li>검색된 infoName 프로퍼티가 data property인지 accessor property인지 확인한다. infoName은 Accessor property이다.</li><li>Accessor property infoName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출해 결과를 반환한다. 프로퍼티 infoName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDescriptor 메소드가 반환하는 프로퍼티 디스크립터(PropertyDescriptor) 객체의 get 프로퍼티 값과 같다.</li></ol><p>Accessor property와 data property의 구별 방법</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// The __proto__ of a generic object is an accessor property.</span></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-built_in">Object</span>.prototype, <span class="hljs-string">'__proto__'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// The prototype of a function object is a data property.</span></span><br><span class="line"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;, <span class="hljs-string">'prototype'</span>);</span><br><span class="line"><span class="hljs-comment">// &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><p>Accessor property와 data property의 property descriptor object의 프로퍼티가 다르다.</p><h1 id="4-Property-Attribute"><a href="#4-Property-Attribute" class="headerlink" title="4. Property Attribute"></a>4. Property Attribute</h1><p>모든 프로퍼티는 자신의 상태와 동작을 정의한 내부 슬롯 / 메소드를 가진다. 이것들을 property attribute라고 한다. Property attribute는 자바스크립트 엔진이 프로퍼티를 생성할 때 default로 자동 정의된다.</p><ul><li><p>Data Property Attributes</p><p>| Property Attribute |                         Description                          | Property of Property Descriptor Object |<br>| :—————-: | :———————————————————-: | :————————————: |<br>|     [[Value]]      | - 프로퍼티 키로 프로퍼티 값에 접근하면 내부 메소드 [[Get]]에 의해 반환되는 값<br>-    프로퍼티 키로 프로퍼티 값을 저장하면 [[Value]]에 값을 저장한다. 이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다. |                 value                  |<br>|    [[Writable]]    | - 프로퍼티 값의 변경 가능 여부. Boolean<br>- [[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다. |                writable                |<br>|   [[Enumarable]]   | - 프로퍼티의 열거 가능 여부. Boolean<br>- [[Enumerable]]의 값이 false인 경우, 해당 프로퍼티는 for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다. |               enumerable               |<br>|  [[Configurable]]  | - 프로퍼티의 재정의 가능 여부. Boolean<br>- [[Configurable]]의 값이 false인 경우, 해당 프로퍼티의 삭제와 프로퍼티 어트리뷰트 값의 변경이 금지된다.<br> - 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. |              configurable              |</p></li></ul><ul><li><p>Accessor Property Attributes</p><p>| Property Attribute |                         Description                          | Property of Property Descriptor Object |<br>| :—————-: | :———————————————————-: | :————————————: |<br>|      [[Get]]       | - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수 <br>- 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값인 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환 |                  get                   |<br>|      [[Set]]       | - 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수 <br>- 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값인 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환 |                  set                   |<br>|   [[Enumerable]]   |            Same as Data Property’s [[Enumerable]]            |               enumerable               |<br>|  [[Configurable]]  |           Same as Data Property’s [[Configurable]]           |              configurable              |</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-What-is-Property-Definition&quot;&gt;&lt;a href=&quot;#1-What-is-Property-Definition&quot; class=&quot;headerlink&quot; title=&quot;1. What is Property Definition?&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>14. let, const and a Block-level Scope</title>
    <link href="https://sub2n.github.io/2019/05/09/14-let-const-and-a-Block-level-Scope/"/>
    <id>https://sub2n.github.io/2019/05/09/14-let-const-and-a-Block-level-Scope/</id>
    <published>2019-05-09T04:58:23.000Z</published>
    <updated>2019-05-10T06:03:31.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Problems-with-Variables-declared-with-the-var-keyword"><a href="#1-Problems-with-Variables-declared-with-the-var-keyword" class="headerlink" title="1. Problems with Variables declared with the var keyword"></a>1. Problems with Variables declared with the <code>var</code> keyword</h1><p>ES5까지 변수를 선언할 수 있는 유일한 키워드는 <code>var</code> 하나였다. <code>var</code> 키워드로 선언된 변수는 다른 언어와는 구별되는 특징을 가진다.</p><h2 id="1-1-Allow-Duplicate-Variable-Declaration"><a href="#1-1-Allow-Duplicate-Variable-Declaration" class="headerlink" title="1.1. Allow Duplicate Variable Declaration"></a>1.1. Allow Duplicate Variable Declaration</h2><p><code>var</code> 키워드로 선언한 변수는 중복 선언이 가능하다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-comment">// No Error</span></span><br><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">//10</span></span><br></pre></td></tr></table></figure><p>같은 스코프 내에서 변수를 중복 선언하면 나중에 선언된 변수는 선언문이 아닌 할당문처럼 동작한다. 이 때 에러가 발생하지 않기 때문에 중복 선언을 인지하기 힘들다. 이로 인해 의도치 않게 변수값이 변경될 수 있다.</p><h2 id="1-2-Function-level-Scope"><a href="#1-2-Function-level-Scope" class="headerlink" title="1.2. Function-level Scope"></a>1.2. Function-level Scope</h2><p><code>var</code> 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서, if문이나 for문 등에서 선언한 <code>var</code> 변수는 모두 전역 변수가 된다.</p><p>대부분의 프로그래밍 언어는 block-level scope이기 때문에 function-level scope를 이용하는 것은 전역 변수를 남발할 가능성을 높인다.</p><h2 id="1-3-Variable-Hoisting"><a href="#1-3-Variable-Hoisting" class="headerlink" title="1.3. Variable Hoisting"></a>1.3. Variable Hoisting</h2><p><code>var</code>키워드로 선언한 변수는 변수 호이스팅에 의해 변수 선언문이 스코프의 가장 위로 끌어 올려진 것처럼 동작한다. 즉, 선언 이전에 <code>var</code> 변수를 참조해도 에러가 나지 않는다. 이는 프로그램의 흐름을 해치고 가독성을 떨어뜨린다.</p><h1 id="2-let-keyword"><a href="#2-let-keyword" class="headerlink" title="2. let keyword"></a>2. <code>let</code> keyword</h1><p><code>var</code> 키워드의 단점들을 보완하기 위해 ES6에서 <code>var</code>와 <code>const</code> 키워드가 추가되었다. 이들은 <code>var</code> 키워드와 같이 변수를 선언할 때 사용된다.</p><h2 id="2-1-Ban-Duplicate-Variable-Declaration"><a href="#2-1-Ban-Duplicate-Variable-Declaration" class="headerlink" title="2.1. Ban Duplicate Variable Declaration"></a>2.1. Ban Duplicate Variable Declaration</h2><p><code>let</code> 키워드로 선언한 변수를 중복 선언하면 <code>var</code>와 달리 SyntaxError가 발생한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;<span class="hljs-comment">// SyntaxError: Identifier 'x' has already been declared</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Block-level-Scope"><a href="#2-2-Block-level-Scope" class="headerlink" title="2.2. Block-level Scope"></a>2.2. Block-level Scope</h2><p><code>var</code> 키워드로 선언한 변수는 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따른다. 그러나 <code>let</code> 키워드로 선언한 변수는 모든 코드 블록 <code>{}</code>을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> foo = <span class="hljs-number">1</span>;<span class="hljs-comment">// global variable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> foo = <span class="hljs-number">3</span>;<span class="hljs-comment">// local variable</span></span><br><span class="line">    <span class="hljs-keyword">let</span> bar = <span class="hljs-number">4</span>;<span class="hljs-comment">// local variable</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 3</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar);<span class="hljs-comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar);<span class="hljs-comment">// ReferenceError: bar is not defined</span></span><br></pre></td></tr></table></figure><h2 id="2-3-Variable-Hoisting"><a href="#2-3-Variable-Hoisting" class="headerlink" title="2.3. Variable Hoisting"></a>2.3. Variable Hoisting</h2><p><code>let</code> 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(foo);<span class="hljs-comment">// ReferenceError: foo is not defined</span></span><br><span class="line"><span class="hljs-keyword">let</span> foo;</span><br></pre></td></tr></table></figure><p>그렇다면 <code>let</code> 키워드로 선언한 선언문은는 런타임 이전에 실행되지 않는 것일까? </p><p>일반적으로 <code>var</code> 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 declaration phase와 initialization phase가 <strong>한 번에</strong> 진행된다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57504827-02424500-7331-11e9-960b-75e673a99ae3.png" alt="var declaration"></p><ol><li>Declaration phase : Execution context의 lexical environment에 있는 스코프에 변수 식별자를 등록하여 변수의 존재를 알린다.</li><li>Initialization phase : declaration phase가 끝나는 즉시 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined로 변수를 할당해 초기화한다.</li></ol><p><code>let</code> 키워드로 선언한 변수는 “Declaration phase”와 “Initialization Phase”가 <strong>분리되어 진행</strong>된다.  즉, 런타임 이전에 암묵적으로 declaration phase가 먼저 실행되지만 <strong>initialization phase는 런타임에 변수 선언문에 도달했을 때 실행</strong>된다.</p><p><img src="https://user-images.githubusercontent.com/48080762/57430144-acef3080-7269-11e9-987d-75b1881b029a.png" alt="let declaration"></p><p>initialization phase가 실행되기 이전에 변수에 접근하려고 하면 reference error가 발생한다. 아직 변수를 위한 메모리 공간이 확보되지 않았기 때문이다. 따라서 스코프의 시작 지점부터 변수 선언문을 만나서 initialization phase가 시작되기 전까지는 변수를 참조할 수 없다.</p><blockquote><h3 id="TDZ-Temporal-Dead-Zone"><a href="#TDZ-Temporal-Dead-Zone" class="headerlink" title="TDZ (Temporal Dead Zone)"></a>TDZ (Temporal Dead Zone)</h3><p>스코프의 시작 지점부터 Initialization phase 시작 지점까지의 구간 </p></blockquote><p><code>let</code> 키워드로 선언한 변수는 hoisting이 되지 않는 게 아니라, 선언문을 만났을 때 initialization phase를 진행하는 것이다.</p><h2 id="2-4-Global-Object-and-let"><a href="#2-4-Global-Object-and-let" class="headerlink" title="2.4. Global Object and let"></a>2.4. Global Object and <code>let</code></h2><p><strong>전역 객체(Global Object)</strong>는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 브라우저 환경에서는 window 객체, Node.js 환경에서는 global 객체를 말한다.</p><p><strong><code>var</code> 키워드로 선언한 전역 변수와, 키워드 없이 선언하고 값을 할당한 암묵적 전역변수, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;</span><br><span class="line">y = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.x === x);<span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.y === y);<span class="hljs-comment">// true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.foo === foo);<span class="hljs-comment">// true</span></span><br></pre></td></tr></table></figure><p>전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.</p><p>그러나 <code>let</code> 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다. <code>let</code> 전역 변수는 전역 렉시컬 환경의 선언적 환경 레코드 내에 존재하게 된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.x);<span class="hljs-comment">// undefined</span></span><br></pre></td></tr></table></figure><h1 id="3-const-Keyword"><a href="#3-const-Keyword" class="headerlink" title="3. const Keyword"></a>3. <code>const</code> Keyword</h1><p><code>const</code> 키워드는 상수(변하지 않는 고정된 값)를 선언하기 위해 사용한다. <code>let</code> 과 <code>const</code> 는 동일한 특징이 많다. 차이점을 살펴보자.</p><h2 id="3-1-Declaration-and-Initialization"><a href="#3-1-Declaration-and-Initialization" class="headerlink" title="3.1. Declaration and Initialization"></a>3.1. Declaration and Initialization</h2><p><code>let</code> 키워드로 선언한 변수와 달리 <code>const</code> 키워드로 선언한 변수는 재할당이 금지된다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.14</span>;</span><br><span class="line"></span><br><span class="line">PI = <span class="hljs-number">3.141492</span>;<span class="hljs-comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p><code>const</code> 키워드로 선언한 변수는 반드시 선언과 할당이 동시에 이루어져야 한다. 이후로는 재할당을 할 수 없다.</p><p><code>const</code> 키워드로 선언한 변수 또한 block-level scope를 갖는다.</p><h2 id="3-2-Constant"><a href="#3-2-Constant" class="headerlink" title="3.2. Constant"></a>3.2. Constant</h2><p>변수를 만들고 재할당을 하지 않을 거라면 상수를 적극적으로 쓰는 게 좋다. 고정된 값을 상수로 만들어 쓰면 코드의 가독성을 높일 수 있다. 상수는 프로그램 전체에서 사용하므로, 유지보수에 효율적이다.</p><h2 id="3-3-const-Keyword-and-Object"><a href="#3-3-const-Keyword-and-Object" class="headerlink" title="3.3. const Keyword and Object"></a>3.3. <code>const</code> Keyword and Object</h2><p><code>const</code> 키워드로 선언한 변수에 primitive value를 할당한 경우, primitive value는 immutable value이고 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법이 없다.</p><p><code>const</code> 키워드로 선언한 변수에 객체를 할당한 경우, 재할당이 금지되는 것은 마찬가지이다. 그러나 객체는 mutable value이므로 <code>const</code> 키워드로 선언된 변수에 할당된 객체는 변경이 가능하다.</p><p>즉, <code>const</code> 키워드는 재할당을 금지할 뿐 immutable을 의미하지 않는다. immutable과 mutable은 상수와 변수의 개념이 아닌, 값의 변경에 대한 개념이다.</p><h1 id="4-var-vs-let-vs-const"><a href="#4-var-vs-let-vs-const" class="headerlink" title="4. var vs. let vs. const"></a>4. <code>var</code> vs. <code>let</code> vs. <code>const</code></h1><p>변수 선언에는 기본적으로 <code>const</code>를 사용하고 <code>let</code>은 재할당이 필요한 경우에 사용하는 것이 좋다. </p><ul><li>ES6 사용시 <code>var</code> 키워드 사용하지 않는다.</li><li>재할당이 필요한 경우에만 <code>let</code> 키워드를 사용하고, 변수의 스코프를 최소화 한다.</li><li>객체와 변경을 하지 않을 원시 값에는 <code>const</code> 키워드를 사용한다.</li><li><code>var</code> 와 <code>let</code>/<code>const</code>를 함께 쓰지 않는다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Problems-with-Variables-declared-with-the-var-keyword&quot;&gt;&lt;a href=&quot;#1-Problems-with-Variables-declared-with-the-var-keyword&quot; class=&quot;h
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>13. Problems with Global Variables</title>
    <link href="https://sub2n.github.io/2019/05/09/13-Problems-with-global-variables/"/>
    <id>https://sub2n.github.io/2019/05/09/13-Problems-with-global-variables/</id>
    <published>2019-05-09T02:26:46.000Z</published>
    <updated>2019-05-10T05:25:54.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Life-Cycle-of-a-Variable"><a href="#1-Life-Cycle-of-a-Variable" class="headerlink" title="1. Life Cycle of a Variable"></a>1. Life Cycle of a Variable</h1><p>변수는 선언에 의해 생성되고 할당을 통해 값을 가진다. 생성된 변수는 언젠가는 소멸한다. 변수가 생성되고 소멸되는 주기를 변수의 생명 주기라고 한다.</p><p>변수가 생성된다는 것은 메모리 공간을 차지하는 것이고, 소멸됨은 차지하던 메모리가 해제되는 것이다.</p><p>조금 더 정확히 말하면 변수가 소멸된다는 것은 등록된 식별자가 소멸한다는 것이다. 이때 식별자와 값의 바인딩이 해제된다. 어떤 지역 스코프가 사라질 때 그 스코프에 등록된 식별자들이 소멸된다.</p><p>함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다. 즉, 지역 변수의 생명주기는 함수와 생명 주기와 같다. 그래서 지역 변수의 생명주기는 비교적 짧다. 그러나 전역 변수는 다르다.</p><p>함수는 함수 몸체의 문이 끝나거나, return 문이 실행되면 종료한다. 하지만 전역 코드는 마지막 문이 끝나서 더 이상 실행할 문이 없어도 함수처럼 종료하지 않는다. 전역변수는 브라우저를 종료해서 애플리케이션을 종료할 때까지 유효하다. 즉, 전역 변수의 생명주기는 애플리케이션의 생명 주기와 일치한다. 이는 다음과 같은 문제점을 가진다.</p><h1 id="2-Problem-of-Global-Variable"><a href="#2-Problem-of-Global-Variable" class="headerlink" title="2. Problem of Global Variable"></a>2. Problem of Global Variable</h1><h2 id="2-1-Implicit-Coupling"><a href="#2-1-Implicit-Coupling" class="headerlink" title="2.1. Implicit Coupling"></a>2.1. Implicit Coupling</h2><p>전역 변수는 코드의 전체 영역에서 사용할 수 있다. 이는 <strong>모든 코드에서 전역 변수를 참조하고 변경할 수 있는 암묵적 결합</strong>을 허용한다. 문제는 변수의 유효 범위가 크면 클수록 코드의 가독성이 나빠지고 의도치 않은 상태 변경이 일어난다는 것이다.</p><h2 id="2-2-Long-Life-Cycle"><a href="#2-2-Long-Life-Cycle" class="headerlink" title="2.2. Long Life Cycle"></a>2.2. Long Life Cycle</h2><p>전역 변수는 생명 주기가 길다. 이는 다음과 같이 몇 가지 문제점을 가진다.</p><ul><li>전역 변수의 상태를 변경할 수 있는 시간이 길다.</li><li>모든 함수가 참조할 수 있으므로 상태가 변경될 위험이 크다.</li><li>메모리 리소스를 오랜기간 차지한다.</li><li><code>var</code> 키워드는 변수의 중복 선언을 허용하므로 중간에 변수명이 중복되어 의도치 않은 재할당이 일어날 수 있다.</li></ul><h2 id="2-3-Exist-at-the-End-of-the-Scope-Chain"><a href="#2-3-Exist-at-the-End-of-the-Scope-Chain" class="headerlink" title="2.3. Exist at the End of the Scope Chain"></a>2.3. Exist at the End of the Scope Chain</h2><p>전역 변수의 또다른 문제점은 스코프 체인 가장 상위에 존재한다는 것이다. 이는 자바스크립트 엔진이 전역 변수를 찾을 때 가장 마지막 스코프까지 검색해야함을 의미한다. 즉, 전역 변수의 검색 속도가 가장 느리다.</p><h2 id="2-4-Namespace-Pollution"><a href="#2-4-Namespace-Pollution" class="headerlink" title="2.4. Namespace Pollution"></a>2.4. Namespace Pollution</h2><p>자바스크립트의 특성으로, 분리되어있는 파일을 함께 import할 경우 하나의 전역 스코프를 공유한다. 따라서 다른 파일 내에서 동일한 이름으로 명명한 변수나 함수가 겹칠 경우 예상치 못한 결과를 가져올 수 있다.</p><h1 id="3-How-to-Suppress-Using-Global-Variables"><a href="#3-How-to-Suppress-Using-Global-Variables" class="headerlink" title="3. How to Suppress Using Global Variables"></a>3. How to Suppress Using Global Variables</h1><p>위에서 살펴본 바와 같이 전역 변수의 사용은 위험하다. 반드시 사용해야할 때가 아니라면 지역 변수를 사용해야 한다. </p><h2 id="3-1-Immediately-Invoke-Function-Expression"><a href="#3-1-Immediately-Invoke-Function-Expression" class="headerlink" title="3.1. Immediately Invoke Function Expression"></a>3.1. Immediately Invoke Function Expression</h2><p>즉시 실행 함수는 함수의 정의와 동시에 한 번만 호출되는 함수로, 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 함수는 스코프를 만들고, 함수 내에 선언된 변수는 지역 변수가 된다는 것을 이용한 방법이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> foo = <span class="hljs-number">10</span>;<span class="hljs-comment">//local variable of IIF</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>가장 간단하고 일반적인 방식이다.</p><h2 id="3-2-Namespace-Object"><a href="#3-2-Namespace-Object" class="headerlink" title="3.2. Namespace Object"></a>3.2. Namespace Object</h2><p>전역 네임 스페이스 역할을 담당할 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다. 즉, 전역 변수를 네임 스페이스 객체의 프로퍼티로 등록하고 사용하는 방법이다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> GLOBAL = &#123;&#125;;<span class="hljs-comment">// global namespace object</span></span><br><span class="line">GLOBAL.name = <span class="hljs-string">'Lee'</span>;</span><br></pre></td></tr></table></figure><p>현재는 잘 안 쓰는 방식.</p><h2 id="3-3-Module-Pattern"><a href="#3-3-Module-Pattern" class="headerlink" title="3.3. Module Pattern"></a>3.3. Module Pattern</h2><p>모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아서 즉시 실행함수로 감싸 하나의 모듈로 만든다. 모듈 패턴은 자바스크립트의 <strong>클로저</strong>를 기반으로 동작한다.</p><p><strong>캡슐화란 보호하고자 하는 내부 구현을 외부로부터 감추는 것</strong>을 말한다. 캡슐화의 목적은 상태 유지로, 외부에서 객체 내부의 상태를 변경하는 것을 제한한다. C++이나 Java의 class는 기본적으로 Access modifier를 제공하여 공개 범위를 한정할 수 있게 한다.</p><p>자바스크립트는 Access modifier를 제공하지 않는다. 모듈 패턴은 전역 네임 스페이스의 오염을 막는 기능에 더해서, 한정적이기는 하지만 캡슐화를 구현하기 위해 사용한다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Account = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// private variable</span></span><br><span class="line">  <span class="hljs-keyword">var</span> balance = <span class="hljs-number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">      deposit(money) &#123;</span><br><span class="line">        balance += money;</span><br><span class="line">          <span class="hljs-keyword">return</span> balance;</span><br><span class="line">      &#125;,</span><br><span class="line">      withdraw(money) &#123;</span><br><span class="line">          balance -= money;</span><br><span class="line">          <span class="hljs-keyword">return</span> balance;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Account.balance);        <span class="hljs-comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Account.deposit(<span class="hljs-number">3000</span>));<span class="hljs-comment">//3000</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(Account.withdraw(<span class="hljs-number">1000</span>));<span class="hljs-comment">//2000</span></span><br></pre></td></tr></table></figure><p>위 코드의 즉시 실행 함수는 외부에 노출할 메소드를 객체에 담아 반환한다. 이 때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버이다. 반환되는 객체에 추가되지 않은 변수나 함수는 모두 외부에서 접근할 수 없는 프라이빗 멤버가 된다.</p><blockquote><h4 id="Closure"><a href="#Closure" class="headerlink" title="Closure?"></a>Closure?</h4><p>그런데 즉시 실행 함수는 선언과 동시에 실행되고 종료되는데 deposit()과 withdraw() 메소드가 어떻게 num을 참조할 수 있을까? </p><p>deposit()과 withdraw()는 즉시 실행 함수의 중첩 함수로, 중첩 함수가 외부 함수보다 더 오래 살아남아 있을 경우 이를 <strong>클로저</strong>라고 부른다. </p><p>자바스크립트의 함수 객체는 생성될 때, 프로퍼티 어트리뷰트로 [[Environment]]라는 내부 슬롯을 가진다. 이 곳에 자신이 생성될 때의 외부 스코프(Lexical scope)를 담는다. 이는 함수 객체가 소멸하기 전까지 유지된다. 위의 num같은 변수를 자유변수라고 한다.</p><p>deposit()과 withdraw()는 같은 lexical scope object를 참조하고 있다. 모던 자바스크립트 프로그래밍에서는 클로저의 사용을 적극 권장한다.</p></blockquote><h2 id="3-4-ES6-Module"><a href="#3-4-ES6-Module" class="headerlink" title="3.4 ES6 Module"></a>3.4 ES6 Module</h2><ul><li>import</li><li>export</li></ul><p>ES6가 구체적인 구현 스펙을 제안하지 않아 대부분의 브라우저가 완전히 지원하지는 않는다. 그러나 Webpack 등의 모듈 번들러를 사용해서 ES6 모듈을 사용할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Life-Cycle-of-a-Variable&quot;&gt;&lt;a href=&quot;#1-Life-Cycle-of-a-Variable&quot; class=&quot;headerlink&quot; title=&quot;1. Life Cycle of a Variable&quot;&gt;&lt;/a&gt;1. Life
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>190508-TIL</title>
    <link href="https://sub2n.github.io/2019/05/08/190508-TIL/"/>
    <id>https://sub2n.github.io/2019/05/08/190508-TIL/</id>
    <published>2019-05-08T12:19:28.000Z</published>
    <updated>2019-05-08T12:23:59.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Today-I-Learend"><a href="#Today-I-Learend" class="headerlink" title="Today I Learend"></a>Today I Learend</h2><p>Studied JavaScript function and scope of JavaScript.</p><p>✨ <a href="https://sub2n.github.io/2019/05/08/11-Function/">Function posting</a> ✨</p><p>✨ <a href="https://sub2n.github.io/2019/05/08/12-Scope/">Scope posting</a> ✨</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Today-I-Learend&quot;&gt;&lt;a href=&quot;#Today-I-Learend&quot; class=&quot;headerlink&quot; title=&quot;Today I Learend&quot;&gt;&lt;/a&gt;Today I Learend&lt;/h2&gt;&lt;p&gt;Studied JavaScript
      
    
    </summary>
    
      <category term="TIL" scheme="https://sub2n.github.io/categories/TIL/"/>
    
    
      <category term="TIL" scheme="https://sub2n.github.io/tags/TIL/"/>
    
  </entry>
  
  <entry>
    <title>12. Scope</title>
    <link href="https://sub2n.github.io/2019/05/08/12-Scope/"/>
    <id>https://sub2n.github.io/2019/05/08/12-Scope/</id>
    <published>2019-05-08T06:23:34.000Z</published>
    <updated>2019-05-08T08:56:00.084Z</updated>
    
    <content type="html"><![CDATA[<p>The scope determines the extent to which the identifier can be referenced. A scope is a data structure that keeps the binding of identifiers and values, and is managed by the JavaScript engine.</p><h1 id="What-is-Scope"><a href="#What-is-Scope" class="headerlink" title="What is Scope?"></a>What is Scope?</h1><p>The range in which the variable is valid. That is, the extent to which other code can refer to the variable itself. The scope is created by the location <strong>where the variable is declared</strong>.</p><p>When there are variables with the same name in different scopes, JavaScript engine must decide which variable to reference at runtime. JavaScript uses the scope to determine which variables to reference. That is, <strong>the scope is the rule that the JavaScript engine uses to search for variables to reference.</strong></p><p>By default, JavaScript supports function-level scopes rather than block-level scopes. Variables declared with <code>var</code> form a function-level scope. However, variables declared with <code>let</code> or <code>const</code> form a block-level scopes.</p><p>If there is no scope, the name of the variable in the program should be unique.</p><blockquote><h4 id="Duplicate-declaration-of-var-keyword-variable"><a href="#Duplicate-declaration-of-var-keyword-variable" class="headerlink" title="Duplicate declaration of var keyword variable"></a>Duplicate declaration of <code>var</code> keyword variable</h4><p>Variables declared with the <code>var</code> keyword allow duplicate declarations within the same scope.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">&gt;     <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="hljs-comment">// This statement operates like x = 2;</span></span><br><span class="line">&gt;     <span class="hljs-comment">// So reassignment occurs.</span></span><br><span class="line">&gt;     <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;<span class="hljs-comment">//2</span></span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">//2</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; foo();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Variables declared as <code>let</code> or <code>const</code> do not allow duplicate declarations, so it is better to use them.</p></blockquote><h1 id="Types-of-scope"><a href="#Types-of-scope" class="headerlink" title="Types of scope"></a>Types of scope</h1><p>Code can be distinguished as global and local.</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">Global</th><th style="text-align:center">Local</th></tr></thead><tbody><tr><td style="text-align:left">Explanation</td><td style="text-align:center">Outermost area of code</td><td style="text-align:center">Inside of function body</td></tr><tr><td style="text-align:left">Scope</td><td style="text-align:center">Global scope</td><td style="text-align:center">Local scope</td></tr><tr><td style="text-align:left">Vaiable</td><td style="text-align:center">Global variable</td><td style="text-align:center">Local variable</td></tr></tbody></table><p>The variable is determined by its declared location (global or local) to the scope in which it is valid. </p><ul><li>A variable declared in global is a global variable having a global scope</li><li>A variable declared in local is a local variable having a local scope.</li></ul><p>Declaring a variable in global is a global variable with a global scope. Global variables can be referenced anywhere. In other words, global variables are valid in the global scope.</p><p>Local variables can be referenced only in the declared region and sub-region (nested function). In other words, local variables are valid in their local and subregional scopes.</p><h1 id="Scope-Chain"><a href="#Scope-Chain" class="headerlink" title="Scope Chain"></a>Scope Chain</h1><p>Scopes are created by functions. Functions can be nested, so the local scope of a function can also be nested. This means that <strong>the scope has a hierarchical structure by nesting of functions</strong>.</p><p>The local scope of the outer function is the top scope of the nested function.</p><p><strong>The scope chain</strong> refers to a structure in which the scopes from the deepest local scope to the global scope of the overlap are hierarchically connected.</p><p>When referring to a variable, the JavaScript engine starts at the scope of the code that references the variable, moves to the top scope, and searches for the declared variable.</p><h1 id="Function-level-Scope"><a href="#Function-level-Scope" class="headerlink" title="Function-level Scope"></a>Function-level Scope</h1><ul><li>Most programming language like C, Java <ul><li>Block-level scope</li><li>All code blocks (if, for, while, try / catch, etc.), not just the function body, create the local scope.</li></ul></li><li>Variables declared with the <code>var</code> keyword <ul><li><strong>Function-level scope</strong></li><li>Accept only the code block of the <strong>function</strong> as the local scope.</li></ul></li></ul><p>The <code>let</code> and <code>const</code> keywords introduced in ES6 support block level scopes.</p><h1 id="Lexical-Scope"><a href="#Lexical-Scope" class="headerlink" title="Lexical Scope"></a>Lexical Scope</h1><ul><li>Dynamic Scope<ul><li>The function’s top scope is determined by <strong>where the function is called.</strong></li></ul></li><li><strong>Lexical Scope</strong> / Static Scope<ul><li>The function’s top scope is determined by <strong>where the function is defined.</strong></li><li>Most programming languages follow the lexical scope.</li></ul></li></ul><p>JavaScript follows a lexical scope. So it determines the top scope depending on where it is defined.</p><h1 id="Implicit-Global-Variable"><a href="#Implicit-Global-Variable" class="headerlink" title="Implicit Global Variable"></a>Implicit Global Variable</h1><p>If declare a variable without <code>var</code> keyword, it becomes a global variable.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    i = <span class="hljs-number">0</span>;<span class="hljs-comment">//implicit global variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// var i = 0 is a duplicate declaration</span></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(i);</span><br><span class="line">&#125;<span class="hljs-comment">// infinite loop</span></span><br></pre></td></tr></table></figure><p>Global variables are so dangerous!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;The scope determines the extent to which the identifier can be referenced. A scope is a data structure that keeps the binding of identifi
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
      <category term="Scope" scheme="https://sub2n.github.io/tags/Scope/"/>
    
  </entry>
  
  <entry>
    <title>11. Function</title>
    <link href="https://sub2n.github.io/2019/05/08/11-Function/"/>
    <id>https://sub2n.github.io/2019/05/08/11-Function/</id>
    <published>2019-05-08T00:47:35.000Z</published>
    <updated>2019-05-16T02:33:20.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-a-Function"><a href="#What-is-a-Function" class="headerlink" title="What is a Function?"></a>What is a Function?</h1><p>수학에서 함수는 input을 받아 output을 내보내는 일련의 과정(series of processes)을 정의한 것이다.</p><p>프로그래밍 언어에서 함수는 input을 받아 output을 내보내는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다. </p><p>함수의 구성 요소로는,</p><ul><li>parameter(매개변수) : input을 함수 내부로 전달받는 변수</li><li>argument(인수) : input</li><li>return value(반환값) : output</li></ul><p>함수는 식별자로 함수명을 사용한다.</p><p>함수는 함수를 정의함으로써 생성된다. 생성된 함수를 실행시키기 위해서는 함수를 호출해야한다. </p><h1 id="Why-use-a-function"><a href="#Why-use-a-function" class="headerlink" title="Why use a function?"></a>Why use a function?</h1><p>함수를 사용해야 하는 이유는 다음과 같다.</p><ul><li>동일한 작업을 반복적으로 수행할 때 함수를 호출해 <strong>코드를 재사용</strong>하기 위해서 사용</li><li>중복되는 코드를 제가해서 <strong>유지보수의 효율성</strong>을 높이기 위해서 사용</li><li>함수의 이름으로 기능을 명시해 코드의 <strong>가독성을 높일 수 있다</strong>.</li></ul><h1 id="Function-Literal"><a href="#Function-Literal" class="headerlink" title="Function Literal"></a>Function Literal</h1><p>Just as objects are created as object literals, functions can also be created as function literals. Function literal consists of function keyword, function name, list of parameters and function body. A <strong>function literal is evaluated to create a function object</strong>.</p><ul><li>Function name<ul><li>Since the function name is an identifier, it must conform to the identifier naming rules.</li><li>A function name is an identifier that can be referenced <strong>only within a function body</strong>.</li><li>The function name can be omitted. A function with a function name is called a <strong><em>named function</em></strong>, and a function without a function name is called an <strong><em>anonymous function</em></strong>.</li></ul></li><li>List of parameters<ul><li>Wrap 0 or more parameters in parentheses and separate them with commas.</li><li>Parameters are assigned arguments.</li><li>Parameters are treated the same as variables in the function body.</li></ul></li><li>Function body<ul><li>It is a block of code that defines the statements to be executed in batches as a unit of execution when the function is called.</li><li>The function body is executed by a function call.</li></ul></li></ul><p>A function literal is evaluated to produce a value, which is an object. In other words, <strong>the function of JavaScript is an object.</strong></p><p>Unlike regular objects, functions can be called and have unique properties. All function objects have <code>[[Call]]</code>.</p><h1 id="Definition-of-Function"><a href="#Definition-of-Function" class="headerlink" title="Definition of Function"></a>Definition of Function</h1><p>There are 4 ways to define a function.</p><ul><li><p>Function Declaration / Function Statement</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Function Expression</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Function Constructor</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'return x + y'</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Arrow Function (ES6)</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure></li></ul><p>Each method defines a function, but there is an important difference.</p><h2 id="Function-Declaration"><a href="#Function-Declaration" class="headerlink" title="Function Declaration"></a>Function Declaration</h2><p>The function declaration has the same format as the function literal, but <strong>the function name can not be omitted.</strong> This is because the JavaScript engine needs to create variables with function names.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Function Declaration</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//Function Call</span></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//5</span></span><br></pre></td></tr></table></figure><p>The function name is an identifier that can be referenced only within the function body.</p><p>However, when you call a function outside a function, you use the function name.</p><p>When a function declaration is executed to create a function object, a variable is needed to assign the function object. This is because the function object can not be stored in memory unless it is allocated anywhere. </p><p>Therefore, the JavaScript engine</p><ol><li>Implicitly declares an identifier of the same name as the function name</li><li>Assigns the created function object to the identifier.</li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// This is the pseudo code when the above function add statement is executed.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// variable add is an identifier created by the JavaScript engine with the same name as the function name implicitly. </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><p>Function name can only be referenced within a function, and implicitly created <strong>variable</strong> name can be referenced <strong>in the scope where the function is defined</strong>.</p><p><img src="https://user-images.githubusercontent.com/48080762/57363047-21b76180-71bb-11e9-9fa1-d67593e265e4.png" alt="Pseudo Code"></p><p>This pseudo code is the following function expression. That is, the JavaScript engine converts function declarations into function expressions to create function objects.</p><h2 id="Function-Expression"><a href="#Function-Expression" class="headerlink" title="Function Expression"></a>Function Expression</h2><h3 id="First-class-object"><a href="#First-class-object" class="headerlink" title="First-class object"></a>First-class object</h3><p>An object that can be assigned to a variable, such as a value, which can be the value of a property or an element of an array.</p><p>Function in JavaScript is a first-class object. It means that a function can be freely used as a value. </p><p>A function object created with a function literal can be assigned to a variable. This way of defining a function is called a <strong>function expression</strong>.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Function Expression</span></span><br><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><p>Unlike function declarations, function literals can omit function names. It is common to use anonymous functions in function expressions.</p><p>Since a function name is an identifier that can be referenced only by a function body, even if a named function is used, the function must be called with the variable name to which the function object is assigned.</p><h2 id="Function-Creation-time-and-Function-Hoisting"><a href="#Function-Creation-time-and-Function-Hoisting" class="headerlink" title="Function Creation time and Function Hoisting"></a>Function Creation time and Function Hoisting</h2><p>Function declarations and function expressions seem to behave similarly, because the JavaScript engine implicitly declares the variable as a function name in the function declaration statement and allocates the created object.<br>However, function declaration is non-expression statement, and function expression is an expression statement. Therefore, there is an important difference.</p><p>The point at which the function is created is when the JavaScript engine evaluates the function declaration to create the function object.</p><ul><li><p><strong>Function declaration statements are executed before runtime</strong> because they are declarations themselves. </p></li><li><p>However, <strong>function expressions are executed at run-time</strong> because they are assignment statements that assign function literals to variables. </p></li></ul><p>That is, the function created by the function declaration statement and the function generated by the function expression are created at different times.</p><p>Functions created with function declarations are executed and hoisted before runtime, but functions created with function expressions are not hoisted.</p><p>Unlike variable hoisting, in the case of function hoisting, a function object is referenced instead of undefined.</p><h2 id="Function-Constructor"><a href="#Function-Constructor" class="headerlink" title="Function Constructor"></a>Function Constructor</h2><blockquote><h2 id="Constructor-Function"><a href="#Constructor-Function" class="headerlink" title="Constructor Function"></a>Constructor Function</h2><p>A constructor function is a function that creates an object.</p></blockquote><p>The <code>function</code> constructor function, which is a built-in function provided by JavaScript, receives a parameter list and a function body as a string. It is called with the <code>new</code> operator and returns the created function object.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Function Constructor</span></span><br><span class="line"><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'return x + y'</span>);</span><br><span class="line"></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><p>However, creating a function as a function constructor is not common. These functions behave differently from function declarations or function expressions.</p><p>Do not use it!</p><h2 id="Arrow-Function"><a href="#Arrow-Function" class="headerlink" title="Arrow Function"></a>Arrow Function</h2><p>An arrow function introduced in ES6 can make a function simply without a <code>function</code> keyword. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Arrow Function</span></span><br><span class="line"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><p>The arrow function is not available in all situations.</p><h1 id="Function-Call"><a href="#Function-Call" class="headerlink" title="Function Call"></a>Function Call</h1><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Function Call</span></span><br><span class="line">add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><ul><li><code>add</code> : Variable name referring to function object, not function name</li><li><code>( )</code> : Function call operator</li><li><code>2, 3</code> : Arguments to be assigned to the parameter</li></ul><p>Calling a function stops the current execution flow and passes control to the called function. At this point, arguments are assigned to the parameters and the statements in the function body begin to execute.</p><h1 id="Parameter-and-Argument"><a href="#Parameter-and-Argument" class="headerlink" title="Parameter and Argument"></a>Parameter and Argument</h1><ul><li>Parameter<ul><li>Declare when defining a function</li><li>Treated as variables in the function body</li><li>When a function is called, the parameter is implicitly created in the function body, initialized to undefined, and then an argument is assigned.</li><li>The scope of the parameter is inside the function.</li></ul></li><li>Argument<ul><li>If the argument is passed less than the parameter, the missing parameter has the value undefined. (No error)</li><li>If the argument is passed in more than the parameter, the excess argument is ignored and kept in the arguments object.</li></ul></li></ul><h1 id="Argument-Check"><a href="#Argument-Check" class="headerlink" title="Argument Check"></a>Argument Check</h1><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">'number'</span> || <span class="hljs-keyword">typeof</span> y !== <span class="hljs-string">'number'</span>)</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Non-number type value has assigned to parameter.'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="hljs-number">2</span>);<span class="hljs-comment">// TypeError: Non-number type value has assigned to parameter.</span></span><br><span class="line">add(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);<span class="hljs-comment">// TypeError: Non-number type value has assigned to parameter.</span></span><br></pre></td></tr></table></figure><p>It is necessary to check whether the argument is passed properly in the JavaScript function. Because..</p><ul><li>JavaScript functions do not check that the number of parameters and arguments match.</li><li>Because JavaScript is a dynamic type language, functions do not specify the type of parameters in advance.</li></ul><h1 id="Number-of-parameters"><a href="#Number-of-parameters" class="headerlink" title="Number of parameters"></a>Number of parameters</h1><p>The smaller the number of parameters, the better. A function with 0 parameters is ideal. The more parameters, the more things to consider when using the function, which leads to errors.</p><p>Also, if the number or sequence of parameters changes, all the code that calls the function must be modified.</p><p>The ideal function should only do one thing and make it as small as possible. In addition to functions, classes and other functional units must be as clear and small as possible too.</p><h1 id="External-State-Changes-and-Functional-Programming"><a href="#External-State-Changes-and-Functional-Programming" class="headerlink" title="External State Changes and Functional Programming"></a>External State Changes and Functional Programming</h1><p>Since functions are objects, they follow pass by reference. Passing a value to a function’s parameters is called as <strong>Call by value</strong> and <strong>Call by reference</strong>, but the behavior is the same as <strong>Pass by value</strong> and <strong>Pass by reference</strong>.</p><p>As we saw in <a href="https://sub2n.github.io/2019/05/07/10-Comparing-primitive-and-objects/">10. Comparing primitive and objects</a>, there is a side effect in which the original object is changed by reference values passed from inside the function body to outside of the function. This is called change of external state.</p><ul><li>Pure function : functions that do not change any external state (No side effect)</li><li>Impure function : functions that change the external state inside a function (Side effect)</li></ul><p><img src="https://user-images.githubusercontent.com/48080762/57363055-2714ac00-71bb-11e9-9810-7770c44966c8.png" alt="External State Change"></p><p>Functional programming is a programming paradigm that avoids state changes by suppressing the use of variables and solves complexity by eliminating conditional statements and loops in the logic through the combination of pure and auxiliary functions. Variable values can be changed by someone at any time, and conditional statements or loop statements can make the flow of logic difficult to understand, which can impair readability and become a root cause of errors.</p><p>Functional programming is a way to avoid errors and increase the stability of programs by minimizing side effects through pure functions.</p><h2 id="Return-Statement"><a href="#Return-Statement" class="headerlink" title="Return Statement"></a>Return Statement</h2><p>The function returns the execution result through a return statement consisting of the <code>retur</code>n keyword and the return value.</p><p>When the return statement is executed, execution of the function is aborted and the function body is exited.</p><p>If do not write anything after the <code>return</code> keyword or write a return statement, <code>undefined</code> is returned implicitly.</p><h2 id="Types-of-various-Functions"><a href="#Types-of-various-Functions" class="headerlink" title="Types of various Functions"></a>Types of various Functions</h2><h3 id="IIFE-Immediately-Invoke-Function-Expression"><a href="#IIFE-Immediately-Invoke-Function-Expression" class="headerlink" title="IIFE ( Immediately Invoke Function Expression)"></a>IIFE ( Immediately Invoke Function Expression)</h3><p>A function that <em>executes concurrently with the definition</em> of a function. It is common to use anonymous functions and can not be called again once.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Anonymous immediately invoke function</span></span><br><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-keyword">var</span> b = <span class="hljs-number">3</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>Even if a named function is used, the function name can not be referenced outside of the function and can not be called again.</p><p>An immediate function must be enclosed in the group operator <code>()</code>. Otherwise, it will not be identified and an error will occur.</p><p>If put the code in the immediate function, collision of the variable name or the function name can be prevented. An immediate execution function is used for this purpose.</p><h3 id="Recursive-Function"><a href="#Recursive-Function" class="headerlink" title="Recursive Function"></a>Recursive Function</h3><p>A recursive call is to call itself. A function that calls itself is called a recursive function.</p><p>When creating a recursive function, a base case with an escape condition must be included. Stack overflow occurs when a function is called without escaping.</p><p>Most of what can be implemented as recursive functions can be implemented as loops.</p><h3 id="Nested-Function-Inner-Function"><a href="#Nested-Function-Inner-Function" class="headerlink" title="Nested Function / Inner Function"></a>Nested Function / Inner Function</h3><p>A function defined inside a function is called a nested function (or inner function). A nested function acts as a helper function of an outer function that contains itself.</p><p>A nested function can access variables of an outer function, but an outer function can not access variables of a nested function. The nesting of functions means the nesting of the scope.</p><h3 id="Callback-Function"><a href="#Callback-Function" class="headerlink" title="Callback Function"></a>Callback Function</h3><p>Because JavaScript functions are first-class objects, can pass functions as arguments to functions.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Function that recieves calback function</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">f</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> string = <span class="hljs-string">'Good'</span>;</span><br><span class="line">    <span class="hljs-comment">// Determine when to call the callback function passed in parameter and call the function</span></span><br><span class="line">    <span class="hljs-keyword">return</span> f(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// It calls the print function and passes the callback function</span></span><br><span class="line"><span class="hljs-keyword">var</span> upper = print(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> str.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// It calls the print function and passes the callback function</span></span><br><span class="line"><span class="hljs-keyword">var</span> lower = print(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> str.toLowerCase();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(upper, lower);<span class="hljs-comment">//GOOD good</span></span><br></pre></td></tr></table></figure><p>The function passed to the print function as an argument is called a <strong>callback function</strong>. The callback function calls the function that receives the callback function as an argument by determining the point of call.</p><p>Using a callback function is like pushing a nested function depending on your needs and circumstances.</p><p>Just as a nested function acts as a helper function to help an outer function, the callback function is passed to the function to serve as a helper function. However, since the nested function is fixed and can not be replaced, the callback function can be freely replaced because it is injected as an argument outside the function.</p><p>When you pass a callback function from the outside, you can create a function that performs various actions depending on the callback function.</p><p>That is, it is useful to use the callback function in situations where it is changed instead of being fixed like a nested function.</p><p>Callback functions are mainly used for <strong>event handling</strong>, Ajax communication, and higher-order functions.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What-is-a-Function&quot;&gt;&lt;a href=&quot;#What-is-a-Function&quot; class=&quot;headerlink&quot; title=&quot;What is a Function?&quot;&gt;&lt;/a&gt;What is a Function?&lt;/h1&gt;&lt;p&gt;수학에서
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://sub2n.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://sub2n.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CodeWars 6kyu. Consecutive strings</title>
    <link href="https://sub2n.github.io/2019/05/07/CodeWars-6kyu-Consecutive-strings/"/>
    <id>https://sub2n.github.io/2019/05/07/CodeWars-6kyu-Consecutive-strings/</id>
    <published>2019-05-07T12:46:33.000Z</published>
    <updated>2019-05-08T10:07:35.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CodeWars-6kyu-Consecutive-strings"><a href="#CodeWars-6kyu-Consecutive-strings" class="headerlink" title="CodeWars 6kyu. Consecutive strings"></a><a href="https://www.codewars.com/kata/consecutive-strings/javascript" target="_blank" rel="noopener">CodeWars 6kyu. Consecutive strings</a></h2><p>Find longest k consecutive strings</p><a id="more"></a><blockquote><p>You are given an array strarr of strings and an integer k. Your task is to return the first longest string consisting of k consecutive strings taken in the array.</p></blockquote><blockquote><p>Example:</p><p>longest_consec([“zone”, “abigail”, “theta”, “form”, “libe”, “zas”, “theta”, “abigail”], 2) –&gt; “abigailtheta”</p></blockquote><blockquote><p>n being the length of the string array, if n = 0 or k &gt; n or k &lt;= 0 return “”.</p></blockquote><blockquote><p>Note</p><p>consecutive strings : follow one after another without an interruption</p></blockquote><h2 id="JavaScript-Solution"><a href="#JavaScript-Solution" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longestConsec</span>(<span class="hljs-params">strarr, k</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (strarr.length == <span class="hljs-number">0</span> || k &gt; strarr.length || k &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">let</span> longStr = <span class="hljs-string">''</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">let</span> newStr = <span class="hljs-string">''</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strarr.length; i++)&#123;</span><br><span class="line">      newStr = strarr.slice(i, i+k);</span><br><span class="line">      <span class="hljs-keyword">if</span> (newStr.join(<span class="hljs-string">''</span>).length &gt; longStr.length )&#123;</span><br><span class="line">        longStr = newStr.join(<span class="hljs-string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> longStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CodeWars-6kyu-Consecutive-strings&quot;&gt;&lt;a href=&quot;#CodeWars-6kyu-Consecutive-strings&quot; class=&quot;headerlink&quot; title=&quot;CodeWars 6kyu. Consecutive strings&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.codewars.com/kata/consecutive-strings/javascript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CodeWars 6kyu. Consecutive strings&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Find longest k consecutive strings&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://sub2n.github.io/categories/Algorithm/"/>
    
      <category term="CodeWars" scheme="https://sub2n.github.io/categories/Algorithm/CodeWars/"/>
    
    
      <category term="Algorithm" scheme="https://sub2n.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
